var TW = Object.defineProperty;
var IW = (n, e, t) => e in n ? TW(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t;
var Ne = (n, e, t) => (IW(n, typeof e != "symbol" ? e + "" : e, t),
t);
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity),
        i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const s = t(i);
        fetch(i.href, s)
    }
}
)();
var ka = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oc(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function RW(n) {
    if (n.__esModule)
        return n;
    var e = n.default;
    if (typeof e == "function") {
        var t = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        t.prototype = e.prototype
    } else
        t = {};
    return Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(n, r);
        Object.defineProperty(t, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return n[r]
            }
        })
    }),
    t
}
var z4 = {
    exports: {}
}
  , Ux = {}
  , G4 = {
    exports: {}
}
  , Dt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o0 = Symbol.for("react.element")
  , UW = Symbol.for("react.portal")
  , FW = Symbol.for("react.fragment")
  , PW = Symbol.for("react.strict_mode")
  , LW = Symbol.for("react.profiler")
  , DW = Symbol.for("react.provider")
  , NW = Symbol.for("react.context")
  , OW = Symbol.for("react.forward_ref")
  , kW = Symbol.for("react.suspense")
  , QW = Symbol.for("react.memo")
  , HW = Symbol.for("react.lazy")
  , BU = Symbol.iterator;
function zW(n) {
    return n === null || typeof n != "object" ? null : (n = BU && n[BU] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var V4 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , j4 = Object.assign
  , W4 = {};
function Qd(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = W4,
    this.updater = t || V4
}
Qd.prototype.isReactComponent = {};
Qd.prototype.setState = function(n, e) {
    if (typeof n != "object" && typeof n != "function" && n != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, n, e, "setState")
}
;
Qd.prototype.forceUpdate = function(n) {
    this.updater.enqueueForceUpdate(this, n, "forceUpdate")
}
;
function K4() {}
K4.prototype = Qd.prototype;
function iI(n, e, t) {
    this.props = n,
    this.context = e,
    this.refs = W4,
    this.updater = t || V4
}
var sI = iI.prototype = new K4;
sI.constructor = iI;
j4(sI, Qd.prototype);
sI.isPureReactComponent = !0;
var MU = Array.isArray
  , X4 = Object.prototype.hasOwnProperty
  , oI = {
    current: null
}
  , Y4 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function $4(n, e, t) {
    var r, i = {}, s = null, o = null;
    if (e != null)
        for (r in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (s = "" + e.key),
        e)
            X4.call(e, r) && !Y4.hasOwnProperty(r) && (i[r] = e[r]);
    var a = arguments.length - 2;
    if (a === 1)
        i.children = t;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        i.children = l
    }
    if (n && n.defaultProps)
        for (r in a = n.defaultProps,
        a)
            i[r] === void 0 && (i[r] = a[r]);
    return {
        $$typeof: o0,
        type: n,
        key: s,
        ref: o,
        props: i,
        _owner: oI.current
    }
}
function GW(n, e) {
    return {
        $$typeof: o0,
        type: n.type,
        key: e,
        ref: n.ref,
        props: n.props,
        _owner: n._owner
    }
}
function aI(n) {
    return typeof n == "object" && n !== null && n.$$typeof === o0
}
function VW(n) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + n.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var SU = /\/+/g;
function pb(n, e) {
    return typeof n == "object" && n !== null && n.key != null ? VW("" + n.key) : e.toString(36)
}
function qy(n, e, t, r, i) {
    var s = typeof n;
    (s === "undefined" || s === "boolean") && (n = null);
    var o = !1;
    if (n === null)
        o = !0;
    else
        switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (n.$$typeof) {
            case o0:
            case UW:
                o = !0
            }
        }
    if (o)
        return o = n,
        i = i(o),
        n = r === "" ? "." + pb(o, 0) : r,
        MU(i) ? (t = "",
        n != null && (t = n.replace(SU, "$&/") + "/"),
        qy(i, e, t, "", function(c) {
            return c
        })) : i != null && (aI(i) && (i = GW(i, t + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(SU, "$&/") + "/") + n)),
        e.push(i)),
        1;
    if (o = 0,
    r = r === "" ? "." : r + ":",
    MU(n))
        for (var a = 0; a < n.length; a++) {
            s = n[a];
            var l = r + pb(s, a);
            o += qy(s, e, t, l, i)
        }
    else if (l = zW(n),
    typeof l == "function")
        for (n = l.call(n),
        a = 0; !(s = n.next()).done; )
            s = s.value,
            l = r + pb(s, a++),
            o += qy(s, e, t, l, i);
    else if (s === "object")
        throw e = String(n),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function k0(n, e, t) {
    if (n == null)
        return n;
    var r = []
      , i = 0;
    return qy(n, r, "", "", function(s) {
        return e.call(t, s, i++)
    }),
    r
}
function jW(n) {
    if (n._status === -1) {
        var e = n._result;
        e = e(),
        e.then(function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 1,
            n._result = t)
        }, function(t) {
            (n._status === 0 || n._status === -1) && (n._status = 2,
            n._result = t)
        }),
        n._status === -1 && (n._status = 0,
        n._result = e)
    }
    if (n._status === 1)
        return n._result.default;
    throw n._result
}
var Qi = {
    current: null
}
  , ew = {
    transition: null
}
  , WW = {
    ReactCurrentDispatcher: Qi,
    ReactCurrentBatchConfig: ew,
    ReactCurrentOwner: oI
};
function Z4() {
    throw Error("act(...) is not supported in production builds of React.")
}
Dt.Children = {
    map: k0,
    forEach: function(n, e, t) {
        k0(n, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(n) {
        var e = 0;
        return k0(n, function() {
            e++
        }),
        e
    },
    toArray: function(n) {
        return k0(n, function(e) {
            return e
        }) || []
    },
    only: function(n) {
        if (!aI(n))
            throw Error("React.Children.only expected to receive a single React element child.");
        return n
    }
};
Dt.Component = Qd;
Dt.Fragment = FW;
Dt.Profiler = LW;
Dt.PureComponent = iI;
Dt.StrictMode = PW;
Dt.Suspense = kW;
Dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = WW;
Dt.act = Z4;
Dt.cloneElement = function(n, e, t) {
    if (n == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + ".");
    var r = j4({}, n.props)
      , i = n.key
      , s = n.ref
      , o = n._owner;
    if (e != null) {
        if (e.ref !== void 0 && (s = e.ref,
        o = oI.current),
        e.key !== void 0 && (i = "" + e.key),
        n.type && n.type.defaultProps)
            var a = n.type.defaultProps;
        for (l in e)
            X4.call(e, l) && !Y4.hasOwnProperty(l) && (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        r.children = t;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        r.children = a
    }
    return {
        $$typeof: o0,
        type: n.type,
        key: i,
        ref: s,
        props: r,
        _owner: o
    }
}
;
Dt.createContext = function(n) {
    return n = {
        $$typeof: NW,
        _currentValue: n,
        _currentValue2: n,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    n.Provider = {
        $$typeof: DW,
        _context: n
    },
    n.Consumer = n
}
;
Dt.createElement = $4;
Dt.createFactory = function(n) {
    var e = $4.bind(null, n);
    return e.type = n,
    e
}
;
Dt.createRef = function() {
    return {
        current: null
    }
}
;
Dt.forwardRef = function(n) {
    return {
        $$typeof: OW,
        render: n
    }
}
;
Dt.isValidElement = aI;
Dt.lazy = function(n) {
    return {
        $$typeof: HW,
        _payload: {
            _status: -1,
            _result: n
        },
        _init: jW
    }
}
;
Dt.memo = function(n, e) {
    return {
        $$typeof: QW,
        type: n,
        compare: e === void 0 ? null : e
    }
}
;
Dt.startTransition = function(n) {
    var e = ew.transition;
    ew.transition = {};
    try {
        n()
    } finally {
        ew.transition = e
    }
}
;
Dt.unstable_act = Z4;
Dt.useCallback = function(n, e) {
    return Qi.current.useCallback(n, e)
}
;
Dt.useContext = function(n) {
    return Qi.current.useContext(n)
}
;
Dt.useDebugValue = function() {}
;
Dt.useDeferredValue = function(n) {
    return Qi.current.useDeferredValue(n)
}
;
Dt.useEffect = function(n, e) {
    return Qi.current.useEffect(n, e)
}
;
Dt.useId = function() {
    return Qi.current.useId()
}
;
Dt.useImperativeHandle = function(n, e, t) {
    return Qi.current.useImperativeHandle(n, e, t)
}
;
Dt.useInsertionEffect = function(n, e) {
    return Qi.current.useInsertionEffect(n, e)
}
;
Dt.useLayoutEffect = function(n, e) {
    return Qi.current.useLayoutEffect(n, e)
}
;
Dt.useMemo = function(n, e) {
    return Qi.current.useMemo(n, e)
}
;
Dt.useReducer = function(n, e, t) {
    return Qi.current.useReducer(n, e, t)
}
;
Dt.useRef = function(n) {
    return Qi.current.useRef(n)
}
;
Dt.useState = function(n) {
    return Qi.current.useState(n)
}
;
Dt.useSyncExternalStore = function(n, e, t) {
    return Qi.current.useSyncExternalStore(n, e, t)
}
;
Dt.useTransition = function() {
    return Qi.current.useTransition()
}
;
Dt.version = "18.3.1";
G4.exports = Dt;
var be = G4.exports;
const Z = oc(be);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KW = be
  , XW = Symbol.for("react.element")
  , YW = Symbol.for("react.fragment")
  , $W = Object.prototype.hasOwnProperty
  , ZW = KW.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , JW = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function J4(n, e, t) {
    var r, i = {}, s = null, o = null;
    t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (r in e)
        $W.call(e, r) && !JW.hasOwnProperty(r) && (i[r] = e[r]);
    if (n && n.defaultProps)
        for (r in e = n.defaultProps,
        e)
            i[r] === void 0 && (i[r] = e[r]);
    return {
        $$typeof: XW,
        type: n,
        key: s,
        ref: o,
        props: i,
        _owner: ZW.current
    }
}
Ux.Fragment = YW;
Ux.jsx = J4;
Ux.jsxs = J4;
z4.exports = Ux;
var k = z4.exports
  , lI = {
    exports: {}
};
const qW = {}
  , e9 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: qW
}, Symbol.toStringTag, {
    value: "Module"
}))
  , t9 = RW(e9);
lI.exports;
(function(n) {
    (function(e, t) {
        function r(T, y) {
            if (!T)
                throw new Error(y || "Assertion failed")
        }
        function i(T, y) {
            T.super_ = y;
            var E = function() {};
            E.prototype = y.prototype,
            T.prototype = new E,
            T.prototype.constructor = T
        }
        function s(T, y, E) {
            if (s.isBN(T))
                return T;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            T !== null && ((y === "le" || y === "be") && (E = y,
            y = 10),
            this._init(T || 0, y || 10, E || "be"))
        }
        typeof e == "object" ? e.exports = s : t.BN = s,
        s.BN = s,
        s.wordSize = 26;
        var o;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = t9.Buffer
        } catch {}
        s.isBN = function(y) {
            return y instanceof s ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === s.wordSize && Array.isArray(y.words)
        }
        ,
        s.max = function(y, E) {
            return y.cmp(E) > 0 ? y : E
        }
        ,
        s.min = function(y, E) {
            return y.cmp(E) < 0 ? y : E
        }
        ,
        s.prototype._init = function(y, E, R) {
            if (typeof y == "number")
                return this._initNumber(y, E, R);
            if (typeof y == "object")
                return this._initArray(y, E, R);
            E === "hex" && (E = 16),
            r(E === (E | 0) && E >= 2 && E <= 36),
            y = y.toString().replace(/\s+/g, "");
            var F = 0;
            y[0] === "-" && (F++,
            this.negative = 1),
            F < y.length && (E === 16 ? this._parseHex(y, F, R) : (this._parseBase(y, E, F),
            R === "le" && this._initArray(this.toArray(), E, R)))
        }
        ,
        s.prototype._initNumber = function(y, E, R) {
            y < 0 && (this.negative = 1,
            y = -y),
            y < 67108864 ? (this.words = [y & 67108863],
            this.length = 1) : y < 4503599627370496 ? (this.words = [y & 67108863, y / 67108864 & 67108863],
            this.length = 2) : (r(y < 9007199254740992),
            this.words = [y & 67108863, y / 67108864 & 67108863, 1],
            this.length = 3),
            R === "le" && this._initArray(this.toArray(), E, R)
        }
        ,
        s.prototype._initArray = function(y, E, R) {
            if (r(typeof y.length == "number"),
            y.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(y.length / 3),
            this.words = new Array(this.length);
            for (var F = 0; F < this.length; F++)
                this.words[F] = 0;
            var O, z, j = 0;
            if (R === "be")
                for (F = y.length - 1,
                O = 0; F >= 0; F -= 3)
                    z = y[F] | y[F - 1] << 8 | y[F - 2] << 16,
                    this.words[O] |= z << j & 67108863,
                    this.words[O + 1] = z >>> 26 - j & 67108863,
                    j += 24,
                    j >= 26 && (j -= 26,
                    O++);
            else if (R === "le")
                for (F = 0,
                O = 0; F < y.length; F += 3)
                    z = y[F] | y[F + 1] << 8 | y[F + 2] << 16,
                    this.words[O] |= z << j & 67108863,
                    this.words[O + 1] = z >>> 26 - j & 67108863,
                    j += 24,
                    j >= 26 && (j -= 26,
                    O++);
            return this._strip()
        }
        ;
        function a(T, y) {
            var E = T.charCodeAt(y);
            if (E >= 48 && E <= 57)
                return E - 48;
            if (E >= 65 && E <= 70)
                return E - 55;
            if (E >= 97 && E <= 102)
                return E - 87;
            r(!1, "Invalid character in " + T)
        }
        function l(T, y, E) {
            var R = a(T, E);
            return E - 1 >= y && (R |= a(T, E - 1) << 4),
            R
        }
        s.prototype._parseHex = function(y, E, R) {
            this.length = Math.ceil((y.length - E) / 6),
            this.words = new Array(this.length);
            for (var F = 0; F < this.length; F++)
                this.words[F] = 0;
            var O = 0, z = 0, j;
            if (R === "be")
                for (F = y.length - 1; F >= E; F -= 2)
                    j = l(y, E, F) << O,
                    this.words[z] |= j & 67108863,
                    O >= 18 ? (O -= 18,
                    z += 1,
                    this.words[z] |= j >>> 26) : O += 8;
            else {
                var Q = y.length - E;
                for (F = Q % 2 === 0 ? E + 1 : E; F < y.length; F += 2)
                    j = l(y, E, F) << O,
                    this.words[z] |= j & 67108863,
                    O >= 18 ? (O -= 18,
                    z += 1,
                    this.words[z] |= j >>> 26) : O += 8
            }
            this._strip()
        }
        ;
        function c(T, y, E, R) {
            for (var F = 0, O = 0, z = Math.min(T.length, E), j = y; j < z; j++) {
                var Q = T.charCodeAt(j) - 48;
                F *= R,
                Q >= 49 ? O = Q - 49 + 10 : Q >= 17 ? O = Q - 17 + 10 : O = Q,
                r(Q >= 0 && O < R, "Invalid character"),
                F += O
            }
            return F
        }
        s.prototype._parseBase = function(y, E, R) {
            this.words = [0],
            this.length = 1;
            for (var F = 0, O = 1; O <= 67108863; O *= E)
                F++;
            F--,
            O = O / E | 0;
            for (var z = y.length - R, j = z % F, Q = Math.min(z, z - j) + R, C = 0, W = R; W < Q; W += F)
                C = c(y, W, W + F, E),
                this.imuln(O),
                this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C);
            if (j !== 0) {
                var ee = 1;
                for (C = c(y, W, y.length, E),
                W = 0; W < j; W++)
                    ee *= E;
                this.imuln(ee),
                this.words[0] + C < 67108864 ? this.words[0] += C : this._iaddn(C)
            }
            this._strip()
        }
        ,
        s.prototype.copy = function(y) {
            y.words = new Array(this.length);
            for (var E = 0; E < this.length; E++)
                y.words[E] = this.words[E];
            y.length = this.length,
            y.negative = this.negative,
            y.red = this.red
        }
        ;
        function A(T, y) {
            T.words = y.words,
            T.length = y.length,
            T.negative = y.negative,
            T.red = y.red
        }
        if (s.prototype._move = function(y) {
            A(y, this)
        }
        ,
        s.prototype.clone = function() {
            var y = new s(null);
            return this.copy(y),
            y
        }
        ,
        s.prototype._expand = function(y) {
            for (; this.length < y; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        s.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        s.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function")
            try {
                s.prototype[Symbol.for("nodejs.util.inspect.custom")] = u
            } catch {
                s.prototype.inspect = u
            }
        else
            s.prototype.inspect = u;
        function u() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var f = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , d = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(y, E) {
            y = y || 10,
            E = E | 0 || 1;
            var R;
            if (y === 16 || y === "hex") {
                R = "";
                for (var F = 0, O = 0, z = 0; z < this.length; z++) {
                    var j = this.words[z]
                      , Q = ((j << F | O) & 16777215).toString(16);
                    O = j >>> 24 - F & 16777215,
                    F += 2,
                    F >= 26 && (F -= 26,
                    z--),
                    O !== 0 || z !== this.length - 1 ? R = f[6 - Q.length] + Q + R : R = Q + R
                }
                for (O !== 0 && (R = O.toString(16) + R); R.length % E !== 0; )
                    R = "0" + R;
                return this.negative !== 0 && (R = "-" + R),
                R
            }
            if (y === (y | 0) && y >= 2 && y <= 36) {
                var C = h[y]
                  , W = d[y];
                R = "";
                var ee = this.clone();
                for (ee.negative = 0; !ee.isZero(); ) {
                    var P = ee.modrn(W).toString(y);
                    ee = ee.idivn(W),
                    ee.isZero() ? R = P + R : R = f[C - P.length] + P + R
                }
                for (this.isZero() && (R = "0" + R); R.length % E !== 0; )
                    R = "0" + R;
                return this.negative !== 0 && (R = "-" + R),
                R
            }
            r(!1, "Base should be between 2 and 36")
        }
        ,
        s.prototype.toNumber = function() {
            var y = this.words[0];
            return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -y : y
        }
        ,
        s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        o && (s.prototype.toBuffer = function(y, E) {
            return this.toArrayLike(o, y, E)
        }
        ),
        s.prototype.toArray = function(y, E) {
            return this.toArrayLike(Array, y, E)
        }
        ;
        var m = function(y, E) {
            return y.allocUnsafe ? y.allocUnsafe(E) : new y(E)
        };
        s.prototype.toArrayLike = function(y, E, R) {
            this._strip();
            var F = this.byteLength()
              , O = R || Math.max(1, F);
            r(F <= O, "byte array longer than desired length"),
            r(O > 0, "Requested array length <= 0");
            var z = m(y, O)
              , j = E === "le" ? "LE" : "BE";
            return this["_toArrayLike" + j](z, F),
            z
        }
        ,
        s.prototype._toArrayLikeLE = function(y, E) {
            for (var R = 0, F = 0, O = 0, z = 0; O < this.length; O++) {
                var j = this.words[O] << z | F;
                y[R++] = j & 255,
                R < y.length && (y[R++] = j >> 8 & 255),
                R < y.length && (y[R++] = j >> 16 & 255),
                z === 6 ? (R < y.length && (y[R++] = j >> 24 & 255),
                F = 0,
                z = 0) : (F = j >>> 24,
                z += 2)
            }
            if (R < y.length)
                for (y[R++] = F; R < y.length; )
                    y[R++] = 0
        }
        ,
        s.prototype._toArrayLikeBE = function(y, E) {
            for (var R = y.length - 1, F = 0, O = 0, z = 0; O < this.length; O++) {
                var j = this.words[O] << z | F;
                y[R--] = j & 255,
                R >= 0 && (y[R--] = j >> 8 & 255),
                R >= 0 && (y[R--] = j >> 16 & 255),
                z === 6 ? (R >= 0 && (y[R--] = j >> 24 & 255),
                F = 0,
                z = 0) : (F = j >>> 24,
                z += 2)
            }
            if (R >= 0)
                for (y[R--] = F; R >= 0; )
                    y[R--] = 0
        }
        ,
        Math.clz32 ? s.prototype._countBits = function(y) {
            return 32 - Math.clz32(y)
        }
        : s.prototype._countBits = function(y) {
            var E = y
              , R = 0;
            return E >= 4096 && (R += 13,
            E >>>= 13),
            E >= 64 && (R += 7,
            E >>>= 7),
            E >= 8 && (R += 4,
            E >>>= 4),
            E >= 2 && (R += 2,
            E >>>= 2),
            R + E
        }
        ,
        s.prototype._zeroBits = function(y) {
            if (y === 0)
                return 26;
            var E = y
              , R = 0;
            return E & 8191 || (R += 13,
            E >>>= 13),
            E & 127 || (R += 7,
            E >>>= 7),
            E & 15 || (R += 4,
            E >>>= 4),
            E & 3 || (R += 2,
            E >>>= 2),
            E & 1 || R++,
            R
        }
        ,
        s.prototype.bitLength = function() {
            var y = this.words[this.length - 1]
              , E = this._countBits(y);
            return (this.length - 1) * 26 + E
        }
        ;
        function g(T) {
            for (var y = new Array(T.bitLength()), E = 0; E < y.length; E++) {
                var R = E / 26 | 0
                  , F = E % 26;
                y[E] = T.words[R] >>> F & 1
            }
            return y
        }
        s.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var y = 0, E = 0; E < this.length; E++) {
                var R = this._zeroBits(this.words[E]);
                if (y += R,
                R !== 26)
                    break
            }
            return y
        }
        ,
        s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        s.prototype.toTwos = function(y) {
            return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone()
        }
        ,
        s.prototype.fromTwos = function(y) {
            return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone()
        }
        ,
        s.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        s.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        s.prototype.iuor = function(y) {
            for (; this.length < y.length; )
                this.words[this.length++] = 0;
            for (var E = 0; E < y.length; E++)
                this.words[E] = this.words[E] | y.words[E];
            return this._strip()
        }
        ,
        s.prototype.ior = function(y) {
            return r((this.negative | y.negative) === 0),
            this.iuor(y)
        }
        ,
        s.prototype.or = function(y) {
            return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this)
        }
        ,
        s.prototype.uor = function(y) {
            return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this)
        }
        ,
        s.prototype.iuand = function(y) {
            var E;
            this.length > y.length ? E = y : E = this;
            for (var R = 0; R < E.length; R++)
                this.words[R] = this.words[R] & y.words[R];
            return this.length = E.length,
            this._strip()
        }
        ,
        s.prototype.iand = function(y) {
            return r((this.negative | y.negative) === 0),
            this.iuand(y)
        }
        ,
        s.prototype.and = function(y) {
            return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this)
        }
        ,
        s.prototype.uand = function(y) {
            return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this)
        }
        ,
        s.prototype.iuxor = function(y) {
            var E, R;
            this.length > y.length ? (E = this,
            R = y) : (E = y,
            R = this);
            for (var F = 0; F < R.length; F++)
                this.words[F] = E.words[F] ^ R.words[F];
            if (this !== E)
                for (; F < E.length; F++)
                    this.words[F] = E.words[F];
            return this.length = E.length,
            this._strip()
        }
        ,
        s.prototype.ixor = function(y) {
            return r((this.negative | y.negative) === 0),
            this.iuxor(y)
        }
        ,
        s.prototype.xor = function(y) {
            return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this)
        }
        ,
        s.prototype.uxor = function(y) {
            return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this)
        }
        ,
        s.prototype.inotn = function(y) {
            r(typeof y == "number" && y >= 0);
            var E = Math.ceil(y / 26) | 0
              , R = y % 26;
            this._expand(E),
            R > 0 && E--;
            for (var F = 0; F < E; F++)
                this.words[F] = ~this.words[F] & 67108863;
            return R > 0 && (this.words[F] = ~this.words[F] & 67108863 >> 26 - R),
            this._strip()
        }
        ,
        s.prototype.notn = function(y) {
            return this.clone().inotn(y)
        }
        ,
        s.prototype.setn = function(y, E) {
            r(typeof y == "number" && y >= 0);
            var R = y / 26 | 0
              , F = y % 26;
            return this._expand(R + 1),
            E ? this.words[R] = this.words[R] | 1 << F : this.words[R] = this.words[R] & ~(1 << F),
            this._strip()
        }
        ,
        s.prototype.iadd = function(y) {
            var E;
            if (this.negative !== 0 && y.negative === 0)
                return this.negative = 0,
                E = this.isub(y),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && y.negative !== 0)
                return y.negative = 0,
                E = this.isub(y),
                y.negative = 1,
                E._normSign();
            var R, F;
            this.length > y.length ? (R = this,
            F = y) : (R = y,
            F = this);
            for (var O = 0, z = 0; z < F.length; z++)
                E = (R.words[z] | 0) + (F.words[z] | 0) + O,
                this.words[z] = E & 67108863,
                O = E >>> 26;
            for (; O !== 0 && z < R.length; z++)
                E = (R.words[z] | 0) + O,
                this.words[z] = E & 67108863,
                O = E >>> 26;
            if (this.length = R.length,
            O !== 0)
                this.words[this.length] = O,
                this.length++;
            else if (R !== this)
                for (; z < R.length; z++)
                    this.words[z] = R.words[z];
            return this
        }
        ,
        s.prototype.add = function(y) {
            var E;
            return y.negative !== 0 && this.negative === 0 ? (y.negative = 0,
            E = this.sub(y),
            y.negative ^= 1,
            E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            E = y.sub(this),
            this.negative = 1,
            E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this)
        }
        ,
        s.prototype.isub = function(y) {
            if (y.negative !== 0) {
                y.negative = 0;
                var E = this.iadd(y);
                return y.negative = 1,
                E._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(y),
                this.negative = 1,
                this._normSign();
            var R = this.cmp(y);
            if (R === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var F, O;
            R > 0 ? (F = this,
            O = y) : (F = y,
            O = this);
            for (var z = 0, j = 0; j < O.length; j++)
                E = (F.words[j] | 0) - (O.words[j] | 0) + z,
                z = E >> 26,
                this.words[j] = E & 67108863;
            for (; z !== 0 && j < F.length; j++)
                E = (F.words[j] | 0) + z,
                z = E >> 26,
                this.words[j] = E & 67108863;
            if (z === 0 && j < F.length && F !== this)
                for (; j < F.length; j++)
                    this.words[j] = F.words[j];
            return this.length = Math.max(this.length, j),
            F !== this && (this.negative = 1),
            this._strip()
        }
        ,
        s.prototype.sub = function(y) {
            return this.clone().isub(y)
        }
        ;
        function p(T, y, E) {
            E.negative = y.negative ^ T.negative;
            var R = T.length + y.length | 0;
            E.length = R,
            R = R - 1 | 0;
            var F = T.words[0] | 0
              , O = y.words[0] | 0
              , z = F * O
              , j = z & 67108863
              , Q = z / 67108864 | 0;
            E.words[0] = j;
            for (var C = 1; C < R; C++) {
                for (var W = Q >>> 26, ee = Q & 67108863, P = Math.min(C, y.length - 1), re = Math.max(0, C - T.length + 1); re <= P; re++) {
                    var ue = C - re | 0;
                    F = T.words[ue] | 0,
                    O = y.words[re] | 0,
                    z = F * O + ee,
                    W += z / 67108864 | 0,
                    ee = z & 67108863
                }
                E.words[C] = ee | 0,
                Q = W | 0
            }
            return Q !== 0 ? E.words[C] = Q | 0 : E.length--,
            E._strip()
        }
        var v = function(y, E, R) {
            var F = y.words, O = E.words, z = R.words, j = 0, Q, C, W, ee = F[0] | 0, P = ee & 8191, re = ee >>> 13, ue = F[1] | 0, le = ue & 8191, me = ue >>> 13, ie = F[2] | 0, ge = ie & 8191, _e = ie >>> 13, se = F[3] | 0, H = se & 8191, fe = se >>> 13, Ae = F[4] | 0, J = Ae & 8191, q = Ae >>> 13, he = F[5] | 0, X = he & 8191, G = he >>> 13, ne = F[6] | 0, Y = ne & 8191, de = ne >>> 13, ae = F[7] | 0, Ee = ae & 8191, V = ae >>> 13, U = F[8] | 0, N = U & 8191, K = U >>> 13, oe = F[9] | 0, pe = oe & 8191, ve = oe >>> 13, Ce = O[0] | 0, Le = Ce & 8191, Re = Ce >>> 13, $e = O[1] | 0, ce = $e & 8191, Pe = $e >>> 13, Se = O[2] | 0, Te = Se & 8191, Fe = Se >>> 13, De = O[3] | 0, Ze = De & 8191, At = De >>> 13, Pn = O[4] | 0, rt = Pn & 8191, xt = Pn >>> 13, Tr = O[5] | 0, tn = Tr & 8191, qt = Tr >>> 13, Jr = O[6] | 0, en = Jr & 8191, nn = Jr >>> 13, Ks = O[7] | 0, Xt = Ks & 8191, Yt = Ks >>> 13, Ii = O[8] | 0, rn = Ii & 8191, sn = Ii >>> 13, ma = O[9] | 0, un = ma & 8191, on = ma >>> 13;
            R.negative = y.negative ^ E.negative,
            R.length = 19,
            Q = Math.imul(P, Le),
            C = Math.imul(P, Re),
            C = C + Math.imul(re, Le) | 0,
            W = Math.imul(re, Re);
            var te = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (te >>> 26) | 0,
            te &= 67108863,
            Q = Math.imul(le, Le),
            C = Math.imul(le, Re),
            C = C + Math.imul(me, Le) | 0,
            W = Math.imul(me, Re),
            Q = Q + Math.imul(P, ce) | 0,
            C = C + Math.imul(P, Pe) | 0,
            C = C + Math.imul(re, ce) | 0,
            W = W + Math.imul(re, Pe) | 0;
            var ye = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (ye >>> 26) | 0,
            ye &= 67108863,
            Q = Math.imul(ge, Le),
            C = Math.imul(ge, Re),
            C = C + Math.imul(_e, Le) | 0,
            W = Math.imul(_e, Re),
            Q = Q + Math.imul(le, ce) | 0,
            C = C + Math.imul(le, Pe) | 0,
            C = C + Math.imul(me, ce) | 0,
            W = W + Math.imul(me, Pe) | 0,
            Q = Q + Math.imul(P, Te) | 0,
            C = C + Math.imul(P, Fe) | 0,
            C = C + Math.imul(re, Te) | 0,
            W = W + Math.imul(re, Fe) | 0;
            var Be = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (Be >>> 26) | 0,
            Be &= 67108863,
            Q = Math.imul(H, Le),
            C = Math.imul(H, Re),
            C = C + Math.imul(fe, Le) | 0,
            W = Math.imul(fe, Re),
            Q = Q + Math.imul(ge, ce) | 0,
            C = C + Math.imul(ge, Pe) | 0,
            C = C + Math.imul(_e, ce) | 0,
            W = W + Math.imul(_e, Pe) | 0,
            Q = Q + Math.imul(le, Te) | 0,
            C = C + Math.imul(le, Fe) | 0,
            C = C + Math.imul(me, Te) | 0,
            W = W + Math.imul(me, Fe) | 0,
            Q = Q + Math.imul(P, Ze) | 0,
            C = C + Math.imul(P, At) | 0,
            C = C + Math.imul(re, Ze) | 0,
            W = W + Math.imul(re, At) | 0;
            var Me = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (Me >>> 26) | 0,
            Me &= 67108863,
            Q = Math.imul(J, Le),
            C = Math.imul(J, Re),
            C = C + Math.imul(q, Le) | 0,
            W = Math.imul(q, Re),
            Q = Q + Math.imul(H, ce) | 0,
            C = C + Math.imul(H, Pe) | 0,
            C = C + Math.imul(fe, ce) | 0,
            W = W + Math.imul(fe, Pe) | 0,
            Q = Q + Math.imul(ge, Te) | 0,
            C = C + Math.imul(ge, Fe) | 0,
            C = C + Math.imul(_e, Te) | 0,
            W = W + Math.imul(_e, Fe) | 0,
            Q = Q + Math.imul(le, Ze) | 0,
            C = C + Math.imul(le, At) | 0,
            C = C + Math.imul(me, Ze) | 0,
            W = W + Math.imul(me, At) | 0,
            Q = Q + Math.imul(P, rt) | 0,
            C = C + Math.imul(P, xt) | 0,
            C = C + Math.imul(re, rt) | 0,
            W = W + Math.imul(re, xt) | 0;
            var we = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (we >>> 26) | 0,
            we &= 67108863,
            Q = Math.imul(X, Le),
            C = Math.imul(X, Re),
            C = C + Math.imul(G, Le) | 0,
            W = Math.imul(G, Re),
            Q = Q + Math.imul(J, ce) | 0,
            C = C + Math.imul(J, Pe) | 0,
            C = C + Math.imul(q, ce) | 0,
            W = W + Math.imul(q, Pe) | 0,
            Q = Q + Math.imul(H, Te) | 0,
            C = C + Math.imul(H, Fe) | 0,
            C = C + Math.imul(fe, Te) | 0,
            W = W + Math.imul(fe, Fe) | 0,
            Q = Q + Math.imul(ge, Ze) | 0,
            C = C + Math.imul(ge, At) | 0,
            C = C + Math.imul(_e, Ze) | 0,
            W = W + Math.imul(_e, At) | 0,
            Q = Q + Math.imul(le, rt) | 0,
            C = C + Math.imul(le, xt) | 0,
            C = C + Math.imul(me, rt) | 0,
            W = W + Math.imul(me, xt) | 0,
            Q = Q + Math.imul(P, tn) | 0,
            C = C + Math.imul(P, qt) | 0,
            C = C + Math.imul(re, tn) | 0,
            W = W + Math.imul(re, qt) | 0;
            var ke = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (ke >>> 26) | 0,
            ke &= 67108863,
            Q = Math.imul(Y, Le),
            C = Math.imul(Y, Re),
            C = C + Math.imul(de, Le) | 0,
            W = Math.imul(de, Re),
            Q = Q + Math.imul(X, ce) | 0,
            C = C + Math.imul(X, Pe) | 0,
            C = C + Math.imul(G, ce) | 0,
            W = W + Math.imul(G, Pe) | 0,
            Q = Q + Math.imul(J, Te) | 0,
            C = C + Math.imul(J, Fe) | 0,
            C = C + Math.imul(q, Te) | 0,
            W = W + Math.imul(q, Fe) | 0,
            Q = Q + Math.imul(H, Ze) | 0,
            C = C + Math.imul(H, At) | 0,
            C = C + Math.imul(fe, Ze) | 0,
            W = W + Math.imul(fe, At) | 0,
            Q = Q + Math.imul(ge, rt) | 0,
            C = C + Math.imul(ge, xt) | 0,
            C = C + Math.imul(_e, rt) | 0,
            W = W + Math.imul(_e, xt) | 0,
            Q = Q + Math.imul(le, tn) | 0,
            C = C + Math.imul(le, qt) | 0,
            C = C + Math.imul(me, tn) | 0,
            W = W + Math.imul(me, qt) | 0,
            Q = Q + Math.imul(P, en) | 0,
            C = C + Math.imul(P, nn) | 0,
            C = C + Math.imul(re, en) | 0,
            W = W + Math.imul(re, nn) | 0;
            var Xe = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (Xe >>> 26) | 0,
            Xe &= 67108863,
            Q = Math.imul(Ee, Le),
            C = Math.imul(Ee, Re),
            C = C + Math.imul(V, Le) | 0,
            W = Math.imul(V, Re),
            Q = Q + Math.imul(Y, ce) | 0,
            C = C + Math.imul(Y, Pe) | 0,
            C = C + Math.imul(de, ce) | 0,
            W = W + Math.imul(de, Pe) | 0,
            Q = Q + Math.imul(X, Te) | 0,
            C = C + Math.imul(X, Fe) | 0,
            C = C + Math.imul(G, Te) | 0,
            W = W + Math.imul(G, Fe) | 0,
            Q = Q + Math.imul(J, Ze) | 0,
            C = C + Math.imul(J, At) | 0,
            C = C + Math.imul(q, Ze) | 0,
            W = W + Math.imul(q, At) | 0,
            Q = Q + Math.imul(H, rt) | 0,
            C = C + Math.imul(H, xt) | 0,
            C = C + Math.imul(fe, rt) | 0,
            W = W + Math.imul(fe, xt) | 0,
            Q = Q + Math.imul(ge, tn) | 0,
            C = C + Math.imul(ge, qt) | 0,
            C = C + Math.imul(_e, tn) | 0,
            W = W + Math.imul(_e, qt) | 0,
            Q = Q + Math.imul(le, en) | 0,
            C = C + Math.imul(le, nn) | 0,
            C = C + Math.imul(me, en) | 0,
            W = W + Math.imul(me, nn) | 0,
            Q = Q + Math.imul(P, Xt) | 0,
            C = C + Math.imul(P, Yt) | 0,
            C = C + Math.imul(re, Xt) | 0,
            W = W + Math.imul(re, Yt) | 0;
            var qe = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (qe >>> 26) | 0,
            qe &= 67108863,
            Q = Math.imul(N, Le),
            C = Math.imul(N, Re),
            C = C + Math.imul(K, Le) | 0,
            W = Math.imul(K, Re),
            Q = Q + Math.imul(Ee, ce) | 0,
            C = C + Math.imul(Ee, Pe) | 0,
            C = C + Math.imul(V, ce) | 0,
            W = W + Math.imul(V, Pe) | 0,
            Q = Q + Math.imul(Y, Te) | 0,
            C = C + Math.imul(Y, Fe) | 0,
            C = C + Math.imul(de, Te) | 0,
            W = W + Math.imul(de, Fe) | 0,
            Q = Q + Math.imul(X, Ze) | 0,
            C = C + Math.imul(X, At) | 0,
            C = C + Math.imul(G, Ze) | 0,
            W = W + Math.imul(G, At) | 0,
            Q = Q + Math.imul(J, rt) | 0,
            C = C + Math.imul(J, xt) | 0,
            C = C + Math.imul(q, rt) | 0,
            W = W + Math.imul(q, xt) | 0,
            Q = Q + Math.imul(H, tn) | 0,
            C = C + Math.imul(H, qt) | 0,
            C = C + Math.imul(fe, tn) | 0,
            W = W + Math.imul(fe, qt) | 0,
            Q = Q + Math.imul(ge, en) | 0,
            C = C + Math.imul(ge, nn) | 0,
            C = C + Math.imul(_e, en) | 0,
            W = W + Math.imul(_e, nn) | 0,
            Q = Q + Math.imul(le, Xt) | 0,
            C = C + Math.imul(le, Yt) | 0,
            C = C + Math.imul(me, Xt) | 0,
            W = W + Math.imul(me, Yt) | 0,
            Q = Q + Math.imul(P, rn) | 0,
            C = C + Math.imul(P, sn) | 0,
            C = C + Math.imul(re, rn) | 0,
            W = W + Math.imul(re, sn) | 0;
            var tt = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (tt >>> 26) | 0,
            tt &= 67108863,
            Q = Math.imul(pe, Le),
            C = Math.imul(pe, Re),
            C = C + Math.imul(ve, Le) | 0,
            W = Math.imul(ve, Re),
            Q = Q + Math.imul(N, ce) | 0,
            C = C + Math.imul(N, Pe) | 0,
            C = C + Math.imul(K, ce) | 0,
            W = W + Math.imul(K, Pe) | 0,
            Q = Q + Math.imul(Ee, Te) | 0,
            C = C + Math.imul(Ee, Fe) | 0,
            C = C + Math.imul(V, Te) | 0,
            W = W + Math.imul(V, Fe) | 0,
            Q = Q + Math.imul(Y, Ze) | 0,
            C = C + Math.imul(Y, At) | 0,
            C = C + Math.imul(de, Ze) | 0,
            W = W + Math.imul(de, At) | 0,
            Q = Q + Math.imul(X, rt) | 0,
            C = C + Math.imul(X, xt) | 0,
            C = C + Math.imul(G, rt) | 0,
            W = W + Math.imul(G, xt) | 0,
            Q = Q + Math.imul(J, tn) | 0,
            C = C + Math.imul(J, qt) | 0,
            C = C + Math.imul(q, tn) | 0,
            W = W + Math.imul(q, qt) | 0,
            Q = Q + Math.imul(H, en) | 0,
            C = C + Math.imul(H, nn) | 0,
            C = C + Math.imul(fe, en) | 0,
            W = W + Math.imul(fe, nn) | 0,
            Q = Q + Math.imul(ge, Xt) | 0,
            C = C + Math.imul(ge, Yt) | 0,
            C = C + Math.imul(_e, Xt) | 0,
            W = W + Math.imul(_e, Yt) | 0,
            Q = Q + Math.imul(le, rn) | 0,
            C = C + Math.imul(le, sn) | 0,
            C = C + Math.imul(me, rn) | 0,
            W = W + Math.imul(me, sn) | 0,
            Q = Q + Math.imul(P, un) | 0,
            C = C + Math.imul(P, on) | 0,
            C = C + Math.imul(re, un) | 0,
            W = W + Math.imul(re, on) | 0;
            var ft = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (ft >>> 26) | 0,
            ft &= 67108863,
            Q = Math.imul(pe, ce),
            C = Math.imul(pe, Pe),
            C = C + Math.imul(ve, ce) | 0,
            W = Math.imul(ve, Pe),
            Q = Q + Math.imul(N, Te) | 0,
            C = C + Math.imul(N, Fe) | 0,
            C = C + Math.imul(K, Te) | 0,
            W = W + Math.imul(K, Fe) | 0,
            Q = Q + Math.imul(Ee, Ze) | 0,
            C = C + Math.imul(Ee, At) | 0,
            C = C + Math.imul(V, Ze) | 0,
            W = W + Math.imul(V, At) | 0,
            Q = Q + Math.imul(Y, rt) | 0,
            C = C + Math.imul(Y, xt) | 0,
            C = C + Math.imul(de, rt) | 0,
            W = W + Math.imul(de, xt) | 0,
            Q = Q + Math.imul(X, tn) | 0,
            C = C + Math.imul(X, qt) | 0,
            C = C + Math.imul(G, tn) | 0,
            W = W + Math.imul(G, qt) | 0,
            Q = Q + Math.imul(J, en) | 0,
            C = C + Math.imul(J, nn) | 0,
            C = C + Math.imul(q, en) | 0,
            W = W + Math.imul(q, nn) | 0,
            Q = Q + Math.imul(H, Xt) | 0,
            C = C + Math.imul(H, Yt) | 0,
            C = C + Math.imul(fe, Xt) | 0,
            W = W + Math.imul(fe, Yt) | 0,
            Q = Q + Math.imul(ge, rn) | 0,
            C = C + Math.imul(ge, sn) | 0,
            C = C + Math.imul(_e, rn) | 0,
            W = W + Math.imul(_e, sn) | 0,
            Q = Q + Math.imul(le, un) | 0,
            C = C + Math.imul(le, on) | 0,
            C = C + Math.imul(me, un) | 0,
            W = W + Math.imul(me, on) | 0;
            var mt = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (mt >>> 26) | 0,
            mt &= 67108863,
            Q = Math.imul(pe, Te),
            C = Math.imul(pe, Fe),
            C = C + Math.imul(ve, Te) | 0,
            W = Math.imul(ve, Fe),
            Q = Q + Math.imul(N, Ze) | 0,
            C = C + Math.imul(N, At) | 0,
            C = C + Math.imul(K, Ze) | 0,
            W = W + Math.imul(K, At) | 0,
            Q = Q + Math.imul(Ee, rt) | 0,
            C = C + Math.imul(Ee, xt) | 0,
            C = C + Math.imul(V, rt) | 0,
            W = W + Math.imul(V, xt) | 0,
            Q = Q + Math.imul(Y, tn) | 0,
            C = C + Math.imul(Y, qt) | 0,
            C = C + Math.imul(de, tn) | 0,
            W = W + Math.imul(de, qt) | 0,
            Q = Q + Math.imul(X, en) | 0,
            C = C + Math.imul(X, nn) | 0,
            C = C + Math.imul(G, en) | 0,
            W = W + Math.imul(G, nn) | 0,
            Q = Q + Math.imul(J, Xt) | 0,
            C = C + Math.imul(J, Yt) | 0,
            C = C + Math.imul(q, Xt) | 0,
            W = W + Math.imul(q, Yt) | 0,
            Q = Q + Math.imul(H, rn) | 0,
            C = C + Math.imul(H, sn) | 0,
            C = C + Math.imul(fe, rn) | 0,
            W = W + Math.imul(fe, sn) | 0,
            Q = Q + Math.imul(ge, un) | 0,
            C = C + Math.imul(ge, on) | 0,
            C = C + Math.imul(_e, un) | 0,
            W = W + Math.imul(_e, on) | 0;
            var st = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (st >>> 26) | 0,
            st &= 67108863,
            Q = Math.imul(pe, Ze),
            C = Math.imul(pe, At),
            C = C + Math.imul(ve, Ze) | 0,
            W = Math.imul(ve, At),
            Q = Q + Math.imul(N, rt) | 0,
            C = C + Math.imul(N, xt) | 0,
            C = C + Math.imul(K, rt) | 0,
            W = W + Math.imul(K, xt) | 0,
            Q = Q + Math.imul(Ee, tn) | 0,
            C = C + Math.imul(Ee, qt) | 0,
            C = C + Math.imul(V, tn) | 0,
            W = W + Math.imul(V, qt) | 0,
            Q = Q + Math.imul(Y, en) | 0,
            C = C + Math.imul(Y, nn) | 0,
            C = C + Math.imul(de, en) | 0,
            W = W + Math.imul(de, nn) | 0,
            Q = Q + Math.imul(X, Xt) | 0,
            C = C + Math.imul(X, Yt) | 0,
            C = C + Math.imul(G, Xt) | 0,
            W = W + Math.imul(G, Yt) | 0,
            Q = Q + Math.imul(J, rn) | 0,
            C = C + Math.imul(J, sn) | 0,
            C = C + Math.imul(q, rn) | 0,
            W = W + Math.imul(q, sn) | 0,
            Q = Q + Math.imul(H, un) | 0,
            C = C + Math.imul(H, on) | 0,
            C = C + Math.imul(fe, un) | 0,
            W = W + Math.imul(fe, on) | 0;
            var Wt = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (Wt >>> 26) | 0,
            Wt &= 67108863,
            Q = Math.imul(pe, rt),
            C = Math.imul(pe, xt),
            C = C + Math.imul(ve, rt) | 0,
            W = Math.imul(ve, xt),
            Q = Q + Math.imul(N, tn) | 0,
            C = C + Math.imul(N, qt) | 0,
            C = C + Math.imul(K, tn) | 0,
            W = W + Math.imul(K, qt) | 0,
            Q = Q + Math.imul(Ee, en) | 0,
            C = C + Math.imul(Ee, nn) | 0,
            C = C + Math.imul(V, en) | 0,
            W = W + Math.imul(V, nn) | 0,
            Q = Q + Math.imul(Y, Xt) | 0,
            C = C + Math.imul(Y, Yt) | 0,
            C = C + Math.imul(de, Xt) | 0,
            W = W + Math.imul(de, Yt) | 0,
            Q = Q + Math.imul(X, rn) | 0,
            C = C + Math.imul(X, sn) | 0,
            C = C + Math.imul(G, rn) | 0,
            W = W + Math.imul(G, sn) | 0,
            Q = Q + Math.imul(J, un) | 0,
            C = C + Math.imul(J, on) | 0,
            C = C + Math.imul(q, un) | 0,
            W = W + Math.imul(q, on) | 0;
            var fn = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (fn >>> 26) | 0,
            fn &= 67108863,
            Q = Math.imul(pe, tn),
            C = Math.imul(pe, qt),
            C = C + Math.imul(ve, tn) | 0,
            W = Math.imul(ve, qt),
            Q = Q + Math.imul(N, en) | 0,
            C = C + Math.imul(N, nn) | 0,
            C = C + Math.imul(K, en) | 0,
            W = W + Math.imul(K, nn) | 0,
            Q = Q + Math.imul(Ee, Xt) | 0,
            C = C + Math.imul(Ee, Yt) | 0,
            C = C + Math.imul(V, Xt) | 0,
            W = W + Math.imul(V, Yt) | 0,
            Q = Q + Math.imul(Y, rn) | 0,
            C = C + Math.imul(Y, sn) | 0,
            C = C + Math.imul(de, rn) | 0,
            W = W + Math.imul(de, sn) | 0,
            Q = Q + Math.imul(X, un) | 0,
            C = C + Math.imul(X, on) | 0,
            C = C + Math.imul(G, un) | 0,
            W = W + Math.imul(G, on) | 0;
            var yn = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (yn >>> 26) | 0,
            yn &= 67108863,
            Q = Math.imul(pe, en),
            C = Math.imul(pe, nn),
            C = C + Math.imul(ve, en) | 0,
            W = Math.imul(ve, nn),
            Q = Q + Math.imul(N, Xt) | 0,
            C = C + Math.imul(N, Yt) | 0,
            C = C + Math.imul(K, Xt) | 0,
            W = W + Math.imul(K, Yt) | 0,
            Q = Q + Math.imul(Ee, rn) | 0,
            C = C + Math.imul(Ee, sn) | 0,
            C = C + Math.imul(V, rn) | 0,
            W = W + Math.imul(V, sn) | 0,
            Q = Q + Math.imul(Y, un) | 0,
            C = C + Math.imul(Y, on) | 0,
            C = C + Math.imul(de, un) | 0,
            W = W + Math.imul(de, on) | 0;
            var qr = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (qr >>> 26) | 0,
            qr &= 67108863,
            Q = Math.imul(pe, Xt),
            C = Math.imul(pe, Yt),
            C = C + Math.imul(ve, Xt) | 0,
            W = Math.imul(ve, Yt),
            Q = Q + Math.imul(N, rn) | 0,
            C = C + Math.imul(N, sn) | 0,
            C = C + Math.imul(K, rn) | 0,
            W = W + Math.imul(K, sn) | 0,
            Q = Q + Math.imul(Ee, un) | 0,
            C = C + Math.imul(Ee, on) | 0,
            C = C + Math.imul(V, un) | 0,
            W = W + Math.imul(V, on) | 0;
            var Vt = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (Vt >>> 26) | 0,
            Vt &= 67108863,
            Q = Math.imul(pe, rn),
            C = Math.imul(pe, sn),
            C = C + Math.imul(ve, rn) | 0,
            W = Math.imul(ve, sn),
            Q = Q + Math.imul(N, un) | 0,
            C = C + Math.imul(N, on) | 0,
            C = C + Math.imul(K, un) | 0,
            W = W + Math.imul(K, on) | 0;
            var at = (j + Q | 0) + ((C & 8191) << 13) | 0;
            j = (W + (C >>> 13) | 0) + (at >>> 26) | 0,
            at &= 67108863,
            Q = Math.imul(pe, un),
            C = Math.imul(pe, on),
            C = C + Math.imul(ve, un) | 0,
            W = Math.imul(ve, on);
            var or = (j + Q | 0) + ((C & 8191) << 13) | 0;
            return j = (W + (C >>> 13) | 0) + (or >>> 26) | 0,
            or &= 67108863,
            z[0] = te,
            z[1] = ye,
            z[2] = Be,
            z[3] = Me,
            z[4] = we,
            z[5] = ke,
            z[6] = Xe,
            z[7] = qe,
            z[8] = tt,
            z[9] = ft,
            z[10] = mt,
            z[11] = st,
            z[12] = Wt,
            z[13] = fn,
            z[14] = yn,
            z[15] = qr,
            z[16] = Vt,
            z[17] = at,
            z[18] = or,
            j !== 0 && (z[19] = j,
            R.length++),
            R
        };
        Math.imul || (v = p);
        function w(T, y, E) {
            E.negative = y.negative ^ T.negative,
            E.length = T.length + y.length;
            for (var R = 0, F = 0, O = 0; O < E.length - 1; O++) {
                var z = F;
                F = 0;
                for (var j = R & 67108863, Q = Math.min(O, y.length - 1), C = Math.max(0, O - T.length + 1); C <= Q; C++) {
                    var W = O - C
                      , ee = T.words[W] | 0
                      , P = y.words[C] | 0
                      , re = ee * P
                      , ue = re & 67108863;
                    z = z + (re / 67108864 | 0) | 0,
                    ue = ue + j | 0,
                    j = ue & 67108863,
                    z = z + (ue >>> 26) | 0,
                    F += z >>> 26,
                    z &= 67108863
                }
                E.words[O] = j,
                R = z,
                z = F
            }
            return R !== 0 ? E.words[O] = R : E.length--,
            E._strip()
        }
        function _(T, y, E) {
            return w(T, y, E)
        }
        s.prototype.mulTo = function(y, E) {
            var R, F = this.length + y.length;
            return this.length === 10 && y.length === 10 ? R = v(this, y, E) : F < 63 ? R = p(this, y, E) : F < 1024 ? R = w(this, y, E) : R = _(this, y, E),
            R
        }
        ,
        s.prototype.mul = function(y) {
            var E = new s(null);
            return E.words = new Array(this.length + y.length),
            this.mulTo(y, E)
        }
        ,
        s.prototype.mulf = function(y) {
            var E = new s(null);
            return E.words = new Array(this.length + y.length),
            _(this, y, E)
        }
        ,
        s.prototype.imul = function(y) {
            return this.clone().mulTo(y, this)
        }
        ,
        s.prototype.imuln = function(y) {
            var E = y < 0;
            E && (y = -y),
            r(typeof y == "number"),
            r(y < 67108864);
            for (var R = 0, F = 0; F < this.length; F++) {
                var O = (this.words[F] | 0) * y
                  , z = (O & 67108863) + (R & 67108863);
                R >>= 26,
                R += O / 67108864 | 0,
                R += z >>> 26,
                this.words[F] = z & 67108863
            }
            return R !== 0 && (this.words[F] = R,
            this.length++),
            E ? this.ineg() : this
        }
        ,
        s.prototype.muln = function(y) {
            return this.clone().imuln(y)
        }
        ,
        s.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        s.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        s.prototype.pow = function(y) {
            var E = g(y);
            if (E.length === 0)
                return new s(1);
            for (var R = this, F = 0; F < E.length && E[F] === 0; F++,
            R = R.sqr())
                ;
            if (++F < E.length)
                for (var O = R.sqr(); F < E.length; F++,
                O = O.sqr())
                    E[F] !== 0 && (R = R.mul(O));
            return R
        }
        ,
        s.prototype.iushln = function(y) {
            r(typeof y == "number" && y >= 0);
            var E = y % 26, R = (y - E) / 26, F = 67108863 >>> 26 - E << 26 - E, O;
            if (E !== 0) {
                var z = 0;
                for (O = 0; O < this.length; O++) {
                    var j = this.words[O] & F
                      , Q = (this.words[O] | 0) - j << E;
                    this.words[O] = Q | z,
                    z = j >>> 26 - E
                }
                z && (this.words[O] = z,
                this.length++)
            }
            if (R !== 0) {
                for (O = this.length - 1; O >= 0; O--)
                    this.words[O + R] = this.words[O];
                for (O = 0; O < R; O++)
                    this.words[O] = 0;
                this.length += R
            }
            return this._strip()
        }
        ,
        s.prototype.ishln = function(y) {
            return r(this.negative === 0),
            this.iushln(y)
        }
        ,
        s.prototype.iushrn = function(y, E, R) {
            r(typeof y == "number" && y >= 0);
            var F;
            E ? F = (E - E % 26) / 26 : F = 0;
            var O = y % 26
              , z = Math.min((y - O) / 26, this.length)
              , j = 67108863 ^ 67108863 >>> O << O
              , Q = R;
            if (F -= z,
            F = Math.max(0, F),
            Q) {
                for (var C = 0; C < z; C++)
                    Q.words[C] = this.words[C];
                Q.length = z
            }
            if (z !== 0)
                if (this.length > z)
                    for (this.length -= z,
                    C = 0; C < this.length; C++)
                        this.words[C] = this.words[C + z];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var W = 0;
            for (C = this.length - 1; C >= 0 && (W !== 0 || C >= F); C--) {
                var ee = this.words[C] | 0;
                this.words[C] = W << 26 - O | ee >>> O,
                W = ee & j
            }
            return Q && W !== 0 && (Q.words[Q.length++] = W),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        s.prototype.ishrn = function(y, E, R) {
            return r(this.negative === 0),
            this.iushrn(y, E, R)
        }
        ,
        s.prototype.shln = function(y) {
            return this.clone().ishln(y)
        }
        ,
        s.prototype.ushln = function(y) {
            return this.clone().iushln(y)
        }
        ,
        s.prototype.shrn = function(y) {
            return this.clone().ishrn(y)
        }
        ,
        s.prototype.ushrn = function(y) {
            return this.clone().iushrn(y)
        }
        ,
        s.prototype.testn = function(y) {
            r(typeof y == "number" && y >= 0);
            var E = y % 26
              , R = (y - E) / 26
              , F = 1 << E;
            if (this.length <= R)
                return !1;
            var O = this.words[R];
            return !!(O & F)
        }
        ,
        s.prototype.imaskn = function(y) {
            r(typeof y == "number" && y >= 0);
            var E = y % 26
              , R = (y - E) / 26;
            if (r(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= R)
                return this;
            if (E !== 0 && R++,
            this.length = Math.min(R, this.length),
            E !== 0) {
                var F = 67108863 ^ 67108863 >>> E << E;
                this.words[this.length - 1] &= F
            }
            return this._strip()
        }
        ,
        s.prototype.maskn = function(y) {
            return this.clone().imaskn(y)
        }
        ,
        s.prototype.iaddn = function(y) {
            return r(typeof y == "number"),
            r(y < 67108864),
            y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= y ? (this.words[0] = y - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(y),
            this.negative = 1,
            this) : this._iaddn(y)
        }
        ,
        s.prototype._iaddn = function(y) {
            this.words[0] += y;
            for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
                this.words[E] -= 67108864,
                E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
            return this.length = Math.max(this.length, E + 1),
            this
        }
        ,
        s.prototype.isubn = function(y) {
            if (r(typeof y == "number"),
            r(y < 67108864),
            y < 0)
                return this.iaddn(-y);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(y),
                this.negative = 1,
                this;
            if (this.words[0] -= y,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var E = 0; E < this.length && this.words[E] < 0; E++)
                    this.words[E] += 67108864,
                    this.words[E + 1] -= 1;
            return this._strip()
        }
        ,
        s.prototype.addn = function(y) {
            return this.clone().iaddn(y)
        }
        ,
        s.prototype.subn = function(y) {
            return this.clone().isubn(y)
        }
        ,
        s.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        s.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        s.prototype._ishlnsubmul = function(y, E, R) {
            var F = y.length + R, O;
            this._expand(F);
            var z, j = 0;
            for (O = 0; O < y.length; O++) {
                z = (this.words[O + R] | 0) + j;
                var Q = (y.words[O] | 0) * E;
                z -= Q & 67108863,
                j = (z >> 26) - (Q / 67108864 | 0),
                this.words[O + R] = z & 67108863
            }
            for (; O < this.length - R; O++)
                z = (this.words[O + R] | 0) + j,
                j = z >> 26,
                this.words[O + R] = z & 67108863;
            if (j === 0)
                return this._strip();
            for (r(j === -1),
            j = 0,
            O = 0; O < this.length; O++)
                z = -(this.words[O] | 0) + j,
                j = z >> 26,
                this.words[O] = z & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        s.prototype._wordDiv = function(y, E) {
            var R = this.length - y.length
              , F = this.clone()
              , O = y
              , z = O.words[O.length - 1] | 0
              , j = this._countBits(z);
            R = 26 - j,
            R !== 0 && (O = O.ushln(R),
            F.iushln(R),
            z = O.words[O.length - 1] | 0);
            var Q = F.length - O.length, C;
            if (E !== "mod") {
                C = new s(null),
                C.length = Q + 1,
                C.words = new Array(C.length);
                for (var W = 0; W < C.length; W++)
                    C.words[W] = 0
            }
            var ee = F.clone()._ishlnsubmul(O, 1, Q);
            ee.negative === 0 && (F = ee,
            C && (C.words[Q] = 1));
            for (var P = Q - 1; P >= 0; P--) {
                var re = (F.words[O.length + P] | 0) * 67108864 + (F.words[O.length + P - 1] | 0);
                for (re = Math.min(re / z | 0, 67108863),
                F._ishlnsubmul(O, re, P); F.negative !== 0; )
                    re--,
                    F.negative = 0,
                    F._ishlnsubmul(O, 1, P),
                    F.isZero() || (F.negative ^= 1);
                C && (C.words[P] = re)
            }
            return C && C._strip(),
            F._strip(),
            E !== "div" && R !== 0 && F.iushrn(R),
            {
                div: C || null,
                mod: F
            }
        }
        ,
        s.prototype.divmod = function(y, E, R) {
            if (r(!y.isZero()),
            this.isZero())
                return {
                    div: new s(0),
                    mod: new s(0)
                };
            var F, O, z;
            return this.negative !== 0 && y.negative === 0 ? (z = this.neg().divmod(y, E),
            E !== "mod" && (F = z.div.neg()),
            E !== "div" && (O = z.mod.neg(),
            R && O.negative !== 0 && O.iadd(y)),
            {
                div: F,
                mod: O
            }) : this.negative === 0 && y.negative !== 0 ? (z = this.divmod(y.neg(), E),
            E !== "mod" && (F = z.div.neg()),
            {
                div: F,
                mod: z.mod
            }) : this.negative & y.negative ? (z = this.neg().divmod(y.neg(), E),
            E !== "div" && (O = z.mod.neg(),
            R && O.negative !== 0 && O.isub(y)),
            {
                div: z.div,
                mod: O
            }) : y.length > this.length || this.cmp(y) < 0 ? {
                div: new s(0),
                mod: this
            } : y.length === 1 ? E === "div" ? {
                div: this.divn(y.words[0]),
                mod: null
            } : E === "mod" ? {
                div: null,
                mod: new s(this.modrn(y.words[0]))
            } : {
                div: this.divn(y.words[0]),
                mod: new s(this.modrn(y.words[0]))
            } : this._wordDiv(y, E)
        }
        ,
        s.prototype.div = function(y) {
            return this.divmod(y, "div", !1).div
        }
        ,
        s.prototype.mod = function(y) {
            return this.divmod(y, "mod", !1).mod
        }
        ,
        s.prototype.umod = function(y) {
            return this.divmod(y, "mod", !0).mod
        }
        ,
        s.prototype.divRound = function(y) {
            var E = this.divmod(y);
            if (E.mod.isZero())
                return E.div;
            var R = E.div.negative !== 0 ? E.mod.isub(y) : E.mod
              , F = y.ushrn(1)
              , O = y.andln(1)
              , z = R.cmp(F);
            return z < 0 || O === 1 && z === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1)
        }
        ,
        s.prototype.modrn = function(y) {
            var E = y < 0;
            E && (y = -y),
            r(y <= 67108863);
            for (var R = (1 << 26) % y, F = 0, O = this.length - 1; O >= 0; O--)
                F = (R * F + (this.words[O] | 0)) % y;
            return E ? -F : F
        }
        ,
        s.prototype.modn = function(y) {
            return this.modrn(y)
        }
        ,
        s.prototype.idivn = function(y) {
            var E = y < 0;
            E && (y = -y),
            r(y <= 67108863);
            for (var R = 0, F = this.length - 1; F >= 0; F--) {
                var O = (this.words[F] | 0) + R * 67108864;
                this.words[F] = O / y | 0,
                R = O % y
            }
            return this._strip(),
            E ? this.ineg() : this
        }
        ,
        s.prototype.divn = function(y) {
            return this.clone().idivn(y)
        }
        ,
        s.prototype.egcd = function(y) {
            r(y.negative === 0),
            r(!y.isZero());
            var E = this
              , R = y.clone();
            E.negative !== 0 ? E = E.umod(y) : E = E.clone();
            for (var F = new s(1), O = new s(0), z = new s(0), j = new s(1), Q = 0; E.isEven() && R.isEven(); )
                E.iushrn(1),
                R.iushrn(1),
                ++Q;
            for (var C = R.clone(), W = E.clone(); !E.isZero(); ) {
                for (var ee = 0, P = 1; !(E.words[0] & P) && ee < 26; ++ee,
                P <<= 1)
                    ;
                if (ee > 0)
                    for (E.iushrn(ee); ee-- > 0; )
                        (F.isOdd() || O.isOdd()) && (F.iadd(C),
                        O.isub(W)),
                        F.iushrn(1),
                        O.iushrn(1);
                for (var re = 0, ue = 1; !(R.words[0] & ue) && re < 26; ++re,
                ue <<= 1)
                    ;
                if (re > 0)
                    for (R.iushrn(re); re-- > 0; )
                        (z.isOdd() || j.isOdd()) && (z.iadd(C),
                        j.isub(W)),
                        z.iushrn(1),
                        j.iushrn(1);
                E.cmp(R) >= 0 ? (E.isub(R),
                F.isub(z),
                O.isub(j)) : (R.isub(E),
                z.isub(F),
                j.isub(O))
            }
            return {
                a: z,
                b: j,
                gcd: R.iushln(Q)
            }
        }
        ,
        s.prototype._invmp = function(y) {
            r(y.negative === 0),
            r(!y.isZero());
            var E = this
              , R = y.clone();
            E.negative !== 0 ? E = E.umod(y) : E = E.clone();
            for (var F = new s(1), O = new s(0), z = R.clone(); E.cmpn(1) > 0 && R.cmpn(1) > 0; ) {
                for (var j = 0, Q = 1; !(E.words[0] & Q) && j < 26; ++j,
                Q <<= 1)
                    ;
                if (j > 0)
                    for (E.iushrn(j); j-- > 0; )
                        F.isOdd() && F.iadd(z),
                        F.iushrn(1);
                for (var C = 0, W = 1; !(R.words[0] & W) && C < 26; ++C,
                W <<= 1)
                    ;
                if (C > 0)
                    for (R.iushrn(C); C-- > 0; )
                        O.isOdd() && O.iadd(z),
                        O.iushrn(1);
                E.cmp(R) >= 0 ? (E.isub(R),
                F.isub(O)) : (R.isub(E),
                O.isub(F))
            }
            var ee;
            return E.cmpn(1) === 0 ? ee = F : ee = O,
            ee.cmpn(0) < 0 && ee.iadd(y),
            ee
        }
        ,
        s.prototype.gcd = function(y) {
            if (this.isZero())
                return y.abs();
            if (y.isZero())
                return this.abs();
            var E = this.clone()
              , R = y.clone();
            E.negative = 0,
            R.negative = 0;
            for (var F = 0; E.isEven() && R.isEven(); F++)
                E.iushrn(1),
                R.iushrn(1);
            do {
                for (; E.isEven(); )
                    E.iushrn(1);
                for (; R.isEven(); )
                    R.iushrn(1);
                var O = E.cmp(R);
                if (O < 0) {
                    var z = E;
                    E = R,
                    R = z
                } else if (O === 0 || R.cmpn(1) === 0)
                    break;
                E.isub(R)
            } while (!0);
            return R.iushln(F)
        }
        ,
        s.prototype.invm = function(y) {
            return this.egcd(y).a.umod(y)
        }
        ,
        s.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        s.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        s.prototype.andln = function(y) {
            return this.words[0] & y
        }
        ,
        s.prototype.bincn = function(y) {
            r(typeof y == "number");
            var E = y % 26
              , R = (y - E) / 26
              , F = 1 << E;
            if (this.length <= R)
                return this._expand(R + 1),
                this.words[R] |= F,
                this;
            for (var O = F, z = R; O !== 0 && z < this.length; z++) {
                var j = this.words[z] | 0;
                j += O,
                O = j >>> 26,
                j &= 67108863,
                this.words[z] = j
            }
            return O !== 0 && (this.words[z] = O,
            this.length++),
            this
        }
        ,
        s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        s.prototype.cmpn = function(y) {
            var E = y < 0;
            if (this.negative !== 0 && !E)
                return -1;
            if (this.negative === 0 && E)
                return 1;
            this._strip();
            var R;
            if (this.length > 1)
                R = 1;
            else {
                E && (y = -y),
                r(y <= 67108863, "Number is too big");
                var F = this.words[0] | 0;
                R = F === y ? 0 : F < y ? -1 : 1
            }
            return this.negative !== 0 ? -R | 0 : R
        }
        ,
        s.prototype.cmp = function(y) {
            if (this.negative !== 0 && y.negative === 0)
                return -1;
            if (this.negative === 0 && y.negative !== 0)
                return 1;
            var E = this.ucmp(y);
            return this.negative !== 0 ? -E | 0 : E
        }
        ,
        s.prototype.ucmp = function(y) {
            if (this.length > y.length)
                return 1;
            if (this.length < y.length)
                return -1;
            for (var E = 0, R = this.length - 1; R >= 0; R--) {
                var F = this.words[R] | 0
                  , O = y.words[R] | 0;
                if (F !== O) {
                    F < O ? E = -1 : F > O && (E = 1);
                    break
                }
            }
            return E
        }
        ,
        s.prototype.gtn = function(y) {
            return this.cmpn(y) === 1
        }
        ,
        s.prototype.gt = function(y) {
            return this.cmp(y) === 1
        }
        ,
        s.prototype.gten = function(y) {
            return this.cmpn(y) >= 0
        }
        ,
        s.prototype.gte = function(y) {
            return this.cmp(y) >= 0
        }
        ,
        s.prototype.ltn = function(y) {
            return this.cmpn(y) === -1
        }
        ,
        s.prototype.lt = function(y) {
            return this.cmp(y) === -1
        }
        ,
        s.prototype.lten = function(y) {
            return this.cmpn(y) <= 0
        }
        ,
        s.prototype.lte = function(y) {
            return this.cmp(y) <= 0
        }
        ,
        s.prototype.eqn = function(y) {
            return this.cmpn(y) === 0
        }
        ,
        s.prototype.eq = function(y) {
            return this.cmp(y) === 0
        }
        ,
        s.red = function(y) {
            return new L(y)
        }
        ,
        s.prototype.toRed = function(y) {
            return r(!this.red, "Already a number in reduction context"),
            r(this.negative === 0, "red works only with positives"),
            y.convertTo(this)._forceRed(y)
        }
        ,
        s.prototype.fromRed = function() {
            return r(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        s.prototype._forceRed = function(y) {
            return this.red = y,
            this
        }
        ,
        s.prototype.forceRed = function(y) {
            return r(!this.red, "Already a number in reduction context"),
            this._forceRed(y)
        }
        ,
        s.prototype.redAdd = function(y) {
            return r(this.red, "redAdd works only with red numbers"),
            this.red.add(this, y)
        }
        ,
        s.prototype.redIAdd = function(y) {
            return r(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, y)
        }
        ,
        s.prototype.redSub = function(y) {
            return r(this.red, "redSub works only with red numbers"),
            this.red.sub(this, y)
        }
        ,
        s.prototype.redISub = function(y) {
            return r(this.red, "redISub works only with red numbers"),
            this.red.isub(this, y)
        }
        ,
        s.prototype.redShl = function(y) {
            return r(this.red, "redShl works only with red numbers"),
            this.red.shl(this, y)
        }
        ,
        s.prototype.redMul = function(y) {
            return r(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, y),
            this.red.mul(this, y)
        }
        ,
        s.prototype.redIMul = function(y) {
            return r(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, y),
            this.red.imul(this, y)
        }
        ,
        s.prototype.redSqr = function() {
            return r(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        s.prototype.redISqr = function() {
            return r(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        s.prototype.redSqrt = function() {
            return r(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        s.prototype.redInvm = function() {
            return r(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        s.prototype.redNeg = function() {
            return r(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        s.prototype.redPow = function(y) {
            return r(this.red && !y.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, y)
        }
        ;
        var x = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function b(T, y) {
            this.name = T,
            this.p = new s(y,16),
            this.n = this.p.bitLength(),
            this.k = new s(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        b.prototype._tmp = function() {
            var y = new s(null);
            return y.words = new Array(Math.ceil(this.n / 13)),
            y
        }
        ,
        b.prototype.ireduce = function(y) {
            var E = y, R;
            do
                this.split(E, this.tmp),
                E = this.imulK(E),
                E = E.iadd(this.tmp),
                R = E.bitLength();
            while (R > this.n);
            var F = R < this.n ? -1 : E.ucmp(this.p);
            return F === 0 ? (E.words[0] = 0,
            E.length = 1) : F > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(),
            E
        }
        ,
        b.prototype.split = function(y, E) {
            y.iushrn(this.n, 0, E)
        }
        ,
        b.prototype.imulK = function(y) {
            return y.imul(this.k)
        }
        ;
        function B() {
            b.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(B, b),
        B.prototype.split = function(y, E) {
            for (var R = 4194303, F = Math.min(y.length, 9), O = 0; O < F; O++)
                E.words[O] = y.words[O];
            if (E.length = F,
            y.length <= 9) {
                y.words[0] = 0,
                y.length = 1;
                return
            }
            var z = y.words[9];
            for (E.words[E.length++] = z & R,
            O = 10; O < y.length; O++) {
                var j = y.words[O] | 0;
                y.words[O - 10] = (j & R) << 4 | z >>> 22,
                z = j
            }
            z >>>= 22,
            y.words[O - 10] = z,
            z === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9
        }
        ,
        B.prototype.imulK = function(y) {
            y.words[y.length] = 0,
            y.words[y.length + 1] = 0,
            y.length += 2;
            for (var E = 0, R = 0; R < y.length; R++) {
                var F = y.words[R] | 0;
                E += F * 977,
                y.words[R] = E & 67108863,
                E = F * 64 + (E / 67108864 | 0)
            }
            return y.words[y.length - 1] === 0 && (y.length--,
            y.words[y.length - 1] === 0 && y.length--),
            y
        }
        ;
        function S() {
            b.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(S, b);
        function I() {
            b.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(I, b);
        function M() {
            b.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(M, b),
        M.prototype.imulK = function(y) {
            for (var E = 0, R = 0; R < y.length; R++) {
                var F = (y.words[R] | 0) * 19 + E
                  , O = F & 67108863;
                F >>>= 26,
                y.words[R] = O,
                E = F
            }
            return E !== 0 && (y.words[y.length++] = E),
            y
        }
        ,
        s._prime = function(y) {
            if (x[y])
                return x[y];
            var E;
            if (y === "k256")
                E = new B;
            else if (y === "p224")
                E = new S;
            else if (y === "p192")
                E = new I;
            else if (y === "p25519")
                E = new M;
            else
                throw new Error("Unknown prime " + y);
            return x[y] = E,
            E
        }
        ;
        function L(T) {
            if (typeof T == "string") {
                var y = s._prime(T);
                this.m = y.p,
                this.prime = y
            } else
                r(T.gtn(1), "modulus must be greater than 1"),
                this.m = T,
                this.prime = null
        }
        L.prototype._verify1 = function(y) {
            r(y.negative === 0, "red works only with positives"),
            r(y.red, "red works only with red numbers")
        }
        ,
        L.prototype._verify2 = function(y, E) {
            r((y.negative | E.negative) === 0, "red works only with positives"),
            r(y.red && y.red === E.red, "red works only with red numbers")
        }
        ,
        L.prototype.imod = function(y) {
            return this.prime ? this.prime.ireduce(y)._forceRed(this) : (A(y, y.umod(this.m)._forceRed(this)),
            y)
        }
        ,
        L.prototype.neg = function(y) {
            return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this)
        }
        ,
        L.prototype.add = function(y, E) {
            this._verify2(y, E);
            var R = y.add(E);
            return R.cmp(this.m) >= 0 && R.isub(this.m),
            R._forceRed(this)
        }
        ,
        L.prototype.iadd = function(y, E) {
            this._verify2(y, E);
            var R = y.iadd(E);
            return R.cmp(this.m) >= 0 && R.isub(this.m),
            R
        }
        ,
        L.prototype.sub = function(y, E) {
            this._verify2(y, E);
            var R = y.sub(E);
            return R.cmpn(0) < 0 && R.iadd(this.m),
            R._forceRed(this)
        }
        ,
        L.prototype.isub = function(y, E) {
            this._verify2(y, E);
            var R = y.isub(E);
            return R.cmpn(0) < 0 && R.iadd(this.m),
            R
        }
        ,
        L.prototype.shl = function(y, E) {
            return this._verify1(y),
            this.imod(y.ushln(E))
        }
        ,
        L.prototype.imul = function(y, E) {
            return this._verify2(y, E),
            this.imod(y.imul(E))
        }
        ,
        L.prototype.mul = function(y, E) {
            return this._verify2(y, E),
            this.imod(y.mul(E))
        }
        ,
        L.prototype.isqr = function(y) {
            return this.imul(y, y.clone())
        }
        ,
        L.prototype.sqr = function(y) {
            return this.mul(y, y)
        }
        ,
        L.prototype.sqrt = function(y) {
            if (y.isZero())
                return y.clone();
            var E = this.m.andln(3);
            if (r(E % 2 === 1),
            E === 3) {
                var R = this.m.add(new s(1)).iushrn(2);
                return this.pow(y, R)
            }
            for (var F = this.m.subn(1), O = 0; !F.isZero() && F.andln(1) === 0; )
                O++,
                F.iushrn(1);
            r(!F.isZero());
            var z = new s(1).toRed(this)
              , j = z.redNeg()
              , Q = this.m.subn(1).iushrn(1)
              , C = this.m.bitLength();
            for (C = new s(2 * C * C).toRed(this); this.pow(C, Q).cmp(j) !== 0; )
                C.redIAdd(j);
            for (var W = this.pow(C, F), ee = this.pow(y, F.addn(1).iushrn(1)), P = this.pow(y, F), re = O; P.cmp(z) !== 0; ) {
                for (var ue = P, le = 0; ue.cmp(z) !== 0; le++)
                    ue = ue.redSqr();
                r(le < re);
                var me = this.pow(W, new s(1).iushln(re - le - 1));
                ee = ee.redMul(me),
                W = me.redSqr(),
                P = P.redMul(W),
                re = le
            }
            return ee
        }
        ,
        L.prototype.invm = function(y) {
            var E = y._invmp(this.m);
            return E.negative !== 0 ? (E.negative = 0,
            this.imod(E).redNeg()) : this.imod(E)
        }
        ,
        L.prototype.pow = function(y, E) {
            if (E.isZero())
                return new s(1).toRed(this);
            if (E.cmpn(1) === 0)
                return y.clone();
            var R = 4
              , F = new Array(1 << R);
            F[0] = new s(1).toRed(this),
            F[1] = y;
            for (var O = 2; O < F.length; O++)
                F[O] = this.mul(F[O - 1], y);
            var z = F[0]
              , j = 0
              , Q = 0
              , C = E.bitLength() % 26;
            for (C === 0 && (C = 26),
            O = E.length - 1; O >= 0; O--) {
                for (var W = E.words[O], ee = C - 1; ee >= 0; ee--) {
                    var P = W >> ee & 1;
                    if (z !== F[0] && (z = this.sqr(z)),
                    P === 0 && j === 0) {
                        Q = 0;
                        continue
                    }
                    j <<= 1,
                    j |= P,
                    Q++,
                    !(Q !== R && (O !== 0 || ee !== 0)) && (z = this.mul(z, F[j]),
                    Q = 0,
                    j = 0)
                }
                C = 26
            }
            return z
        }
        ,
        L.prototype.convertTo = function(y) {
            var E = y.umod(this.m);
            return E === y ? E.clone() : E
        }
        ,
        L.prototype.convertFrom = function(y) {
            var E = y.clone();
            return E.red = null,
            E
        }
        ,
        s.mont = function(y) {
            return new D(y)
        }
        ;
        function D(T) {
            L.call(this, T),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new s(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        i(D, L),
        D.prototype.convertTo = function(y) {
            return this.imod(y.ushln(this.shift))
        }
        ,
        D.prototype.convertFrom = function(y) {
            var E = this.imod(y.mul(this.rinv));
            return E.red = null,
            E
        }
        ,
        D.prototype.imul = function(y, E) {
            if (y.isZero() || E.isZero())
                return y.words[0] = 0,
                y.length = 1,
                y;
            var R = y.imul(E)
              , F = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , O = R.isub(F).iushrn(this.shift)
              , z = O;
            return O.cmp(this.m) >= 0 ? z = O.isub(this.m) : O.cmpn(0) < 0 && (z = O.iadd(this.m)),
            z._forceRed(this)
        }
        ,
        D.prototype.mul = function(y, E) {
            if (y.isZero() || E.isZero())
                return new s(0)._forceRed(this);
            var R = y.mul(E)
              , F = R.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , O = R.isub(F).iushrn(this.shift)
              , z = O;
            return O.cmp(this.m) >= 0 ? z = O.isub(this.m) : O.cmpn(0) < 0 && (z = O.iadd(this.m)),
            z._forceRed(this)
        }
        ,
        D.prototype.invm = function(y) {
            var E = this.imod(y._invmp(this.m).mul(this.r2));
            return E._forceRed(this)
        }
    }
    )(n, ka)
}
)(lI);
var n9 = lI.exports;
const _t = oc(n9)
  , r9 = "logger/5.7.0";
let CU = !1
  , TU = !1;
const tw = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let IU = tw.default
  , mb = null;
function i9() {
    try {
        const n = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
            try {
                if ("test".normalize(e) !== "test")
                    throw new Error("bad normalize")
            } catch {
                n.push(e)
            }
        }
        ),
        n.length)
            throw new Error("missing " + n.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
            throw new Error("broken implementation")
    } catch (n) {
        return n.message
    }
    return null
}
const RU = i9();
var IM;
(function(n) {
    n.DEBUG = "DEBUG",
    n.INFO = "INFO",
    n.WARNING = "WARNING",
    n.ERROR = "ERROR",
    n.OFF = "OFF"
}
)(IM || (IM = {}));
var jo;
(function(n) {
    n.UNKNOWN_ERROR = "UNKNOWN_ERROR",
    n.NOT_IMPLEMENTED = "NOT_IMPLEMENTED",
    n.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION",
    n.NETWORK_ERROR = "NETWORK_ERROR",
    n.SERVER_ERROR = "SERVER_ERROR",
    n.TIMEOUT = "TIMEOUT",
    n.BUFFER_OVERRUN = "BUFFER_OVERRUN",
    n.NUMERIC_FAULT = "NUMERIC_FAULT",
    n.MISSING_NEW = "MISSING_NEW",
    n.INVALID_ARGUMENT = "INVALID_ARGUMENT",
    n.MISSING_ARGUMENT = "MISSING_ARGUMENT",
    n.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT",
    n.CALL_EXCEPTION = "CALL_EXCEPTION",
    n.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
    n.NONCE_EXPIRED = "NONCE_EXPIRED",
    n.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED",
    n.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT",
    n.TRANSACTION_REPLACED = "TRANSACTION_REPLACED",
    n.ACTION_REJECTED = "ACTION_REJECTED"
}
)(jo || (jo = {}));
const UU = "0123456789abcdef";
let xe = class Rr {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, t) {
        const r = e.toLowerCase();
        tw[r] == null && this.throwArgumentError("invalid log level name", "logLevel", e),
        !(IU > tw[r]) && console.log.apply(console, t)
    }
    debug(...e) {
        this._log(Rr.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Rr.levels.INFO, e)
    }
    warn(...e) {
        this._log(Rr.levels.WARNING, e)
    }
    makeError(e, t, r) {
        if (TU)
            return this.makeError("censored error", t, {});
        t || (t = Rr.errors.UNKNOWN_ERROR),
        r || (r = {});
        const i = [];
        Object.keys(r).forEach(l => {
            const c = r[l];
            try {
                if (c instanceof Uint8Array) {
                    let A = "";
                    for (let u = 0; u < c.length; u++)
                        A += UU[c[u] >> 4],
                        A += UU[c[u] & 15];
                    i.push(l + "=Uint8Array(0x" + A + ")")
                } else
                    i.push(l + "=" + JSON.stringify(c))
            } catch {
                i.push(l + "=" + JSON.stringify(r[l].toString()))
            }
        }
        ),
        i.push(`code=${t}`),
        i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (t) {
        case jo.NUMERIC_FAULT:
            {
                o = "NUMERIC_FAULT";
                const l = e;
                switch (l) {
                case "overflow":
                case "underflow":
                case "division-by-zero":
                    o += "-" + l;
                    break;
                case "negative-power":
                case "negative-width":
                    o += "-unsupported";
                    break;
                case "unbound-bitwise-result":
                    o += "-unbound-result";
                    break
                }
                break
            }
        case jo.CALL_EXCEPTION:
        case jo.INSUFFICIENT_FUNDS:
        case jo.MISSING_NEW:
        case jo.NONCE_EXPIRED:
        case jo.REPLACEMENT_UNDERPRICED:
        case jo.TRANSACTION_REPLACED:
        case jo.UNPREDICTABLE_GAS_LIMIT:
            o = t;
            break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"),
        i.length && (e += " (" + i.join(", ") + ")");
        const a = new Error(e);
        return a.reason = s,
        a.code = t,
        Object.keys(r).forEach(function(l) {
            a[l] = r[l]
        }),
        a
    }
    throwError(e, t, r) {
        throw this.makeError(e, t, r)
    }
    throwArgumentError(e, t, r) {
        return this.throwError(e, Rr.errors.INVALID_ARGUMENT, {
            argument: t,
            value: r
        })
    }
    assert(e, t, r, i) {
        e || this.throwError(t, r, i)
    }
    assertArgument(e, t, r, i) {
        e || this.throwArgumentError(t, r, i)
    }
    checkNormalize(e) {
        RU && this.throwError("platform missing String.prototype.normalize", Rr.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: RU
        })
    }
    checkSafeUint53(e, t) {
        typeof e == "number" && (t == null && (t = "value not safe"),
        (e < 0 || e >= 9007199254740991) && this.throwError(t, Rr.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }),
        e % 1 && this.throwError(t, Rr.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, t, r) {
        r ? r = ": " + r : r = "",
        e < t && this.throwError("missing argument" + r, Rr.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: t
        }),
        e > t && this.throwError("too many arguments" + r, Rr.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: t
        })
    }
    checkNew(e, t) {
        (e === Object || e == null) && this.throwError("missing new", Rr.errors.MISSING_NEW, {
            name: t.name
        })
    }
    checkAbstract(e, t) {
        e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", Rr.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Rr.errors.MISSING_NEW, {
            name: t.name
        })
    }
    static globalLogger() {
        return mb || (mb = new Rr(r9)),
        mb
    }
    static setCensorship(e, t) {
        if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", Rr.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
        }),
        CU) {
            if (!e)
                return;
            this.globalLogger().throwError("error censorship permanent", Rr.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        TU = !!e,
        CU = !!t
    }
    static setLogLevel(e) {
        const t = tw[e.toLowerCase()];
        if (t == null) {
            Rr.globalLogger().warn("invalid log level - " + e);
            return
        }
        IU = t
    }
    static from(e) {
        return new Rr(e)
    }
}
;
xe.errors = jo;
xe.levels = IM;
const s9 = "bytes/5.7.0"
  , Jn = new xe(s9);
function q4(n) {
    return !!n.toHexString
}
function Wh(n) {
    return n.slice || (n.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Wh(new Uint8Array(Array.prototype.slice.apply(n, e)))
    }
    ),
    n
}
function cI(n) {
    return It(n) && !(n.length % 2) || Fx(n)
}
function FU(n) {
    return typeof n == "number" && n == n && n % 1 === 0
}
function Fx(n) {
    if (n == null)
        return !1;
    if (n.constructor === Uint8Array)
        return !0;
    if (typeof n == "string" || !FU(n.length) || n.length < 0)
        return !1;
    for (let e = 0; e < n.length; e++) {
        const t = n[e];
        if (!FU(t) || t < 0 || t >= 256)
            return !1
    }
    return !0
}
function pt(n, e) {
    if (e || (e = {}),
    typeof n == "number") {
        Jn.checkSafeUint53(n, "invalid arrayify value");
        const t = [];
        for (; n; )
            t.unshift(n & 255),
            n = parseInt(String(n / 256));
        return t.length === 0 && t.push(0),
        Wh(new Uint8Array(t))
    }
    if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n),
    q4(n) && (n = n.toHexString()),
    It(n)) {
        let t = n.substring(2);
        t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : Jn.throwArgumentError("hex data is odd-length", "value", n));
        const r = [];
        for (let i = 0; i < t.length; i += 2)
            r.push(parseInt(t.substring(i, i + 2), 16));
        return Wh(new Uint8Array(r))
    }
    return Fx(n) ? Wh(new Uint8Array(n)) : Jn.throwArgumentError("invalid arrayify value", "value", n)
}
function Ss(n) {
    const e = n.map(i => pt(i))
      , t = e.reduce( (i, s) => i + s.length, 0)
      , r = new Uint8Array(t);
    return e.reduce( (i, s) => (r.set(s, i),
    i + s.length), 0),
    Wh(r)
}
function hd(n) {
    let e = pt(n);
    if (e.length === 0)
        return e;
    let t = 0;
    for (; t < e.length && e[t] === 0; )
        t++;
    return t && (e = e.slice(t)),
    e
}
function o9(n, e) {
    n = pt(n),
    n.length > e && Jn.throwArgumentError("value out of range", "value", arguments[0]);
    const t = new Uint8Array(e);
    return t.set(n, e - n.length),
    Wh(t)
}
function It(n, e) {
    return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || e && n.length !== 2 + 2 * e)
}
const gb = "0123456789abcdef";
function lt(n, e) {
    if (e || (e = {}),
    typeof n == "number") {
        Jn.checkSafeUint53(n, "invalid hexlify value");
        let t = "";
        for (; n; )
            t = gb[n & 15] + t,
            n = Math.floor(n / 16);
        return t.length ? (t.length % 2 && (t = "0" + t),
        "0x" + t) : "0x00"
    }
    if (typeof n == "bigint")
        return n = n.toString(16),
        n.length % 2 ? "0x0" + n : "0x" + n;
    if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n),
    q4(n))
        return n.toHexString();
    if (It(n))
        return n.length % 2 && (e.hexPad === "left" ? n = "0x0" + n.substring(2) : e.hexPad === "right" ? n += "0" : Jn.throwArgumentError("hex data is odd-length", "value", n)),
        n.toLowerCase();
    if (Fx(n)) {
        let t = "0x";
        for (let r = 0; r < n.length; r++) {
            let i = n[r];
            t += gb[(i & 240) >> 4] + gb[i & 15]
        }
        return t
    }
    return Jn.throwArgumentError("invalid hexlify value", "value", n)
}
function Su(n) {
    if (typeof n != "string")
        n = lt(n);
    else if (!It(n) || n.length % 2)
        return null;
    return (n.length - 2) / 2
}
function mi(n, e, t) {
    return typeof n != "string" ? n = lt(n) : (!It(n) || n.length % 2) && Jn.throwArgumentError("invalid hexData", "value", n),
    e = 2 + 2 * e,
    t != null ? "0x" + n.substring(e, 2 + 2 * t) : "0x" + n.substring(e)
}
function $i(n) {
    let e = "0x";
    return n.forEach(t => {
        e += lt(t).substring(2)
    }
    ),
    e
}
function Px(n) {
    const e = a9(lt(n, {
        hexPad: "left"
    }));
    return e === "0x" ? "0x0" : e
}
function a9(n) {
    typeof n != "string" && (n = lt(n)),
    It(n) || Jn.throwArgumentError("invalid hex string", "value", n),
    n = n.substring(2);
    let e = 0;
    for (; e < n.length && n[e] === "0"; )
        e++;
    return "0x" + n.substring(e)
}
function ir(n, e) {
    for (typeof n != "string" ? n = lt(n) : It(n) || Jn.throwArgumentError("invalid hex string", "value", n),
    n.length > 2 * e + 2 && Jn.throwArgumentError("value out of range", "value", arguments[1]); n.length < 2 * e + 2; )
        n = "0x0" + n.substring(2);
    return n
}
function Lx(n) {
    const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (cI(n)) {
        let t = pt(n);
        t.length === 64 ? (e.v = 27 + (t[32] >> 7),
        t[32] &= 127,
        e.r = lt(t.slice(0, 32)),
        e.s = lt(t.slice(32, 64))) : t.length === 65 ? (e.r = lt(t.slice(0, 32)),
        e.s = lt(t.slice(32, 64)),
        e.v = t[64]) : Jn.throwArgumentError("invalid signature string", "signature", n),
        e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Jn.throwArgumentError("signature invalid v byte", "signature", n)),
        e.recoveryParam = 1 - e.v % 2,
        e.recoveryParam && (t[32] |= 128),
        e._vs = lt(t.slice(32, 64))
    } else {
        if (e.r = n.r,
        e.s = n.s,
        e.v = n.v,
        e.recoveryParam = n.recoveryParam,
        e._vs = n._vs,
        e._vs != null) {
            const i = o9(pt(e._vs), 32);
            e._vs = lt(i);
            const s = i[0] >= 128 ? 1 : 0;
            e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Jn.throwArgumentError("signature recoveryParam mismatch _vs", "signature", n),
            i[0] &= 127;
            const o = lt(i);
            e.s == null ? e.s = o : e.s !== o && Jn.throwArgumentError("signature v mismatch _vs", "signature", n)
        }
        if (e.recoveryParam == null)
            e.v == null ? Jn.throwArgumentError("signature missing v and recoveryParam", "signature", n) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
        else if (e.v == null)
            e.v = 27 + e.recoveryParam;
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
            e.recoveryParam !== i && Jn.throwArgumentError("signature recoveryParam mismatch v", "signature", n)
        }
        e.r == null || !It(e.r) ? Jn.throwArgumentError("signature missing or invalid r", "signature", n) : e.r = ir(e.r, 32),
        e.s == null || !It(e.s) ? Jn.throwArgumentError("signature missing or invalid s", "signature", n) : e.s = ir(e.s, 32);
        const t = pt(e.s);
        t[0] >= 128 && Jn.throwArgumentError("signature s out of range", "signature", n),
        e.recoveryParam && (t[0] |= 128);
        const r = lt(t);
        e._vs && (It(e._vs) || Jn.throwArgumentError("signature invalid _vs", "signature", n),
        e._vs = ir(e._vs, 32)),
        e._vs == null ? e._vs = r : e._vs !== r && Jn.throwArgumentError("signature _vs mismatch v and s", "signature", n)
    }
    return e.yParityAndS = e._vs,
    e.compact = e.r + e.yParityAndS.substring(2),
    e
}
const l9 = "bignumber/5.7.0";
var Xw = _t.BN;
const Cl = new xe(l9)
  , vb = {}
  , PU = 9007199254740991;
let LU = !1;
class je {
    constructor(e, t) {
        e !== vb && Cl.throwError("cannot call constructor directly; use BigNumber.from", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }),
        this._hex = t,
        this._isBigNumber = !0,
        Object.freeze(this)
    }
    fromTwos(e) {
        return Gi(Nt(this).fromTwos(e))
    }
    toTwos(e) {
        return Gi(Nt(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? je.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Gi(Nt(this).add(Nt(e)))
    }
    sub(e) {
        return Gi(Nt(this).sub(Nt(e)))
    }
    div(e) {
        return je.from(e).isZero() && Ys("division-by-zero", "div"),
        Gi(Nt(this).div(Nt(e)))
    }
    mul(e) {
        return Gi(Nt(this).mul(Nt(e)))
    }
    mod(e) {
        const t = Nt(e);
        return t.isNeg() && Ys("division-by-zero", "mod"),
        Gi(Nt(this).umod(t))
    }
    pow(e) {
        const t = Nt(e);
        return t.isNeg() && Ys("negative-power", "pow"),
        Gi(Nt(this).pow(t))
    }
    and(e) {
        const t = Nt(e);
        return (this.isNegative() || t.isNeg()) && Ys("unbound-bitwise-result", "and"),
        Gi(Nt(this).and(t))
    }
    or(e) {
        const t = Nt(e);
        return (this.isNegative() || t.isNeg()) && Ys("unbound-bitwise-result", "or"),
        Gi(Nt(this).or(t))
    }
    xor(e) {
        const t = Nt(e);
        return (this.isNegative() || t.isNeg()) && Ys("unbound-bitwise-result", "xor"),
        Gi(Nt(this).xor(t))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && Ys("negative-width", "mask"),
        Gi(Nt(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && Ys("negative-width", "shl"),
        Gi(Nt(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && Ys("negative-width", "shr"),
        Gi(Nt(this).shrn(e))
    }
    eq(e) {
        return Nt(this).eq(Nt(e))
    }
    lt(e) {
        return Nt(this).lt(Nt(e))
    }
    lte(e) {
        return Nt(this).lte(Nt(e))
    }
    gt(e) {
        return Nt(this).gt(Nt(e))
    }
    gte(e) {
        return Nt(this).gte(Nt(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return Nt(this).isZero()
    }
    toNumber() {
        try {
            return Nt(this).toNumber()
        } catch {
            Ys("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return Cl.throwError("this platform does not support BigInt", xe.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? LU || (LU = !0,
        Cl.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Cl.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", xe.errors.UNEXPECTED_ARGUMENT, {}) : Cl.throwError("BigNumber.toString does not accept parameters", xe.errors.UNEXPECTED_ARGUMENT, {})),
        Nt(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof je)
            return e;
        if (typeof e == "string")
            return e.match(/^-?0x[0-9a-f]+$/i) ? new je(vb,cg(e)) : e.match(/^-?[0-9]+$/) ? new je(vb,cg(new Xw(e))) : Cl.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number")
            return e % 1 && Ys("underflow", "BigNumber.from", e),
            (e >= PU || e <= -PU) && Ys("overflow", "BigNumber.from", e),
            je.from(String(e));
        const t = e;
        if (typeof t == "bigint")
            return je.from(t.toString());
        if (Fx(t))
            return je.from(lt(t));
        if (t)
            if (t.toHexString) {
                const r = t.toHexString();
                if (typeof r == "string")
                    return je.from(r)
            } else {
                let r = t._hex;
                if (r == null && t.type === "BigNumber" && (r = t.hex),
                typeof r == "string" && (It(r) || r[0] === "-" && It(r.substring(1))))
                    return je.from(r)
            }
        return Cl.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}
function cg(n) {
    if (typeof n != "string")
        return cg(n.toString(16));
    if (n[0] === "-")
        return n = n.substring(1),
        n[0] === "-" && Cl.throwArgumentError("invalid hex", "value", n),
        n = cg(n),
        n === "0x00" ? n : "-" + n;
    if (n.substring(0, 2) !== "0x" && (n = "0x" + n),
    n === "0x")
        return "0x00";
    for (n.length % 2 && (n = "0x0" + n.substring(2)); n.length > 4 && n.substring(0, 4) === "0x00"; )
        n = "0x" + n.substring(4);
    return n
}
function Gi(n) {
    return je.from(cg(n))
}
function Nt(n) {
    const e = je.from(n).toHexString();
    return e[0] === "-" ? new Xw("-" + e.substring(3),16) : new Xw(e.substring(2),16)
}
function Ys(n, e, t) {
    const r = {
        fault: n,
        operation: e
    };
    return t != null && (r.value = t),
    Cl.throwError(n, xe.errors.NUMERIC_FAULT, r)
}
function c9(n) {
    return new Xw(n,36).toString(16)
}
const A9 = "properties/5.7.0";
var u9 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Yw = new xe(A9);
function Ue(n, e, t) {
    Object.defineProperty(n, e, {
        enumerable: !0,
        value: t,
        writable: !1
    })
}
function Cs(n, e) {
    for (let t = 0; t < 32; t++) {
        if (n[e])
            return n[e];
        if (!n.prototype || typeof n.prototype != "object")
            break;
        n = Object.getPrototypeOf(n.prototype).constructor
    }
    return null
}
function wr(n) {
    return u9(this, void 0, void 0, function*() {
        const e = Object.keys(n).map(r => {
            const i = n[r];
            return Promise.resolve(i).then(s => ({
                key: r,
                value: s
            }))
        }
        );
        return (yield Promise.all(e)).reduce( (r, i) => (r[i.key] = i.value,
        r), {})
    })
}
function f9(n, e) {
    (!n || typeof n != "object") && Yw.throwArgumentError("invalid object", "object", n),
    Object.keys(n).forEach(t => {
        e[t] || Yw.throwArgumentError("invalid object key - " + t, "transaction:" + t, n)
    }
    )
}
function Qn(n) {
    const e = {};
    for (const t in n)
        e[t] = n[t];
    return e
}
const h9 = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};
function eQ(n) {
    if (n == null || h9[typeof n])
        return !0;
    if (Array.isArray(n) || typeof n == "object") {
        if (!Object.isFrozen(n))
            return !1;
        const e = Object.keys(n);
        for (let t = 0; t < e.length; t++) {
            let r = null;
            try {
                r = n[e[t]]
            } catch {
                continue
            }
            if (!eQ(r))
                return !1
        }
        return !0
    }
    return Yw.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n)
}
function d9(n) {
    if (eQ(n))
        return n;
    if (Array.isArray(n))
        return Object.freeze(n.map(e => Ps(e)));
    if (typeof n == "object") {
        const e = {};
        for (const t in n) {
            const r = n[t];
            r !== void 0 && Ue(e, t, Ps(r))
        }
        return e
    }
    return Yw.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n)
}
function Ps(n) {
    return d9(n)
}
class a0 {
    constructor(e) {
        for (const t in e)
            this[t] = Ps(e[t])
    }
}
const p9 = "abstract-provider/5.7.0";
var m9 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const g9 = new xe(p9);
class v9 extends a0 {
    static isForkEvent(e) {
        return !!(e && e._isForkEvent)
    }
}
class l0 {
    constructor() {
        g9.checkAbstract(new.target, l0),
        Ue(this, "_isProvider", !0)
    }
    getFeeData() {
        return m9(this, void 0, void 0, function*() {
            const {block: e, gasPrice: t} = yield wr({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch(o => null)
            });
            let r = null
              , i = null
              , s = null;
            return e && e.baseFeePerGas && (r = e.baseFeePerGas,
            s = je.from("1500000000"),
            i = e.baseFeePerGas.mul(2).add(s)),
            {
                lastBaseFeePerGas: r,
                maxFeePerGas: i,
                maxPriorityFeePerGas: s,
                gasPrice: t
            }
        })
    }
    addListener(e, t) {
        return this.on(e, t)
    }
    removeListener(e, t) {
        return this.off(e, t)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const y9 = "networks/5.7.1"
  , DU = new xe(y9);
function w9(n) {
    return n && typeof n.renetwork == "function"
}
function Fl(n) {
    const e = function(t, r) {
        r == null && (r = {});
        const i = [];
        if (t.InfuraProvider && r.infura !== "-")
            try {
                i.push(new t.InfuraProvider(n,r.infura))
            } catch {}
        if (t.EtherscanProvider && r.etherscan !== "-")
            try {
                i.push(new t.EtherscanProvider(n,r.etherscan))
            } catch {}
        if (t.AlchemyProvider && r.alchemy !== "-")
            try {
                i.push(new t.AlchemyProvider(n,r.alchemy))
            } catch {}
        if (t.PocketProvider && r.pocket !== "-") {
            const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
            try {
                const o = new t.PocketProvider(n,r.pocket);
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        }
        if (t.CloudflareProvider && r.cloudflare !== "-")
            try {
                i.push(new t.CloudflareProvider(n))
            } catch {}
        if (t.AnkrProvider && r.ankr !== "-")
            try {
                const s = ["ropsten"]
                  , o = new t.AnkrProvider(n,r.ankr);
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        if (i.length === 0)
            return null;
        if (t.FallbackProvider) {
            let s = 1;
            return r.quorum != null ? s = r.quorum : n === "homestead" && (s = 2),
            new t.FallbackProvider(i,s)
        }
        return i[0]
    };
    return e.renetwork = function(t) {
        return Fl(t)
    }
    ,
    e
}
function $w(n, e) {
    const t = function(r, i) {
        return r.JsonRpcProvider ? new r.JsonRpcProvider(n,e) : null
    };
    return t.renetwork = function(r) {
        return $w(n, r)
    }
    ,
    t
}
const NU = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: Fl("homestead")
}
  , OU = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: Fl("ropsten")
}
  , kU = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: $w("https://www.ethercluster.com/mordor", "classicMordor")
}
  , Q0 = {
    unspecified: {
        chainId: 0,
        name: "unspecified"
    },
    homestead: NU,
    mainnet: NU,
    morden: {
        chainId: 2,
        name: "morden"
    },
    ropsten: OU,
    testnet: OU,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: Fl("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: Fl("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: Fl("goerli")
    },
    kintsugi: {
        chainId: 1337702,
        name: "kintsugi"
    },
    sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: Fl("sepolia")
    },
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: $w("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: {
        chainId: 62,
        name: "classicMorden"
    },
    classicMordor: kU,
    classicTestnet: kU,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: $w("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: {
        chainId: 100,
        name: "xdai"
    },
    matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: Fl("matic")
    },
    maticmum: {
        chainId: 80001,
        name: "maticmum"
    },
    optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: Fl("optimism")
    },
    "optimism-kovan": {
        chainId: 69,
        name: "optimism-kovan"
    },
    "optimism-goerli": {
        chainId: 420,
        name: "optimism-goerli"
    },
    arbitrum: {
        chainId: 42161,
        name: "arbitrum"
    },
    "arbitrum-rinkeby": {
        chainId: 421611,
        name: "arbitrum-rinkeby"
    },
    "arbitrum-goerli": {
        chainId: 421613,
        name: "arbitrum-goerli"
    },
    bnb: {
        chainId: 56,
        name: "bnb"
    },
    bnbt: {
        chainId: 97,
        name: "bnbt"
    }
};
function tQ(n) {
    if (n == null)
        return null;
    if (typeof n == "number") {
        for (const r in Q0) {
            const i = Q0[r];
            if (i.chainId === n)
                return {
                    name: i.name,
                    chainId: i.chainId,
                    ensAddress: i.ensAddress || null,
                    _defaultProvider: i._defaultProvider || null
                }
        }
        return {
            chainId: n,
            name: "unknown"
        }
    }
    if (typeof n == "string") {
        const r = Q0[n];
        return r == null ? null : {
            name: r.name,
            chainId: r.chainId,
            ensAddress: r.ensAddress,
            _defaultProvider: r._defaultProvider || null
        }
    }
    const e = Q0[n.name];
    if (!e)
        return typeof n.chainId != "number" && DU.throwArgumentError("invalid network chainId", "network", n),
        n;
    n.chainId !== 0 && n.chainId !== e.chainId && DU.throwArgumentError("network chainId mismatch", "network", n);
    let t = n._defaultProvider || null;
    return t == null && e._defaultProvider && (w9(e._defaultProvider) ? t = e._defaultProvider.renetwork(n) : t = e._defaultProvider),
    {
        name: n.name,
        chainId: e.chainId,
        ensAddress: n.ensAddress || e.ensAddress || null,
        _defaultProvider: t
    }
}
function nQ(n) {
    n = atob(n);
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n.charCodeAt(t));
    return pt(e)
}
function rQ(n) {
    n = pt(n);
    let e = "";
    for (let t = 0; t < n.length; t++)
        e += String.fromCharCode(n[t]);
    return btoa(e)
}
class iQ {
    constructor(e) {
        Ue(this, "alphabet", e),
        Ue(this, "base", e.length),
        Ue(this, "_alphabetMap", {}),
        Ue(this, "_leader", e.charAt(0));
        for (let t = 0; t < e.length; t++)
            this._alphabetMap[e.charAt(t)] = t
    }
    encode(e) {
        let t = pt(e);
        if (t.length === 0)
            return "";
        let r = [0];
        for (let s = 0; s < t.length; ++s) {
            let o = t[s];
            for (let a = 0; a < r.length; ++a)
                o += r[a] << 8,
                r[a] = o % this.base,
                o = o / this.base | 0;
            for (; o > 0; )
                r.push(o % this.base),
                o = o / this.base | 0
        }
        let i = "";
        for (let s = 0; t[s] === 0 && s < t.length - 1; ++s)
            i += this._leader;
        for (let s = r.length - 1; s >= 0; --s)
            i += this.alphabet[r[s]];
        return i
    }
    decode(e) {
        if (typeof e != "string")
            throw new TypeError("Expected String");
        let t = [];
        if (e.length === 0)
            return new Uint8Array(t);
        t.push(0);
        for (let r = 0; r < e.length; r++) {
            let i = this._alphabetMap[e[r]];
            if (i === void 0)
                throw new Error("Non-base" + this.base + " character");
            let s = i;
            for (let o = 0; o < t.length; ++o)
                s += t[o] * this.base,
                t[o] = s & 255,
                s >>= 8;
            for (; s > 0; )
                t.push(s & 255),
                s >>= 8
        }
        for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r)
            t.push(0);
        return pt(new Uint8Array(t.reverse()))
    }
}
new iQ("abcdefghijklmnopqrstuvwxyz234567");
const RM = new iQ("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
  , _9 = "0x0000000000000000000000000000000000000000"
  , x9 = je.from(-1)
  , sQ = je.from(0)
  , b9 = je.from(1)
  , E9 = je.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
  , B9 = "0x0000000000000000000000000000000000000000000000000000000000000000";
var oQ = {
    exports: {}
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(n) {
    (function() {
        var e = "input is invalid type"
          , t = "finalize already called"
          , r = typeof window == "object"
          , i = r ? window : {};
        i.JS_SHA3_NO_WINDOW && (r = !1);
        var s = !r && typeof self == "object"
          , o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        o ? i = ka : s && (i = self);
        var a = !i.JS_SHA3_NO_COMMON_JS && !0 && n.exports
          , l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u"
          , c = "0123456789abcdef".split("")
          , A = [31, 7936, 2031616, 520093696]
          , u = [4, 1024, 262144, 67108864]
          , f = [1, 256, 65536, 16777216]
          , h = [6, 1536, 393216, 100663296]
          , d = [0, 8, 16, 24]
          , m = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]
          , g = [224, 256, 384, 512]
          , p = [128, 256]
          , v = ["hex", "buffer", "arrayBuffer", "array", "digest"]
          , w = {
            128: 168,
            256: 136
        };
        (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(P) {
            return Object.prototype.toString.call(P) === "[object Array]"
        }
        ),
        l && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(P) {
            return typeof P == "object" && P.buffer && P.buffer.constructor === ArrayBuffer
        }
        );
        for (var _ = function(P, re, ue) {
            return function(le) {
                return new C(P,re,P).update(le)[ue]()
            }
        }, x = function(P, re, ue) {
            return function(le, me) {
                return new C(P,re,me).update(le)[ue]()
            }
        }, b = function(P, re, ue) {
            return function(le, me, ie, ge) {
                return y["cshake" + P].update(le, me, ie, ge)[ue]()
            }
        }, B = function(P, re, ue) {
            return function(le, me, ie, ge) {
                return y["kmac" + P].update(le, me, ie, ge)[ue]()
            }
        }, S = function(P, re, ue, le) {
            for (var me = 0; me < v.length; ++me) {
                var ie = v[me];
                P[ie] = re(ue, le, ie)
            }
            return P
        }, I = function(P, re) {
            var ue = _(P, re, "hex");
            return ue.create = function() {
                return new C(P,re,P)
            }
            ,
            ue.update = function(le) {
                return ue.create().update(le)
            }
            ,
            S(ue, _, P, re)
        }, M = function(P, re) {
            var ue = x(P, re, "hex");
            return ue.create = function(le) {
                return new C(P,re,le)
            }
            ,
            ue.update = function(le, me) {
                return ue.create(me).update(le)
            }
            ,
            S(ue, x, P, re)
        }, L = function(P, re) {
            var ue = w[P]
              , le = b(P, re, "hex");
            return le.create = function(me, ie, ge) {
                return !ie && !ge ? y["shake" + P].create(me) : new C(P,re,me).bytepad([ie, ge], ue)
            }
            ,
            le.update = function(me, ie, ge, _e) {
                return le.create(ie, ge, _e).update(me)
            }
            ,
            S(le, b, P, re)
        }, D = function(P, re) {
            var ue = w[P]
              , le = B(P, re, "hex");
            return le.create = function(me, ie, ge) {
                return new W(P,re,ie).bytepad(["KMAC", ge], ue).bytepad([me], ue)
            }
            ,
            le.update = function(me, ie, ge, _e) {
                return le.create(me, ge, _e).update(ie)
            }
            ,
            S(le, B, P, re)
        }, T = [{
            name: "keccak",
            padding: f,
            bits: g,
            createMethod: I
        }, {
            name: "sha3",
            padding: h,
            bits: g,
            createMethod: I
        }, {
            name: "shake",
            padding: A,
            bits: p,
            createMethod: M
        }, {
            name: "cshake",
            padding: u,
            bits: p,
            createMethod: L
        }, {
            name: "kmac",
            padding: u,
            bits: p,
            createMethod: D
        }], y = {}, E = [], R = 0; R < T.length; ++R)
            for (var F = T[R], O = F.bits, z = 0; z < O.length; ++z) {
                var j = F.name + "_" + O[z];
                if (E.push(j),
                y[j] = F.createMethod(O[z], F.padding),
                F.name !== "sha3") {
                    var Q = F.name + O[z];
                    E.push(Q),
                    y[Q] = y[j]
                }
            }
        function C(P, re, ue) {
            this.blocks = [],
            this.s = [],
            this.padding = re,
            this.outputBits = ue,
            this.reset = !0,
            this.finalized = !1,
            this.block = 0,
            this.start = 0,
            this.blockCount = 1600 - (P << 1) >> 5,
            this.byteCount = this.blockCount << 2,
            this.outputBlocks = ue >> 5,
            this.extraBytes = (ue & 31) >> 3;
            for (var le = 0; le < 50; ++le)
                this.s[le] = 0
        }
        C.prototype.update = function(P) {
            if (this.finalized)
                throw new Error(t);
            var re, ue = typeof P;
            if (ue !== "string") {
                if (ue === "object") {
                    if (P === null)
                        throw new Error(e);
                    if (l && P.constructor === ArrayBuffer)
                        P = new Uint8Array(P);
                    else if (!Array.isArray(P) && (!l || !ArrayBuffer.isView(P)))
                        throw new Error(e)
                } else
                    throw new Error(e);
                re = !0
            }
            for (var le = this.blocks, me = this.byteCount, ie = P.length, ge = this.blockCount, _e = 0, se = this.s, H, fe; _e < ie; ) {
                if (this.reset)
                    for (this.reset = !1,
                    le[0] = this.block,
                    H = 1; H < ge + 1; ++H)
                        le[H] = 0;
                if (re)
                    for (H = this.start; _e < ie && H < me; ++_e)
                        le[H >> 2] |= P[_e] << d[H++ & 3];
                else
                    for (H = this.start; _e < ie && H < me; ++_e)
                        fe = P.charCodeAt(_e),
                        fe < 128 ? le[H >> 2] |= fe << d[H++ & 3] : fe < 2048 ? (le[H >> 2] |= (192 | fe >> 6) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe & 63) << d[H++ & 3]) : fe < 55296 || fe >= 57344 ? (le[H >> 2] |= (224 | fe >> 12) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe >> 6 & 63) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe & 63) << d[H++ & 3]) : (fe = 65536 + ((fe & 1023) << 10 | P.charCodeAt(++_e) & 1023),
                        le[H >> 2] |= (240 | fe >> 18) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe >> 12 & 63) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe >> 6 & 63) << d[H++ & 3],
                        le[H >> 2] |= (128 | fe & 63) << d[H++ & 3]);
                if (this.lastByteIndex = H,
                H >= me) {
                    for (this.start = H - me,
                    this.block = le[ge],
                    H = 0; H < ge; ++H)
                        se[H] ^= le[H];
                    ee(se),
                    this.reset = !0
                } else
                    this.start = H
            }
            return this
        }
        ,
        C.prototype.encode = function(P, re) {
            var ue = P & 255
              , le = 1
              , me = [ue];
            for (P = P >> 8,
            ue = P & 255; ue > 0; )
                me.unshift(ue),
                P = P >> 8,
                ue = P & 255,
                ++le;
            return re ? me.push(le) : me.unshift(le),
            this.update(me),
            me.length
        }
        ,
        C.prototype.encodeString = function(P) {
            var re, ue = typeof P;
            if (ue !== "string") {
                if (ue === "object") {
                    if (P === null)
                        throw new Error(e);
                    if (l && P.constructor === ArrayBuffer)
                        P = new Uint8Array(P);
                    else if (!Array.isArray(P) && (!l || !ArrayBuffer.isView(P)))
                        throw new Error(e)
                } else
                    throw new Error(e);
                re = !0
            }
            var le = 0
              , me = P.length;
            if (re)
                le = me;
            else
                for (var ie = 0; ie < P.length; ++ie) {
                    var ge = P.charCodeAt(ie);
                    ge < 128 ? le += 1 : ge < 2048 ? le += 2 : ge < 55296 || ge >= 57344 ? le += 3 : (ge = 65536 + ((ge & 1023) << 10 | P.charCodeAt(++ie) & 1023),
                    le += 4)
                }
            return le += this.encode(le * 8),
            this.update(P),
            le
        }
        ,
        C.prototype.bytepad = function(P, re) {
            for (var ue = this.encode(re), le = 0; le < P.length; ++le)
                ue += this.encodeString(P[le]);
            var me = re - ue % re
              , ie = [];
            return ie.length = me,
            this.update(ie),
            this
        }
        ,
        C.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var P = this.blocks
                  , re = this.lastByteIndex
                  , ue = this.blockCount
                  , le = this.s;
                if (P[re >> 2] |= this.padding[re & 3],
                this.lastByteIndex === this.byteCount)
                    for (P[0] = P[ue],
                    re = 1; re < ue + 1; ++re)
                        P[re] = 0;
                for (P[ue - 1] |= 2147483648,
                re = 0; re < ue; ++re)
                    le[re] ^= P[re];
                ee(le)
            }
        }
        ,
        C.prototype.toString = C.prototype.hex = function() {
            this.finalize();
            for (var P = this.blockCount, re = this.s, ue = this.outputBlocks, le = this.extraBytes, me = 0, ie = 0, ge = "", _e; ie < ue; ) {
                for (me = 0; me < P && ie < ue; ++me,
                ++ie)
                    _e = re[me],
                    ge += c[_e >> 4 & 15] + c[_e & 15] + c[_e >> 12 & 15] + c[_e >> 8 & 15] + c[_e >> 20 & 15] + c[_e >> 16 & 15] + c[_e >> 28 & 15] + c[_e >> 24 & 15];
                ie % P === 0 && (ee(re),
                me = 0)
            }
            return le && (_e = re[me],
            ge += c[_e >> 4 & 15] + c[_e & 15],
            le > 1 && (ge += c[_e >> 12 & 15] + c[_e >> 8 & 15]),
            le > 2 && (ge += c[_e >> 20 & 15] + c[_e >> 16 & 15])),
            ge
        }
        ,
        C.prototype.arrayBuffer = function() {
            this.finalize();
            var P = this.blockCount, re = this.s, ue = this.outputBlocks, le = this.extraBytes, me = 0, ie = 0, ge = this.outputBits >> 3, _e;
            le ? _e = new ArrayBuffer(ue + 1 << 2) : _e = new ArrayBuffer(ge);
            for (var se = new Uint32Array(_e); ie < ue; ) {
                for (me = 0; me < P && ie < ue; ++me,
                ++ie)
                    se[ie] = re[me];
                ie % P === 0 && ee(re)
            }
            return le && (se[me] = re[me],
            _e = _e.slice(0, ge)),
            _e
        }
        ,
        C.prototype.buffer = C.prototype.arrayBuffer,
        C.prototype.digest = C.prototype.array = function() {
            this.finalize();
            for (var P = this.blockCount, re = this.s, ue = this.outputBlocks, le = this.extraBytes, me = 0, ie = 0, ge = [], _e, se; ie < ue; ) {
                for (me = 0; me < P && ie < ue; ++me,
                ++ie)
                    _e = ie << 2,
                    se = re[me],
                    ge[_e] = se & 255,
                    ge[_e + 1] = se >> 8 & 255,
                    ge[_e + 2] = se >> 16 & 255,
                    ge[_e + 3] = se >> 24 & 255;
                ie % P === 0 && ee(re)
            }
            return le && (_e = ie << 2,
            se = re[me],
            ge[_e] = se & 255,
            le > 1 && (ge[_e + 1] = se >> 8 & 255),
            le > 2 && (ge[_e + 2] = se >> 16 & 255)),
            ge
        }
        ;
        function W(P, re, ue) {
            C.call(this, P, re, ue)
        }
        W.prototype = new C,
        W.prototype.finalize = function() {
            return this.encode(this.outputBits, !0),
            C.prototype.finalize.call(this)
        }
        ;
        var ee = function(P) {
            var re, ue, le, me, ie, ge, _e, se, H, fe, Ae, J, q, he, X, G, ne, Y, de, ae, Ee, V, U, N, K, oe, pe, ve, Ce, Le, Re, $e, ce, Pe, Se, Te, Fe, De, Ze, At, Pn, rt, xt, Tr, tn, qt, Jr, en, nn, Ks, Xt, Yt, Ii, rn, sn, ma, un, on, te, ye, Be, Me, we;
            for (le = 0; le < 48; le += 2)
                me = P[0] ^ P[10] ^ P[20] ^ P[30] ^ P[40],
                ie = P[1] ^ P[11] ^ P[21] ^ P[31] ^ P[41],
                ge = P[2] ^ P[12] ^ P[22] ^ P[32] ^ P[42],
                _e = P[3] ^ P[13] ^ P[23] ^ P[33] ^ P[43],
                se = P[4] ^ P[14] ^ P[24] ^ P[34] ^ P[44],
                H = P[5] ^ P[15] ^ P[25] ^ P[35] ^ P[45],
                fe = P[6] ^ P[16] ^ P[26] ^ P[36] ^ P[46],
                Ae = P[7] ^ P[17] ^ P[27] ^ P[37] ^ P[47],
                J = P[8] ^ P[18] ^ P[28] ^ P[38] ^ P[48],
                q = P[9] ^ P[19] ^ P[29] ^ P[39] ^ P[49],
                re = J ^ (ge << 1 | _e >>> 31),
                ue = q ^ (_e << 1 | ge >>> 31),
                P[0] ^= re,
                P[1] ^= ue,
                P[10] ^= re,
                P[11] ^= ue,
                P[20] ^= re,
                P[21] ^= ue,
                P[30] ^= re,
                P[31] ^= ue,
                P[40] ^= re,
                P[41] ^= ue,
                re = me ^ (se << 1 | H >>> 31),
                ue = ie ^ (H << 1 | se >>> 31),
                P[2] ^= re,
                P[3] ^= ue,
                P[12] ^= re,
                P[13] ^= ue,
                P[22] ^= re,
                P[23] ^= ue,
                P[32] ^= re,
                P[33] ^= ue,
                P[42] ^= re,
                P[43] ^= ue,
                re = ge ^ (fe << 1 | Ae >>> 31),
                ue = _e ^ (Ae << 1 | fe >>> 31),
                P[4] ^= re,
                P[5] ^= ue,
                P[14] ^= re,
                P[15] ^= ue,
                P[24] ^= re,
                P[25] ^= ue,
                P[34] ^= re,
                P[35] ^= ue,
                P[44] ^= re,
                P[45] ^= ue,
                re = se ^ (J << 1 | q >>> 31),
                ue = H ^ (q << 1 | J >>> 31),
                P[6] ^= re,
                P[7] ^= ue,
                P[16] ^= re,
                P[17] ^= ue,
                P[26] ^= re,
                P[27] ^= ue,
                P[36] ^= re,
                P[37] ^= ue,
                P[46] ^= re,
                P[47] ^= ue,
                re = fe ^ (me << 1 | ie >>> 31),
                ue = Ae ^ (ie << 1 | me >>> 31),
                P[8] ^= re,
                P[9] ^= ue,
                P[18] ^= re,
                P[19] ^= ue,
                P[28] ^= re,
                P[29] ^= ue,
                P[38] ^= re,
                P[39] ^= ue,
                P[48] ^= re,
                P[49] ^= ue,
                he = P[0],
                X = P[1],
                qt = P[11] << 4 | P[10] >>> 28,
                Jr = P[10] << 4 | P[11] >>> 28,
                ve = P[20] << 3 | P[21] >>> 29,
                Ce = P[21] << 3 | P[20] >>> 29,
                ye = P[31] << 9 | P[30] >>> 23,
                Be = P[30] << 9 | P[31] >>> 23,
                rt = P[40] << 18 | P[41] >>> 14,
                xt = P[41] << 18 | P[40] >>> 14,
                Pe = P[2] << 1 | P[3] >>> 31,
                Se = P[3] << 1 | P[2] >>> 31,
                G = P[13] << 12 | P[12] >>> 20,
                ne = P[12] << 12 | P[13] >>> 20,
                en = P[22] << 10 | P[23] >>> 22,
                nn = P[23] << 10 | P[22] >>> 22,
                Le = P[33] << 13 | P[32] >>> 19,
                Re = P[32] << 13 | P[33] >>> 19,
                Me = P[42] << 2 | P[43] >>> 30,
                we = P[43] << 2 | P[42] >>> 30,
                rn = P[5] << 30 | P[4] >>> 2,
                sn = P[4] << 30 | P[5] >>> 2,
                Te = P[14] << 6 | P[15] >>> 26,
                Fe = P[15] << 6 | P[14] >>> 26,
                Y = P[25] << 11 | P[24] >>> 21,
                de = P[24] << 11 | P[25] >>> 21,
                Ks = P[34] << 15 | P[35] >>> 17,
                Xt = P[35] << 15 | P[34] >>> 17,
                $e = P[45] << 29 | P[44] >>> 3,
                ce = P[44] << 29 | P[45] >>> 3,
                N = P[6] << 28 | P[7] >>> 4,
                K = P[7] << 28 | P[6] >>> 4,
                ma = P[17] << 23 | P[16] >>> 9,
                un = P[16] << 23 | P[17] >>> 9,
                De = P[26] << 25 | P[27] >>> 7,
                Ze = P[27] << 25 | P[26] >>> 7,
                ae = P[36] << 21 | P[37] >>> 11,
                Ee = P[37] << 21 | P[36] >>> 11,
                Yt = P[47] << 24 | P[46] >>> 8,
                Ii = P[46] << 24 | P[47] >>> 8,
                Tr = P[8] << 27 | P[9] >>> 5,
                tn = P[9] << 27 | P[8] >>> 5,
                oe = P[18] << 20 | P[19] >>> 12,
                pe = P[19] << 20 | P[18] >>> 12,
                on = P[29] << 7 | P[28] >>> 25,
                te = P[28] << 7 | P[29] >>> 25,
                At = P[38] << 8 | P[39] >>> 24,
                Pn = P[39] << 8 | P[38] >>> 24,
                V = P[48] << 14 | P[49] >>> 18,
                U = P[49] << 14 | P[48] >>> 18,
                P[0] = he ^ ~G & Y,
                P[1] = X ^ ~ne & de,
                P[10] = N ^ ~oe & ve,
                P[11] = K ^ ~pe & Ce,
                P[20] = Pe ^ ~Te & De,
                P[21] = Se ^ ~Fe & Ze,
                P[30] = Tr ^ ~qt & en,
                P[31] = tn ^ ~Jr & nn,
                P[40] = rn ^ ~ma & on,
                P[41] = sn ^ ~un & te,
                P[2] = G ^ ~Y & ae,
                P[3] = ne ^ ~de & Ee,
                P[12] = oe ^ ~ve & Le,
                P[13] = pe ^ ~Ce & Re,
                P[22] = Te ^ ~De & At,
                P[23] = Fe ^ ~Ze & Pn,
                P[32] = qt ^ ~en & Ks,
                P[33] = Jr ^ ~nn & Xt,
                P[42] = ma ^ ~on & ye,
                P[43] = un ^ ~te & Be,
                P[4] = Y ^ ~ae & V,
                P[5] = de ^ ~Ee & U,
                P[14] = ve ^ ~Le & $e,
                P[15] = Ce ^ ~Re & ce,
                P[24] = De ^ ~At & rt,
                P[25] = Ze ^ ~Pn & xt,
                P[34] = en ^ ~Ks & Yt,
                P[35] = nn ^ ~Xt & Ii,
                P[44] = on ^ ~ye & Me,
                P[45] = te ^ ~Be & we,
                P[6] = ae ^ ~V & he,
                P[7] = Ee ^ ~U & X,
                P[16] = Le ^ ~$e & N,
                P[17] = Re ^ ~ce & K,
                P[26] = At ^ ~rt & Pe,
                P[27] = Pn ^ ~xt & Se,
                P[36] = Ks ^ ~Yt & Tr,
                P[37] = Xt ^ ~Ii & tn,
                P[46] = ye ^ ~Me & rn,
                P[47] = Be ^ ~we & sn,
                P[8] = V ^ ~he & G,
                P[9] = U ^ ~X & ne,
                P[18] = $e ^ ~N & oe,
                P[19] = ce ^ ~K & pe,
                P[28] = rt ^ ~Pe & Te,
                P[29] = xt ^ ~Se & Fe,
                P[38] = Yt ^ ~Tr & qt,
                P[39] = Ii ^ ~tn & Jr,
                P[48] = Me ^ ~rn & ma,
                P[49] = we ^ ~sn & un,
                P[0] ^= m[le],
                P[1] ^= m[le + 1]
        };
        if (a)
            n.exports = y;
        else
            for (R = 0; R < E.length; ++R)
                i[E[R]] = y[E[R]]
    }
    )()
}
)(oQ);
var M9 = oQ.exports;
const S9 = oc(M9);
function Er(n) {
    return "0x" + S9.keccak_256(pt(n))
}
const C9 = "strings/5.7.0"
  , aQ = new xe(C9);
var Ag;
(function(n) {
    n.current = "",
    n.NFC = "NFC",
    n.NFD = "NFD",
    n.NFKC = "NFKC",
    n.NFKD = "NFKD"
}
)(Ag || (Ag = {}));
var bs;
(function(n) {
    n.UNEXPECTED_CONTINUE = "unexpected continuation byte",
    n.BAD_PREFIX = "bad codepoint prefix",
    n.OVERRUN = "string overrun",
    n.MISSING_CONTINUE = "missing continuation byte",
    n.OUT_OF_RANGE = "out of UTF-8 range",
    n.UTF16_SURROGATE = "UTF-16 surrogate",
    n.OVERLONG = "overlong representation"
}
)(bs || (bs = {}));
function T9(n, e, t, r, i) {
    return aQ.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, "bytes", t)
}
function lQ(n, e, t, r, i) {
    if (n === bs.BAD_PREFIX || n === bs.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let o = e + 1; o < t.length && t[o] >> 6 === 2; o++)
            s++;
        return s
    }
    return n === bs.OVERRUN ? t.length - e - 1 : 0
}
function I9(n, e, t, r, i) {
    return n === bs.OVERLONG ? (r.push(i),
    0) : (r.push(65533),
    lQ(n, e, t))
}
const R9 = Object.freeze({
    error: T9,
    ignore: lQ,
    replace: I9
});
function cQ(n, e) {
    e == null && (e = R9.error),
    n = pt(n);
    const t = [];
    let r = 0;
    for (; r < n.length; ) {
        const i = n[r++];
        if (!(i >> 7)) {
            t.push(i);
            continue
        }
        let s = null
          , o = null;
        if ((i & 224) === 192)
            s = 1,
            o = 127;
        else if ((i & 240) === 224)
            s = 2,
            o = 2047;
        else if ((i & 248) === 240)
            s = 3,
            o = 65535;
        else {
            (i & 192) === 128 ? r += e(bs.UNEXPECTED_CONTINUE, r - 1, n, t) : r += e(bs.BAD_PREFIX, r - 1, n, t);
            continue
        }
        if (r - 1 + s >= n.length) {
            r += e(bs.OVERRUN, r - 1, n, t);
            continue
        }
        let a = i & (1 << 8 - s - 1) - 1;
        for (let l = 0; l < s; l++) {
            let c = n[r];
            if ((c & 192) != 128) {
                r += e(bs.MISSING_CONTINUE, r, n, t),
                a = null;
                break
            }
            a = a << 6 | c & 63,
            r++
        }
        if (a !== null) {
            if (a > 1114111) {
                r += e(bs.OUT_OF_RANGE, r - 1 - s, n, t, a);
                continue
            }
            if (a >= 55296 && a <= 57343) {
                r += e(bs.UTF16_SURROGATE, r - 1 - s, n, t, a);
                continue
            }
            if (a <= o) {
                r += e(bs.OVERLONG, r - 1 - s, n, t, a);
                continue
            }
            t.push(a)
        }
    }
    return t
}
function $a(n, e=Ag.current) {
    e != Ag.current && (aQ.checkNormalize(),
    n = n.normalize(e));
    let t = [];
    for (let r = 0; r < n.length; r++) {
        const i = n.charCodeAt(r);
        if (i < 128)
            t.push(i);
        else if (i < 2048)
            t.push(i >> 6 | 192),
            t.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            r++;
            const s = n.charCodeAt(r);
            if (r >= n.length || (s & 64512) !== 56320)
                throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            t.push(o >> 18 | 240),
            t.push(o >> 12 & 63 | 128),
            t.push(o >> 6 & 63 | 128),
            t.push(o & 63 | 128)
        } else
            t.push(i >> 12 | 224),
            t.push(i >> 6 & 63 | 128),
            t.push(i & 63 | 128)
    }
    return pt(t)
}
function U9(n) {
    return n.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536,
    String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}
function c0(n, e) {
    return U9(cQ(n, e))
}
function F9(n, e=Ag.current) {
    return cQ($a(n, e))
}
function mh(n) {
    return Er($a(n))
}
const AQ = "hash/5.7.0";
function uQ(n, e) {
    e == null && (e = 1);
    const t = []
      , r = t.forEach
      , i = function(s, o) {
        r.call(s, function(a) {
            o > 0 && Array.isArray(a) ? i(a, o - 1) : t.push(a)
        })
    };
    return i(n, e),
    t
}
function P9(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const r = n[t];
        e[r[0]] = r[1]
    }
    return e
}
function L9(n) {
    let e = 0;
    function t() {
        return n[e++] << 8 | n[e++]
    }
    let r = t()
      , i = 1
      , s = [0, 1];
    for (let x = 1; x < r; x++)
        s.push(i += t());
    let o = t()
      , a = e;
    e += o;
    let l = 0
      , c = 0;
    function A() {
        return l == 0 && (c = c << 8 | n[e++],
        l = 8),
        c >> --l & 1
    }
    const u = 31
      , f = Math.pow(2, u)
      , h = f >>> 1
      , d = h >> 1
      , m = f - 1;
    let g = 0;
    for (let x = 0; x < u; x++)
        g = g << 1 | A();
    let p = []
      , v = 0
      , w = f;
    for (; ; ) {
        let x = Math.floor(((g - v + 1) * i - 1) / w)
          , b = 0
          , B = r;
        for (; B - b > 1; ) {
            let M = b + B >>> 1;
            x < s[M] ? B = M : b = M
        }
        if (b == 0)
            break;
        p.push(b);
        let S = v + Math.floor(w * s[b] / i)
          , I = v + Math.floor(w * s[b + 1] / i) - 1;
        for (; !((S ^ I) & h); )
            g = g << 1 & m | A(),
            S = S << 1 & m,
            I = I << 1 & m | 1;
        for (; S & ~I & d; )
            g = g & h | g << 1 & m >>> 1 | A(),
            S = S << 1 ^ h,
            I = (I ^ h) << 1 | h | 1;
        v = S,
        w = 1 + I - S
    }
    let _ = r - 4;
    return p.map(x => {
        switch (x - _) {
        case 3:
            return _ + 65792 + (n[a++] << 16 | n[a++] << 8 | n[a++]);
        case 2:
            return _ + 256 + (n[a++] << 8 | n[a++]);
        case 1:
            return _ + n[a++];
        default:
            return x - 1
        }
    }
    )
}
function D9(n) {
    let e = 0;
    return () => n[e++]
}
function N9(n) {
    return D9(L9(n))
}
function O9(n) {
    return n & 1 ? ~n >> 1 : n >> 1
}
function k9(n, e) {
    let t = Array(n);
    for (let r = 0; r < n; r++)
        t[r] = 1 + e();
    return t
}
function QU(n, e) {
    let t = Array(n);
    for (let r = 0, i = -1; r < n; r++)
        t[r] = i += 1 + e();
    return t
}
function Q9(n, e) {
    let t = Array(n);
    for (let r = 0, i = 0; r < n; r++)
        t[r] = i += O9(e());
    return t
}
function Zw(n, e) {
    let t = QU(n(), n)
      , r = n()
      , i = QU(r, n)
      , s = k9(r, n);
    for (let o = 0; o < r; o++)
        for (let a = 0; a < s[o]; a++)
            t.push(i[o] + a);
    return e ? t.map(o => e[o]) : t
}
function H9(n) {
    let e = [];
    for (; ; ) {
        let t = n();
        if (t == 0)
            break;
        e.push(G9(t, n))
    }
    for (; ; ) {
        let t = n() - 1;
        if (t < 0)
            break;
        e.push(V9(t, n))
    }
    return P9(uQ(e))
}
function z9(n) {
    let e = [];
    for (; ; ) {
        let t = n();
        if (t == 0)
            break;
        e.push(t)
    }
    return e
}
function fQ(n, e, t) {
    let r = Array(n).fill(void 0).map( () => []);
    for (let i = 0; i < e; i++)
        Q9(n, t).forEach( (s, o) => r[o].push(s));
    return r
}
function G9(n, e) {
    let t = 1 + e()
      , r = e()
      , i = z9(e)
      , s = fQ(i.length, 1 + n, e);
    return uQ(s.map( (o, a) => {
        const l = o[0]
          , c = o.slice(1);
        return Array(i[a]).fill(void 0).map( (A, u) => {
            let f = u * r;
            return [l + u * t, c.map(h => h + f)]
        }
        )
    }
    ))
}
function V9(n, e) {
    let t = 1 + e();
    return fQ(t, 1 + n, e).map(i => [i[0], i.slice(1)])
}
function j9(n) {
    let e = Zw(n).sort( (r, i) => r - i);
    return t();
    function t() {
        let r = [];
        for (; ; ) {
            let c = Zw(n, e);
            if (c.length == 0)
                break;
            r.push({
                set: new Set(c),
                node: t()
            })
        }
        r.sort( (c, A) => A.set.size - c.set.size);
        let i = n()
          , s = i % 3;
        i = i / 3 | 0;
        let o = !!(i & 1);
        i >>= 1;
        let a = i == 1
          , l = i == 2;
        return {
            branches: r,
            valid: s,
            fe0f: o,
            save: a,
            check: l
        }
    }
}
function W9() {
    return N9(nQ("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="))
}
const Dx = W9()
  , K9 = new Set(Zw(Dx))
  , X9 = new Set(Zw(Dx))
  , Y9 = H9(Dx)
  , $9 = j9(Dx)
  , HU = 45
  , zU = 95;
function hQ(n) {
    return F9(n)
}
function Z9(n) {
    return n.filter(e => e != 65039)
}
function dQ(n) {
    for (let e of n.split(".")) {
        let t = hQ(e);
        try {
            for (let r = t.lastIndexOf(zU) - 1; r >= 0; r--)
                if (t[r] !== zU)
                    throw new Error("underscore only allowed at start");
            if (t.length >= 4 && t.every(r => r < 128) && t[2] === HU && t[3] === HU)
                throw new Error("invalid label extension")
        } catch (r) {
            throw new Error(`Invalid label "${e}": ${r.message}`)
        }
    }
    return n
}
function J9(n) {
    return dQ(q9(n, Z9))
}
function q9(n, e) {
    let t = hQ(n).reverse()
      , r = [];
    for (; t.length; ) {
        let i = tK(t);
        if (i) {
            r.push(...e(i));
            continue
        }
        let s = t.pop();
        if (K9.has(s)) {
            r.push(s);
            continue
        }
        if (X9.has(s))
            continue;
        let o = Y9[s];
        if (o) {
            r.push(...o);
            continue
        }
        throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`)
    }
    return dQ(eK(String.fromCodePoint(...r)))
}
function eK(n) {
    return n.normalize("NFC")
}
function tK(n, e) {
    var t;
    let r = $9, i, s, o = [], a = n.length;
    for (e && (e.length = 0); a; ) {
        let l = n[--a];
        if (r = (t = r.branches.find(c => c.set.has(l))) === null || t === void 0 ? void 0 : t.node,
        !r)
            break;
        if (r.save)
            s = l;
        else if (r.check && l === s)
            break;
        o.push(l),
        r.fe0f && (o.push(65039),
        a > 0 && n[a - 1] == 65039 && a--),
        r.valid && (i = o.slice(),
        r.valid == 2 && i.splice(1, 1),
        e && e.push(...n.slice(a).reverse()),
        n.length = a)
    }
    return i
}
const nK = new xe(AQ)
  , pQ = new Uint8Array(32);
pQ.fill(0);
function GU(n) {
    if (n.length === 0)
        throw new Error("invalid ENS name; empty component");
    return n
}
function mQ(n) {
    const e = $a(J9(n))
      , t = [];
    if (n.length === 0)
        return t;
    let r = 0;
    for (let i = 0; i < e.length; i++)
        e[i] === 46 && (t.push(GU(e.slice(r, i))),
        r = i + 1);
    if (r >= e.length)
        throw new Error("invalid ENS name; empty component");
    return t.push(GU(e.slice(r))),
    t
}
function nw(n) {
    typeof n != "string" && nK.throwArgumentError("invalid ENS name; not a string", "name", n);
    let e = pQ;
    const t = mQ(n);
    for (; t.length; )
        e = Er(Ss([e, Er(t.pop())]));
    return lt(e)
}
function rK(n) {
    return lt(Ss(mQ(n).map(e => {
        if (e.length > 63)
            throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        const t = new Uint8Array(e.length + 1);
        return t.set(e, 1),
        t[0] = t.length - 1,
        t
    }
    ))) + "00"
}
const iK = "rlp/5.7.0"
  , Ca = new xe(iK);
function VU(n) {
    const e = [];
    for (; n; )
        e.unshift(n & 255),
        n >>= 8;
    return e
}
function jU(n, e, t) {
    let r = 0;
    for (let i = 0; i < t; i++)
        r = r * 256 + n[e + i];
    return r
}
function gQ(n) {
    if (Array.isArray(n)) {
        let r = [];
        if (n.forEach(function(s) {
            r = r.concat(gQ(s))
        }),
        r.length <= 55)
            return r.unshift(192 + r.length),
            r;
        const i = VU(r.length);
        return i.unshift(247 + i.length),
        i.concat(r)
    }
    cI(n) || Ca.throwArgumentError("RLP object must be BytesLike", "object", n);
    const e = Array.prototype.slice.call(pt(n));
    if (e.length === 1 && e[0] <= 127)
        return e;
    if (e.length <= 55)
        return e.unshift(128 + e.length),
        e;
    const t = VU(e.length);
    return t.unshift(183 + t.length),
    t.concat(e)
}
function Nx(n) {
    return lt(gQ(n))
}
function WU(n, e, t, r) {
    const i = [];
    for (; t < e + 1 + r; ) {
        const s = vQ(n, t);
        i.push(s.result),
        t += s.consumed,
        t > e + 1 + r && Ca.throwError("child data too short", xe.errors.BUFFER_OVERRUN, {})
    }
    return {
        consumed: 1 + r,
        result: i
    }
}
function vQ(n, e) {
    if (n.length === 0 && Ca.throwError("data too short", xe.errors.BUFFER_OVERRUN, {}),
    n[e] >= 248) {
        const t = n[e] - 247;
        e + 1 + t > n.length && Ca.throwError("data short segment too short", xe.errors.BUFFER_OVERRUN, {});
        const r = jU(n, e + 1, t);
        return e + 1 + t + r > n.length && Ca.throwError("data long segment too short", xe.errors.BUFFER_OVERRUN, {}),
        WU(n, e, e + 1 + t, t + r)
    } else if (n[e] >= 192) {
        const t = n[e] - 192;
        return e + 1 + t > n.length && Ca.throwError("data array too short", xe.errors.BUFFER_OVERRUN, {}),
        WU(n, e, e + 1, t)
    } else if (n[e] >= 184) {
        const t = n[e] - 183;
        e + 1 + t > n.length && Ca.throwError("data array too short", xe.errors.BUFFER_OVERRUN, {});
        const r = jU(n, e + 1, t);
        e + 1 + t + r > n.length && Ca.throwError("data array too short", xe.errors.BUFFER_OVERRUN, {});
        const i = lt(n.slice(e + 1 + t, e + 1 + t + r));
        return {
            consumed: 1 + t + r,
            result: i
        }
    } else if (n[e] >= 128) {
        const t = n[e] - 128;
        e + 1 + t > n.length && Ca.throwError("data too short", xe.errors.BUFFER_OVERRUN, {});
        const r = lt(n.slice(e + 1, e + 1 + t));
        return {
            consumed: 1 + t,
            result: r
        }
    }
    return {
        consumed: 1,
        result: lt(n[e])
    }
}
function AI(n) {
    const e = pt(n)
      , t = vQ(e, 0);
    return t.consumed !== e.length && Ca.throwArgumentError("invalid rlp data", "data", n),
    t.result
}
const sK = "address/5.7.0"
  , gh = new xe(sK);
function KU(n) {
    It(n, 20) || gh.throwArgumentError("invalid address", "address", n),
    n = n.toLowerCase();
    const e = n.substring(2).split("")
      , t = new Uint8Array(40);
    for (let i = 0; i < 40; i++)
        t[i] = e[i].charCodeAt(0);
    const r = pt(Er(t));
    for (let i = 0; i < 40; i += 2)
        r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()),
        (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const oK = 9007199254740991;
function aK(n) {
    return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10
}
const uI = {};
for (let n = 0; n < 10; n++)
    uI[String(n)] = String(n);
for (let n = 0; n < 26; n++)
    uI[String.fromCharCode(65 + n)] = String(10 + n);
const XU = Math.floor(aK(oK));
function lK(n) {
    n = n.toUpperCase(),
    n = n.substring(4) + n.substring(0, 2) + "00";
    let e = n.split("").map(r => uI[r]).join("");
    for (; e.length >= XU; ) {
        let r = e.substring(0, XU);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
    }
    let t = String(98 - parseInt(e, 10) % 97);
    for (; t.length < 2; )
        t = "0" + t;
    return t
}
function ai(n) {
    let e = null;
    if (typeof n != "string" && gh.throwArgumentError("invalid address", "address", n),
    n.match(/^(0x)?[0-9a-fA-F]{40}$/))
        n.substring(0, 2) !== "0x" && (n = "0x" + n),
        e = KU(n),
        n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && gh.throwArgumentError("bad address checksum", "address", n);
    else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (n.substring(2, 4) !== lK(n) && gh.throwArgumentError("bad icap checksum", "address", n),
        e = c9(n.substring(4)); e.length < 40; )
            e = "0" + e;
        e = KU("0x" + e)
    } else
        gh.throwArgumentError("invalid address", "address", n);
    return e
}
function yQ(n) {
    let e = null;
    try {
        e = ai(n.from)
    } catch {
        gh.throwArgumentError("missing from address", "transaction", n)
    }
    const t = hd(pt(je.from(n.nonce).toHexString()));
    return ai(mi(Er(Nx([e, t])), 12))
}
var cK = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Gn = new xe(AQ)
  , wQ = new Uint8Array(32);
wQ.fill(0);
const AK = je.from(-1)
  , _Q = je.from(0)
  , xQ = je.from(1)
  , uK = je.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function fK(n) {
    const e = pt(n)
      , t = e.length % 32;
    return t ? $i([e, wQ.slice(t)]) : lt(e)
}
const hK = ir(xQ.toHexString(), 32)
  , dK = ir(_Q.toHexString(), 32)
  , YU = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
}
  , yb = ["name", "version", "chainId", "verifyingContract", "salt"];
function $U(n) {
    return function(e) {
        return typeof e != "string" && Gn.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e),
        e
    }
}
const pK = {
    name: $U("name"),
    version: $U("version"),
    chainId: function(n) {
        try {
            return je.from(n).toString()
        } catch {}
        return Gn.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", n)
    },
    verifyingContract: function(n) {
        try {
            return ai(n).toLowerCase()
        } catch {}
        return Gn.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", n)
    },
    salt: function(n) {
        try {
            const e = pt(n);
            if (e.length !== 32)
                throw new Error("bad length");
            return lt(e)
        } catch {}
        return Gn.throwArgumentError('invalid domain value "salt"', "domain.salt", n)
    }
};
function wb(n) {
    {
        const e = n.match(/^(u?)int(\d*)$/);
        if (e) {
            const t = e[1] === ""
              , r = parseInt(e[2] || "256");
            (r % 8 !== 0 || r > 256 || e[2] && e[2] !== String(r)) && Gn.throwArgumentError("invalid numeric width", "type", n);
            const i = uK.mask(t ? r - 1 : r)
              , s = t ? i.add(xQ).mul(AK) : _Q;
            return function(o) {
                const a = je.from(o);
                return (a.lt(s) || a.gt(i)) && Gn.throwArgumentError(`value out-of-bounds for ${n}`, "value", o),
                ir(a.toTwos(256).toHexString(), 32)
            }
        }
    }
    {
        const e = n.match(/^bytes(\d+)$/);
        if (e) {
            const t = parseInt(e[1]);
            return (t === 0 || t > 32 || e[1] !== String(t)) && Gn.throwArgumentError("invalid bytes width", "type", n),
            function(r) {
                return pt(r).length !== t && Gn.throwArgumentError(`invalid length for ${n}`, "value", r),
                fK(r)
            }
        }
    }
    switch (n) {
    case "address":
        return function(e) {
            return ir(ai(e), 32)
        }
        ;
    case "bool":
        return function(e) {
            return e ? hK : dK
        }
        ;
    case "bytes":
        return function(e) {
            return Er(e)
        }
        ;
    case "string":
        return function(e) {
            return mh(e)
        }
    }
    return null
}
function ZU(n, e) {
    return `${n}(${e.map( ({name: t, type: r}) => r + " " + t).join(",")})`
}
class ws {
    constructor(e) {
        Ue(this, "types", Object.freeze(Ps(e))),
        Ue(this, "_encoderCache", {}),
        Ue(this, "_types", {});
        const t = {}
          , r = {}
          , i = {};
        Object.keys(e).forEach(a => {
            t[a] = {},
            r[a] = [],
            i[a] = {}
        }
        );
        for (const a in e) {
            const l = {};
            e[a].forEach(c => {
                l[c.name] && Gn.throwArgumentError(`duplicate variable name ${JSON.stringify(c.name)} in ${JSON.stringify(a)}`, "types", e),
                l[c.name] = !0;
                const A = c.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                A === a && Gn.throwArgumentError(`circular type reference to ${JSON.stringify(A)}`, "types", e),
                !wb(A) && (r[A] || Gn.throwArgumentError(`unknown type ${JSON.stringify(A)}`, "types", e),
                r[A].push(a),
                t[a][A] = !0)
            }
            )
        }
        const s = Object.keys(r).filter(a => r[a].length === 0);
        s.length === 0 ? Gn.throwArgumentError("missing primary type", "types", e) : s.length > 1 && Gn.throwArgumentError(`ambiguous primary types or unused types: ${s.map(a => JSON.stringify(a)).join(", ")}`, "types", e),
        Ue(this, "primaryType", s[0]);
        function o(a, l) {
            l[a] && Gn.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", e),
            l[a] = !0,
            Object.keys(t[a]).forEach(c => {
                r[c] && (o(c, l),
                Object.keys(l).forEach(A => {
                    i[A][c] = !0
                }
                ))
            }
            ),
            delete l[a]
        }
        o(this.primaryType, {});
        for (const a in i) {
            const l = Object.keys(i[a]);
            l.sort(),
            this._types[a] = ZU(a, e[a]) + l.map(c => ZU(c, e[c])).join("")
        }
    }
    getEncoder(e) {
        let t = this._encoderCache[e];
        return t || (t = this._encoderCache[e] = this._getEncoder(e)),
        t
    }
    _getEncoder(e) {
        {
            const i = wb(e);
            if (i)
                return i
        }
        const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (t) {
            const i = t[1]
              , s = this.getEncoder(i)
              , o = parseInt(t[3]);
            return a => {
                o >= 0 && a.length !== o && Gn.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", a);
                let l = a.map(s);
                return this._types[i] && (l = l.map(Er)),
                Er($i(l))
            }
        }
        const r = this.types[e];
        if (r) {
            const i = mh(this._types[e]);
            return s => {
                const o = r.map( ({name: a, type: l}) => {
                    const c = this.getEncoder(l)(s[a]);
                    return this._types[l] ? Er(c) : c
                }
                );
                return o.unshift(i),
                $i(o)
            }
        }
        return Gn.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const t = this._types[e];
        return t || Gn.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e),
        t
    }
    encodeData(e, t) {
        return this.getEncoder(e)(t)
    }
    hashStruct(e, t) {
        return Er(this.encodeData(e, t))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, t, r) {
        if (wb(e))
            return r(e, t);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i) {
            const o = i[1]
              , a = parseInt(i[3]);
            return a >= 0 && t.length !== a && Gn.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t),
            t.map(l => this._visit(o, l, r))
        }
        const s = this.types[e];
        return s ? s.reduce( (o, {name: a, type: l}) => (o[a] = this._visit(l, t[a], r),
        o), {}) : Gn.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, t) {
        return this._visit(this.primaryType, e, t)
    }
    static from(e) {
        return new ws(e)
    }
    static getPrimaryType(e) {
        return ws.from(e).primaryType
    }
    static hashStruct(e, t, r) {
        return ws.from(t).hashStruct(e, r)
    }
    static hashDomain(e) {
        const t = [];
        for (const r in e) {
            const i = YU[r];
            i || Gn.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e),
            t.push({
                name: r,
                type: i
            })
        }
        return t.sort( (r, i) => yb.indexOf(r.name) - yb.indexOf(i.name)),
        ws.hashStruct("EIP712Domain", {
            EIP712Domain: t
        }, e)
    }
    static encode(e, t, r) {
        return $i(["0x1901", ws.hashDomain(e), ws.from(t).hash(r)])
    }
    static hash(e, t, r) {
        return Er(ws.encode(e, t, r))
    }
    static resolveNames(e, t, r, i) {
        return cK(this, void 0, void 0, function*() {
            e = Qn(e);
            const s = {};
            e.verifyingContract && !It(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
            const o = ws.from(t);
            o.visit(r, (a, l) => (a === "address" && !It(l, 20) && (s[l] = "0x"),
            l));
            for (const a in s)
                s[a] = yield i(a);
            return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]),
            r = o.visit(r, (a, l) => a === "address" && s[l] ? s[l] : l),
            {
                domain: e,
                value: r
            }
        })
    }
    static getPayload(e, t, r) {
        ws.hashDomain(e);
        const i = {}
          , s = [];
        yb.forEach(l => {
            const c = e[l];
            c != null && (i[l] = pK[l](c),
            s.push({
                name: l,
                type: YU[l]
            }))
        }
        );
        const o = ws.from(t)
          , a = Qn(t);
        return a.EIP712Domain ? Gn.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : a.EIP712Domain = s,
        o.encode(r),
        {
            types: a,
            domain: i,
            primaryType: o.primaryType,
            message: o.visit(r, (l, c) => {
                if (l.match(/^bytes(\d*)/))
                    return lt(pt(c));
                if (l.match(/^u?int/))
                    return je.from(c).toString();
                switch (l) {
                case "address":
                    return c.toLowerCase();
                case "bool":
                    return !!c;
                case "string":
                    return typeof c != "string" && Gn.throwArgumentError("invalid string", "value", c),
                    c
                }
                return Gn.throwArgumentError("unsupported type", "type", l)
            }
            )
        }
    }
}
var bQ = {}
  , kt = {}
  , A0 = EQ;
function EQ(n, e) {
    if (!n)
        throw new Error(e || "Assertion failed")
}
EQ.equal = function(e, t, r) {
    if (e != t)
        throw new Error(r || "Assertion failed: " + e + " != " + t)
}
;
var UM = {
    exports: {}
};
typeof Object.create == "function" ? UM.exports = function(e, t) {
    t && (e.super_ = t,
    e.prototype = Object.create(t.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
}
: UM.exports = function(e, t) {
    if (t) {
        e.super_ = t;
        var r = function() {};
        r.prototype = t.prototype,
        e.prototype = new r,
        e.prototype.constructor = e
    }
}
;
var mK = UM.exports
  , gK = A0
  , vK = mK;
kt.inherits = vK;
function yK(n, e) {
    return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320
}
function wK(n, e) {
    if (Array.isArray(n))
        return n.slice();
    if (!n)
        return [];
    var t = [];
    if (typeof n == "string")
        if (e) {
            if (e === "hex")
                for (n = n.replace(/[^a-z0-9]+/ig, ""),
                n.length % 2 !== 0 && (n = "0" + n),
                i = 0; i < n.length; i += 2)
                    t.push(parseInt(n[i] + n[i + 1], 16))
        } else
            for (var r = 0, i = 0; i < n.length; i++) {
                var s = n.charCodeAt(i);
                s < 128 ? t[r++] = s : s < 2048 ? (t[r++] = s >> 6 | 192,
                t[r++] = s & 63 | 128) : yK(n, i) ? (s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++i) & 1023),
                t[r++] = s >> 18 | 240,
                t[r++] = s >> 12 & 63 | 128,
                t[r++] = s >> 6 & 63 | 128,
                t[r++] = s & 63 | 128) : (t[r++] = s >> 12 | 224,
                t[r++] = s >> 6 & 63 | 128,
                t[r++] = s & 63 | 128)
            }
    else
        for (i = 0; i < n.length; i++)
            t[i] = n[i] | 0;
    return t
}
kt.toArray = wK;
function _K(n) {
    for (var e = "", t = 0; t < n.length; t++)
        e += MQ(n[t].toString(16));
    return e
}
kt.toHex = _K;
function BQ(n) {
    var e = n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (n & 255) << 24;
    return e >>> 0
}
kt.htonl = BQ;
function xK(n, e) {
    for (var t = "", r = 0; r < n.length; r++) {
        var i = n[r];
        e === "little" && (i = BQ(i)),
        t += SQ(i.toString(16))
    }
    return t
}
kt.toHex32 = xK;
function MQ(n) {
    return n.length === 1 ? "0" + n : n
}
kt.zero2 = MQ;
function SQ(n) {
    return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n
}
kt.zero8 = SQ;
function bK(n, e, t, r) {
    var i = t - e;
    gK(i % 4 === 0);
    for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++,
    a += 4) {
        var l;
        r === "big" ? l = n[a] << 24 | n[a + 1] << 16 | n[a + 2] << 8 | n[a + 3] : l = n[a + 3] << 24 | n[a + 2] << 16 | n[a + 1] << 8 | n[a],
        s[o] = l >>> 0
    }
    return s
}
kt.join32 = bK;
function EK(n, e) {
    for (var t = new Array(n.length * 4), r = 0, i = 0; r < n.length; r++,
    i += 4) {
        var s = n[r];
        e === "big" ? (t[i] = s >>> 24,
        t[i + 1] = s >>> 16 & 255,
        t[i + 2] = s >>> 8 & 255,
        t[i + 3] = s & 255) : (t[i + 3] = s >>> 24,
        t[i + 2] = s >>> 16 & 255,
        t[i + 1] = s >>> 8 & 255,
        t[i] = s & 255)
    }
    return t
}
kt.split32 = EK;
function BK(n, e) {
    return n >>> e | n << 32 - e
}
kt.rotr32 = BK;
function MK(n, e) {
    return n << e | n >>> 32 - e
}
kt.rotl32 = MK;
function SK(n, e) {
    return n + e >>> 0
}
kt.sum32 = SK;
function CK(n, e, t) {
    return n + e + t >>> 0
}
kt.sum32_3 = CK;
function TK(n, e, t, r) {
    return n + e + t + r >>> 0
}
kt.sum32_4 = TK;
function IK(n, e, t, r, i) {
    return n + e + t + r + i >>> 0
}
kt.sum32_5 = IK;
function RK(n, e, t, r) {
    var i = n[e]
      , s = n[e + 1]
      , o = r + s >>> 0
      , a = (o < r ? 1 : 0) + t + i;
    n[e] = a >>> 0,
    n[e + 1] = o
}
kt.sum64 = RK;
function UK(n, e, t, r) {
    var i = e + r >>> 0
      , s = (i < e ? 1 : 0) + n + t;
    return s >>> 0
}
kt.sum64_hi = UK;
function FK(n, e, t, r) {
    var i = e + r;
    return i >>> 0
}
kt.sum64_lo = FK;
function PK(n, e, t, r, i, s, o, a) {
    var l = 0
      , c = e;
    c = c + r >>> 0,
    l += c < e ? 1 : 0,
    c = c + s >>> 0,
    l += c < s ? 1 : 0,
    c = c + a >>> 0,
    l += c < a ? 1 : 0;
    var A = n + t + i + o + l;
    return A >>> 0
}
kt.sum64_4_hi = PK;
function LK(n, e, t, r, i, s, o, a) {
    var l = e + r + s + a;
    return l >>> 0
}
kt.sum64_4_lo = LK;
function DK(n, e, t, r, i, s, o, a, l, c) {
    var A = 0
      , u = e;
    u = u + r >>> 0,
    A += u < e ? 1 : 0,
    u = u + s >>> 0,
    A += u < s ? 1 : 0,
    u = u + a >>> 0,
    A += u < a ? 1 : 0,
    u = u + c >>> 0,
    A += u < c ? 1 : 0;
    var f = n + t + i + o + l + A;
    return f >>> 0
}
kt.sum64_5_hi = DK;
function NK(n, e, t, r, i, s, o, a, l, c) {
    var A = e + r + s + a + c;
    return A >>> 0
}
kt.sum64_5_lo = NK;
function OK(n, e, t) {
    var r = e << 32 - t | n >>> t;
    return r >>> 0
}
kt.rotr64_hi = OK;
function kK(n, e, t) {
    var r = n << 32 - t | e >>> t;
    return r >>> 0
}
kt.rotr64_lo = kK;
function QK(n, e, t) {
    return n >>> t
}
kt.shr64_hi = QK;
function HK(n, e, t) {
    var r = n << 32 - t | e >>> t;
    return r >>> 0
}
kt.shr64_lo = HK;
var Hd = {}
  , JU = kt
  , zK = A0;
function Ox() {
    this.pending = null,
    this.pendingTotal = 0,
    this.blockSize = this.constructor.blockSize,
    this.outSize = this.constructor.outSize,
    this.hmacStrength = this.constructor.hmacStrength,
    this.padLength = this.constructor.padLength / 8,
    this.endian = "big",
    this._delta8 = this.blockSize / 8,
    this._delta32 = this.blockSize / 32
}
Hd.BlockHash = Ox;
Ox.prototype.update = function(e, t) {
    if (e = JU.toArray(e, t),
    this.pending ? this.pending = this.pending.concat(e) : this.pending = e,
    this.pendingTotal += e.length,
    this.pending.length >= this._delta8) {
        e = this.pending;
        var r = e.length % this._delta8;
        this.pending = e.slice(e.length - r, e.length),
        this.pending.length === 0 && (this.pending = null),
        e = JU.join32(e, 0, e.length - r, this.endian);
        for (var i = 0; i < e.length; i += this._delta32)
            this._update(e, i, i + this._delta32)
    }
    return this
}
;
Ox.prototype.digest = function(e) {
    return this.update(this._pad()),
    zK(this.pending === null),
    this._digest(e)
}
;
Ox.prototype._pad = function() {
    var e = this.pendingTotal
      , t = this._delta8
      , r = t - (e + this.padLength) % t
      , i = new Array(r + this.padLength);
    i[0] = 128;
    for (var s = 1; s < r; s++)
        i[s] = 0;
    if (e <<= 3,
    this.endian === "big") {
        for (var o = 8; o < this.padLength; o++)
            i[s++] = 0;
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = e >>> 24 & 255,
        i[s++] = e >>> 16 & 255,
        i[s++] = e >>> 8 & 255,
        i[s++] = e & 255
    } else
        for (i[s++] = e & 255,
        i[s++] = e >>> 8 & 255,
        i[s++] = e >>> 16 & 255,
        i[s++] = e >>> 24 & 255,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        i[s++] = 0,
        o = 8; o < this.padLength; o++)
            i[s++] = 0;
    return i
}
;
var zd = {}
  , sl = {}
  , GK = kt
  , Ga = GK.rotr32;
function VK(n, e, t, r) {
    if (n === 0)
        return CQ(e, t, r);
    if (n === 1 || n === 3)
        return IQ(e, t, r);
    if (n === 2)
        return TQ(e, t, r)
}
sl.ft_1 = VK;
function CQ(n, e, t) {
    return n & e ^ ~n & t
}
sl.ch32 = CQ;
function TQ(n, e, t) {
    return n & e ^ n & t ^ e & t
}
sl.maj32 = TQ;
function IQ(n, e, t) {
    return n ^ e ^ t
}
sl.p32 = IQ;
function jK(n) {
    return Ga(n, 2) ^ Ga(n, 13) ^ Ga(n, 22)
}
sl.s0_256 = jK;
function WK(n) {
    return Ga(n, 6) ^ Ga(n, 11) ^ Ga(n, 25)
}
sl.s1_256 = WK;
function KK(n) {
    return Ga(n, 7) ^ Ga(n, 18) ^ n >>> 3
}
sl.g0_256 = KK;
function XK(n) {
    return Ga(n, 17) ^ Ga(n, 19) ^ n >>> 10
}
sl.g1_256 = XK;
var dd = kt
  , YK = Hd
  , $K = sl
  , _b = dd.rotl32
  , dp = dd.sum32
  , ZK = dd.sum32_5
  , JK = $K.ft_1
  , RQ = YK.BlockHash
  , qK = [1518500249, 1859775393, 2400959708, 3395469782];
function Za() {
    if (!(this instanceof Za))
        return new Za;
    RQ.call(this),
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
    this.W = new Array(80)
}
dd.inherits(Za, RQ);
var e7 = Za;
Za.blockSize = 512;
Za.outSize = 160;
Za.hmacStrength = 80;
Za.padLength = 64;
Za.prototype._update = function(e, t) {
    for (var r = this.W, i = 0; i < 16; i++)
        r[i] = e[t + i];
    for (; i < r.length; i++)
        r[i] = _b(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
    var s = this.h[0]
      , o = this.h[1]
      , a = this.h[2]
      , l = this.h[3]
      , c = this.h[4];
    for (i = 0; i < r.length; i++) {
        var A = ~~(i / 20)
          , u = ZK(_b(s, 5), JK(A, o, a, l), c, r[i], qK[A]);
        c = l,
        l = a,
        a = _b(o, 30),
        o = s,
        s = u
    }
    this.h[0] = dp(this.h[0], s),
    this.h[1] = dp(this.h[1], o),
    this.h[2] = dp(this.h[2], a),
    this.h[3] = dp(this.h[3], l),
    this.h[4] = dp(this.h[4], c)
}
;
Za.prototype._digest = function(e) {
    return e === "hex" ? dd.toHex32(this.h, "big") : dd.split32(this.h, "big")
}
;
var pd = kt
  , t7 = Hd
  , Gd = sl
  , n7 = A0
  , Uo = pd.sum32
  , r7 = pd.sum32_4
  , i7 = pd.sum32_5
  , s7 = Gd.ch32
  , o7 = Gd.maj32
  , a7 = Gd.s0_256
  , l7 = Gd.s1_256
  , c7 = Gd.g0_256
  , A7 = Gd.g1_256
  , UQ = t7.BlockHash
  , u7 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function Ja() {
    if (!(this instanceof Ja))
        return new Ja;
    UQ.call(this),
    this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
    this.k = u7,
    this.W = new Array(64)
}
pd.inherits(Ja, UQ);
var FQ = Ja;
Ja.blockSize = 512;
Ja.outSize = 256;
Ja.hmacStrength = 192;
Ja.padLength = 64;
Ja.prototype._update = function(e, t) {
    for (var r = this.W, i = 0; i < 16; i++)
        r[i] = e[t + i];
    for (; i < r.length; i++)
        r[i] = r7(A7(r[i - 2]), r[i - 7], c7(r[i - 15]), r[i - 16]);
    var s = this.h[0]
      , o = this.h[1]
      , a = this.h[2]
      , l = this.h[3]
      , c = this.h[4]
      , A = this.h[5]
      , u = this.h[6]
      , f = this.h[7];
    for (n7(this.k.length === r.length),
    i = 0; i < r.length; i++) {
        var h = i7(f, l7(c), s7(c, A, u), this.k[i], r[i])
          , d = Uo(a7(s), o7(s, o, a));
        f = u,
        u = A,
        A = c,
        c = Uo(l, h),
        l = a,
        a = o,
        o = s,
        s = Uo(h, d)
    }
    this.h[0] = Uo(this.h[0], s),
    this.h[1] = Uo(this.h[1], o),
    this.h[2] = Uo(this.h[2], a),
    this.h[3] = Uo(this.h[3], l),
    this.h[4] = Uo(this.h[4], c),
    this.h[5] = Uo(this.h[5], A),
    this.h[6] = Uo(this.h[6], u),
    this.h[7] = Uo(this.h[7], f)
}
;
Ja.prototype._digest = function(e) {
    return e === "hex" ? pd.toHex32(this.h, "big") : pd.split32(this.h, "big")
}
;
var FM = kt
  , PQ = FQ;
function Xl() {
    if (!(this instanceof Xl))
        return new Xl;
    PQ.call(this),
    this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}
FM.inherits(Xl, PQ);
var f7 = Xl;
Xl.blockSize = 512;
Xl.outSize = 224;
Xl.hmacStrength = 192;
Xl.padLength = 64;
Xl.prototype._digest = function(e) {
    return e === "hex" ? FM.toHex32(this.h.slice(0, 7), "big") : FM.split32(this.h.slice(0, 7), "big")
}
;
var cs = kt
  , h7 = Hd
  , d7 = A0
  , Va = cs.rotr64_hi
  , ja = cs.rotr64_lo
  , LQ = cs.shr64_hi
  , DQ = cs.shr64_lo
  , mc = cs.sum64
  , xb = cs.sum64_hi
  , bb = cs.sum64_lo
  , p7 = cs.sum64_4_hi
  , m7 = cs.sum64_4_lo
  , g7 = cs.sum64_5_hi
  , v7 = cs.sum64_5_lo
  , NQ = h7.BlockHash
  , y7 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function aa() {
    if (!(this instanceof aa))
        return new aa;
    NQ.call(this),
    this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209],
    this.k = y7,
    this.W = new Array(160)
}
cs.inherits(aa, NQ);
var OQ = aa;
aa.blockSize = 1024;
aa.outSize = 512;
aa.hmacStrength = 192;
aa.padLength = 128;
aa.prototype._prepareBlock = function(e, t) {
    for (var r = this.W, i = 0; i < 32; i++)
        r[i] = e[t + i];
    for (; i < r.length; i += 2) {
        var s = I7(r[i - 4], r[i - 3])
          , o = R7(r[i - 4], r[i - 3])
          , a = r[i - 14]
          , l = r[i - 13]
          , c = C7(r[i - 30], r[i - 29])
          , A = T7(r[i - 30], r[i - 29])
          , u = r[i - 32]
          , f = r[i - 31];
        r[i] = p7(s, o, a, l, c, A, u, f),
        r[i + 1] = m7(s, o, a, l, c, A, u, f)
    }
}
;
aa.prototype._update = function(e, t) {
    this._prepareBlock(e, t);
    var r = this.W
      , i = this.h[0]
      , s = this.h[1]
      , o = this.h[2]
      , a = this.h[3]
      , l = this.h[4]
      , c = this.h[5]
      , A = this.h[6]
      , u = this.h[7]
      , f = this.h[8]
      , h = this.h[9]
      , d = this.h[10]
      , m = this.h[11]
      , g = this.h[12]
      , p = this.h[13]
      , v = this.h[14]
      , w = this.h[15];
    d7(this.k.length === r.length);
    for (var _ = 0; _ < r.length; _ += 2) {
        var x = v
          , b = w
          , B = M7(f, h)
          , S = S7(f, h)
          , I = w7(f, h, d, m, g)
          , M = _7(f, h, d, m, g, p)
          , L = this.k[_]
          , D = this.k[_ + 1]
          , T = r[_]
          , y = r[_ + 1]
          , E = g7(x, b, B, S, I, M, L, D, T, y)
          , R = v7(x, b, B, S, I, M, L, D, T, y);
        x = E7(i, s),
        b = B7(i, s),
        B = x7(i, s, o, a, l),
        S = b7(i, s, o, a, l, c);
        var F = xb(x, b, B, S)
          , O = bb(x, b, B, S);
        v = g,
        w = p,
        g = d,
        p = m,
        d = f,
        m = h,
        f = xb(A, u, E, R),
        h = bb(u, u, E, R),
        A = l,
        u = c,
        l = o,
        c = a,
        o = i,
        a = s,
        i = xb(E, R, F, O),
        s = bb(E, R, F, O)
    }
    mc(this.h, 0, i, s),
    mc(this.h, 2, o, a),
    mc(this.h, 4, l, c),
    mc(this.h, 6, A, u),
    mc(this.h, 8, f, h),
    mc(this.h, 10, d, m),
    mc(this.h, 12, g, p),
    mc(this.h, 14, v, w)
}
;
aa.prototype._digest = function(e) {
    return e === "hex" ? cs.toHex32(this.h, "big") : cs.split32(this.h, "big")
}
;
function w7(n, e, t, r, i) {
    var s = n & t ^ ~n & i;
    return s < 0 && (s += 4294967296),
    s
}
function _7(n, e, t, r, i, s) {
    var o = e & r ^ ~e & s;
    return o < 0 && (o += 4294967296),
    o
}
function x7(n, e, t, r, i) {
    var s = n & t ^ n & i ^ t & i;
    return s < 0 && (s += 4294967296),
    s
}
function b7(n, e, t, r, i, s) {
    var o = e & r ^ e & s ^ r & s;
    return o < 0 && (o += 4294967296),
    o
}
function E7(n, e) {
    var t = Va(n, e, 28)
      , r = Va(e, n, 2)
      , i = Va(e, n, 7)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function B7(n, e) {
    var t = ja(n, e, 28)
      , r = ja(e, n, 2)
      , i = ja(e, n, 7)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function M7(n, e) {
    var t = Va(n, e, 14)
      , r = Va(n, e, 18)
      , i = Va(e, n, 9)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function S7(n, e) {
    var t = ja(n, e, 14)
      , r = ja(n, e, 18)
      , i = ja(e, n, 9)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function C7(n, e) {
    var t = Va(n, e, 1)
      , r = Va(n, e, 8)
      , i = LQ(n, e, 7)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function T7(n, e) {
    var t = ja(n, e, 1)
      , r = ja(n, e, 8)
      , i = DQ(n, e, 7)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function I7(n, e) {
    var t = Va(n, e, 19)
      , r = Va(e, n, 29)
      , i = LQ(n, e, 6)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
function R7(n, e) {
    var t = ja(n, e, 19)
      , r = ja(e, n, 29)
      , i = DQ(n, e, 6)
      , s = t ^ r ^ i;
    return s < 0 && (s += 4294967296),
    s
}
var PM = kt
  , kQ = OQ;
function Yl() {
    if (!(this instanceof Yl))
        return new Yl;
    kQ.call(this),
    this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}
PM.inherits(Yl, kQ);
var U7 = Yl;
Yl.blockSize = 1024;
Yl.outSize = 384;
Yl.hmacStrength = 192;
Yl.padLength = 128;
Yl.prototype._digest = function(e) {
    return e === "hex" ? PM.toHex32(this.h.slice(0, 12), "big") : PM.split32(this.h.slice(0, 12), "big")
}
;
zd.sha1 = e7;
zd.sha224 = f7;
zd.sha256 = FQ;
zd.sha384 = U7;
zd.sha512 = OQ;
var QQ = {}
  , Cu = kt
  , F7 = Hd
  , H0 = Cu.rotl32
  , qU = Cu.sum32
  , pp = Cu.sum32_3
  , eF = Cu.sum32_4
  , HQ = F7.BlockHash;
function qa() {
    if (!(this instanceof qa))
        return new qa;
    HQ.call(this),
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
    this.endian = "little"
}
Cu.inherits(qa, HQ);
QQ.ripemd160 = qa;
qa.blockSize = 512;
qa.outSize = 160;
qa.hmacStrength = 192;
qa.padLength = 64;
qa.prototype._update = function(e, t) {
    for (var r = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], l = r, c = i, A = s, u = o, f = a, h = 0; h < 80; h++) {
        var d = qU(H0(eF(r, tF(h, i, s, o), e[D7[h] + t], P7(h)), O7[h]), a);
        r = a,
        a = o,
        o = H0(s, 10),
        s = i,
        i = d,
        d = qU(H0(eF(l, tF(79 - h, c, A, u), e[N7[h] + t], L7(h)), k7[h]), f),
        l = f,
        f = u,
        u = H0(A, 10),
        A = c,
        c = d
    }
    d = pp(this.h[1], s, u),
    this.h[1] = pp(this.h[2], o, f),
    this.h[2] = pp(this.h[3], a, l),
    this.h[3] = pp(this.h[4], r, c),
    this.h[4] = pp(this.h[0], i, A),
    this.h[0] = d
}
;
qa.prototype._digest = function(e) {
    return e === "hex" ? Cu.toHex32(this.h, "little") : Cu.split32(this.h, "little")
}
;
function tF(n, e, t, r) {
    return n <= 15 ? e ^ t ^ r : n <= 31 ? e & t | ~e & r : n <= 47 ? (e | ~t) ^ r : n <= 63 ? e & r | t & ~r : e ^ (t | ~r)
}
function P7(n) {
    return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838
}
function L7(n) {
    return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0
}
var D7 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]
  , N7 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]
  , O7 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
  , k7 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
  , Q7 = kt
  , H7 = A0;
function md(n, e, t) {
    if (!(this instanceof md))
        return new md(n,e,t);
    this.Hash = n,
    this.blockSize = n.blockSize / 8,
    this.outSize = n.outSize / 8,
    this.inner = null,
    this.outer = null,
    this._init(Q7.toArray(e, t))
}
var z7 = md;
md.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()),
    H7(e.length <= this.blockSize);
    for (var t = e.length; t < this.blockSize; t++)
        e.push(0);
    for (t = 0; t < e.length; t++)
        e[t] ^= 54;
    for (this.inner = new this.Hash().update(e),
    t = 0; t < e.length; t++)
        e[t] ^= 106;
    this.outer = new this.Hash().update(e)
}
;
md.prototype.update = function(e, t) {
    return this.inner.update(e, t),
    this
}
;
md.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()),
    this.outer.digest(e)
}
;
(function(n) {
    var e = n;
    e.utils = kt,
    e.common = Hd,
    e.sha = zd,
    e.ripemd = QQ,
    e.hmac = z7,
    e.sha1 = e.sha.sha1,
    e.sha256 = e.sha.sha256,
    e.sha224 = e.sha.sha224,
    e.sha384 = e.sha.sha384,
    e.sha512 = e.sha.sha512,
    e.ripemd160 = e.ripemd.ripemd160
}
)(bQ);
const Ba = oc(bQ);
function nF(n) {
    return "0x" + Ba.sha256().update(pt(n)).digest("hex")
}
const G7 = "web/5.7.1";
var V7 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
function j7(n, e) {
    return V7(this, void 0, void 0, function*() {
        e == null && (e = {});
        const t = {
            method: e.method || "GET",
            headers: e.headers || {},
            body: e.body || void 0
        };
        if (e.skipFetchSetup !== !0 && (t.mode = "cors",
        t.cache = "no-cache",
        t.credentials = "same-origin",
        t.redirect = "follow",
        t.referrer = "client"),
        e.fetchOptions != null) {
            const o = e.fetchOptions;
            o.mode && (t.mode = o.mode),
            o.cache && (t.cache = o.cache),
            o.credentials && (t.credentials = o.credentials),
            o.redirect && (t.redirect = o.redirect),
            o.referrer && (t.referrer = o.referrer)
        }
        const r = yield fetch(n, t)
          , i = yield r.arrayBuffer()
          , s = {};
        return r.headers.forEach ? r.headers.forEach( (o, a) => {
            s[a.toLowerCase()] = o
        }
        ) : r.headers.keys().forEach(o => {
            s[o.toLowerCase()] = r.headers.get(o)
        }
        ),
        {
            headers: s,
            statusCode: r.status,
            statusMessage: r.statusText,
            body: pt(new Uint8Array(i))
        }
    })
}
var W7 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Qo = new xe(G7);
function rF(n) {
    return new Promise(e => {
        setTimeout(e, n)
    }
    )
}
function gc(n, e) {
    if (n == null)
        return null;
    if (typeof n == "string")
        return n;
    if (cI(n)) {
        if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
            try {
                return c0(n)
            } catch {}
        return lt(n)
    }
    return n
}
function K7(n) {
    return $a(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))))
}
function X7(n, e, t) {
    const r = typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
    Qo.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
    const i = typeof n == "object" ? n.throttleCallback : null
      , s = typeof n == "object" && typeof n.throttleSlotInterval == "number" ? n.throttleSlotInterval : 100;
    Qo.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
    const o = typeof n == "object" ? !!n.errorPassThrough : !1
      , a = {};
    let l = null;
    const c = {
        method: "GET"
    };
    let A = !1
      , u = 2 * 60 * 1e3;
    if (typeof n == "string")
        l = n;
    else if (typeof n == "object") {
        if ((n == null || n.url == null) && Qo.throwArgumentError("missing URL", "connection.url", n),
        l = n.url,
        typeof n.timeout == "number" && n.timeout > 0 && (u = n.timeout),
        n.headers)
            for (const p in n.headers)
                a[p.toLowerCase()] = {
                    key: p,
                    value: String(n.headers[p])
                },
                ["if-none-match", "if-modified-since"].indexOf(p.toLowerCase()) >= 0 && (A = !0);
        if (c.allowGzip = !!n.allowGzip,
        n.user != null && n.password != null) {
            l.substring(0, 6) !== "https:" && n.allowInsecureAuthentication !== !0 && Qo.throwError("basic authentication requires a secure https url", xe.errors.INVALID_ARGUMENT, {
                argument: "url",
                url: l,
                user: n.user,
                password: "[REDACTED]"
            });
            const p = n.user + ":" + n.password;
            a.authorization = {
                key: "Authorization",
                value: "Basic " + rQ($a(p))
            }
        }
        n.skipFetchSetup != null && (c.skipFetchSetup = !!n.skipFetchSetup),
        n.fetchOptions != null && (c.fetchOptions = Qn(n.fetchOptions))
    }
    const f = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$","i")
      , h = l ? l.match(f) : null;
    if (h)
        try {
            const p = {
                statusCode: 200,
                statusMessage: "OK",
                headers: {
                    "content-type": h[1] || "text/plain"
                },
                body: h[2] ? nQ(h[3]) : K7(h[3])
            };
            let v = p.body;
            return t && (v = t(p.body, p)),
            Promise.resolve(v)
        } catch (p) {
            Qo.throwError("processing response error", xe.errors.SERVER_ERROR, {
                body: gc(h[1], h[2]),
                error: p,
                requestBody: null,
                requestMethod: "GET",
                url: l
            })
        }
    e && (c.method = "POST",
    c.body = e,
    a["content-type"] == null && (a["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
    }),
    a["content-length"] == null && (a["content-length"] = {
        key: "Content-Length",
        value: String(e.length)
    }));
    const d = {};
    Object.keys(a).forEach(p => {
        const v = a[p];
        d[v.key] = v.value
    }
    ),
    c.headers = d;
    const m = function() {
        let p = null;
        return {
            promise: new Promise(function(_, x) {
                u && (p = setTimeout( () => {
                    p != null && (p = null,
                    x(Qo.makeError("timeout", xe.errors.TIMEOUT, {
                        requestBody: gc(c.body, d["content-type"]),
                        requestMethod: c.method,
                        timeout: u,
                        url: l
                    })))
                }
                , u))
            }
            ),
            cancel: function() {
                p != null && (clearTimeout(p),
                p = null)
            }
        }
    }()
      , g = function() {
        return W7(this, void 0, void 0, function*() {
            for (let p = 0; p < r; p++) {
                let v = null;
                try {
                    if (v = yield j7(l, c),
                    p < r) {
                        if (v.statusCode === 301 || v.statusCode === 302) {
                            const _ = v.headers.location || "";
                            if (c.method === "GET" && _.match(/^https:/)) {
                                l = v.headers.location;
                                continue
                            }
                        } else if (v.statusCode === 429) {
                            let _ = !0;
                            if (i && (_ = yield i(p, l)),
                            _) {
                                let x = 0;
                                const b = v.headers["retry-after"];
                                typeof b == "string" && b.match(/^[1-9][0-9]*$/) ? x = parseInt(b) * 1e3 : x = s * parseInt(String(Math.random() * Math.pow(2, p))),
                                yield rF(x);
                                continue
                            }
                        }
                    }
                } catch (_) {
                    v = _.response,
                    v == null && (m.cancel(),
                    Qo.throwError("missing response", xe.errors.SERVER_ERROR, {
                        requestBody: gc(c.body, d["content-type"]),
                        requestMethod: c.method,
                        serverError: _,
                        url: l
                    }))
                }
                let w = v.body;
                if (A && v.statusCode === 304 ? w = null : !o && (v.statusCode < 200 || v.statusCode >= 300) && (m.cancel(),
                Qo.throwError("bad response", xe.errors.SERVER_ERROR, {
                    status: v.statusCode,
                    headers: v.headers,
                    body: gc(w, v.headers ? v.headers["content-type"] : null),
                    requestBody: gc(c.body, d["content-type"]),
                    requestMethod: c.method,
                    url: l
                })),
                t)
                    try {
                        const _ = yield t(w, v);
                        return m.cancel(),
                        _
                    } catch (_) {
                        if (_.throttleRetry && p < r) {
                            let x = !0;
                            if (i && (x = yield i(p, l)),
                            x) {
                                const b = s * parseInt(String(Math.random() * Math.pow(2, p)));
                                yield rF(b);
                                continue
                            }
                        }
                        m.cancel(),
                        Qo.throwError("processing response error", xe.errors.SERVER_ERROR, {
                            body: gc(w, v.headers ? v.headers["content-type"] : null),
                            error: _,
                            requestBody: gc(c.body, d["content-type"]),
                            requestMethod: c.method,
                            url: l
                        })
                    }
                return m.cancel(),
                w
            }
            return Qo.throwError("failed response", xe.errors.SERVER_ERROR, {
                requestBody: gc(c.body, d["content-type"]),
                requestMethod: c.method,
                url: l
            })
        })
    }();
    return Promise.race([m.promise, g])
}
function kx(n, e, t) {
    let r = (s, o) => {
        let a = null;
        if (s != null)
            try {
                a = JSON.parse(c0(s))
            } catch (l) {
                Qo.throwError("invalid JSON", xe.errors.SERVER_ERROR, {
                    body: s,
                    error: l
                })
            }
        return t && (a = t(a, o)),
        a
    }
      , i = null;
    if (e != null) {
        i = $a(e);
        const s = typeof n == "string" ? {
            url: n
        } : Qn(n);
        s.headers ? Object.keys(s.headers).filter(a => a.toLowerCase() === "content-type").length !== 0 || (s.headers = Qn(s.headers),
        s.headers["content-type"] = "application/json") : s.headers = {
            "content-type": "application/json"
        },
        n = s
    }
    return X7(n, i, r)
}
function vh(n, e) {
    return e || (e = {}),
    e = Qn(e),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function(t, r) {
        let i = null
          , s = !1;
        const o = () => s ? !1 : (s = !0,
        i && clearTimeout(i),
        !0);
        e.timeout && (i = setTimeout( () => {
            o() && r(new Error("timeout"))
        }
        , e.timeout));
        const a = e.retryLimit;
        let l = 0;
        function c() {
            return n().then(function(A) {
                if (A !== void 0)
                    o() && t(A);
                else if (e.oncePoll)
                    e.oncePoll.once("poll", c);
                else if (e.onceBlock)
                    e.onceBlock.once("block", c);
                else if (!s) {
                    if (l++,
                    l > a) {
                        o() && r(new Error("retry limit reached"));
                        return
                    }
                    let u = e.interval * parseInt(String(Math.random() * Math.pow(2, l)));
                    u < e.floor && (u = e.floor),
                    u > e.ceiling && (u = e.ceiling),
                    setTimeout(c, u)
                }
                return null
            }, function(A) {
                o() && r(A)
            })
        }
        c()
    }
    )
}
var Jw = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
  , LM = {};
for (var z0 = 0; z0 < Jw.length; z0++) {
    var Eb = Jw.charAt(z0);
    if (LM[Eb] !== void 0)
        throw new TypeError(Eb + " is ambiguous");
    LM[Eb] = z0
}
function Kh(n) {
    var e = n >> 25;
    return (n & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059
}
function zQ(n) {
    for (var e = 1, t = 0; t < n.length; ++t) {
        var r = n.charCodeAt(t);
        if (r < 33 || r > 126)
            return "Invalid prefix (" + n + ")";
        e = Kh(e) ^ r >> 5
    }
    for (e = Kh(e),
    t = 0; t < n.length; ++t) {
        var i = n.charCodeAt(t);
        e = Kh(e) ^ i & 31
    }
    return e
}
function Y7(n, e, t) {
    if (t = t || 90,
    n.length + 7 + e.length > t)
        throw new TypeError("Exceeds length limit");
    n = n.toLowerCase();
    var r = zQ(n);
    if (typeof r == "string")
        throw new Error(r);
    for (var i = n + "1", s = 0; s < e.length; ++s) {
        var o = e[s];
        if (o >> 5)
            throw new Error("Non 5-bit word");
        r = Kh(r) ^ o,
        i += Jw.charAt(o)
    }
    for (s = 0; s < 6; ++s)
        r = Kh(r);
    for (r ^= 1,
    s = 0; s < 6; ++s) {
        var a = r >> (5 - s) * 5 & 31;
        i += Jw.charAt(a)
    }
    return i
}
function GQ(n, e) {
    if (e = e || 90,
    n.length < 8)
        return n + " too short";
    if (n.length > e)
        return "Exceeds length limit";
    var t = n.toLowerCase()
      , r = n.toUpperCase();
    if (n !== t && n !== r)
        return "Mixed-case string " + n;
    n = t;
    var i = n.lastIndexOf("1");
    if (i === -1)
        return "No separator character for " + n;
    if (i === 0)
        return "Missing prefix for " + n;
    var s = n.slice(0, i)
      , o = n.slice(i + 1);
    if (o.length < 6)
        return "Data too short";
    var a = zQ(s);
    if (typeof a == "string")
        return a;
    for (var l = [], c = 0; c < o.length; ++c) {
        var A = o.charAt(c)
          , u = LM[A];
        if (u === void 0)
            return "Unknown character " + A;
        a = Kh(a) ^ u,
        !(c + 6 >= o.length) && l.push(u)
    }
    return a !== 1 ? "Invalid checksum for " + n : {
        prefix: s,
        words: l
    }
}
function $7() {
    var n = GQ.apply(null, arguments);
    if (typeof n == "object")
        return n
}
function Z7(n) {
    var e = GQ.apply(null, arguments);
    if (typeof e == "object")
        return e;
    throw new Error(e)
}
function Qx(n, e, t, r) {
    for (var i = 0, s = 0, o = (1 << t) - 1, a = [], l = 0; l < n.length; ++l)
        for (i = i << e | n[l],
        s += e; s >= t; )
            s -= t,
            a.push(i >> s & o);
    if (r)
        s > 0 && a.push(i << t - s & o);
    else {
        if (s >= e)
            return "Excess padding";
        if (i << t - s & o)
            return "Non-zero padding"
    }
    return a
}
function J7(n) {
    var e = Qx(n, 8, 5, !0);
    if (Array.isArray(e))
        return e
}
function q7(n) {
    var e = Qx(n, 8, 5, !0);
    if (Array.isArray(e))
        return e;
    throw new Error(e)
}
function eX(n) {
    var e = Qx(n, 5, 8, !1);
    if (Array.isArray(e))
        return e
}
function tX(n) {
    var e = Qx(n, 5, 8, !1);
    if (Array.isArray(e))
        return e;
    throw new Error(e)
}
var nX = {
    decodeUnsafe: $7,
    decode: Z7,
    encode: Y7,
    toWordsUnsafe: J7,
    toWords: q7,
    fromWordsUnsafe: eX,
    fromWords: tX
};
const iF = oc(nX)
  , Ci = "providers/5.7.2";
function Vd(n, e, t) {
    return t = {
        path: e,
        exports: {},
        require: function(r, i) {
            return rX(r, i ?? t.path)
        }
    },
    n(t, t.exports),
    t.exports
}
function rX() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var fI = VQ;
function VQ(n, e) {
    if (!n)
        throw new Error(e || "Assertion failed")
}
VQ.equal = function(e, t, r) {
    if (e != t)
        throw new Error(r || "Assertion failed: " + e + " != " + t)
}
;
var qo = Vd(function(n, e) {
    var t = e;
    function r(o, a) {
        if (Array.isArray(o))
            return o.slice();
        if (!o)
            return [];
        var l = [];
        if (typeof o != "string") {
            for (var c = 0; c < o.length; c++)
                l[c] = o[c] | 0;
            return l
        }
        if (a === "hex") {
            o = o.replace(/[^a-z0-9]+/ig, ""),
            o.length % 2 !== 0 && (o = "0" + o);
            for (var c = 0; c < o.length; c += 2)
                l.push(parseInt(o[c] + o[c + 1], 16))
        } else
            for (var c = 0; c < o.length; c++) {
                var A = o.charCodeAt(c)
                  , u = A >> 8
                  , f = A & 255;
                u ? l.push(u, f) : l.push(f)
            }
        return l
    }
    t.toArray = r;
    function i(o) {
        return o.length === 1 ? "0" + o : o
    }
    t.zero2 = i;
    function s(o) {
        for (var a = "", l = 0; l < o.length; l++)
            a += i(o[l].toString(16));
        return a
    }
    t.toHex = s,
    t.encode = function(a, l) {
        return l === "hex" ? s(a) : a
    }
})
  , Vs = Vd(function(n, e) {
    var t = e;
    t.assert = fI,
    t.toArray = qo.toArray,
    t.zero2 = qo.zero2,
    t.toHex = qo.toHex,
    t.encode = qo.encode;
    function r(l, c, A) {
        var u = new Array(Math.max(l.bitLength(), A) + 1);
        u.fill(0);
        for (var f = 1 << c + 1, h = l.clone(), d = 0; d < u.length; d++) {
            var m, g = h.andln(f - 1);
            h.isOdd() ? (g > (f >> 1) - 1 ? m = (f >> 1) - g : m = g,
            h.isubn(m)) : m = 0,
            u[d] = m,
            h.iushrn(1)
        }
        return u
    }
    t.getNAF = r;
    function i(l, c) {
        var A = [[], []];
        l = l.clone(),
        c = c.clone();
        for (var u = 0, f = 0, h; l.cmpn(-u) > 0 || c.cmpn(-f) > 0; ) {
            var d = l.andln(3) + u & 3
              , m = c.andln(3) + f & 3;
            d === 3 && (d = -1),
            m === 3 && (m = -1);
            var g;
            d & 1 ? (h = l.andln(7) + u & 7,
            (h === 3 || h === 5) && m === 2 ? g = -d : g = d) : g = 0,
            A[0].push(g);
            var p;
            m & 1 ? (h = c.andln(7) + f & 7,
            (h === 3 || h === 5) && d === 2 ? p = -m : p = m) : p = 0,
            A[1].push(p),
            2 * u === g + 1 && (u = 1 - u),
            2 * f === p + 1 && (f = 1 - f),
            l.iushrn(1),
            c.iushrn(1)
        }
        return A
    }
    t.getJSF = i;
    function s(l, c, A) {
        var u = "_" + c;
        l.prototype[c] = function() {
            return this[u] !== void 0 ? this[u] : this[u] = A.call(this)
        }
    }
    t.cachedProperty = s;
    function o(l) {
        return typeof l == "string" ? t.toArray(l, "hex") : l
    }
    t.parseBytes = o;
    function a(l) {
        return new _t(l,"hex","le")
    }
    t.intFromLE = a
})
  , qw = Vs.getNAF
  , iX = Vs.getJSF
  , e_ = Vs.assert;
function MA(n, e) {
    this.type = n,
    this.p = new _t(e.p,16),
    this.red = e.prime ? _t.red(e.prime) : _t.mont(this.p),
    this.zero = new _t(0).toRed(this.red),
    this.one = new _t(1).toRed(this.red),
    this.two = new _t(2).toRed(this.red),
    this.n = e.n && new _t(e.n,16),
    this.g = e.g && this.pointFromJSON(e.g, e.gRed),
    this._wnafT1 = new Array(4),
    this._wnafT2 = new Array(4),
    this._wnafT3 = new Array(4),
    this._wnafT4 = new Array(4),
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var t = this.n && this.p.div(this.n);
    !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0,
    this.redN = this.n.toRed(this.red))
}
var ju = MA;
MA.prototype.point = function() {
    throw new Error("Not implemented")
}
;
MA.prototype.validate = function() {
    throw new Error("Not implemented")
}
;
MA.prototype._fixedNafMul = function(e, t) {
    e_(e.precomputed);
    var r = e._getDoubles()
      , i = qw(t, 1, this._bitLength)
      , s = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
    s /= 3;
    var o = [], a, l;
    for (a = 0; a < i.length; a += r.step) {
        l = 0;
        for (var c = a + r.step - 1; c >= a; c--)
            l = (l << 1) + i[c];
        o.push(l)
    }
    for (var A = this.jpoint(null, null, null), u = this.jpoint(null, null, null), f = s; f > 0; f--) {
        for (a = 0; a < o.length; a++)
            l = o[a],
            l === f ? u = u.mixedAdd(r.points[a]) : l === -f && (u = u.mixedAdd(r.points[a].neg()));
        A = A.add(u)
    }
    return A.toP()
}
;
MA.prototype._wnafMul = function(e, t) {
    var r = 4
      , i = e._getNAFPoints(r);
    r = i.wnd;
    for (var s = i.points, o = qw(t, r, this._bitLength), a = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
        for (var c = 0; l >= 0 && o[l] === 0; l--)
            c++;
        if (l >= 0 && c++,
        a = a.dblp(c),
        l < 0)
            break;
        var A = o[l];
        e_(A !== 0),
        e.type === "affine" ? A > 0 ? a = a.mixedAdd(s[A - 1 >> 1]) : a = a.mixedAdd(s[-A - 1 >> 1].neg()) : A > 0 ? a = a.add(s[A - 1 >> 1]) : a = a.add(s[-A - 1 >> 1].neg())
    }
    return e.type === "affine" ? a.toP() : a
}
;
MA.prototype._wnafMulAdd = function(e, t, r, i, s) {
    var o = this._wnafT1, a = this._wnafT2, l = this._wnafT3, c = 0, A, u, f;
    for (A = 0; A < i; A++) {
        f = t[A];
        var h = f._getNAFPoints(e);
        o[A] = h.wnd,
        a[A] = h.points
    }
    for (A = i - 1; A >= 1; A -= 2) {
        var d = A - 1
          , m = A;
        if (o[d] !== 1 || o[m] !== 1) {
            l[d] = qw(r[d], o[d], this._bitLength),
            l[m] = qw(r[m], o[m], this._bitLength),
            c = Math.max(l[d].length, c),
            c = Math.max(l[m].length, c);
            continue
        }
        var g = [t[d], null, null, t[m]];
        t[d].y.cmp(t[m].y) === 0 ? (g[1] = t[d].add(t[m]),
        g[2] = t[d].toJ().mixedAdd(t[m].neg())) : t[d].y.cmp(t[m].y.redNeg()) === 0 ? (g[1] = t[d].toJ().mixedAdd(t[m]),
        g[2] = t[d].add(t[m].neg())) : (g[1] = t[d].toJ().mixedAdd(t[m]),
        g[2] = t[d].toJ().mixedAdd(t[m].neg()));
        var p = [-3, -1, -5, -7, 0, 7, 5, 1, 3]
          , v = iX(r[d], r[m]);
        for (c = Math.max(v[0].length, c),
        l[d] = new Array(c),
        l[m] = new Array(c),
        u = 0; u < c; u++) {
            var w = v[0][u] | 0
              , _ = v[1][u] | 0;
            l[d][u] = p[(w + 1) * 3 + (_ + 1)],
            l[m][u] = 0,
            a[d] = g
        }
    }
    var x = this.jpoint(null, null, null)
      , b = this._wnafT4;
    for (A = c; A >= 0; A--) {
        for (var B = 0; A >= 0; ) {
            var S = !0;
            for (u = 0; u < i; u++)
                b[u] = l[u][A] | 0,
                b[u] !== 0 && (S = !1);
            if (!S)
                break;
            B++,
            A--
        }
        if (A >= 0 && B++,
        x = x.dblp(B),
        A < 0)
            break;
        for (u = 0; u < i; u++) {
            var I = b[u];
            I !== 0 && (I > 0 ? f = a[u][I - 1 >> 1] : I < 0 && (f = a[u][-I - 1 >> 1].neg()),
            f.type === "affine" ? x = x.mixedAdd(f) : x = x.add(f))
        }
    }
    for (A = 0; A < i; A++)
        a[A] = null;
    return s ? x : x.toP()
}
;
function Bo(n, e) {
    this.curve = n,
    this.type = e,
    this.precomputed = null
}
MA.BasePoint = Bo;
Bo.prototype.eq = function() {
    throw new Error("Not implemented")
}
;
Bo.prototype.validate = function() {
    return this.curve.validate(this)
}
;
MA.prototype.decodePoint = function(e, t) {
    e = Vs.toArray(e, t);
    var r = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
        e[0] === 6 ? e_(e[e.length - 1] % 2 === 0) : e[0] === 7 && e_(e[e.length - 1] % 2 === 1);
        var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
        return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
    throw new Error("Unknown point format")
}
;
Bo.prototype.encodeCompressed = function(e) {
    return this.encode(e, !0)
}
;
Bo.prototype._encode = function(e) {
    var t = this.curve.p.byteLength()
      , r = this.getX().toArray("be", t);
    return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", t))
}
;
Bo.prototype.encode = function(e, t) {
    return Vs.encode(this._encode(t), e)
}
;
Bo.prototype.precompute = function(e) {
    if (this.precomputed)
        return this;
    var t = {
        doubles: null,
        naf: null,
        beta: null
    };
    return t.naf = this._getNAFPoints(8),
    t.doubles = this._getDoubles(4, e),
    t.beta = this._getBeta(),
    this.precomputed = t,
    this
}
;
Bo.prototype._hasDoubles = function(e) {
    if (!this.precomputed)
        return !1;
    var t = this.precomputed.doubles;
    return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1
}
;
Bo.prototype._getDoubles = function(e, t) {
    if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
    for (var r = [this], i = this, s = 0; s < t; s += e) {
        for (var o = 0; o < e; o++)
            i = i.dbl();
        r.push(i)
    }
    return {
        step: e,
        points: r
    }
}
;
Bo.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
    for (var t = [this], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++)
        t[s] = t[s - 1].add(i);
    return {
        wnd: e,
        points: t
    }
}
;
Bo.prototype._getBeta = function() {
    return null
}
;
Bo.prototype.dblp = function(e) {
    for (var t = this, r = 0; r < e; r++)
        t = t.dbl();
    return t
}
;
var hI = Vd(function(n) {
    typeof Object.create == "function" ? n.exports = function(t, r) {
        r && (t.super_ = r,
        t.prototype = Object.create(r.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    }
    : n.exports = function(t, r) {
        if (r) {
            t.super_ = r;
            var i = function() {};
            i.prototype = r.prototype,
            t.prototype = new i,
            t.prototype.constructor = t
        }
    }
})
  , sX = Vs.assert;
function Mo(n) {
    ju.call(this, "short", n),
    this.a = new _t(n.a,16).toRed(this.red),
    this.b = new _t(n.b,16).toRed(this.red),
    this.tinv = this.two.redInvm(),
    this.zeroA = this.a.fromRed().cmpn(0) === 0,
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0,
    this.endo = this._getEndomorphism(n),
    this._endoWnafT1 = new Array(4),
    this._endoWnafT2 = new Array(4)
}
hI(Mo, ju);
var oX = Mo;
Mo.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var t, r;
        if (e.beta)
            t = new _t(e.beta,16).toRed(this.red);
        else {
            var i = this._getEndoRoots(this.p);
            t = i[0].cmp(i[1]) < 0 ? i[0] : i[1],
            t = t.toRed(this.red)
        }
        if (e.lambda)
            r = new _t(e.lambda,16);
        else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? r = s[0] : (r = s[1],
            sX(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0))
        }
        var o;
        return e.basis ? o = e.basis.map(function(a) {
            return {
                a: new _t(a.a,16),
                b: new _t(a.b,16)
            }
        }) : o = this._getEndoBasis(r),
        {
            beta: t,
            lambda: r,
            basis: o
        }
    }
}
;
Mo.prototype._getEndoRoots = function(e) {
    var t = e === this.p ? this.red : _t.mont(e)
      , r = new _t(2).toRed(t).redInvm()
      , i = r.redNeg()
      , s = new _t(3).toRed(t).redNeg().redSqrt().redMul(r)
      , o = i.redAdd(s).fromRed()
      , a = i.redSub(s).fromRed();
    return [o, a]
}
;
Mo.prototype._getEndoBasis = function(e) {
    for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, i = this.n.clone(), s = new _t(1), o = new _t(0), a = new _t(0), l = new _t(1), c, A, u, f, h, d, m, g = 0, p, v; r.cmpn(0) !== 0; ) {
        var w = i.div(r);
        p = i.sub(w.mul(r)),
        v = a.sub(w.mul(s));
        var _ = l.sub(w.mul(o));
        if (!u && p.cmp(t) < 0)
            c = m.neg(),
            A = s,
            u = p.neg(),
            f = v;
        else if (u && ++g === 2)
            break;
        m = p,
        i = r,
        r = p,
        a = s,
        s = v,
        l = o,
        o = _
    }
    h = p.neg(),
    d = v;
    var x = u.sqr().add(f.sqr())
      , b = h.sqr().add(d.sqr());
    return b.cmp(x) >= 0 && (h = c,
    d = A),
    u.negative && (u = u.neg(),
    f = f.neg()),
    h.negative && (h = h.neg(),
    d = d.neg()),
    [{
        a: u,
        b: f
    }, {
        a: h,
        b: d
    }]
}
;
Mo.prototype._endoSplit = function(e) {
    var t = this.endo.basis
      , r = t[0]
      , i = t[1]
      , s = i.b.mul(e).divRound(this.n)
      , o = r.b.neg().mul(e).divRound(this.n)
      , a = s.mul(r.a)
      , l = o.mul(i.a)
      , c = s.mul(r.b)
      , A = o.mul(i.b)
      , u = e.sub(a).sub(l)
      , f = c.add(A).neg();
    return {
        k1: u,
        k2: f
    }
}
;
Mo.prototype.pointFromX = function(e, t) {
    e = new _t(e,16),
    e.red || (e = e.toRed(this.red));
    var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b)
      , i = r.redSqrt();
    if (i.redSqr().redSub(r).cmp(this.zero) !== 0)
        throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (t && !s || !t && s) && (i = i.redNeg()),
    this.point(e, i)
}
;
Mo.prototype.validate = function(e) {
    if (e.inf)
        return !0;
    var t = e.x
      , r = e.y
      , i = this.a.redMul(t)
      , s = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
    return r.redSqr().redISub(s).cmpn(0) === 0
}
;
Mo.prototype._endoWnafMulAdd = function(e, t, r) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
        var a = this._endoSplit(t[o])
          , l = e[o]
          , c = l._getBeta();
        a.k1.negative && (a.k1.ineg(),
        l = l.neg(!0)),
        a.k2.negative && (a.k2.ineg(),
        c = c.neg(!0)),
        i[o * 2] = l,
        i[o * 2 + 1] = c,
        s[o * 2] = a.k1,
        s[o * 2 + 1] = a.k2
    }
    for (var A = this._wnafMulAdd(1, i, s, o * 2, r), u = 0; u < o * 2; u++)
        i[u] = null,
        s[u] = null;
    return A
}
;
function Zr(n, e, t, r) {
    ju.BasePoint.call(this, n, "affine"),
    e === null && t === null ? (this.x = null,
    this.y = null,
    this.inf = !0) : (this.x = new _t(e,16),
    this.y = new _t(t,16),
    r && (this.x.forceRed(this.curve.red),
    this.y.forceRed(this.curve.red)),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.inf = !1)
}
hI(Zr, ju.BasePoint);
Mo.prototype.point = function(e, t, r) {
    return new Zr(this,e,t,r)
}
;
Mo.prototype.pointFromJSON = function(e, t) {
    return Zr.fromJSON(this, e, t)
}
;
Zr.prototype._getBeta = function() {
    if (this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
            return e.beta;
        var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var r = this.curve
              , i = function(s) {
                return r.point(s.x.redMul(r.endo.beta), s.y)
            };
            e.beta = t,
            t.precomputed = {
                beta: null,
                naf: e.naf && {
                    wnd: e.naf.wnd,
                    points: e.naf.points.map(i)
                },
                doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i)
                }
            }
        }
        return t
    }
}
;
Zr.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
        }
    }] : [this.x, this.y]
}
;
Zr.fromJSON = function(e, t, r) {
    typeof t == "string" && (t = JSON.parse(t));
    var i = e.point(t[0], t[1], r);
    if (!t[2])
        return i;
    function s(a) {
        return e.point(a[0], a[1], r)
    }
    var o = t[2];
    return i.precomputed = {
        beta: null,
        doubles: o.doubles && {
            step: o.doubles.step,
            points: [i].concat(o.doubles.points.map(s))
        },
        naf: o.naf && {
            wnd: o.naf.wnd,
            points: [i].concat(o.naf.points.map(s))
        }
    },
    i
}
;
Zr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
}
;
Zr.prototype.isInfinity = function() {
    return this.inf
}
;
Zr.prototype.add = function(e) {
    if (this.inf)
        return e;
    if (e.inf)
        return this;
    if (this.eq(e))
        return this.dbl();
    if (this.neg().eq(e))
        return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
    var t = this.y.redSub(e.y);
    t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
    var r = t.redSqr().redISub(this.x).redISub(e.x)
      , i = t.redMul(this.x.redSub(r)).redISub(this.y);
    return this.curve.point(r, i)
}
;
Zr.prototype.dbl = function() {
    if (this.inf)
        return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
    var t = this.curve.a
      , r = this.x.redSqr()
      , i = e.redInvm()
      , s = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i)
      , o = s.redSqr().redISub(this.x.redAdd(this.x))
      , a = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, a)
}
;
Zr.prototype.getX = function() {
    return this.x.fromRed()
}
;
Zr.prototype.getY = function() {
    return this.y.fromRed()
}
;
Zr.prototype.mul = function(e) {
    return e = new _t(e,16),
    this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
}
;
Zr.prototype.mulAdd = function(e, t, r) {
    var i = [this, t]
      , s = [e, r];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
}
;
Zr.prototype.jmulAdd = function(e, t, r) {
    var i = [this, t]
      , s = [e, r];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
}
;
Zr.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
}
;
Zr.prototype.neg = function(e) {
    if (this.inf)
        return this;
    var t = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var r = this.precomputed
          , i = function(s) {
            return s.neg()
        };
        t.precomputed = {
            naf: r.naf && {
                wnd: r.naf.wnd,
                points: r.naf.points.map(i)
            },
            doubles: r.doubles && {
                step: r.doubles.step,
                points: r.doubles.points.map(i)
            }
        }
    }
    return t
}
;
Zr.prototype.toJ = function() {
    if (this.inf)
        return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
}
;
function ci(n, e, t, r) {
    ju.BasePoint.call(this, n, "jacobian"),
    e === null && t === null && r === null ? (this.x = this.curve.one,
    this.y = this.curve.one,
    this.z = new _t(0)) : (this.x = new _t(e,16),
    this.y = new _t(t,16),
    this.z = new _t(r,16)),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    this.zOne = this.z === this.curve.one
}
hI(ci, ju.BasePoint);
Mo.prototype.jpoint = function(e, t, r) {
    return new ci(this,e,t,r)
}
;
ci.prototype.toP = function() {
    if (this.isInfinity())
        return this.curve.point(null, null);
    var e = this.z.redInvm()
      , t = e.redSqr()
      , r = this.x.redMul(t)
      , i = this.y.redMul(t).redMul(e);
    return this.curve.point(r, i)
}
;
ci.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
}
;
ci.prototype.add = function(e) {
    if (this.isInfinity())
        return e;
    if (e.isInfinity())
        return this;
    var t = e.z.redSqr()
      , r = this.z.redSqr()
      , i = this.x.redMul(t)
      , s = e.x.redMul(r)
      , o = this.y.redMul(t.redMul(e.z))
      , a = e.y.redMul(r.redMul(this.z))
      , l = i.redSub(s)
      , c = o.redSub(a);
    if (l.cmpn(0) === 0)
        return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var A = l.redSqr()
      , u = A.redMul(l)
      , f = i.redMul(A)
      , h = c.redSqr().redIAdd(u).redISub(f).redISub(f)
      , d = c.redMul(f.redISub(h)).redISub(o.redMul(u))
      , m = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(h, d, m)
}
;
ci.prototype.mixedAdd = function(e) {
    if (this.isInfinity())
        return e.toJ();
    if (e.isInfinity())
        return this;
    var t = this.z.redSqr()
      , r = this.x
      , i = e.x.redMul(t)
      , s = this.y
      , o = e.y.redMul(t).redMul(this.z)
      , a = r.redSub(i)
      , l = s.redSub(o);
    if (a.cmpn(0) === 0)
        return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var c = a.redSqr()
      , A = c.redMul(a)
      , u = r.redMul(c)
      , f = l.redSqr().redIAdd(A).redISub(u).redISub(u)
      , h = l.redMul(u.redISub(f)).redISub(s.redMul(A))
      , d = this.z.redMul(a);
    return this.curve.jpoint(f, h, d)
}
;
ci.prototype.dblp = function(e) {
    if (e === 0)
        return this;
    if (this.isInfinity())
        return this;
    if (!e)
        return this.dbl();
    var t;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (t = 0; t < e; t++)
            r = r.dbl();
        return r
    }
    var i = this.curve.a
      , s = this.curve.tinv
      , o = this.x
      , a = this.y
      , l = this.z
      , c = l.redSqr().redSqr()
      , A = a.redAdd(a);
    for (t = 0; t < e; t++) {
        var u = o.redSqr()
          , f = A.redSqr()
          , h = f.redSqr()
          , d = u.redAdd(u).redIAdd(u).redIAdd(i.redMul(c))
          , m = o.redMul(f)
          , g = d.redSqr().redISub(m.redAdd(m))
          , p = m.redISub(g)
          , v = d.redMul(p);
        v = v.redIAdd(v).redISub(h);
        var w = A.redMul(l);
        t + 1 < e && (c = c.redMul(h)),
        o = g,
        l = w,
        A = v
    }
    return this.curve.jpoint(o, A.redMul(s), l)
}
;
ci.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
}
;
ci.prototype._zeroDbl = function() {
    var e, t, r;
    if (this.zOne) {
        var i = this.x.redSqr()
          , s = this.y.redSqr()
          , o = s.redSqr()
          , a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        a = a.redIAdd(a);
        var l = i.redAdd(i).redIAdd(i)
          , c = l.redSqr().redISub(a).redISub(a)
          , A = o.redIAdd(o);
        A = A.redIAdd(A),
        A = A.redIAdd(A),
        e = c,
        t = l.redMul(a.redISub(c)).redISub(A),
        r = this.y.redAdd(this.y)
    } else {
        var u = this.x.redSqr()
          , f = this.y.redSqr()
          , h = f.redSqr()
          , d = this.x.redAdd(f).redSqr().redISub(u).redISub(h);
        d = d.redIAdd(d);
        var m = u.redAdd(u).redIAdd(u)
          , g = m.redSqr()
          , p = h.redIAdd(h);
        p = p.redIAdd(p),
        p = p.redIAdd(p),
        e = g.redISub(d).redISub(d),
        t = m.redMul(d.redISub(e)).redISub(p),
        r = this.y.redMul(this.z),
        r = r.redIAdd(r)
    }
    return this.curve.jpoint(e, t, r)
}
;
ci.prototype._threeDbl = function() {
    var e, t, r;
    if (this.zOne) {
        var i = this.x.redSqr()
          , s = this.y.redSqr()
          , o = s.redSqr()
          , a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        a = a.redIAdd(a);
        var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a)
          , c = l.redSqr().redISub(a).redISub(a);
        e = c;
        var A = o.redIAdd(o);
        A = A.redIAdd(A),
        A = A.redIAdd(A),
        t = l.redMul(a.redISub(c)).redISub(A),
        r = this.y.redAdd(this.y)
    } else {
        var u = this.z.redSqr()
          , f = this.y.redSqr()
          , h = this.x.redMul(f)
          , d = this.x.redSub(u).redMul(this.x.redAdd(u));
        d = d.redAdd(d).redIAdd(d);
        var m = h.redIAdd(h);
        m = m.redIAdd(m);
        var g = m.redAdd(m);
        e = d.redSqr().redISub(g),
        r = this.y.redAdd(this.z).redSqr().redISub(f).redISub(u);
        var p = f.redSqr();
        p = p.redIAdd(p),
        p = p.redIAdd(p),
        p = p.redIAdd(p),
        t = d.redMul(m.redISub(e)).redISub(p)
    }
    return this.curve.jpoint(e, t, r)
}
;
ci.prototype._dbl = function() {
    var e = this.curve.a
      , t = this.x
      , r = this.y
      , i = this.z
      , s = i.redSqr().redSqr()
      , o = t.redSqr()
      , a = r.redSqr()
      , l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s))
      , c = t.redAdd(t);
    c = c.redIAdd(c);
    var A = c.redMul(a)
      , u = l.redSqr().redISub(A.redAdd(A))
      , f = A.redISub(u)
      , h = a.redSqr();
    h = h.redIAdd(h),
    h = h.redIAdd(h),
    h = h.redIAdd(h);
    var d = l.redMul(f).redISub(h)
      , m = r.redAdd(r).redMul(i);
    return this.curve.jpoint(u, d, m)
}
;
ci.prototype.trpl = function() {
    if (!this.curve.zeroA)
        return this.dbl().add(this);
    var e = this.x.redSqr()
      , t = this.y.redSqr()
      , r = this.z.redSqr()
      , i = t.redSqr()
      , s = e.redAdd(e).redIAdd(e)
      , o = s.redSqr()
      , a = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
    a = a.redIAdd(a),
    a = a.redAdd(a).redIAdd(a),
    a = a.redISub(o);
    var l = a.redSqr()
      , c = i.redIAdd(i);
    c = c.redIAdd(c),
    c = c.redIAdd(c),
    c = c.redIAdd(c);
    var A = s.redIAdd(a).redSqr().redISub(o).redISub(l).redISub(c)
      , u = t.redMul(A);
    u = u.redIAdd(u),
    u = u.redIAdd(u);
    var f = this.x.redMul(l).redISub(u);
    f = f.redIAdd(f),
    f = f.redIAdd(f);
    var h = this.y.redMul(A.redMul(c.redISub(A)).redISub(a.redMul(l)));
    h = h.redIAdd(h),
    h = h.redIAdd(h),
    h = h.redIAdd(h);
    var d = this.z.redAdd(a).redSqr().redISub(r).redISub(l);
    return this.curve.jpoint(f, h, d)
}
;
ci.prototype.mul = function(e, t) {
    return e = new _t(e,t),
    this.curve._wnafMul(this, e)
}
;
ci.prototype.eq = function(e) {
    if (e.type === "affine")
        return this.eq(e.toJ());
    if (this === e)
        return !0;
    var t = this.z.redSqr()
      , r = e.z.redSqr();
    if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0)
        return !1;
    var i = t.redMul(this.z)
      , s = r.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
}
;
ci.prototype.eqXToP = function(e) {
    var t = this.z.redSqr()
      , r = e.toRed(this.curve.red).redMul(t);
    if (this.x.cmp(r) === 0)
        return !0;
    for (var i = e.clone(), s = this.curve.redN.redMul(t); ; ) {
        if (i.iadd(this.curve.n),
        i.cmp(this.curve.p) >= 0)
            return !1;
        if (r.redIAdd(s),
        this.x.cmp(r) === 0)
            return !0
    }
}
;
ci.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
}
;
ci.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
}
;
var rw = Vd(function(n, e) {
    var t = e;
    t.base = ju,
    t.short = oX,
    t.mont = null,
    t.edwards = null
})
  , iw = Vd(function(n, e) {
    var t = e
      , r = Vs.assert;
    function i(a) {
        a.type === "short" ? this.curve = new rw.short(a) : a.type === "edwards" ? this.curve = new rw.edwards(a) : this.curve = new rw.mont(a),
        this.g = this.curve.g,
        this.n = this.curve.n,
        this.hash = a.hash,
        r(this.g.validate(), "Invalid curve"),
        r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
    }
    t.PresetCurve = i;
    function s(a, l) {
        Object.defineProperty(t, a, {
            configurable: !0,
            enumerable: !0,
            get: function() {
                var c = new i(l);
                return Object.defineProperty(t, a, {
                    configurable: !0,
                    enumerable: !0,
                    value: c
                }),
                c
            }
        })
    }
    s("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: Ba.sha256,
        gRed: !1,
        g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
    }),
    s("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: Ba.sha256,
        gRed: !1,
        g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
    }),
    s("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: Ba.sha256,
        gRed: !1,
        g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
    }),
    s("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: Ba.sha384,
        gRed: !1,
        g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
    }),
    s("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: Ba.sha512,
        gRed: !1,
        g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
    }),
    s("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Ba.sha256,
        gRed: !1,
        g: ["9"]
    }),
    s("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: Ba.sha256,
        gRed: !1,
        g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
    });
    var o;
    try {
        o = null.crash()
    } catch {
        o = void 0
    }
    s("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: Ba.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }],
        gRed: !1,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", o]
    })
});
function pA(n) {
    if (!(this instanceof pA))
        return new pA(n);
    this.hash = n.hash,
    this.predResist = !!n.predResist,
    this.outLen = this.hash.outSize,
    this.minEntropy = n.minEntropy || this.hash.hmacStrength,
    this._reseed = null,
    this.reseedInterval = null,
    this.K = null,
    this.V = null;
    var e = qo.toArray(n.entropy, n.entropyEnc || "hex")
      , t = qo.toArray(n.nonce, n.nonceEnc || "hex")
      , r = qo.toArray(n.pers, n.persEnc || "hex");
    fI(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
    this._init(e, t, r)
}
var jQ = pA;
pA.prototype._init = function(e, t, r) {
    var i = e.concat(t).concat(r);
    this.K = new Array(this.outLen / 8),
    this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++)
        this.K[s] = 0,
        this.V[s] = 1;
    this._update(i),
    this._reseed = 1,
    this.reseedInterval = 281474976710656
}
;
pA.prototype._hmac = function() {
    return new Ba.hmac(this.hash,this.K)
}
;
pA.prototype._update = function(e) {
    var t = this._hmac().update(this.V).update([0]);
    e && (t = t.update(e)),
    this.K = t.digest(),
    this.V = this._hmac().update(this.V).digest(),
    e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(),
    this.V = this._hmac().update(this.V).digest())
}
;
pA.prototype.reseed = function(e, t, r, i) {
    typeof t != "string" && (i = r,
    r = t,
    t = null),
    e = qo.toArray(e, t),
    r = qo.toArray(r, i),
    fI(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"),
    this._update(e.concat(r || [])),
    this._reseed = 1
}
;
pA.prototype.generate = function(e, t, r, i) {
    if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
    typeof t != "string" && (i = r,
    r = t,
    t = null),
    r && (r = qo.toArray(r, i || "hex"),
    this._update(r));
    for (var s = []; s.length < e; )
        this.V = this._hmac().update(this.V).digest(),
        s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(r),
    this._reseed++,
    qo.encode(o, t)
}
;
var DM = Vs.assert;
function bi(n, e) {
    this.ec = n,
    this.priv = null,
    this.pub = null,
    e.priv && this._importPrivate(e.priv, e.privEnc),
    e.pub && this._importPublic(e.pub, e.pubEnc)
}
var dI = bi;
bi.fromPublic = function(e, t, r) {
    return t instanceof bi ? t : new bi(e,{
        pub: t,
        pubEnc: r
    })
}
;
bi.fromPrivate = function(e, t, r) {
    return t instanceof bi ? t : new bi(e,{
        priv: t,
        privEnc: r
    })
}
;
bi.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    }
}
;
bi.prototype.getPublic = function(e, t) {
    return typeof e == "string" && (t = e,
    e = null),
    this.pub || (this.pub = this.ec.g.mul(this.priv)),
    t ? this.pub.encode(t, e) : this.pub
}
;
bi.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
}
;
bi.prototype._importPrivate = function(e, t) {
    this.priv = new _t(e,t || 16),
    this.priv = this.priv.umod(this.ec.curve.n)
}
;
bi.prototype._importPublic = function(e, t) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? DM(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && DM(e.x && e.y, "Need both x and y coordinate"),
        this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, t)
}
;
bi.prototype.derive = function(e) {
    return e.validate() || DM(e.validate(), "public point not validated"),
    e.mul(this.priv).getX()
}
;
bi.prototype.sign = function(e, t, r) {
    return this.ec.sign(e, this, t, r)
}
;
bi.prototype.verify = function(e, t) {
    return this.ec.verify(e, t, this)
}
;
bi.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
}
;
var aX = Vs.assert;
function Hx(n, e) {
    if (n instanceof Hx)
        return n;
    this._importDER(n, e) || (aX(n.r && n.s, "Signature without r or s"),
    this.r = new _t(n.r,16),
    this.s = new _t(n.s,16),
    n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam)
}
var zx = Hx;
function lX() {
    this.place = 0
}
function Bb(n, e) {
    var t = n[e.place++];
    if (!(t & 128))
        return t;
    var r = t & 15;
    if (r === 0 || r > 4)
        return !1;
    for (var i = 0, s = 0, o = e.place; s < r; s++,
    o++)
        i <<= 8,
        i |= n[o],
        i >>>= 0;
    return i <= 127 ? !1 : (e.place = o,
    i)
}
function sF(n) {
    for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; )
        e++;
    return e === 0 ? n : n.slice(e)
}
Hx.prototype._importDER = function(e, t) {
    e = Vs.toArray(e, t);
    var r = new lX;
    if (e[r.place++] !== 48)
        return !1;
    var i = Bb(e, r);
    if (i === !1 || i + r.place !== e.length || e[r.place++] !== 2)
        return !1;
    var s = Bb(e, r);
    if (s === !1)
        return !1;
    var o = e.slice(r.place, s + r.place);
    if (r.place += s,
    e[r.place++] !== 2)
        return !1;
    var a = Bb(e, r);
    if (a === !1 || e.length !== a + r.place)
        return !1;
    var l = e.slice(r.place, a + r.place);
    if (o[0] === 0)
        if (o[1] & 128)
            o = o.slice(1);
        else
            return !1;
    if (l[0] === 0)
        if (l[1] & 128)
            l = l.slice(1);
        else
            return !1;
    return this.r = new _t(o),
    this.s = new _t(l),
    this.recoveryParam = null,
    !0
}
;
function Mb(n, e) {
    if (e < 128) {
        n.push(e);
        return
    }
    var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (n.push(t | 128); --t; )
        n.push(e >>> (t << 3) & 255);
    n.push(e)
}
Hx.prototype.toDER = function(e) {
    var t = this.r.toArray()
      , r = this.s.toArray();
    for (t[0] & 128 && (t = [0].concat(t)),
    r[0] & 128 && (r = [0].concat(r)),
    t = sF(t),
    r = sF(r); !r[0] && !(r[1] & 128); )
        r = r.slice(1);
    var i = [2];
    Mb(i, t.length),
    i = i.concat(t),
    i.push(2),
    Mb(i, r.length);
    var s = i.concat(r)
      , o = [48];
    return Mb(o, s.length),
    o = o.concat(s),
    Vs.encode(o, e)
}
;
var cX = function() {
    throw new Error("unsupported")
}
  , WQ = Vs.assert;
function wo(n) {
    if (!(this instanceof wo))
        return new wo(n);
    typeof n == "string" && (WQ(Object.prototype.hasOwnProperty.call(iw, n), "Unknown curve " + n),
    n = iw[n]),
    n instanceof iw.PresetCurve && (n = {
        curve: n
    }),
    this.curve = n.curve.curve,
    this.n = this.curve.n,
    this.nh = this.n.ushrn(1),
    this.g = this.curve.g,
    this.g = n.curve.g,
    this.g.precompute(n.curve.n.bitLength() + 1),
    this.hash = n.hash || n.curve.hash
}
var AX = wo;
wo.prototype.keyPair = function(e) {
    return new dI(this,e)
}
;
wo.prototype.keyFromPrivate = function(e, t) {
    return dI.fromPrivate(this, e, t)
}
;
wo.prototype.keyFromPublic = function(e, t) {
    return dI.fromPublic(this, e, t)
}
;
wo.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var t = new jQ({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || "utf8",
        entropy: e.entropy || cX(this.hash.hmacStrength),
        entropyEnc: e.entropy && e.entropyEnc || "utf8",
        nonce: this.n.toArray()
    }), r = this.n.byteLength(), i = this.n.sub(new _t(2)); ; ) {
        var s = new _t(t.generate(r));
        if (!(s.cmp(i) > 0))
            return s.iaddn(1),
            this.keyFromPrivate(s)
    }
}
;
wo.prototype._truncateToN = function(e, t) {
    var r = e.byteLength() * 8 - this.n.bitLength();
    return r > 0 && (e = e.ushrn(r)),
    !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
}
;
wo.prototype.sign = function(e, t, r, i) {
    typeof r == "object" && (i = r,
    r = null),
    i || (i = {}),
    t = this.keyFromPrivate(t, r),
    e = this._truncateToN(new _t(e,16));
    for (var s = this.n.byteLength(), o = t.getPrivate().toArray("be", s), a = e.toArray("be", s), l = new jQ({
        hash: this.hash,
        entropy: o,
        nonce: a,
        pers: i.pers,
        persEnc: i.persEnc || "utf8"
    }), c = this.n.sub(new _t(1)), A = 0; ; A++) {
        var u = i.k ? i.k(A) : new _t(l.generate(this.n.byteLength()));
        if (u = this._truncateToN(u, !0),
        !(u.cmpn(1) <= 0 || u.cmp(c) >= 0)) {
            var f = this.g.mul(u);
            if (!f.isInfinity()) {
                var h = f.getX()
                  , d = h.umod(this.n);
                if (d.cmpn(0) !== 0) {
                    var m = u.invm(this.n).mul(d.mul(t.getPrivate()).iadd(e));
                    if (m = m.umod(this.n),
                    m.cmpn(0) !== 0) {
                        var g = (f.getY().isOdd() ? 1 : 0) | (h.cmp(d) !== 0 ? 2 : 0);
                        return i.canonical && m.cmp(this.nh) > 0 && (m = this.n.sub(m),
                        g ^= 1),
                        new zx({
                            r: d,
                            s: m,
                            recoveryParam: g
                        })
                    }
                }
            }
        }
    }
}
;
wo.prototype.verify = function(e, t, r, i) {
    e = this._truncateToN(new _t(e,16)),
    r = this.keyFromPublic(r, i),
    t = new zx(t,"hex");
    var s = t.r
      , o = t.s;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
        return !1;
    var a = o.invm(this.n), l = a.mul(e).umod(this.n), c = a.mul(s).umod(this.n), A;
    return this.curve._maxwellTrick ? (A = this.g.jmulAdd(l, r.getPublic(), c),
    A.isInfinity() ? !1 : A.eqXToP(s)) : (A = this.g.mulAdd(l, r.getPublic(), c),
    A.isInfinity() ? !1 : A.getX().umod(this.n).cmp(s) === 0)
}
;
wo.prototype.recoverPubKey = function(n, e, t, r) {
    WQ((3 & t) === t, "The recovery param is more than two bits"),
    e = new zx(e,r);
    var i = this.n
      , s = new _t(n)
      , o = e.r
      , a = e.s
      , l = t & 1
      , c = t >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && c)
        throw new Error("Unable to find sencond key candinate");
    c ? o = this.curve.pointFromX(o.add(this.curve.n), l) : o = this.curve.pointFromX(o, l);
    var A = e.r.invm(i)
      , u = i.sub(s).mul(A).umod(i)
      , f = a.mul(A).umod(i);
    return this.g.mulAdd(u, o, f)
}
;
wo.prototype.getKeyRecoveryParam = function(n, e, t, r) {
    if (e = new zx(e,r),
    e.recoveryParam !== null)
        return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
        var s;
        try {
            s = this.recoverPubKey(n, e, i)
        } catch {
            continue
        }
        if (s.eq(t))
            return i
    }
    throw new Error("Unable to find valid recovery factor")
}
;
var uX = Vd(function(n, e) {
    var t = e;
    t.version = "6.5.4",
    t.utils = Vs,
    t.rand = function() {
        throw new Error("unsupported")
    }
    ,
    t.curve = rw,
    t.curves = iw,
    t.ec = AX,
    t.eddsa = null
})
  , fX = uX.ec;
const hX = "signing-key/5.7.0"
  , NM = new xe(hX);
let Sb = null;
function Ia() {
    return Sb || (Sb = new fX("secp256k1")),
    Sb
}
class dX {
    constructor(e) {
        Ue(this, "curve", "secp256k1"),
        Ue(this, "privateKey", lt(e)),
        Su(this.privateKey) !== 32 && NM.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const t = Ia().keyFromPrivate(pt(this.privateKey));
        Ue(this, "publicKey", "0x" + t.getPublic(!1, "hex")),
        Ue(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")),
        Ue(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const t = Ia().keyFromPublic(pt(this.publicKey))
          , r = Ia().keyFromPublic(pt(e));
        return "0x" + t.pub.add(r.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const t = Ia().keyFromPrivate(pt(this.privateKey))
          , r = pt(e);
        r.length !== 32 && NM.throwArgumentError("bad digest length", "digest", e);
        const i = t.sign(r, {
            canonical: !0
        });
        return Lx({
            recoveryParam: i.recoveryParam,
            r: ir("0x" + i.r.toString(16), 32),
            s: ir("0x" + i.s.toString(16), 32)
        })
    }
    computeSharedSecret(e) {
        const t = Ia().keyFromPrivate(pt(this.privateKey))
          , r = Ia().keyFromPublic(pt(KQ(e)));
        return ir("0x" + t.derive(r.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}
function pX(n, e) {
    const t = Lx(e)
      , r = {
        r: pt(t.r),
        s: pt(t.s)
    };
    return "0x" + Ia().recoverPubKey(pt(n), r, t.recoveryParam).encode("hex", !1)
}
function KQ(n, e) {
    const t = pt(n);
    if (t.length === 32) {
        const r = new dX(t);
        return e ? "0x" + Ia().keyFromPrivate(t).getPublic(!0, "hex") : r.publicKey
    } else {
        if (t.length === 33)
            return e ? lt(t) : "0x" + Ia().keyFromPublic(t).getPublic(!1, "hex");
        if (t.length === 65)
            return e ? "0x" + Ia().keyFromPublic(t).getPublic(!0, "hex") : lt(t)
    }
    return NM.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const mX = "transactions/5.7.0"
  , ac = new xe(mX);
var oF;
(function(n) {
    n[n.legacy = 0] = "legacy",
    n[n.eip2930 = 1] = "eip2930",
    n[n.eip1559 = 2] = "eip1559"
}
)(oF || (oF = {}));
function pI(n) {
    return n === "0x" ? null : ai(n)
}
function vi(n) {
    return n === "0x" ? sQ : je.from(n)
}
function gX(n) {
    const e = KQ(n);
    return ai(mi(Er(mi(e, 1)), 12))
}
function XQ(n, e) {
    return gX(pX(pt(n), e))
}
function Es(n, e) {
    const t = hd(je.from(n).toHexString());
    return t.length > 32 && ac.throwArgumentError("invalid length for " + e, "transaction:" + e, n),
    t
}
function Cb(n, e) {
    return {
        address: ai(n),
        storageKeys: (e || []).map( (t, r) => (Su(t) !== 32 && ac.throwArgumentError("invalid access list storageKey", `accessList[${n}:${r}]`, t),
        t.toLowerCase()))
    }
}
function Wu(n) {
    if (Array.isArray(n))
        return n.map( (t, r) => Array.isArray(t) ? (t.length > 2 && ac.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, t),
        Cb(t[0], t[1])) : Cb(t.address, t.storageKeys));
    const e = Object.keys(n).map(t => {
        const r = n[t].reduce( (i, s) => (i[s] = !0,
        i), {});
        return Cb(t, Object.keys(r).sort())
    }
    );
    return e.sort( (t, r) => t.address.localeCompare(r.address)),
    e
}
function YQ(n) {
    return Wu(n).map(e => [e.address, e.storageKeys])
}
function vX(n, e) {
    if (n.gasPrice != null) {
        const r = je.from(n.gasPrice)
          , i = je.from(n.maxFeePerGas || 0);
        r.eq(i) || ac.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice: r,
            maxFeePerGas: i
        })
    }
    const t = [Es(n.chainId || 0, "chainId"), Es(n.nonce || 0, "nonce"), Es(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Es(n.maxFeePerGas || 0, "maxFeePerGas"), Es(n.gasLimit || 0, "gasLimit"), n.to != null ? ai(n.to) : "0x", Es(n.value || 0, "value"), n.data || "0x", YQ(n.accessList || [])];
    if (e) {
        const r = Lx(e);
        t.push(Es(r.recoveryParam, "recoveryParam")),
        t.push(hd(r.r)),
        t.push(hd(r.s))
    }
    return $i(["0x02", Nx(t)])
}
function yX(n, e) {
    const t = [Es(n.chainId || 0, "chainId"), Es(n.nonce || 0, "nonce"), Es(n.gasPrice || 0, "gasPrice"), Es(n.gasLimit || 0, "gasLimit"), n.to != null ? ai(n.to) : "0x", Es(n.value || 0, "value"), n.data || "0x", YQ(n.accessList || [])];
    if (e) {
        const r = Lx(e);
        t.push(Es(r.recoveryParam, "recoveryParam")),
        t.push(hd(r.r)),
        t.push(hd(r.s))
    }
    return $i(["0x01", Nx(t)])
}
function $Q(n, e, t) {
    try {
        const r = vi(e[0]).toNumber();
        if (r !== 0 && r !== 1)
            throw new Error("bad recid");
        n.v = r
    } catch {
        ac.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
    }
    n.r = ir(e[1], 32),
    n.s = ir(e[2], 32);
    try {
        const r = Er(t(n));
        n.from = XQ(r, {
            r: n.r,
            s: n.s,
            recoveryParam: n.v
        })
    } catch {}
}
function wX(n) {
    const e = AI(n.slice(1));
    e.length !== 9 && e.length !== 12 && ac.throwArgumentError("invalid component count for transaction type: 2", "payload", lt(n));
    const t = vi(e[2])
      , r = vi(e[3])
      , i = {
        type: 2,
        chainId: vi(e[0]).toNumber(),
        nonce: vi(e[1]).toNumber(),
        maxPriorityFeePerGas: t,
        maxFeePerGas: r,
        gasPrice: null,
        gasLimit: vi(e[4]),
        to: pI(e[5]),
        value: vi(e[6]),
        data: e[7],
        accessList: Wu(e[8])
    };
    return e.length === 9 || (i.hash = Er(n),
    $Q(i, e.slice(9), vX)),
    i
}
function _X(n) {
    const e = AI(n.slice(1));
    e.length !== 8 && e.length !== 11 && ac.throwArgumentError("invalid component count for transaction type: 1", "payload", lt(n));
    const t = {
        type: 1,
        chainId: vi(e[0]).toNumber(),
        nonce: vi(e[1]).toNumber(),
        gasPrice: vi(e[2]),
        gasLimit: vi(e[3]),
        to: pI(e[4]),
        value: vi(e[5]),
        data: e[6],
        accessList: Wu(e[7])
    };
    return e.length === 8 || (t.hash = Er(n),
    $Q(t, e.slice(8), yX)),
    t
}
function xX(n) {
    const e = AI(n);
    e.length !== 9 && e.length !== 6 && ac.throwArgumentError("invalid raw transaction", "rawTransaction", n);
    const t = {
        nonce: vi(e[0]).toNumber(),
        gasPrice: vi(e[1]),
        gasLimit: vi(e[2]),
        to: pI(e[3]),
        value: vi(e[4]),
        data: e[5],
        chainId: 0
    };
    if (e.length === 6)
        return t;
    try {
        t.v = je.from(e[6]).toNumber()
    } catch {
        return t
    }
    if (t.r = ir(e[7], 32),
    t.s = ir(e[8], 32),
    je.from(t.r).isZero() && je.from(t.s).isZero())
        t.chainId = t.v,
        t.v = 0;
    else {
        t.chainId = Math.floor((t.v - 35) / 2),
        t.chainId < 0 && (t.chainId = 0);
        let r = t.v - 27;
        const i = e.slice(0, 6);
        t.chainId !== 0 && (i.push(lt(t.chainId)),
        i.push("0x"),
        i.push("0x"),
        r -= t.chainId * 2 + 8);
        const s = Er(Nx(i));
        try {
            t.from = XQ(s, {
                r: lt(t.r),
                s: lt(t.s),
                recoveryParam: r
            })
        } catch {}
        t.hash = Er(n)
    }
    return t.type = null,
    t
}
function bX(n) {
    const e = pt(n);
    if (e[0] > 127)
        return xX(e);
    switch (e[0]) {
    case 1:
        return _X(e);
    case 2:
        return wX(e)
    }
    return ac.throwError(`unsupported transaction type: ${e[0]}`, xe.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: e[0]
    })
}
const mp = new xe(Ci);
let aF = class it {
    constructor() {
        this.formats = this.getDefaultFormats()
    }
    getDefaultFormats() {
        const e = {}
          , t = this.address.bind(this)
          , r = this.bigNumber.bind(this)
          , i = this.blockTag.bind(this)
          , s = this.data.bind(this)
          , o = this.hash.bind(this)
          , a = this.hex.bind(this)
          , l = this.number.bind(this)
          , c = this.type.bind(this)
          , A = u => this.data(u, !0);
        return e.transaction = {
            hash: o,
            type: c,
            accessList: it.allowNull(this.accessList.bind(this), null),
            blockHash: it.allowNull(o, null),
            blockNumber: it.allowNull(l, null),
            transactionIndex: it.allowNull(l, null),
            confirmations: it.allowNull(l, null),
            from: t,
            gasPrice: it.allowNull(r),
            maxPriorityFeePerGas: it.allowNull(r),
            maxFeePerGas: it.allowNull(r),
            gasLimit: r,
            to: it.allowNull(t, null),
            value: r,
            nonce: l,
            data: s,
            r: it.allowNull(this.uint256),
            s: it.allowNull(this.uint256),
            v: it.allowNull(l),
            creates: it.allowNull(t, null),
            raw: it.allowNull(s)
        },
        e.transactionRequest = {
            from: it.allowNull(t),
            nonce: it.allowNull(l),
            gasLimit: it.allowNull(r),
            gasPrice: it.allowNull(r),
            maxPriorityFeePerGas: it.allowNull(r),
            maxFeePerGas: it.allowNull(r),
            to: it.allowNull(t),
            value: it.allowNull(r),
            data: it.allowNull(A),
            type: it.allowNull(l),
            accessList: it.allowNull(this.accessList.bind(this), null)
        },
        e.receiptLog = {
            transactionIndex: l,
            blockNumber: l,
            transactionHash: o,
            address: t,
            topics: it.arrayOf(o),
            data: s,
            logIndex: l,
            blockHash: o
        },
        e.receipt = {
            to: it.allowNull(this.address, null),
            from: it.allowNull(this.address, null),
            contractAddress: it.allowNull(t, null),
            transactionIndex: l,
            root: it.allowNull(a),
            gasUsed: r,
            logsBloom: it.allowNull(s),
            blockHash: o,
            transactionHash: o,
            logs: it.arrayOf(this.receiptLog.bind(this)),
            blockNumber: l,
            confirmations: it.allowNull(l, null),
            cumulativeGasUsed: r,
            effectiveGasPrice: it.allowNull(r),
            status: it.allowNull(l),
            type: c
        },
        e.block = {
            hash: it.allowNull(o),
            parentHash: o,
            number: l,
            timestamp: l,
            nonce: it.allowNull(a),
            difficulty: this.difficulty.bind(this),
            gasLimit: r,
            gasUsed: r,
            miner: it.allowNull(t),
            extraData: s,
            transactions: it.allowNull(it.arrayOf(o)),
            baseFeePerGas: it.allowNull(r)
        },
        e.blockWithTransactions = Qn(e.block),
        e.blockWithTransactions.transactions = it.allowNull(it.arrayOf(this.transactionResponse.bind(this))),
        e.filter = {
            fromBlock: it.allowNull(i, void 0),
            toBlock: it.allowNull(i, void 0),
            blockHash: it.allowNull(o, void 0),
            address: it.allowNull(t, void 0),
            topics: it.allowNull(this.topics.bind(this), void 0)
        },
        e.filterLog = {
            blockNumber: it.allowNull(l),
            blockHash: it.allowNull(o),
            transactionIndex: l,
            removed: it.allowNull(this.boolean.bind(this)),
            address: t,
            data: it.allowFalsish(s, "0x"),
            topics: it.arrayOf(o),
            transactionHash: o,
            logIndex: l
        },
        e
    }
    accessList(e) {
        return Wu(e || [])
    }
    number(e) {
        return e === "0x" ? 0 : je.from(e).toNumber()
    }
    type(e) {
        return e === "0x" || e == null ? 0 : je.from(e).toNumber()
    }
    bigNumber(e) {
        return je.from(e)
    }
    boolean(e) {
        if (typeof e == "boolean")
            return e;
        if (typeof e == "string") {
            if (e = e.toLowerCase(),
            e === "true")
                return !0;
            if (e === "false")
                return !1
        }
        throw new Error("invalid boolean - " + e)
    }
    hex(e, t) {
        return typeof e == "string" && (!t && e.substring(0, 2) !== "0x" && (e = "0x" + e),
        It(e)) ? e.toLowerCase() : mp.throwArgumentError("invalid hash", "value", e)
    }
    data(e, t) {
        const r = this.hex(e, t);
        if (r.length % 2 !== 0)
            throw new Error("invalid data; odd-length - " + e);
        return r
    }
    address(e) {
        return ai(e)
    }
    callAddress(e) {
        if (!It(e, 32))
            return null;
        const t = ai(mi(e, 12));
        return t === _9 ? null : t
    }
    contractAddress(e) {
        return yQ(e)
    }
    blockTag(e) {
        if (e == null)
            return "latest";
        if (e === "earliest")
            return "0x0";
        switch (e) {
        case "earliest":
            return "0x0";
        case "latest":
        case "pending":
        case "safe":
        case "finalized":
            return e
        }
        if (typeof e == "number" || It(e))
            return Px(e);
        throw new Error("invalid blockTag")
    }
    hash(e, t) {
        const r = this.hex(e, t);
        return Su(r) !== 32 ? mp.throwArgumentError("invalid hash", "value", e) : r
    }
    difficulty(e) {
        if (e == null)
            return null;
        const t = je.from(e);
        try {
            return t.toNumber()
        } catch {}
        return null
    }
    uint256(e) {
        if (!It(e))
            throw new Error("invalid uint256");
        return ir(e, 32)
    }
    _block(e, t) {
        e.author != null && e.miner == null && (e.miner = e.author);
        const r = e._difficulty != null ? e._difficulty : e.difficulty
          , i = it.check(t, e);
        return i._difficulty = r == null ? null : je.from(r),
        i
    }
    block(e) {
        return this._block(e, this.formats.block)
    }
    blockWithTransactions(e) {
        return this._block(e, this.formats.blockWithTransactions)
    }
    transactionRequest(e) {
        return it.check(this.formats.transactionRequest, e)
    }
    transactionResponse(e) {
        e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
        e.to && je.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"),
        e.input != null && e.data == null && (e.data = e.input),
        e.to == null && e.creates == null && (e.creates = this.contractAddress(e)),
        (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
        const t = it.check(this.formats.transaction, e);
        if (e.chainId != null) {
            let r = e.chainId;
            It(r) && (r = je.from(r).toNumber()),
            t.chainId = r
        } else {
            let r = e.networkId;
            r == null && t.v == null && (r = e.chainId),
            It(r) && (r = je.from(r).toNumber()),
            typeof r != "number" && t.v != null && (r = (t.v - 35) / 2,
            r < 0 && (r = 0),
            r = parseInt(r)),
            typeof r != "number" && (r = 0),
            t.chainId = r
        }
        return t.blockHash && t.blockHash.replace(/0/g, "") === "x" && (t.blockHash = null),
        t
    }
    transaction(e) {
        return bX(e)
    }
    receiptLog(e) {
        return it.check(this.formats.receiptLog, e)
    }
    receipt(e) {
        const t = it.check(this.formats.receipt, e);
        if (t.root != null)
            if (t.root.length <= 4) {
                const r = je.from(t.root).toNumber();
                r === 0 || r === 1 ? (t.status != null && t.status !== r && mp.throwArgumentError("alt-root-status/status mismatch", "value", {
                    root: t.root,
                    status: t.status
                }),
                t.status = r,
                delete t.root) : mp.throwArgumentError("invalid alt-root-status", "value.root", t.root)
            } else
                t.root.length !== 66 && mp.throwArgumentError("invalid root hash", "value.root", t.root);
        return t.status != null && (t.byzantium = !0),
        t
    }
    topics(e) {
        return Array.isArray(e) ? e.map(t => this.topics(t)) : e != null ? this.hash(e, !0) : null
    }
    filter(e) {
        return it.check(this.formats.filter, e)
    }
    filterLog(e) {
        return it.check(this.formats.filterLog, e)
    }
    static check(e, t) {
        const r = {};
        for (const i in e)
            try {
                const s = e[i](t[i]);
                s !== void 0 && (r[i] = s)
            } catch (s) {
                throw s.checkKey = i,
                s.checkValue = t[i],
                s
            }
        return r
    }
    static allowNull(e, t) {
        return function(r) {
            return r == null ? t : e(r)
        }
    }
    static allowFalsish(e, t) {
        return function(r) {
            return r ? e(r) : t
        }
    }
    static arrayOf(e) {
        return function(t) {
            if (!Array.isArray(t))
                throw new Error("not an array");
            const r = [];
            return t.forEach(function(i) {
                r.push(e(i))
            }),
            r
        }
    }
}
;
function EX(n) {
    return n && typeof n.isCommunityResource == "function"
}
function lF(n) {
    return EX(n) && n.isCommunityResource()
}
let cF = !1;
function Gx() {
    cF || (cF = !0,
    console.log("========= NOTICE ========="),
    console.log("Request-Rate Exceeded  (this message will not be repeated)"),
    console.log(""),
    console.log("The default API keys for each service are provided as a highly-throttled,"),
    console.log("community resource for low-traffic projects and early prototyping."),
    console.log(""),
    console.log("While your application will continue to function, we highly recommended"),
    console.log("signing up for your own API keys to improve performance, increase your"),
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."),
    console.log(""),
    console.log("For more details: https://docs.ethers.io/api-keys/"),
    console.log("=========================="))
}
var yt = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Tt = new xe(Ci)
  , BX = 10;
function AF(n) {
    return n == null ? "null" : (Su(n) !== 32 && Tt.throwArgumentError("invalid topic", "topic", n),
    n.toLowerCase())
}
function uF(n) {
    for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; )
        n.pop();
    return n.map(e => {
        if (Array.isArray(e)) {
            const t = {};
            e.forEach(i => {
                t[AF(i)] = !0
            }
            );
            const r = Object.keys(t);
            return r.sort(),
            r.join("|")
        } else
            return AF(e)
    }
    ).join("&")
}
function MX(n) {
    return n === "" ? [] : n.split(/&/g).map(e => {
        if (e === "")
            return [];
        const t = e.split("|").map(r => r === "null" ? null : r);
        return t.length === 1 ? t[0] : t
    }
    )
}
function of(n) {
    if (typeof n == "string") {
        if (n = n.toLowerCase(),
        Su(n) === 32)
            return "tx:" + n;
        if (n.indexOf(":") === -1)
            return n
    } else {
        if (Array.isArray(n))
            return "filter:*:" + uF(n);
        if (v9.isForkEvent(n))
            throw Tt.warn("not implemented"),
            new Error("not implemented");
        if (n && typeof n == "object")
            return "filter:" + (n.address || "*") + ":" + uF(n.topics || [])
    }
    throw new Error("invalid event - " + n)
}
function gp() {
    return new Date().getTime()
}
function fF(n) {
    return new Promise(e => {
        setTimeout(e, n)
    }
    )
}
const SX = ["block", "network", "pending", "poll"];
let CX = class {
    constructor(e, t, r) {
        Ue(this, "tag", e),
        Ue(this, "listener", t),
        Ue(this, "once", r),
        this._lastBlockNumber = -2,
        this._inflight = !1
    }
    get event() {
        switch (this.type) {
        case "tx":
            return this.hash;
        case "filter":
            return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const e = this.tag.split(":");
        return e[0] !== "tx" ? null : e[1]
    }
    get filter() {
        const e = this.tag.split(":");
        if (e[0] !== "filter")
            return null;
        const t = e[1]
          , r = MX(e[2])
          , i = {};
        return r.length > 0 && (i.topics = r),
        t && t !== "*" && (i.address = t),
        i
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || SX.indexOf(this.tag) >= 0
    }
}
;
const TX = {
    0: {
        symbol: "btc",
        p2pkh: 0,
        p2sh: 5,
        prefix: "bc"
    },
    2: {
        symbol: "ltc",
        p2pkh: 48,
        p2sh: 50,
        prefix: "ltc"
    },
    3: {
        symbol: "doge",
        p2pkh: 30,
        p2sh: 22
    },
    60: {
        symbol: "eth",
        ilk: "eth"
    },
    61: {
        symbol: "etc",
        ilk: "eth"
    },
    700: {
        symbol: "xdai",
        ilk: "eth"
    }
};
function Tb(n) {
    return ir(je.from(n).toHexString(), 32)
}
function hF(n) {
    return RM.encode(Ss([n, mi(nF(nF(n)), 0, 4)]))
}
const ZQ = new RegExp("^(ipfs)://(.*)$","i")
  , dF = [new RegExp("^(https)://(.*)$","i"), new RegExp("^(data):(.*)$","i"), ZQ, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$","i")];
function sw(n, e) {
    try {
        return c0(ug(n, e))
    } catch {}
    return null
}
function ug(n, e) {
    if (n === "0x")
        return null;
    const t = je.from(mi(n, e, e + 32)).toNumber()
      , r = je.from(mi(n, t, t + 32)).toNumber();
    return mi(n, t + 32, t + 32 + r)
}
function Ib(n) {
    return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : Tt.throwArgumentError("unsupported IPFS format", "link", n),
    `https://gateway.ipfs.io/ipfs/${n}`
}
function pF(n) {
    const e = pt(n);
    if (e.length > 32)
        throw new Error("internal; should not happen");
    const t = new Uint8Array(32);
    return t.set(e, 32 - e.length),
    t
}
function IX(n) {
    if (n.length % 32 === 0)
        return n;
    const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
    return e.set(n),
    e
}
function JQ(n) {
    const e = [];
    let t = 0;
    for (let r = 0; r < n.length; r++)
        e.push(null),
        t += 32;
    for (let r = 0; r < n.length; r++) {
        const i = pt(n[r]);
        e[r] = pF(t),
        e.push(pF(i.length)),
        e.push(IX(i)),
        t += 32 + Math.ceil(i.length / 32) * 32
    }
    return $i(e)
}
class mF {
    constructor(e, t, r, i) {
        Ue(this, "provider", e),
        Ue(this, "name", r),
        Ue(this, "address", e.formatter.address(t)),
        Ue(this, "_resolvedAddress", i)
    }
    supportsWildcard() {
        return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then(e => je.from(e).eq(1)).catch(e => {
            if (e.code === xe.errors.CALL_EXCEPTION)
                return !1;
            throw this._supportsEip2544 = null,
            e
        }
        )),
        this._supportsEip2544
    }
    _fetch(e, t) {
        return yt(this, void 0, void 0, function*() {
            const r = {
                to: this.address,
                ccipReadEnabled: !0,
                data: $i([e, nw(this.name), t || "0x"])
            };
            let i = !1;
            (yield this.supportsWildcard()) && (i = !0,
            r.data = $i(["0x9061b923", JQ([rK(this.name), r.data])]));
            try {
                let s = yield this.provider.call(r);
                return pt(s).length % 32 === 4 && Tt.throwError("resolver threw error", xe.errors.CALL_EXCEPTION, {
                    transaction: r,
                    data: s
                }),
                i && (s = ug(s, 0)),
                s
            } catch (s) {
                if (s.code === xe.errors.CALL_EXCEPTION)
                    return null;
                throw s
            }
        })
    }
    _fetchBytes(e, t) {
        return yt(this, void 0, void 0, function*() {
            const r = yield this._fetch(e, t);
            return r != null ? ug(r, 0) : null
        })
    }
    _getAddress(e, t) {
        const r = TX[String(e)];
        if (r == null && Tt.throwError(`unsupported coin type: ${e}`, xe.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${e})`
        }),
        r.ilk === "eth")
            return this.provider.formatter.address(t);
        const i = pt(t);
        if (r.p2pkh != null) {
            const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (s) {
                const o = parseInt(s[1], 16);
                if (s[2].length === o * 2 && o >= 1 && o <= 75)
                    return hF(Ss([[r.p2pkh], "0x" + s[2]]))
            }
        }
        if (r.p2sh != null) {
            const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (s) {
                const o = parseInt(s[1], 16);
                if (s[2].length === o * 2 && o >= 1 && o <= 75)
                    return hF(Ss([[r.p2sh], "0x" + s[2]]))
            }
        }
        if (r.prefix != null) {
            const s = i[1];
            let o = i[0];
            if (o === 0 ? s !== 20 && s !== 32 && (o = -1) : o = -1,
            o >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
                const a = iF.toWords(i.slice(2));
                return a.unshift(o),
                iF.encode(r.prefix, a)
            }
        }
        return null
    }
    getAddress(e) {
        return yt(this, void 0, void 0, function*() {
            if (e == null && (e = 60),
            e === 60)
                try {
                    const i = yield this._fetch("0x3b3b57de");
                    return i === "0x" || i === B9 ? null : this.provider.formatter.callAddress(i)
                } catch (i) {
                    if (i.code === xe.errors.CALL_EXCEPTION)
                        return null;
                    throw i
                }
            const t = yield this._fetchBytes("0xf1cb7e06", Tb(e));
            if (t == null || t === "0x")
                return null;
            const r = this._getAddress(e, t);
            return r == null && Tt.throwError("invalid or unsupported coin data", xe.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${e})`,
                coinType: e,
                data: t
            }),
            r
        })
    }
    getAvatar() {
        return yt(this, void 0, void 0, function*() {
            const e = [{
                type: "name",
                content: this.name
            }];
            try {
                const t = yield this.getText("avatar");
                if (t == null)
                    return null;
                for (let r = 0; r < dF.length; r++) {
                    const i = t.match(dF[r]);
                    if (i == null)
                        continue;
                    const s = i[1].toLowerCase();
                    switch (s) {
                    case "https":
                        return e.push({
                            type: "url",
                            content: t
                        }),
                        {
                            linkage: e,
                            url: t
                        };
                    case "data":
                        return e.push({
                            type: "data",
                            content: t
                        }),
                        {
                            linkage: e,
                            url: t
                        };
                    case "ipfs":
                        return e.push({
                            type: "ipfs",
                            content: t
                        }),
                        {
                            linkage: e,
                            url: Ib(t)
                        };
                    case "erc721":
                    case "erc1155":
                        {
                            const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                            e.push({
                                type: s,
                                content: t
                            });
                            const a = this._resolvedAddress || (yield this.getAddress())
                              , l = (i[2] || "").split("/");
                            if (l.length !== 2)
                                return null;
                            const c = yield this.provider.formatter.address(l[0])
                              , A = ir(je.from(l[1]).toHexString(), 32);
                            if (s === "erc721") {
                                const m = this.provider.formatter.callAddress(yield this.provider.call({
                                    to: c,
                                    data: $i(["0x6352211e", A])
                                }));
                                if (a !== m)
                                    return null;
                                e.push({
                                    type: "owner",
                                    content: m
                                })
                            } else if (s === "erc1155") {
                                const m = je.from(yield this.provider.call({
                                    to: c,
                                    data: $i(["0x00fdd58e", ir(a, 32), A])
                                }));
                                if (m.isZero())
                                    return null;
                                e.push({
                                    type: "balance",
                                    content: m.toString()
                                })
                            }
                            const u = {
                                to: this.provider.formatter.address(l[0]),
                                data: $i([o, A])
                            };
                            let f = sw(yield this.provider.call(u), 0);
                            if (f == null)
                                return null;
                            e.push({
                                type: "metadata-url-base",
                                content: f
                            }),
                            s === "erc1155" && (f = f.replace("{id}", A.substring(2)),
                            e.push({
                                type: "metadata-url-expanded",
                                content: f
                            })),
                            f.match(/^ipfs:/i) && (f = Ib(f)),
                            e.push({
                                type: "metadata-url",
                                content: f
                            });
                            const h = yield kx(f);
                            if (!h)
                                return null;
                            e.push({
                                type: "metadata",
                                content: JSON.stringify(h)
                            });
                            let d = h.image;
                            if (typeof d != "string")
                                return null;
                            if (!d.match(/^(https:\/\/|data:)/i)) {
                                if (d.match(ZQ) == null)
                                    return null;
                                e.push({
                                    type: "url-ipfs",
                                    content: d
                                }),
                                d = Ib(d)
                            }
                            return e.push({
                                type: "url",
                                content: d
                            }),
                            {
                                linkage: e,
                                url: d
                            }
                        }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return yt(this, void 0, void 0, function*() {
            const e = yield this._fetchBytes("0xbc1c58d1");
            if (e == null || e === "0x")
                return null;
            const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (t) {
                const o = parseInt(t[3], 16);
                if (t[4].length === o * 2)
                    return "ipfs://" + RM.encode("0x" + t[1])
            }
            const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (r) {
                const o = parseInt(r[3], 16);
                if (r[4].length === o * 2)
                    return "ipns://" + RM.encode("0x" + r[1])
            }
            const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (i && i[1].length === 32 * 2)
                return "bzz://" + i[1];
            const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
            if (s && s[1].length === 34 * 2) {
                const o = {
                    "=": "",
                    "+": "-",
                    "/": "_"
                };
                return "sia://" + rQ("0x" + s[1]).replace(/[=+\/]/g, l => o[l])
            }
            return Tt.throwError("invalid or unsupported content hash data", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: e
            })
        })
    }
    getText(e) {
        return yt(this, void 0, void 0, function*() {
            let t = $a(e);
            t = Ss([Tb(64), Tb(t.length), t]),
            t.length % 32 !== 0 && (t = Ss([t, ir("0x", 32 - e.length % 32)]));
            const r = yield this._fetchBytes("0x59d1d43c", lt(t));
            return r == null || r === "0x" ? null : c0(r)
        })
    }
}
let Rb = null
  , RX = 1;
class mI extends l0 {
    constructor(e) {
        if (super(),
        this._events = [],
        this._emitted = {
            block: -2
        },
        this.disableCcipRead = !1,
        this.formatter = new.target.getFormatter(),
        Ue(this, "anyNetwork", e === "any"),
        this.anyNetwork && (e = this.detectNetwork()),
        e instanceof Promise)
            this._networkPromise = e,
            e.catch(t => {}
            ),
            this._ready().catch(t => {}
            );
        else {
            const t = Cs(new.target, "getNetwork")(e);
            t ? (Ue(this, "_network", t),
            this.emit("network", t, null)) : Tt.throwArgumentError("invalid network", "network", e)
        }
        this._maxInternalBlockNumber = -1024,
        this._lastBlockNumber = -2,
        this._maxFilterBlockRange = 10,
        this._pollingInterval = 4e3,
        this._fastQueryDate = 0
    }
    _ready() {
        return yt(this, void 0, void 0, function*() {
            if (this._network == null) {
                let e = null;
                if (this._networkPromise)
                    try {
                        e = yield this._networkPromise
                    } catch {}
                e == null && (e = yield this.detectNetwork()),
                e || Tt.throwError("no network detected", xe.errors.UNKNOWN_ERROR, {}),
                this._network == null && (this.anyNetwork ? this._network = e : Ue(this, "_network", e),
                this.emit("network", e, null))
            }
            return this._network
        })
    }
    get ready() {
        return vh( () => this._ready().then(e => e, e => {
            if (!(e.code === xe.errors.NETWORK_ERROR && e.event === "noNetwork"))
                throw e
        }
        ))
    }
    static getFormatter() {
        return Rb == null && (Rb = new aF),
        Rb
    }
    static getNetwork(e) {
        return tQ(e ?? "homestead")
    }
    ccipReadFetch(e, t, r) {
        return yt(this, void 0, void 0, function*() {
            if (this.disableCcipRead || r.length === 0)
                return null;
            const i = e.to.toLowerCase()
              , s = t.toLowerCase()
              , o = [];
            for (let a = 0; a < r.length; a++) {
                const l = r[a]
                  , c = l.replace("{sender}", i).replace("{data}", s)
                  , A = l.indexOf("{data}") >= 0 ? null : JSON.stringify({
                    data: s,
                    sender: i
                })
                  , u = yield kx({
                    url: c,
                    errorPassThrough: !0
                }, A, (h, d) => (h.status = d.statusCode,
                h));
                if (u.data)
                    return u.data;
                const f = u.message || "unknown error";
                if (u.status >= 400 && u.status < 500)
                    return Tt.throwError(`response not found during CCIP fetch: ${f}`, xe.errors.SERVER_ERROR, {
                        url: l,
                        errorMessage: f
                    });
                o.push(f)
            }
            return Tt.throwError(`error encountered during CCIP fetch: ${o.map(a => JSON.stringify(a)).join(", ")}`, xe.errors.SERVER_ERROR, {
                urls: r,
                errorMessages: o
            })
        })
    }
    _getInternalBlockNumber(e) {
        return yt(this, void 0, void 0, function*() {
            if (yield this._ready(),
            e > 0)
                for (; this._internalBlockNumber; ) {
                    const i = this._internalBlockNumber;
                    try {
                        const s = yield i;
                        if (gp() - s.respTime <= e)
                            return s.blockNumber;
                        break
                    } catch {
                        if (this._internalBlockNumber === i)
                            break
                    }
                }
            const t = gp()
              , r = wr({
                blockNumber: this.perform("getBlockNumber", {}),
                networkError: this.getNetwork().then(i => null, i => i)
            }).then( ({blockNumber: i, networkError: s}) => {
                if (s)
                    throw this._internalBlockNumber === r && (this._internalBlockNumber = null),
                    s;
                const o = gp();
                return i = je.from(i).toNumber(),
                i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber),
                this._maxInternalBlockNumber = i,
                this._setFastBlockNumber(i),
                {
                    blockNumber: i,
                    reqTime: t,
                    respTime: o
                }
            }
            );
            return this._internalBlockNumber = r,
            r.catch(i => {
                this._internalBlockNumber === r && (this._internalBlockNumber = null)
            }
            ),
            (yield r).blockNumber
        })
    }
    poll() {
        return yt(this, void 0, void 0, function*() {
            const e = RX++
              , t = [];
            let r = null;
            try {
                r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (i) {
                this.emit("error", i);
                return
            }
            if (this._setFastBlockNumber(r),
            this.emit("poll", e, r),
            r === this._lastBlockNumber) {
                this.emit("didPoll", e);
                return
            }
            if (this._emitted.block === -2 && (this._emitted.block = r - 1),
            Math.abs(this._emitted.block - r) > 1e3)
                Tt.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`),
                this.emit("error", Tt.makeError("network block skew detected", xe.errors.NETWORK_ERROR, {
                    blockNumber: r,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                })),
                this.emit("block", r);
            else
                for (let i = this._emitted.block + 1; i <= r; i++)
                    this.emit("block", i);
            this._emitted.block !== r && (this._emitted.block = r,
            Object.keys(this._emitted).forEach(i => {
                if (i === "block")
                    return;
                const s = this._emitted[i];
                s !== "pending" && r - s > 12 && delete this._emitted[i]
            }
            )),
            this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1),
            this._events.forEach(i => {
                switch (i.type) {
                case "tx":
                    {
                        const s = i.hash;
                        let o = this.getTransactionReceipt(s).then(a => (!a || a.blockNumber == null || (this._emitted["t:" + s] = a.blockNumber,
                        this.emit(s, a)),
                        null)).catch(a => {
                            this.emit("error", a)
                        }
                        );
                        t.push(o);
                        break
                    }
                case "filter":
                    {
                        if (!i._inflight) {
                            i._inflight = !0,
                            i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
                            const s = i.filter;
                            s.fromBlock = i._lastBlockNumber + 1,
                            s.toBlock = r;
                            const o = s.toBlock - this._maxFilterBlockRange;
                            o > s.fromBlock && (s.fromBlock = o),
                            s.fromBlock < 0 && (s.fromBlock = 0);
                            const a = this.getLogs(s).then(l => {
                                i._inflight = !1,
                                l.length !== 0 && l.forEach(c => {
                                    c.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = c.blockNumber),
                                    this._emitted["b:" + c.blockHash] = c.blockNumber,
                                    this._emitted["t:" + c.transactionHash] = c.blockNumber,
                                    this.emit(s, c)
                                }
                                )
                            }
                            ).catch(l => {
                                this.emit("error", l),
                                i._inflight = !1
                            }
                            );
                            t.push(a)
                        }
                        break
                    }
                }
            }
            ),
            this._lastBlockNumber = r,
            Promise.all(t).then( () => {
                this.emit("didPoll", e)
            }
            ).catch(i => {
                this.emit("error", i)
            }
            )
        })
    }
    resetEventsBlock(e) {
        this._lastBlockNumber = e - 1,
        this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return yt(this, void 0, void 0, function*() {
            return Tt.throwError("provider does not support network detection", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            })
        })
    }
    getNetwork() {
        return yt(this, void 0, void 0, function*() {
            const e = yield this._ready()
              , t = yield this.detectNetwork();
            if (e.chainId !== t.chainId) {
                if (this.anyNetwork)
                    return this._network = t,
                    this._lastBlockNumber = -2,
                    this._fastBlockNumber = null,
                    this._fastBlockNumberPromise = null,
                    this._fastQueryDate = 0,
                    this._emitted.block = -2,
                    this._maxInternalBlockNumber = -1024,
                    this._internalBlockNumber = null,
                    this.emit("network", t, e),
                    yield fF(0),
                    this._network;
                const r = Tt.makeError("underlying network changed", xe.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: e,
                    detectedNetwork: t
                });
                throw this.emit("error", r),
                r
            }
            return e
        })
    }
    get blockNumber() {
        return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(e => {
            this._setFastBlockNumber(e)
        }
        , e => {}
        ),
        this._fastBlockNumber != null ? this._fastBlockNumber : -1
    }
    get polling() {
        return this._poller != null
    }
    set polling(e) {
        e && !this._poller ? (this._poller = setInterval( () => {
            this.poll()
        }
        , this.pollingInterval),
        this._bootstrapPoll || (this._bootstrapPoll = setTimeout( () => {
            this.poll(),
            this._bootstrapPoll = setTimeout( () => {
                this._poller || this.poll(),
                this._bootstrapPoll = null
            }
            , this.pollingInterval)
        }
        , 0))) : !e && this._poller && (clearInterval(this._poller),
        this._poller = null)
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(e) {
        if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
            throw new Error("invalid polling interval");
        this._pollingInterval = e,
        this._poller && (clearInterval(this._poller),
        this._poller = setInterval( () => {
            this.poll()
        }
        , this._pollingInterval))
    }
    _getFastBlockNumber() {
        const e = gp();
        return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e,
        this._fastBlockNumberPromise = this.getBlockNumber().then(t => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t),
        this._fastBlockNumber))),
        this._fastBlockNumberPromise
    }
    _setFastBlockNumber(e) {
        this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = gp(),
        (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e,
        this._fastBlockNumberPromise = Promise.resolve(e)))
    }
    waitForTransaction(e, t, r) {
        return yt(this, void 0, void 0, function*() {
            return this._waitForTransaction(e, t ?? 1, r || 0, null)
        })
    }
    _waitForTransaction(e, t, r, i) {
        return yt(this, void 0, void 0, function*() {
            const s = yield this.getTransactionReceipt(e);
            return (s ? s.confirmations : 0) >= t ? s : new Promise( (o, a) => {
                const l = [];
                let c = !1;
                const A = function() {
                    return c ? !0 : (c = !0,
                    l.forEach(f => {
                        f()
                    }
                    ),
                    !1)
                }
                  , u = f => {
                    f.confirmations < t || A() || o(f)
                }
                ;
                if (this.on(e, u),
                l.push( () => {
                    this.removeListener(e, u)
                }
                ),
                i) {
                    let f = i.startBlock
                      , h = null;
                    const d = m => yt(this, void 0, void 0, function*() {
                        c || (yield fF(1e3),
                        this.getTransactionCount(i.from).then(g => yt(this, void 0, void 0, function*() {
                            if (!c) {
                                if (g <= i.nonce)
                                    f = m;
                                else {
                                    {
                                        const p = yield this.getTransaction(e);
                                        if (p && p.blockNumber != null)
                                            return
                                    }
                                    for (h == null && (h = f - 3,
                                    h < i.startBlock && (h = i.startBlock)); h <= m; ) {
                                        if (c)
                                            return;
                                        const p = yield this.getBlockWithTransactions(h);
                                        for (let v = 0; v < p.transactions.length; v++) {
                                            const w = p.transactions[v];
                                            if (w.hash === e)
                                                return;
                                            if (w.from === i.from && w.nonce === i.nonce) {
                                                if (c)
                                                    return;
                                                const _ = yield this.waitForTransaction(w.hash, t);
                                                if (A())
                                                    return;
                                                let x = "replaced";
                                                w.data === i.data && w.to === i.to && w.value.eq(i.value) ? x = "repriced" : w.data === "0x" && w.from === w.to && w.value.isZero() && (x = "cancelled"),
                                                a(Tt.makeError("transaction was replaced", xe.errors.TRANSACTION_REPLACED, {
                                                    cancelled: x === "replaced" || x === "cancelled",
                                                    reason: x,
                                                    replacement: this._wrapTransaction(w),
                                                    hash: e,
                                                    receipt: _
                                                }));
                                                return
                                            }
                                        }
                                        h++
                                    }
                                }
                                c || this.once("block", d)
                            }
                        }), g => {
                            c || this.once("block", d)
                        }
                        ))
                    });
                    if (c)
                        return;
                    this.once("block", d),
                    l.push( () => {
                        this.removeListener("block", d)
                    }
                    )
                }
                if (typeof r == "number" && r > 0) {
                    const f = setTimeout( () => {
                        A() || a(Tt.makeError("timeout exceeded", xe.errors.TIMEOUT, {
                            timeout: r
                        }))
                    }
                    , r);
                    f.unref && f.unref(),
                    l.push( () => {
                        clearTimeout(f)
                    }
                    )
                }
            }
            )
        })
    }
    getBlockNumber() {
        return yt(this, void 0, void 0, function*() {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const e = yield this.perform("getGasPrice", {});
            try {
                return je.from(e)
            } catch (t) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result: e,
                    error: t
                })
            }
        })
    }
    getBalance(e, t) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield wr({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(t)
            })
              , i = yield this.perform("getBalance", r);
            try {
                return je.from(i)
            } catch (s) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params: r,
                    result: i,
                    error: s
                })
            }
        })
    }
    getTransactionCount(e, t) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield wr({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(t)
            })
              , i = yield this.perform("getTransactionCount", r);
            try {
                return je.from(i).toNumber()
            } catch (s) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: r,
                    result: i,
                    error: s
                })
            }
        })
    }
    getCode(e, t) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield wr({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(t)
            })
              , i = yield this.perform("getCode", r);
            try {
                return lt(i)
            } catch (s) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "getCode",
                    params: r,
                    result: i,
                    error: s
                })
            }
        })
    }
    getStorageAt(e, t, r) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const i = yield wr({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r),
                position: Promise.resolve(t).then(o => Px(o))
            })
              , s = yield this.perform("getStorageAt", i);
            try {
                return lt(s)
            } catch (o) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: i,
                    result: s,
                    error: o
                })
            }
        })
    }
    _wrapTransaction(e, t, r) {
        if (t != null && Su(t) !== 32)
            throw new Error("invalid response - sendTransaction");
        const i = e;
        return t != null && e.hash !== t && Tt.throwError("Transaction hash mismatch from Provider.sendTransaction.", xe.errors.UNKNOWN_ERROR, {
            expectedHash: e.hash,
            returnedHash: t
        }),
        i.wait = (s, o) => yt(this, void 0, void 0, function*() {
            s == null && (s = 1),
            o == null && (o = 0);
            let a;
            s !== 0 && r != null && (a = {
                data: e.data,
                from: e.from,
                nonce: e.nonce,
                to: e.to,
                value: e.value,
                startBlock: r
            });
            const l = yield this._waitForTransaction(e.hash, s, o, a);
            return l == null && s === 0 ? null : (this._emitted["t:" + e.hash] = l.blockNumber,
            l.status === 0 && Tt.throwError("transaction failed", xe.errors.CALL_EXCEPTION, {
                transactionHash: e.hash,
                transaction: e,
                receipt: l
            }),
            l)
        }),
        i
    }
    sendTransaction(e) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const t = yield Promise.resolve(e).then(s => lt(s))
              , r = this.formatter.transaction(e);
            r.confirmations == null && (r.confirmations = 0);
            const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const s = yield this.perform("sendTransaction", {
                    signedTransaction: t
                });
                return this._wrapTransaction(r, s, i)
            } catch (s) {
                throw s.transaction = r,
                s.transactionHash = r.hash,
                s
            }
        })
    }
    _getTransactionRequest(e) {
        return yt(this, void 0, void 0, function*() {
            const t = yield e
              , r = {};
            return ["from", "to"].forEach(i => {
                t[i] != null && (r[i] = Promise.resolve(t[i]).then(s => s ? this._getAddress(s) : null))
            }
            ),
            ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(i => {
                t[i] != null && (r[i] = Promise.resolve(t[i]).then(s => s ? je.from(s) : null))
            }
            ),
            ["type"].forEach(i => {
                t[i] != null && (r[i] = Promise.resolve(t[i]).then(s => s ?? null))
            }
            ),
            t.accessList && (r.accessList = this.formatter.accessList(t.accessList)),
            ["data"].forEach(i => {
                t[i] != null && (r[i] = Promise.resolve(t[i]).then(s => s ? lt(s) : null))
            }
            ),
            this.formatter.transactionRequest(yield wr(r))
        })
    }
    _getFilter(e) {
        return yt(this, void 0, void 0, function*() {
            e = yield e;
            const t = {};
            return e.address != null && (t.address = this._getAddress(e.address)),
            ["blockHash", "topics"].forEach(r => {
                e[r] != null && (t[r] = e[r])
            }
            ),
            ["fromBlock", "toBlock"].forEach(r => {
                e[r] != null && (t[r] = this._getBlockTag(e[r]))
            }
            ),
            this.formatter.filter(yield wr(t))
        })
    }
    _call(e, t, r) {
        return yt(this, void 0, void 0, function*() {
            r >= BX && Tt.throwError("CCIP read exceeded maximum redirections", xe.errors.SERVER_ERROR, {
                redirects: r,
                transaction: e
            });
            const i = e.to
              , s = yield this.perform("call", {
                transaction: e,
                blockTag: t
            });
            if (r >= 0 && t === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && Su(s) % 32 === 4)
                try {
                    const o = mi(s, 4)
                      , a = mi(o, 0, 32);
                    je.from(a).eq(i) || Tt.throwError("CCIP Read sender did not match", xe.errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction: e,
                        data: s
                    });
                    const l = []
                      , c = je.from(mi(o, 32, 64)).toNumber()
                      , A = je.from(mi(o, c, c + 32)).toNumber()
                      , u = mi(o, c + 32);
                    for (let p = 0; p < A; p++) {
                        const v = sw(u, p * 32);
                        v == null && Tt.throwError("CCIP Read contained corrupt URL string", xe.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: s
                        }),
                        l.push(v)
                    }
                    const f = ug(o, 64);
                    je.from(mi(o, 100, 128)).isZero() || Tt.throwError("CCIP Read callback selector included junk", xe.errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction: e,
                        data: s
                    });
                    const h = mi(o, 96, 100)
                      , d = ug(o, 128)
                      , m = yield this.ccipReadFetch(e, f, l);
                    m == null && Tt.throwError("CCIP Read disabled or provided no URLs", xe.errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction: e,
                        data: s
                    });
                    const g = {
                        to: i,
                        data: $i([h, JQ([m, d])])
                    };
                    return this._call(g, t, r + 1)
                } catch (o) {
                    if (o.code === xe.errors.SERVER_ERROR)
                        throw o
                }
            try {
                return lt(s)
            } catch (o) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "call",
                    params: {
                        transaction: e,
                        blockTag: t
                    },
                    result: s,
                    error: o
                })
            }
        })
    }
    call(e, t) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield wr({
                transaction: this._getTransactionRequest(e),
                blockTag: this._getBlockTag(t),
                ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
            });
            return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1)
        })
    }
    estimateGas(e) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const t = yield wr({
                transaction: this._getTransactionRequest(e)
            })
              , r = yield this.perform("estimateGas", t);
            try {
                return je.from(r)
            } catch (i) {
                return Tt.throwError("bad result from backend", xe.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params: t,
                    result: r,
                    error: i
                })
            }
        })
    }
    _getAddress(e) {
        return yt(this, void 0, void 0, function*() {
            e = yield e,
            typeof e != "string" && Tt.throwArgumentError("invalid address or ENS name", "name", e);
            const t = yield this.resolveName(e);
            return t == null && Tt.throwError("ENS name not configured", xe.errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${JSON.stringify(e)})`
            }),
            t
        })
    }
    _getBlock(e, t) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork(),
            e = yield e;
            let r = -128;
            const i = {
                includeTransactions: !!t
            };
            if (It(e, 32))
                i.blockHash = e;
            else
                try {
                    i.blockTag = yield this._getBlockTag(e),
                    It(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16))
                } catch {
                    Tt.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
                }
            return vh( () => yt(this, void 0, void 0, function*() {
                const s = yield this.perform("getBlock", i);
                if (s == null)
                    return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && r > this._emitted.block ? null : void 0;
                if (t) {
                    let o = null;
                    for (let l = 0; l < s.transactions.length; l++) {
                        const c = s.transactions[l];
                        if (c.blockNumber == null)
                            c.confirmations = 0;
                        else if (c.confirmations == null) {
                            o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                            let A = o - c.blockNumber + 1;
                            A <= 0 && (A = 1),
                            c.confirmations = A
                        }
                    }
                    const a = this.formatter.blockWithTransactions(s);
                    return a.transactions = a.transactions.map(l => this._wrapTransaction(l)),
                    a
                }
                return this.formatter.block(s)
            }), {
                oncePoll: this
            })
        })
    }
    getBlock(e) {
        return this._getBlock(e, !1)
    }
    getBlockWithTransactions(e) {
        return this._getBlock(e, !0)
    }
    getTransaction(e) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork(),
            e = yield e;
            const t = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return vh( () => yt(this, void 0, void 0, function*() {
                const r = yield this.perform("getTransaction", t);
                if (r == null)
                    return this._emitted["t:" + e] == null ? null : void 0;
                const i = this.formatter.transactionResponse(r);
                if (i.blockNumber == null)
                    i.confirmations = 0;
                else if (i.confirmations == null) {
                    let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    o <= 0 && (o = 1),
                    i.confirmations = o
                }
                return this._wrapTransaction(i)
            }), {
                oncePoll: this
            })
        })
    }
    getTransactionReceipt(e) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork(),
            e = yield e;
            const t = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return vh( () => yt(this, void 0, void 0, function*() {
                const r = yield this.perform("getTransactionReceipt", t);
                if (r == null)
                    return this._emitted["t:" + e] == null ? null : void 0;
                if (r.blockHash == null)
                    return;
                const i = this.formatter.receipt(r);
                if (i.blockNumber == null)
                    i.confirmations = 0;
                else if (i.confirmations == null) {
                    let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    o <= 0 && (o = 1),
                    i.confirmations = o
                }
                return i
            }), {
                oncePoll: this
            })
        })
    }
    getLogs(e) {
        return yt(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const t = yield wr({
                filter: this._getFilter(e)
            })
              , r = yield this.perform("getLogs", t);
            return r.forEach(i => {
                i.removed == null && (i.removed = !1)
            }
            ),
            aF.arrayOf(this.formatter.filterLog.bind(this.formatter))(r)
        })
    }
    getEtherPrice() {
        return yt(this, void 0, void 0, function*() {
            return yield this.getNetwork(),
            this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(e) {
        return yt(this, void 0, void 0, function*() {
            if (e = yield e,
            typeof e == "number" && e < 0) {
                e % 1 && Tt.throwArgumentError("invalid BlockTag", "blockTag", e);
                let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                return t += e,
                t < 0 && (t = 0),
                this.formatter.blockTag(t)
            }
            return this.formatter.blockTag(e)
        })
    }
    getResolver(e) {
        return yt(this, void 0, void 0, function*() {
            let t = e;
            for (; ; ) {
                if (t === "" || t === "." || e !== "eth" && t === "eth")
                    return null;
                const r = yield this._getResolver(t, "getResolver");
                if (r != null) {
                    const i = new mF(this,r,e);
                    return t !== e && !(yield i.supportsWildcard()) ? null : i
                }
                t = t.split(".").slice(1).join(".")
            }
        })
    }
    _getResolver(e, t) {
        return yt(this, void 0, void 0, function*() {
            t == null && (t = "ENS");
            const r = yield this.getNetwork();
            r.ensAddress || Tt.throwError("network does not support ENS", xe.errors.UNSUPPORTED_OPERATION, {
                operation: t,
                network: r.name
            });
            try {
                const i = yield this.call({
                    to: r.ensAddress,
                    data: "0x0178b8bf" + nw(e).substring(2)
                });
                return this.formatter.callAddress(i)
            } catch {}
            return null
        })
    }
    resolveName(e) {
        return yt(this, void 0, void 0, function*() {
            e = yield e;
            try {
                return Promise.resolve(this.formatter.address(e))
            } catch (r) {
                if (It(e))
                    throw r
            }
            typeof e != "string" && Tt.throwArgumentError("invalid ENS name", "name", e);
            const t = yield this.getResolver(e);
            return t ? yield t.getAddress() : null
        })
    }
    lookupAddress(e) {
        return yt(this, void 0, void 0, function*() {
            e = yield e,
            e = this.formatter.address(e);
            const t = e.substring(2).toLowerCase() + ".addr.reverse"
              , r = yield this._getResolver(t, "lookupAddress");
            if (r == null)
                return null;
            const i = sw(yield this.call({
                to: r,
                data: "0x691f3431" + nw(t).substring(2)
            }), 0);
            return (yield this.resolveName(i)) != e ? null : i
        })
    }
    getAvatar(e) {
        return yt(this, void 0, void 0, function*() {
            let t = null;
            if (It(e)) {
                const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse"
                  , o = yield this._getResolver(s, "getAvatar");
                if (!o)
                    return null;
                t = new mF(this,o,s);
                try {
                    const a = yield t.getAvatar();
                    if (a)
                        return a.url
                } catch (a) {
                    if (a.code !== xe.errors.CALL_EXCEPTION)
                        throw a
                }
                try {
                    const a = sw(yield this.call({
                        to: o,
                        data: "0x691f3431" + nw(s).substring(2)
                    }), 0);
                    t = yield this.getResolver(a)
                } catch (a) {
                    if (a.code !== xe.errors.CALL_EXCEPTION)
                        throw a;
                    return null
                }
            } else if (t = yield this.getResolver(e),
            !t)
                return null;
            const r = yield t.getAvatar();
            return r == null ? null : r.url
        })
    }
    perform(e, t) {
        return Tt.throwError(e + " not implemented", xe.errors.NOT_IMPLEMENTED, {
            operation: e
        })
    }
    _startEvent(e) {
        this.polling = this._events.filter(t => t.pollable()).length > 0
    }
    _stopEvent(e) {
        this.polling = this._events.filter(t => t.pollable()).length > 0
    }
    _addEventListener(e, t, r) {
        const i = new CX(of(e),t,r);
        return this._events.push(i),
        this._startEvent(i),
        this
    }
    on(e, t) {
        return this._addEventListener(e, t, !1)
    }
    once(e, t) {
        return this._addEventListener(e, t, !0)
    }
    emit(e, ...t) {
        let r = !1
          , i = []
          , s = of(e);
        return this._events = this._events.filter(o => o.tag !== s ? !0 : (setTimeout( () => {
            o.listener.apply(this, t)
        }
        , 0),
        r = !0,
        o.once ? (i.push(o),
        !1) : !0)),
        i.forEach(o => {
            this._stopEvent(o)
        }
        ),
        r
    }
    listenerCount(e) {
        if (!e)
            return this._events.length;
        let t = of(e);
        return this._events.filter(r => r.tag === t).length
    }
    listeners(e) {
        if (e == null)
            return this._events.map(r => r.listener);
        let t = of(e);
        return this._events.filter(r => r.tag === t).map(r => r.listener)
    }
    off(e, t) {
        if (t == null)
            return this.removeAllListeners(e);
        const r = [];
        let i = !1
          , s = of(e);
        return this._events = this._events.filter(o => o.tag !== s || o.listener != t || i ? !0 : (i = !0,
        r.push(o),
        !1)),
        r.forEach(o => {
            this._stopEvent(o)
        }
        ),
        this
    }
    removeAllListeners(e) {
        let t = [];
        if (e == null)
            t = this._events,
            this._events = [];
        else {
            const r = of(e);
            this._events = this._events.filter(i => i.tag !== r ? !0 : (t.push(i),
            !1))
        }
        return t.forEach(r => {
            this._stopEvent(r)
        }
        ),
        this
    }
}
const UX = "abstract-signer/5.7.0";
var Fo = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Js = new xe(UX)
  , FX = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"]
  , PX = [xe.errors.INSUFFICIENT_FUNDS, xe.errors.NONCE_EXPIRED, xe.errors.REPLACEMENT_UNDERPRICED];
class u0 {
    constructor() {
        Js.checkAbstract(new.target, u0),
        Ue(this, "_isSigner", !0)
    }
    getBalance(e) {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("getBalance"),
            yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("getTransactionCount"),
            yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return Fo(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const t = yield wr(this.checkTransaction(e));
            return yield this.provider.estimateGas(t)
        })
    }
    call(e, t) {
        return Fo(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const r = yield wr(this.checkTransaction(e));
            return yield this.provider.call(r, t)
        })
    }
    sendTransaction(e) {
        return Fo(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const t = yield this.populateTransaction(e)
              , r = yield this.signTransaction(t);
            return yield this.provider.sendTransaction(r)
        })
    }
    getChainId() {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("getChainId"),
            (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("getGasPrice"),
            yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("getFeeData"),
            yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return Fo(this, void 0, void 0, function*() {
            return this._checkProvider("resolveName"),
            yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const r in e)
            FX.indexOf(r) === -1 && Js.throwArgumentError("invalid transaction key: " + r, "transaction", e);
        const t = Qn(e);
        return t.from == null ? t.from = this.getAddress() : t.from = Promise.all([Promise.resolve(t.from), this.getAddress()]).then(r => (r[0].toLowerCase() !== r[1].toLowerCase() && Js.throwArgumentError("from address mismatch", "transaction", e),
        r[0])),
        t
    }
    populateTransaction(e) {
        return Fo(this, void 0, void 0, function*() {
            const t = yield wr(this.checkTransaction(e));
            t.to != null && (t.to = Promise.resolve(t.to).then(i => Fo(this, void 0, void 0, function*() {
                if (i == null)
                    return null;
                const s = yield this.resolveName(i);
                return s == null && Js.throwArgumentError("provided ENS name resolves to null", "tx.to", i),
                s
            })),
            t.to.catch(i => {}
            ));
            const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
            if (t.gasPrice != null && (t.type === 2 || r) ? Js.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (t.type === 0 || t.type === 1) && r && Js.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e),
            (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
                t.type = 2;
            else if (t.type === 0 || t.type === 1)
                t.gasPrice == null && (t.gasPrice = this.getGasPrice());
            else {
                const i = yield this.getFeeData();
                if (t.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (t.type = 2,
                        t.gasPrice != null) {
                            const s = t.gasPrice;
                            delete t.gasPrice,
                            t.maxFeePerGas = s,
                            t.maxPriorityFeePerGas = s
                        } else
                            t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas),
                            t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
                    else
                        i.gasPrice != null ? (r && Js.throwError("network does not support EIP-1559", xe.errors.UNSUPPORTED_OPERATION, {
                            operation: "populateTransaction"
                        }),
                        t.gasPrice == null && (t.gasPrice = i.gasPrice),
                        t.type = 0) : Js.throwError("failed to get consistent fee data", xe.errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                else
                    t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas),
                    t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return t.nonce == null && (t.nonce = this.getTransactionCount("pending")),
            t.gasLimit == null && (t.gasLimit = this.estimateGas(t).catch(i => {
                if (PX.indexOf(i.code) >= 0)
                    throw i;
                return Js.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", xe.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: i,
                    tx: t
                })
            }
            )),
            t.chainId == null ? t.chainId = this.getChainId() : t.chainId = Promise.all([Promise.resolve(t.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && Js.throwArgumentError("chainId address mismatch", "transaction", e),
            i[0])),
            yield wr(t)
        })
    }
    _checkProvider(e) {
        this.provider || Js.throwError("missing provider", xe.errors.UNSUPPORTED_OPERATION, {
            operation: e || "_checkProvider"
        })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class gI extends u0 {
    constructor(e, t) {
        super(),
        Ue(this, "address", e),
        Ue(this, "provider", t || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, t) {
        return Promise.resolve().then( () => {
            Js.throwError(e, xe.errors.UNSUPPORTED_OPERATION, {
                operation: t
            })
        }
        )
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, t, r) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new gI(this.address,e)
    }
}
var Tl = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const _r = new xe(Ci)
  , LX = ["call", "estimateGas"];
function km(n, e) {
    if (n == null)
        return null;
    if (typeof n.message == "string" && n.message.match("reverted")) {
        const t = It(n.data) ? n.data : null;
        if (!e || t)
            return {
                message: n.message,
                data: t
            }
    }
    if (typeof n == "object") {
        for (const t in n) {
            const r = km(n[t], e);
            if (r)
                return r
        }
        return null
    }
    if (typeof n == "string")
        try {
            return km(JSON.parse(n), e)
        } catch {}
    return null
}
function qQ(n, e, t) {
    const r = t.transaction || t.signedTransaction;
    if (n === "call") {
        const s = km(e, !0);
        if (s)
            return s.data;
        _r.throwError("missing revert data in call exception; Transaction reverted without a reason string", xe.errors.CALL_EXCEPTION, {
            data: "0x",
            transaction: r,
            error: e
        })
    }
    if (n === "estimateGas") {
        let s = km(e.body, !1);
        s == null && (s = km(e, !1)),
        s && _r.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", xe.errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: s.message,
            method: n,
            transaction: r,
            error: e
        })
    }
    let i = e.message;
    throw e.code === xe.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? i = e.error.message : typeof e.body == "string" ? i = e.body : typeof e.responseText == "string" && (i = e.responseText),
    i = (i || "").toLowerCase(),
    i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && _r.throwError("insufficient funds for intrinsic transaction cost", xe.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: n,
        transaction: r
    }),
    i.match(/nonce (is )?too low/i) && _r.throwError("nonce has already been used", xe.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: r
    }),
    i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && _r.throwError("replacement fee too low", xe.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: n,
        transaction: r
    }),
    i.match(/only replay-protected/i) && _r.throwError("legacy pre-eip-155 transactions not supported", xe.errors.UNSUPPORTED_OPERATION, {
        error: e,
        method: n,
        transaction: r
    }),
    LX.indexOf(n) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && _r.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", xe.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: n,
        transaction: r
    }),
    e
}
function gF(n) {
    return new Promise(function(e) {
        setTimeout(e, n)
    }
    )
}
function DX(n) {
    if (n.error) {
        const e = new Error(n.error.message);
        throw e.code = n.error.code,
        e.data = n.error.data,
        e
    }
    return n.result
}
function vp(n) {
    return n && n.toLowerCase()
}
const OM = {};
class eH extends u0 {
    constructor(e, t, r) {
        if (super(),
        e !== OM)
            throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        Ue(this, "provider", t),
        r == null && (r = 0),
        typeof r == "string" ? (Ue(this, "_address", this.provider.formatter.address(r)),
        Ue(this, "_index", null)) : typeof r == "number" ? (Ue(this, "_index", r),
        Ue(this, "_address", null)) : _r.throwArgumentError("invalid address or index", "addressOrIndex", r)
    }
    connect(e) {
        return _r.throwError("cannot alter JSON-RPC Signer connection", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        })
    }
    connectUnchecked() {
        return new NX(OM,this.provider,this._address || this._index)
    }
    getAddress() {
        return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(e => (e.length <= this._index && _r.throwError("unknown account #" + this._index, xe.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
        }),
        this.provider.formatter.address(e[this._index])))
    }
    sendUncheckedTransaction(e) {
        e = Qn(e);
        const t = this.getAddress().then(r => (r && (r = r.toLowerCase()),
        r));
        if (e.gasLimit == null) {
            const r = Qn(e);
            r.from = t,
            e.gasLimit = this.provider.estimateGas(r)
        }
        return e.to != null && (e.to = Promise.resolve(e.to).then(r => Tl(this, void 0, void 0, function*() {
            if (r == null)
                return null;
            const i = yield this.provider.resolveName(r);
            return i == null && _r.throwArgumentError("provided ENS name resolves to null", "tx.to", r),
            i
        }))),
        wr({
            tx: wr(e),
            sender: t
        }).then( ({tx: r, sender: i}) => {
            r.from != null ? r.from.toLowerCase() !== i && _r.throwArgumentError("from address mismatch", "transaction", e) : r.from = i;
            const s = this.provider.constructor.hexlifyTransaction(r, {
                from: !0
            });
            return this.provider.send("eth_sendTransaction", [s]).then(o => o, o => (typeof o.message == "string" && o.message.match(/user denied/i) && _r.throwError("user rejected transaction", xe.errors.ACTION_REJECTED, {
                action: "sendTransaction",
                transaction: r
            }),
            qQ("sendTransaction", o, s)))
        }
        )
    }
    signTransaction(e) {
        return _r.throwError("signing transactions is unsupported", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        })
    }
    sendTransaction(e) {
        return Tl(this, void 0, void 0, function*() {
            const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)
              , r = yield this.sendUncheckedTransaction(e);
            try {
                return yield vh( () => Tl(this, void 0, void 0, function*() {
                    const i = yield this.provider.getTransaction(r);
                    if (i !== null)
                        return this.provider._wrapTransaction(i, r, t)
                }), {
                    oncePoll: this.provider
                })
            } catch (i) {
                throw i.transactionHash = r,
                i
            }
        })
    }
    signMessage(e) {
        return Tl(this, void 0, void 0, function*() {
            const t = typeof e == "string" ? $a(e) : e
              , r = yield this.getAddress();
            try {
                return yield this.provider.send("personal_sign", [lt(t), r.toLowerCase()])
            } catch (i) {
                throw typeof i.message == "string" && i.message.match(/user denied/i) && _r.throwError("user rejected signing", xe.errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: r,
                    messageData: e
                }),
                i
            }
        })
    }
    _legacySignMessage(e) {
        return Tl(this, void 0, void 0, function*() {
            const t = typeof e == "string" ? $a(e) : e
              , r = yield this.getAddress();
            try {
                return yield this.provider.send("eth_sign", [r.toLowerCase(), lt(t)])
            } catch (i) {
                throw typeof i.message == "string" && i.message.match(/user denied/i) && _r.throwError("user rejected signing", xe.errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: r,
                    messageData: e
                }),
                i
            }
        })
    }
    _signTypedData(e, t, r) {
        return Tl(this, void 0, void 0, function*() {
            const i = yield ws.resolveNames(e, t, r, o => this.provider.resolveName(o))
              , s = yield this.getAddress();
            try {
                return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(ws.getPayload(i.domain, t, i.value))])
            } catch (o) {
                throw typeof o.message == "string" && o.message.match(/user denied/i) && _r.throwError("user rejected signing", xe.errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: s,
                    messageData: {
                        domain: i.domain,
                        types: t,
                        value: i.value
                    }
                }),
                o
            }
        })
    }
    unlock(e) {
        return Tl(this, void 0, void 0, function*() {
            const t = this.provider
              , r = yield this.getAddress();
            return t.send("personal_unlockAccount", [r.toLowerCase(), e, null])
        })
    }
}
class NX extends eH {
    sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then(t => ({
            hash: t,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: r => this.provider.waitForTransaction(t, r)
        }))
    }
}
const OX = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0
};
class fg extends mI {
    constructor(e, t) {
        let r = t;
        r == null && (r = new Promise( (i, s) => {
            setTimeout( () => {
                this.detectNetwork().then(o => {
                    i(o)
                }
                , o => {
                    s(o)
                }
                )
            }
            , 0)
        }
        )),
        super(r),
        e || (e = Cs(this.constructor, "defaultUrl")()),
        typeof e == "string" ? Ue(this, "connection", Object.freeze({
            url: e
        })) : Ue(this, "connection", Object.freeze(Qn(e))),
        this._nextId = 42
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}),
        this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(),
        setTimeout( () => {
            this._cache.detectNetwork = null
        }
        , 0)),
        this._cache.detectNetwork
    }
    _uncachedDetectNetwork() {
        return Tl(this, void 0, void 0, function*() {
            yield gF(0);
            let e = null;
            try {
                e = yield this.send("eth_chainId", [])
            } catch {
                try {
                    e = yield this.send("net_version", [])
                } catch {}
            }
            if (e != null) {
                const t = Cs(this.constructor, "getNetwork");
                try {
                    return t(je.from(e).toNumber())
                } catch (r) {
                    return _r.throwError("could not detect network", xe.errors.NETWORK_ERROR, {
                        chainId: e,
                        event: "invalidNetwork",
                        serverError: r
                    })
                }
            }
            return _r.throwError("could not detect network", xe.errors.NETWORK_ERROR, {
                event: "noNetwork"
            })
        })
    }
    getSigner(e) {
        return new eH(OM,this,e)
    }
    getUncheckedSigner(e) {
        return this.getSigner(e).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then(e => e.map(t => this.formatter.address(t)))
    }
    send(e, t) {
        const r = {
            method: e,
            params: t,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: Ps(r),
            provider: this
        });
        const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
        if (i && this._cache[e])
            return this._cache[e];
        const s = kx(this.connection, JSON.stringify(r), DX).then(o => (this.emit("debug", {
            action: "response",
            request: r,
            response: o,
            provider: this
        }),
        o), o => {
            throw this.emit("debug", {
                action: "response",
                error: o,
                request: r,
                provider: this
            }),
            o
        }
        );
        return i && (this._cache[e] = s,
        setTimeout( () => {
            this._cache[e] = null
        }
        , 0)),
        s
    }
    prepareRequest(e, t) {
        switch (e) {
        case "getBlockNumber":
            return ["eth_blockNumber", []];
        case "getGasPrice":
            return ["eth_gasPrice", []];
        case "getBalance":
            return ["eth_getBalance", [vp(t.address), t.blockTag]];
        case "getTransactionCount":
            return ["eth_getTransactionCount", [vp(t.address), t.blockTag]];
        case "getCode":
            return ["eth_getCode", [vp(t.address), t.blockTag]];
        case "getStorageAt":
            return ["eth_getStorageAt", [vp(t.address), ir(t.position, 32), t.blockTag]];
        case "sendTransaction":
            return ["eth_sendRawTransaction", [t.signedTransaction]];
        case "getBlock":
            return t.blockTag ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]] : null;
        case "getTransaction":
            return ["eth_getTransactionByHash", [t.transactionHash]];
        case "getTransactionReceipt":
            return ["eth_getTransactionReceipt", [t.transactionHash]];
        case "call":
            return ["eth_call", [Cs(this.constructor, "hexlifyTransaction")(t.transaction, {
                from: !0
            }), t.blockTag]];
        case "estimateGas":
            return ["eth_estimateGas", [Cs(this.constructor, "hexlifyTransaction")(t.transaction, {
                from: !0
            })]];
        case "getLogs":
            return t.filter && t.filter.address != null && (t.filter.address = vp(t.filter.address)),
            ["eth_getLogs", [t.filter]]
        }
        return null
    }
    perform(e, t) {
        return Tl(this, void 0, void 0, function*() {
            if (e === "call" || e === "estimateGas") {
                const i = t.transaction;
                if (i && i.type != null && je.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                    const s = yield this.getFeeData();
                    s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (t = Qn(t),
                    t.transaction = Qn(i),
                    delete t.transaction.type)
                }
            }
            const r = this.prepareRequest(e, t);
            r == null && _r.throwError(e + " not implemented", xe.errors.NOT_IMPLEMENTED, {
                operation: e
            });
            try {
                return yield this.send(r[0], r[1])
            } catch (i) {
                return qQ(e, i, t)
            }
        })
    }
    _startEvent(e) {
        e.tag === "pending" && this._startPending(),
        super._startEvent(e)
    }
    _startPending() {
        if (this._pendingFilter != null)
            return;
        const e = this
          , t = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = t,
        t.then(function(r) {
            function i() {
                e.send("eth_getFilterChanges", [r]).then(function(s) {
                    if (e._pendingFilter != t)
                        return null;
                    let o = Promise.resolve();
                    return s.forEach(function(a) {
                        e._emitted["t:" + a.toLowerCase()] = "pending",
                        o = o.then(function() {
                            return e.getTransaction(a).then(function(l) {
                                return e.emit("pending", l),
                                null
                            })
                        })
                    }),
                    o.then(function() {
                        return gF(1e3)
                    })
                }).then(function() {
                    if (e._pendingFilter != t) {
                        e.send("eth_uninstallFilter", [r]);
                        return
                    }
                    return setTimeout(function() {
                        i()
                    }, 0),
                    null
                }).catch(s => {}
                )
            }
            return i(),
            r
        }).catch(r => {}
        )
    }
    _stopEvent(e) {
        e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null),
        super._stopEvent(e)
    }
    static hexlifyTransaction(e, t) {
        const r = Qn(OX);
        if (t)
            for (const s in t)
                t[s] && (r[s] = !0);
        f9(e, r);
        const i = {};
        return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
            if (e[s] == null)
                return;
            const o = Px(je.from(e[s]));
            s === "gasLimit" && (s = "gas"),
            i[s] = o
        }),
        ["from", "to", "data"].forEach(function(s) {
            e[s] != null && (i[s] = lt(e[s]))
        }),
        e.accessList && (i.accessList = Wu(e.accessList)),
        i
    }
}
let Qm = null;
try {
    if (Qm = WebSocket,
    Qm == null)
        throw new Error("inject please")
} catch {
    const e = new xe(Ci);
    Qm = function() {
        e.throwError("WebSockets not supported in this environment", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        })
    }
}
var Ub = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const G0 = new xe(Ci);
let kX = 1;
class vI extends fg {
    constructor(e, t) {
        t === "any" && G0.throwError("WebSocketProvider does not support 'any' network yet", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
        }),
        typeof e == "string" ? super(e, t) : super("_websocket", t),
        this._pollingInterval = -1,
        this._wsReady = !1,
        typeof e == "string" ? Ue(this, "_websocket", new Qm(this.connection.url)) : Ue(this, "_websocket", e),
        Ue(this, "_requests", {}),
        Ue(this, "_subs", {}),
        Ue(this, "_subIds", {}),
        Ue(this, "_detectNetwork", super.detectNetwork()),
        this.websocket.onopen = () => {
            this._wsReady = !0,
            Object.keys(this._requests).forEach(i => {
                this.websocket.send(this._requests[i].payload)
            }
            )
        }
        ,
        this.websocket.onmessage = i => {
            const s = i.data
              , o = JSON.parse(s);
            if (o.id != null) {
                const a = String(o.id)
                  , l = this._requests[a];
                if (delete this._requests[a],
                o.result !== void 0)
                    l.callback(null, o.result),
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(l.payload),
                        response: o.result,
                        provider: this
                    });
                else {
                    let c = null;
                    o.error ? (c = new Error(o.error.message || "unknown error"),
                    Ue(c, "code", o.error.code || null),
                    Ue(c, "response", s)) : c = new Error("unknown error"),
                    l.callback(c, void 0),
                    this.emit("debug", {
                        action: "response",
                        error: c,
                        request: JSON.parse(l.payload),
                        provider: this
                    })
                }
            } else if (o.method === "eth_subscription") {
                const a = this._subs[o.params.subscription];
                a && a.processFunc(o.params.result)
            } else
                console.warn("this should not happen")
        }
        ;
        const r = setInterval( () => {
            this.emit("poll")
        }
        , 1e3);
        r.unref && r.unref()
    }
    get websocket() {
        return this._websocket
    }
    detectNetwork() {
        return this._detectNetwork
    }
    get pollingInterval() {
        return 0
    }
    resetEventsBlock(e) {
        G0.throwError("cannot reset events block on WebSocketProvider", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        })
    }
    set pollingInterval(e) {
        G0.throwError("cannot set polling interval on WebSocketProvider", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        })
    }
    poll() {
        return Ub(this, void 0, void 0, function*() {
            return null
        })
    }
    set polling(e) {
        e && G0.throwError("cannot set polling on WebSocketProvider", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        })
    }
    send(e, t) {
        const r = kX++;
        return new Promise( (i, s) => {
            function o(l, c) {
                return l ? s(l) : i(c)
            }
            const a = JSON.stringify({
                method: e,
                params: t,
                id: r,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(a),
                provider: this
            }),
            this._requests[String(r)] = {
                callback: o,
                payload: a
            },
            this._wsReady && this.websocket.send(a)
        }
        )
    }
    static defaultUrl() {
        return "ws://localhost:8546"
    }
    _subscribe(e, t, r) {
        return Ub(this, void 0, void 0, function*() {
            let i = this._subIds[e];
            i == null && (i = Promise.all(t).then(o => this.send("eth_subscribe", o)),
            this._subIds[e] = i);
            const s = yield i;
            this._subs[s] = {
                tag: e,
                processFunc: r
            }
        })
    }
    _startEvent(e) {
        switch (e.type) {
        case "block":
            this._subscribe("block", ["newHeads"], t => {
                const r = je.from(t.number).toNumber();
                this._emitted.block = r,
                this.emit("block", r)
            }
            );
            break;
        case "pending":
            this._subscribe("pending", ["newPendingTransactions"], t => {
                this.emit("pending", t)
            }
            );
            break;
        case "filter":
            this._subscribe(e.tag, ["logs", this._getFilter(e.filter)], t => {
                t.removed == null && (t.removed = !1),
                this.emit(e.filter, this.formatter.filterLog(t))
            }
            );
            break;
        case "tx":
            {
                const t = r => {
                    const i = r.hash;
                    this.getTransactionReceipt(i).then(s => {
                        s && this.emit(i, s)
                    }
                    )
                }
                ;
                t(e),
                this._subscribe("tx", ["newHeads"], r => {
                    this._events.filter(i => i.type === "tx").forEach(t)
                }
                );
                break
            }
        case "debug":
        case "poll":
        case "willPoll":
        case "didPoll":
        case "error":
            break;
        default:
            console.log("unhandled:", e);
            break
        }
    }
    _stopEvent(e) {
        let t = e.tag;
        if (e.type === "tx") {
            if (this._events.filter(i => i.type === "tx").length)
                return;
            t = "tx"
        } else if (this.listenerCount(e.event))
            return;
        const r = this._subIds[t];
        r && (delete this._subIds[t],
        r.then(i => {
            this._subs[i] && (delete this._subs[i],
            this.send("eth_unsubscribe", [i]))
        }
        ))
    }
    destroy() {
        return Ub(this, void 0, void 0, function*() {
            this.websocket.readyState === Qm.CONNECTING && (yield new Promise(e => {
                this.websocket.onopen = function() {
                    e(!0)
                }
                ,
                this.websocket.onerror = function() {
                    e(!1)
                }
            }
            )),
            this.websocket.close(1e3)
        })
    }
}
var QX = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const dm = new xe(Ci);
class tH extends fg {
    detectNetwork() {
        const e = Object.create(null, {
            detectNetwork: {
                get: () => super.detectNetwork
            }
        });
        return QX(this, void 0, void 0, function*() {
            let t = this.network;
            return t == null && (t = yield e.detectNetwork.call(this),
            t || dm.throwError("no network detected", xe.errors.UNKNOWN_ERROR, {}),
            this._network == null && (Ue(this, "_network", t),
            this.emit("network", t, null))),
            t
        })
    }
}
class SA extends tH {
    constructor(e, t) {
        dm.checkAbstract(new.target, SA),
        e = Cs(new.target, "getNetwork")(e),
        t = Cs(new.target, "getApiKey")(t);
        const r = Cs(new.target, "getUrl")(e, t);
        super(r, e),
        typeof t == "string" ? Ue(this, "apiKey", t) : t != null && Object.keys(t).forEach(i => {
            Ue(this, i, t[i])
        }
        )
    }
    _startPending() {
        dm.warn("WARNING: API provider does not support pending filters")
    }
    isCommunityResource() {
        return !1
    }
    getSigner(e) {
        return dm.throwError("API provider does not support signing", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "getSigner"
        })
    }
    listAccounts() {
        return Promise.resolve([])
    }
    static getApiKey(e) {
        return e
    }
    static getUrl(e, t) {
        return dm.throwError("not implemented; sub-classes must override getUrl", xe.errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        })
    }
}
const vF = new xe(Ci)
  , ow = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class HX extends vI {
    constructor(e, t) {
        const r = new nH(e,t)
          , i = r.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        super(i, r.network),
        Ue(this, "apiKey", r.apiKey)
    }
    isCommunityResource() {
        return this.apiKey === ow
    }
}
class nH extends SA {
    static getWebSocketProvider(e, t) {
        return new HX(e,t)
    }
    static getApiKey(e) {
        return e == null ? ow : (e && typeof e != "string" && vF.throwArgumentError("invalid apiKey", "apiKey", e),
        e)
    }
    static getUrl(e, t) {
        let r = null;
        switch (e.name) {
        case "homestead":
            r = "eth-mainnet.alchemyapi.io/v2/";
            break;
        case "goerli":
            r = "eth-goerli.g.alchemy.com/v2/";
            break;
        case "matic":
            r = "polygon-mainnet.g.alchemy.com/v2/";
            break;
        case "maticmum":
            r = "polygon-mumbai.g.alchemy.com/v2/";
            break;
        case "arbitrum":
            r = "arb-mainnet.g.alchemy.com/v2/";
            break;
        case "arbitrum-goerli":
            r = "arb-goerli.g.alchemy.com/v2/";
            break;
        case "optimism":
            r = "opt-mainnet.g.alchemy.com/v2/";
            break;
        case "optimism-goerli":
            r = "opt-goerli.g.alchemy.com/v2/";
            break;
        default:
            vF.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return {
            allowGzip: !0,
            url: "https://" + r + t,
            throttleCallback: (i, s) => (t === ow && Gx(),
            Promise.resolve(!0))
        }
    }
    isCommunityResource() {
        return this.apiKey === ow
    }
}
const zX = new xe(Ci)
  , V0 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function GX(n) {
    switch (n) {
    case "homestead":
        return "rpc.ankr.com/eth/";
    case "ropsten":
        return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
        return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
        return "rpc.ankr.com/eth_goerli/";
    case "matic":
        return "rpc.ankr.com/polygon/";
    case "arbitrum":
        return "rpc.ankr.com/arbitrum/"
    }
    return zX.throwArgumentError("unsupported network", "name", n)
}
class VX extends SA {
    isCommunityResource() {
        return this.apiKey === V0
    }
    static getApiKey(e) {
        return e ?? V0
    }
    static getUrl(e, t) {
        t == null && (t = V0);
        const r = {
            allowGzip: !0,
            url: "https://" + GX(e.name) + t,
            throttleCallback: (i, s) => (t.apiKey === V0 && Gx(),
            Promise.resolve(!0))
        };
        return t.projectSecret != null && (r.user = "",
        r.password = t.projectSecret),
        r
    }
}
var jX = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const yF = new xe(Ci);
class WX extends SA {
    static getApiKey(e) {
        return e != null && yF.throwArgumentError("apiKey not supported for cloudflare", "apiKey", e),
        null
    }
    static getUrl(e, t) {
        let r = null;
        switch (e.name) {
        case "homestead":
            r = "https://cloudflare-eth.com/";
            break;
        default:
            yF.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return r
    }
    perform(e, t) {
        const r = Object.create(null, {
            perform: {
                get: () => super.perform
            }
        });
        return jX(this, void 0, void 0, function*() {
            return e === "getBlockNumber" ? (yield r.perform.call(this, "getBlock", {
                blockTag: "latest"
            })).number : r.perform.call(this, e, t)
        })
    }
}
var j0 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const Hc = new xe(Ci);
function wF(n) {
    const e = {};
    for (let t in n) {
        if (n[t] == null)
            continue;
        let r = n[t];
        t === "type" && r === 0 || ({
            type: !0,
            gasLimit: !0,
            gasPrice: !0,
            maxFeePerGs: !0,
            maxPriorityFeePerGas: !0,
            nonce: !0,
            value: !0
        }[t] ? r = Px(lt(r)) : t === "accessList" ? r = "[" + Wu(r).map(i => `{address:"${i.address}",storageKeys:["${i.storageKeys.join('","')}"]}`).join(",") + "]" : r = lt(r),
        e[t] = r)
    }
    return e
}
function KX(n) {
    if (n.status == 0 && (n.message === "No records found" || n.message === "No transactions found"))
        return n.result;
    if (n.status != 1 || typeof n.message != "string" || !n.message.match(/^OK/)) {
        const e = new Error("invalid response");
        throw e.result = JSON.stringify(n),
        (n.result || "").toLowerCase().indexOf("rate limit") >= 0 && (e.throttleRetry = !0),
        e
    }
    return n.result
}
function _F(n) {
    if (n && n.status == 0 && n.message == "NOTOK" && (n.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const e = new Error("throttled response");
        throw e.result = JSON.stringify(n),
        e.throttleRetry = !0,
        e
    }
    if (n.jsonrpc != "2.0") {
        const e = new Error("invalid response");
        throw e.result = JSON.stringify(n),
        e
    }
    if (n.error) {
        const e = new Error(n.error.message || "unknown error");
        throw n.error.code && (e.code = n.error.code),
        n.error.data && (e.data = n.error.data),
        e
    }
    return n.result
}
function xF(n) {
    if (n === "pending")
        throw new Error("pending not supported");
    return n === "latest" ? n : parseInt(n.substring(2), 16)
}
function Fb(n, e, t) {
    if (n === "call" && e.code === xe.errors.SERVER_ERROR) {
        const i = e.error;
        if (i && (i.message.match(/reverted/i) || i.message.match(/VM execution error/i))) {
            let s = i.data;
            if (s && (s = "0x" + s.replace(/^.*0x/i, "")),
            It(s))
                return s;
            Hc.throwError("missing revert data in call exception", xe.errors.CALL_EXCEPTION, {
                error: e,
                data: "0x"
            })
        }
    }
    let r = e.message;
    throw e.code === xe.errors.SERVER_ERROR && (e.error && typeof e.error.message == "string" ? r = e.error.message : typeof e.body == "string" ? r = e.body : typeof e.responseText == "string" && (r = e.responseText)),
    r = (r || "").toLowerCase(),
    r.match(/insufficient funds/) && Hc.throwError("insufficient funds for intrinsic transaction cost", xe.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: n,
        transaction: t
    }),
    r.match(/same hash was already imported|transaction nonce is too low|nonce too low/) && Hc.throwError("nonce has already been used", xe.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: t
    }),
    r.match(/another transaction with same nonce/) && Hc.throwError("replacement fee too low", xe.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: n,
        transaction: t
    }),
    r.match(/execution failed due to an exception|execution reverted/) && Hc.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", xe.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: n,
        transaction: t
    }),
    e
}
class XX extends mI {
    constructor(e, t) {
        super(e),
        Ue(this, "baseUrl", this.getBaseUrl()),
        Ue(this, "apiKey", t || null)
    }
    getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
        case "homestead":
            return "https://api.etherscan.io";
        case "goerli":
            return "https://api-goerli.etherscan.io";
        case "sepolia":
            return "https://api-sepolia.etherscan.io";
        case "matic":
            return "https://api.polygonscan.com";
        case "maticmum":
            return "https://api-testnet.polygonscan.com";
        case "arbitrum":
            return "https://api.arbiscan.io";
        case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
        case "optimism":
            return "https://api-optimistic.etherscan.io";
        case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io"
        }
        return Hc.throwArgumentError("unsupported network", "network", this.network.name)
    }
    getUrl(e, t) {
        const r = Object.keys(t).reduce( (s, o) => {
            const a = t[o];
            return a != null && (s += `&${o}=${a}`),
            s
        }
        , "")
          , i = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.baseUrl}/api?module=${e}${r}${i}`
    }
    getPostUrl() {
        return `${this.baseUrl}/api`
    }
    getPostData(e, t) {
        return t.module = e,
        t.apikey = this.apiKey,
        t
    }
    fetch(e, t, r) {
        return j0(this, void 0, void 0, function*() {
            const i = r ? this.getPostUrl() : this.getUrl(e, t)
              , s = r ? this.getPostData(e, t) : null
              , o = e === "proxy" ? _F : KX;
            this.emit("debug", {
                action: "request",
                request: i,
                provider: this
            });
            const a = {
                url: i,
                throttleSlotInterval: 1e3,
                throttleCallback: (A, u) => (this.isCommunityResource() && Gx(),
                Promise.resolve(!0))
            };
            let l = null;
            s && (a.headers = {
                "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            l = Object.keys(s).map(A => `${A}=${s[A]}`).join("&"));
            const c = yield kx(a, l, o || _F);
            return this.emit("debug", {
                action: "response",
                request: i,
                response: Ps(c),
                provider: this
            }),
            c
        })
    }
    detectNetwork() {
        return j0(this, void 0, void 0, function*() {
            return this.network
        })
    }
    perform(e, t) {
        const r = Object.create(null, {
            perform: {
                get: () => super.perform
            }
        });
        return j0(this, void 0, void 0, function*() {
            switch (e) {
            case "getBlockNumber":
                return this.fetch("proxy", {
                    action: "eth_blockNumber"
                });
            case "getGasPrice":
                return this.fetch("proxy", {
                    action: "eth_gasPrice"
                });
            case "getBalance":
                return this.fetch("account", {
                    action: "balance",
                    address: t.address,
                    tag: t.blockTag
                });
            case "getTransactionCount":
                return this.fetch("proxy", {
                    action: "eth_getTransactionCount",
                    address: t.address,
                    tag: t.blockTag
                });
            case "getCode":
                return this.fetch("proxy", {
                    action: "eth_getCode",
                    address: t.address,
                    tag: t.blockTag
                });
            case "getStorageAt":
                return this.fetch("proxy", {
                    action: "eth_getStorageAt",
                    address: t.address,
                    position: t.position,
                    tag: t.blockTag
                });
            case "sendTransaction":
                return this.fetch("proxy", {
                    action: "eth_sendRawTransaction",
                    hex: t.signedTransaction
                }, !0).catch(i => Fb("sendTransaction", i, t.signedTransaction));
            case "getBlock":
                if (t.blockTag)
                    return this.fetch("proxy", {
                        action: "eth_getBlockByNumber",
                        tag: t.blockTag,
                        boolean: t.includeTransactions ? "true" : "false"
                    });
                throw new Error("getBlock by blockHash not implemented");
            case "getTransaction":
                return this.fetch("proxy", {
                    action: "eth_getTransactionByHash",
                    txhash: t.transactionHash
                });
            case "getTransactionReceipt":
                return this.fetch("proxy", {
                    action: "eth_getTransactionReceipt",
                    txhash: t.transactionHash
                });
            case "call":
                {
                    if (t.blockTag !== "latest")
                        throw new Error("EtherscanProvider does not support blockTag for call");
                    const i = wF(t.transaction);
                    i.module = "proxy",
                    i.action = "eth_call";
                    try {
                        return yield this.fetch("proxy", i, !0)
                    } catch (s) {
                        return Fb("call", s, t.transaction)
                    }
                }
            case "estimateGas":
                {
                    const i = wF(t.transaction);
                    i.module = "proxy",
                    i.action = "eth_estimateGas";
                    try {
                        return yield this.fetch("proxy", i, !0)
                    } catch (s) {
                        return Fb("estimateGas", s, t.transaction)
                    }
                }
            case "getLogs":
                {
                    const i = {
                        action: "getLogs"
                    };
                    if (t.filter.fromBlock && (i.fromBlock = xF(t.filter.fromBlock)),
                    t.filter.toBlock && (i.toBlock = xF(t.filter.toBlock)),
                    t.filter.address && (i.address = t.filter.address),
                    t.filter.topics && t.filter.topics.length > 0 && (t.filter.topics.length > 1 && Hc.throwError("unsupported topic count", xe.errors.UNSUPPORTED_OPERATION, {
                        topics: t.filter.topics
                    }),
                    t.filter.topics.length === 1)) {
                        const a = t.filter.topics[0];
                        (typeof a != "string" || a.length !== 66) && Hc.throwError("unsupported topic format", xe.errors.UNSUPPORTED_OPERATION, {
                            topic0: a
                        }),
                        i.topic0 = a
                    }
                    const s = yield this.fetch("logs", i);
                    let o = {};
                    for (let a = 0; a < s.length; a++) {
                        const l = s[a];
                        if (l.blockHash == null) {
                            if (o[l.blockNumber] == null) {
                                const c = yield this.getBlock(l.blockNumber);
                                c && (o[l.blockNumber] = c.hash)
                            }
                            l.blockHash = o[l.blockNumber]
                        }
                    }
                    return s
                }
            case "getEtherPrice":
                return this.network.name !== "homestead" ? 0 : parseFloat((yield this.fetch("stats", {
                    action: "ethprice"
                })).ethusd)
            }
            return r.perform.call(this, e, t)
        })
    }
    getHistory(e, t, r) {
        return j0(this, void 0, void 0, function*() {
            const i = {
                action: "txlist",
                address: yield this.resolveName(e),
                startblock: t ?? 0,
                endblock: r ?? 99999999,
                sort: "asc"
            };
            return (yield this.fetch("account", i)).map(o => {
                ["contractAddress", "to"].forEach(function(l) {
                    o[l] == "" && delete o[l]
                }),
                o.creates == null && o.contractAddress != null && (o.creates = o.contractAddress);
                const a = this.formatter.transactionResponse(o);
                return o.timeStamp && (a.timestamp = parseInt(o.timeStamp)),
                a
            }
            )
        })
    }
    isCommunityResource() {
        return this.apiKey == null
    }
}
function YX(n) {
    n = n.slice();
    for (let e = n.length - 1; e > 0; e--) {
        const t = Math.floor(Math.random() * (e + 1))
          , r = n[e];
        n[e] = n[t],
        n[t] = r
    }
    return n
}
var t_ = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const ou = new xe(Ci);
function W0() {
    return new Date().getTime()
}
function bF(n) {
    let e = null;
    for (let t = 0; t < n.length; t++) {
        const r = n[t];
        if (r == null)
            return null;
        e ? e.name === r.name && e.chainId === r.chainId && (e.ensAddress === r.ensAddress || e.ensAddress == null && r.ensAddress == null) || ou.throwArgumentError("provider mismatch", "networks", n) : e = r
    }
    return e
}
function EF(n, e) {
    n = n.slice().sort();
    const t = Math.floor(n.length / 2);
    if (n.length % 2)
        return n[t];
    const r = n[t - 1]
      , i = n[t];
    return e != null && Math.abs(r - i) > e ? null : (r + i) / 2
}
function yh(n) {
    if (n === null)
        return "null";
    if (typeof n == "number" || typeof n == "boolean")
        return JSON.stringify(n);
    if (typeof n == "string")
        return n;
    if (je.isBigNumber(n))
        return n.toString();
    if (Array.isArray(n))
        return JSON.stringify(n.map(e => yh(e)));
    if (typeof n == "object") {
        const e = Object.keys(n);
        return e.sort(),
        "{" + e.map(t => {
            let r = n[t];
            return typeof r == "function" ? r = "[function]" : r = yh(r),
            JSON.stringify(t) + ":" + r
        }
        ).join(",") + "}"
    }
    throw new Error("unknown value type: " + typeof n)
}
let $X = 1;
function BF(n) {
    let e = null
      , t = null
      , r = new Promise(o => {
        e = function() {
            t && (clearTimeout(t),
            t = null),
            o()
        }
        ,
        t = setTimeout(e, n)
    }
    );
    const i = o => (r = r.then(o),
    r);
    function s() {
        return r
    }
    return {
        cancel: e,
        getPromise: s,
        wait: i
    }
}
const ZX = [xe.errors.CALL_EXCEPTION, xe.errors.INSUFFICIENT_FUNDS, xe.errors.NONCE_EXPIRED, xe.errors.REPLACEMENT_UNDERPRICED, xe.errors.UNPREDICTABLE_GAS_LIMIT]
  , JX = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];
function K0(n, e) {
    const t = {
        weight: n.weight
    };
    return Object.defineProperty(t, "provider", {
        get: () => n.provider
    }),
    n.start && (t.start = n.start),
    e && (t.duration = e - n.start),
    n.done && (n.error ? t.error = n.error : t.result = n.result || null),
    t
}
function qX(n, e) {
    return function(t) {
        const r = {};
        t.forEach(s => {
            const o = n(s.result);
            r[o] || (r[o] = {
                count: 0,
                result: s.result
            }),
            r[o].count++
        }
        );
        const i = Object.keys(r);
        for (let s = 0; s < i.length; s++) {
            const o = r[i[s]];
            if (o.count >= e)
                return o.result
        }
    }
}
function eY(n, e, t) {
    let r = yh;
    switch (e) {
    case "getBlockNumber":
        return function(i) {
            const s = i.map(a => a.result);
            let o = EF(i.map(a => a.result), 2);
            if (o != null)
                return o = Math.ceil(o),
                s.indexOf(o + 1) >= 0 && o++,
                o >= n._highestBlockNumber && (n._highestBlockNumber = o),
                n._highestBlockNumber
        }
        ;
    case "getGasPrice":
        return function(i) {
            const s = i.map(o => o.result);
            return s.sort(),
            s[Math.floor(s.length / 2)]
        }
        ;
    case "getEtherPrice":
        return function(i) {
            return EF(i.map(s => s.result))
        }
        ;
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
        break;
    case "getTransaction":
    case "getTransactionReceipt":
        r = function(i) {
            return i == null ? null : (i = Qn(i),
            i.confirmations = -1,
            yh(i))
        }
        ;
        break;
    case "getBlock":
        t.includeTransactions ? r = function(i) {
            return i == null ? null : (i = Qn(i),
            i.transactions = i.transactions.map(s => (s = Qn(s),
            s.confirmations = -1,
            s)),
            yh(i))
        }
        : r = function(i) {
            return i == null ? null : yh(i)
        }
        ;
        break;
    default:
        throw new Error("unknown method: " + e)
    }
    return qX(r, n.quorum)
}
function yp(n, e) {
    return t_(this, void 0, void 0, function*() {
        const t = n.provider;
        return t.blockNumber != null && t.blockNumber >= e || e === -1 ? t : vh( () => new Promise( (r, i) => {
            setTimeout(function() {
                return t.blockNumber >= e ? r(t) : n.cancelled ? r(null) : r(void 0)
            }, 0)
        }
        ), {
            oncePoll: t
        })
    })
}
function tY(n, e, t, r) {
    return t_(this, void 0, void 0, function*() {
        let i = n.provider;
        switch (t) {
        case "getBlockNumber":
        case "getGasPrice":
            return i[t]();
        case "getEtherPrice":
            if (i.getEtherPrice)
                return i.getEtherPrice();
            break;
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
            return r.blockTag && It(r.blockTag) && (i = yield yp(n, e)),
            i[t](r.address, r.blockTag || "latest");
        case "getStorageAt":
            return r.blockTag && It(r.blockTag) && (i = yield yp(n, e)),
            i.getStorageAt(r.address, r.position, r.blockTag || "latest");
        case "getBlock":
            return r.blockTag && It(r.blockTag) && (i = yield yp(n, e)),
            i[r.includeTransactions ? "getBlockWithTransactions" : "getBlock"](r.blockTag || r.blockHash);
        case "call":
        case "estimateGas":
            return r.blockTag && It(r.blockTag) && (i = yield yp(n, e)),
            t === "call" && r.blockTag ? i[t](r.transaction, r.blockTag) : i[t](r.transaction);
        case "getTransaction":
        case "getTransactionReceipt":
            return i[t](r.transactionHash);
        case "getLogs":
            {
                let s = r.filter;
                return (s.fromBlock && It(s.fromBlock) || s.toBlock && It(s.toBlock)) && (i = yield yp(n, e)),
                i.getLogs(s)
            }
        }
        return ou.throwError("unknown method error", xe.errors.UNKNOWN_ERROR, {
            method: t,
            params: r
        })
    })
}
class nY extends mI {
    constructor(e, t) {
        e.length === 0 && ou.throwArgumentError("missing providers", "providers", e);
        const r = e.map( (o, a) => {
            if (l0.isProvider(o)) {
                const A = lF(o) ? 2e3 : 750;
                return Object.freeze({
                    provider: o,
                    weight: 1,
                    stallTimeout: A,
                    priority: 1
                })
            }
            const l = Qn(o);
            l.priority == null && (l.priority = 1),
            l.stallTimeout == null && (l.stallTimeout = lF(o) ? 2e3 : 750),
            l.weight == null && (l.weight = 1);
            const c = l.weight;
            return (c % 1 || c > 512 || c < 1) && ou.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${a}].weight`, c),
            Object.freeze(l)
        }
        )
          , i = r.reduce( (o, a) => o + a.weight, 0);
        t == null ? t = i / 2 : t > i && ou.throwArgumentError("quorum will always fail; larger than total weight", "quorum", t);
        let s = bF(r.map(o => o.provider.network));
        s == null && (s = new Promise( (o, a) => {
            setTimeout( () => {
                this.detectNetwork().then(o, a)
            }
            , 0)
        }
        )),
        super(s),
        Ue(this, "providerConfigs", Object.freeze(r)),
        Ue(this, "quorum", t),
        this._highestBlockNumber = -1
    }
    detectNetwork() {
        return t_(this, void 0, void 0, function*() {
            const e = yield Promise.all(this.providerConfigs.map(t => t.provider.getNetwork()));
            return bF(e)
        })
    }
    perform(e, t) {
        return t_(this, void 0, void 0, function*() {
            if (e === "sendTransaction") {
                const l = yield Promise.all(this.providerConfigs.map(c => c.provider.sendTransaction(t.signedTransaction).then(A => A.hash, A => A)));
                for (let c = 0; c < l.length; c++) {
                    const A = l[c];
                    if (typeof A == "string")
                        return A
                }
                throw l[0]
            }
            this._highestBlockNumber === -1 && e !== "getBlockNumber" && (yield this.getBlockNumber());
            const r = eY(this, e, t)
              , i = YX(this.providerConfigs.map(Qn));
            i.sort( (l, c) => l.priority - c.priority);
            const s = this._highestBlockNumber;
            let o = 0
              , a = !0;
            for (; ; ) {
                const l = W0();
                let c = i.filter(h => h.runner && l - h.start < h.stallTimeout).reduce( (h, d) => h + d.weight, 0);
                for (; c < this.quorum && o < i.length; ) {
                    const h = i[o++]
                      , d = $X++;
                    h.start = W0(),
                    h.staller = BF(h.stallTimeout),
                    h.staller.wait( () => {
                        h.staller = null
                    }
                    ),
                    h.runner = tY(h, s, e, t).then(m => {
                        h.done = !0,
                        h.result = m,
                        this.listenerCount("debug") && this.emit("debug", {
                            action: "request",
                            rid: d,
                            backend: K0(h, W0()),
                            request: {
                                method: e,
                                params: Ps(t)
                            },
                            provider: this
                        })
                    }
                    , m => {
                        h.done = !0,
                        h.error = m,
                        this.listenerCount("debug") && this.emit("debug", {
                            action: "request",
                            rid: d,
                            backend: K0(h, W0()),
                            request: {
                                method: e,
                                params: Ps(t)
                            },
                            provider: this
                        })
                    }
                    ),
                    this.listenerCount("debug") && this.emit("debug", {
                        action: "request",
                        rid: d,
                        backend: K0(h, null),
                        request: {
                            method: e,
                            params: Ps(t)
                        },
                        provider: this
                    }),
                    c += h.weight
                }
                const A = [];
                i.forEach(h => {
                    h.done || !h.runner || (A.push(h.runner),
                    h.staller && A.push(h.staller.getPromise()))
                }
                ),
                A.length && (yield Promise.race(A));
                const u = i.filter(h => h.done && h.error == null);
                if (u.length >= this.quorum) {
                    const h = r(u);
                    if (h !== void 0)
                        return i.forEach(d => {
                            d.staller && d.staller.cancel(),
                            d.cancelled = !0
                        }
                        ),
                        h;
                    a || (yield BF(100).getPromise()),
                    a = !1
                }
                const f = i.reduce( (h, d) => {
                    if (!d.done || d.error == null)
                        return h;
                    const m = d.error.code;
                    return ZX.indexOf(m) >= 0 && (h[m] || (h[m] = {
                        error: d.error,
                        weight: 0
                    }),
                    h[m].weight += d.weight),
                    h
                }
                , {});
                if (Object.keys(f).forEach(h => {
                    const d = f[h];
                    if (d.weight < this.quorum)
                        return;
                    i.forEach(p => {
                        p.staller && p.staller.cancel(),
                        p.cancelled = !0
                    }
                    );
                    const m = d.error
                      , g = {};
                    JX.forEach(p => {
                        m[p] != null && (g[p] = m[p])
                    }
                    ),
                    ou.throwError(m.reason || m.message, h, g)
                }
                ),
                i.filter(h => !h.done).length === 0)
                    break
            }
            return i.forEach(l => {
                l.staller && l.staller.cancel(),
                l.cancelled = !0
            }
            ),
            ou.throwError("failed to meet quorum", xe.errors.SERVER_ERROR, {
                method: e,
                params: t,
                results: i.map(l => K0(l)),
                provider: this
            })
        })
    }
}
const rY = null
  , aw = new xe(Ci)
  , pm = "84842078b09946638c03157f83405213";
class iY extends vI {
    constructor(e, t) {
        const r = new rH(e,t)
          , i = r.connection;
        i.password && aw.throwError("INFURA WebSocket project secrets unsupported", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
        });
        const s = i.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(s, e),
        Ue(this, "apiKey", r.projectId),
        Ue(this, "projectId", r.projectId),
        Ue(this, "projectSecret", r.projectSecret)
    }
    isCommunityResource() {
        return this.projectId === pm
    }
}
class rH extends SA {
    static getWebSocketProvider(e, t) {
        return new iY(e,t)
    }
    static getApiKey(e) {
        const t = {
            apiKey: pm,
            projectId: pm,
            projectSecret: null
        };
        return e == null || (typeof e == "string" ? t.projectId = e : e.projectSecret != null ? (aw.assertArgument(typeof e.projectId == "string", "projectSecret requires a projectId", "projectId", e.projectId),
        aw.assertArgument(typeof e.projectSecret == "string", "invalid projectSecret", "projectSecret", "[REDACTED]"),
        t.projectId = e.projectId,
        t.projectSecret = e.projectSecret) : e.projectId && (t.projectId = e.projectId),
        t.apiKey = t.projectId),
        t
    }
    static getUrl(e, t) {
        let r = null;
        switch (e ? e.name : "unknown") {
        case "homestead":
            r = "mainnet.infura.io";
            break;
        case "goerli":
            r = "goerli.infura.io";
            break;
        case "sepolia":
            r = "sepolia.infura.io";
            break;
        case "matic":
            r = "polygon-mainnet.infura.io";
            break;
        case "maticmum":
            r = "polygon-mumbai.infura.io";
            break;
        case "optimism":
            r = "optimism-mainnet.infura.io";
            break;
        case "optimism-goerli":
            r = "optimism-goerli.infura.io";
            break;
        case "arbitrum":
            r = "arbitrum-mainnet.infura.io";
            break;
        case "arbitrum-goerli":
            r = "arbitrum-goerli.infura.io";
            break;
        default:
            aw.throwError("unsupported network", xe.errors.INVALID_ARGUMENT, {
                argument: "network",
                value: e
            })
        }
        const i = {
            allowGzip: !0,
            url: "https://" + r + "/v3/" + t.projectId,
            throttleCallback: (s, o) => (t.projectId === pm && Gx(),
            Promise.resolve(!0))
        };
        return t.projectSecret != null && (i.user = "",
        i.password = t.projectSecret),
        i
    }
    isCommunityResource() {
        return this.projectId === pm
    }
}
const Pb = new xe(Ci)
  , sY = "ETHERS_JS_SHARED";
class oY extends SA {
    static getApiKey(e) {
        return e && typeof e != "string" && Pb.throwArgumentError("invalid apiKey", "apiKey", e),
        e || sY
    }
    static getUrl(e, t) {
        Pb.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let r = null;
        switch (e.name) {
        case "homestead":
            r = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
            break;
        case "ropsten":
            r = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
            break;
        case "rinkeby":
            r = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
            break;
        case "goerli":
            r = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
            break;
        case "kovan":
            r = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
            break;
        default:
            Pb.throwArgumentError("unsupported network", "network", arguments[0])
        }
        return r + "?apiKey=" + t
    }
}
const MF = new xe(Ci)
  , SF = "62e1ad51b37b8e00394bda3b";
class aY extends SA {
    static getApiKey(e) {
        const t = {
            applicationId: null,
            loadBalancer: !0,
            applicationSecretKey: null
        };
        return e == null ? t.applicationId = SF : typeof e == "string" ? t.applicationId = e : e.applicationSecretKey != null ? (t.applicationId = e.applicationId,
        t.applicationSecretKey = e.applicationSecretKey) : e.applicationId ? t.applicationId = e.applicationId : MF.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", e),
        t
    }
    static getUrl(e, t) {
        let r = null;
        switch (e ? e.name : "unknown") {
        case "goerli":
            r = "eth-goerli.gateway.pokt.network";
            break;
        case "homestead":
            r = "eth-mainnet.gateway.pokt.network";
            break;
        case "kovan":
            r = "poa-kovan.gateway.pokt.network";
            break;
        case "matic":
            r = "poly-mainnet.gateway.pokt.network";
            break;
        case "maticmum":
            r = "polygon-mumbai-rpc.gateway.pokt.network";
            break;
        case "rinkeby":
            r = "eth-rinkeby.gateway.pokt.network";
            break;
        case "ropsten":
            r = "eth-ropsten.gateway.pokt.network";
            break;
        default:
            MF.throwError("unsupported network", xe.errors.INVALID_ARGUMENT, {
                argument: "network",
                value: e
            })
        }
        const i = `https://${r}/v1/lb/${t.applicationId}`
          , s = {
            headers: {},
            url: i
        };
        return t.applicationSecretKey != null && (s.user = "",
        s.password = t.applicationSecretKey),
        s
    }
    isCommunityResource() {
        return this.applicationId === SF
    }
}
const CF = new xe(Ci);
let lY = 1;
function TF(n, e) {
    const t = "Web3LegacyFetcher";
    return function(r, i) {
        const s = {
            method: r,
            params: i,
            id: lY++,
            jsonrpc: "2.0"
        };
        return new Promise( (o, a) => {
            this.emit("debug", {
                action: "request",
                fetcher: t,
                request: Ps(s),
                provider: this
            }),
            e(s, (l, c) => {
                if (l)
                    return this.emit("debug", {
                        action: "response",
                        fetcher: t,
                        error: l,
                        request: s,
                        provider: this
                    }),
                    a(l);
                if (this.emit("debug", {
                    action: "response",
                    fetcher: t,
                    request: s,
                    response: c,
                    provider: this
                }),
                c.error) {
                    const A = new Error(c.error.message);
                    return A.code = c.error.code,
                    A.data = c.error.data,
                    a(A)
                }
                o(c.result)
            }
            )
        }
        )
    }
}
function cY(n) {
    return function(e, t) {
        t == null && (t = []);
        const r = {
            method: e,
            params: t
        };
        return this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: Ps(r),
            provider: this
        }),
        n.request(r).then(i => (this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: r,
            response: i,
            provider: this
        }),
        i), i => {
            throw this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request: r,
                error: i,
                provider: this
            }),
            i
        }
        )
    }
}
class yI extends fg {
    constructor(e, t) {
        e == null && CF.throwArgumentError("missing provider", "provider", e);
        let r = null
          , i = null
          , s = null;
        typeof e == "function" ? (r = "unknown:",
        i = e) : (r = e.host || e.path || "",
        !r && e.isMetaMask && (r = "metamask"),
        s = e,
        e.request ? (r === "" && (r = "eip-1193:"),
        i = cY(e)) : e.sendAsync ? i = TF(e, e.sendAsync.bind(e)) : e.send ? i = TF(e, e.send.bind(e)) : CF.throwArgumentError("unsupported provider", "provider", e),
        r || (r = "unknown:")),
        super(r, t),
        Ue(this, "jsonRpcFetchFunc", i),
        Ue(this, "provider", s)
    }
    send(e, t) {
        return this.jsonRpcFetchFunc(e, t)
    }
}
const IF = new xe(Ci);
function AY(n, e) {
    if (n == null && (n = "homestead"),
    typeof n == "string") {
        const r = n.match(/^(ws|http)s?:/i);
        if (r)
            switch (r[1].toLowerCase()) {
            case "http":
            case "https":
                return new fg(n);
            case "ws":
            case "wss":
                return new vI(n);
            default:
                IF.throwArgumentError("unsupported URL scheme", "network", n)
            }
    }
    const t = tQ(n);
    return (!t || !t._defaultProvider) && IF.throwError("unsupported getDefaultProvider network", xe.errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network: n
    }),
    t._defaultProvider({
        FallbackProvider: nY,
        AlchemyProvider: nH,
        AnkrProvider: VX,
        CloudflareProvider: WX,
        EtherscanProvider: XX,
        InfuraProvider: rH,
        JsonRpcProvider: fg,
        NodesmithProvider: oY,
        PocketProvider: aY,
        Web3Provider: yI,
        IpcProvider: rY
    }, e)
}
var uY = !0
  , Lb = "Invariant failed";
function kl(n, e) {
    if (!n) {
        if (uY)
            throw new Error(Lb);
        var t = typeof e == "function" ? e() : e
          , r = t ? "".concat(Lb, ": ").concat(t) : Lb;
        throw new Error(r)
    }
}
var Yo;
(function(n) {
    n.Update = "Web3ReactUpdate",
    n.Error = "Web3ReactError",
    n.Deactivate = "Web3ReactDeactivate"
}
)(Yo || (Yo = {}));
function hg() {
    return hg = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ,
    hg.apply(this, arguments)
}
function iH(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    dg(n, e)
}
function kM(n) {
    return kM = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }
    ,
    kM(n)
}
function dg(n, e) {
    return dg = Object.setPrototypeOf || function(r, i) {
        return r.__proto__ = i,
        r
    }
    ,
    dg(n, e)
}
function fY() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function lw(n, e, t) {
    return fY() ? lw = Reflect.construct : lw = function(i, s, o) {
        var a = [null];
        a.push.apply(a, s);
        var l = Function.bind.apply(i, a)
          , c = new l;
        return o && dg(c, o.prototype),
        c
    }
    ,
    lw.apply(null, arguments)
}
function hY(n) {
    return Function.toString.call(n).indexOf("[native code]") !== -1
}
function n_(n) {
    var e = typeof Map == "function" ? new Map : void 0;
    return n_ = function(r) {
        if (r === null || !hY(r))
            return r;
        if (typeof r != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(r))
                return e.get(r);
            e.set(r, i)
        }
        function i() {
            return lw(r, arguments, kM(this).constructor)
        }
        return i.prototype = Object.create(r.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        dg(i, r)
    }
    ,
    n_(n)
}
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")));
typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
function RF(n, e) {
    try {
        var t = n()
    } catch (r) {
        return e(r)
    }
    return t && t.then ? t.then(void 0, e) : t
}
function sH(n) {
    if (typeof n == "string") {
        n = n.replace(/^Ox/, "0x");
        var e = Number.parseInt(n, n.trim().substring(0, 2) === "0x" ? 16 : 10);
        return Number.isNaN(e) && kl(!1),
        e
    } else
        return Number.isInteger(n) || kl(!1),
        n
}
function oH(n) {
    typeof n == "string" && n.match(/^(0x)?[0-9a-fA-F]{40}$/) || kl(!1);
    for (var e = n.substring(0, 2) === "0x" ? n : "0x" + n, t = e.toLowerCase().substring(2).split(""), r = new Uint8Array(40), i = 0; i < 40; i++)
        r[i] = t[i].charCodeAt(0);
    for (var s = pt(Er(r)), o = 0; o < 40; o += 2)
        s[o >> 1] >> 4 >= 8 && (t[o] = t[o].toUpperCase()),
        (s[o >> 1] & 15) >= 8 && (t[o + 1] = t[o + 1].toUpperCase());
    var a = "0x" + t.join("");
    return e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== a && kl(!1),
    a
}
var UF = function(e, t) {
    try {
        var r = function(o) {
            return Promise.resolve(Promise.all([t.chainId === void 0 ? e.getChainId() : t.chainId, t.account === void 0 ? e.getAccount() : t.account])).then(function(a) {
                var l = a[0]
                  , c = a[1]
                  , A = sH(l);
                if (e.supportedChainIds && !e.supportedChainIds.includes(A))
                    throw new aH(A,e.supportedChainIds);
                var u = c === null ? c : oH(c);
                return {
                    provider: o,
                    chainId: A,
                    account: u
                }
            })
        }
          , i = t.provider === void 0;
        return Promise.resolve(i ? Promise.resolve(e.getProvider()).then(r) : r(t.provider))
    } catch (s) {
        return Promise.reject(s)
    }
}, X0 = function(n) {
    iH(e, n);
    function e() {
        var t;
        return t = n.call(this) || this,
        t.name = t.constructor.name,
        t
    }
    return e
}(n_(Error)), aH = function(n) {
    iH(e, n);
    function e(t, r) {
        var i;
        return i = n.call(this) || this,
        i.name = i.constructor.name,
        i.message = "Unsupported chain id: " + t + ". Supported chain ids are: " + r + ".",
        i
    }
    return e
}(n_(Error)), zr;
(function(n) {
    n[n.ACTIVATE_CONNECTOR = 0] = "ACTIVATE_CONNECTOR",
    n[n.UPDATE = 1] = "UPDATE",
    n[n.UPDATE_FROM_ERROR = 2] = "UPDATE_FROM_ERROR",
    n[n.ERROR = 3] = "ERROR",
    n[n.ERROR_FROM_ACTIVATION = 4] = "ERROR_FROM_ACTIVATION",
    n[n.DEACTIVATE_CONNECTOR = 5] = "DEACTIVATE_CONNECTOR"
}
)(zr || (zr = {}));
function dY(n, e) {
    var t = e.type
      , r = e.payload;
    switch (t) {
    case zr.ACTIVATE_CONNECTOR:
        {
            var i = r.connector
              , s = r.provider
              , o = r.chainId
              , a = r.account
              , l = r.onError;
            return {
                connector: i,
                provider: s,
                chainId: o,
                account: a,
                onError: l
            }
        }
    case zr.UPDATE:
        {
            var c = r.provider
              , A = r.chainId
              , u = r.account;
            return hg({}, n, c === void 0 ? {} : {
                provider: c
            }, A === void 0 ? {} : {
                chainId: A
            }, u === void 0 ? {} : {
                account: u
            })
        }
    case zr.UPDATE_FROM_ERROR:
        {
            var f = r.provider
              , h = r.chainId
              , d = r.account;
            return hg({}, n, f === void 0 ? {} : {
                provider: f
            }, h === void 0 ? {} : {
                chainId: h
            }, d === void 0 ? {} : {
                account: d
            }, {
                error: void 0
            })
        }
    case zr.ERROR:
        {
            var m = r.error
              , g = n.connector
              , p = n.onError;
            return {
                connector: g,
                error: m,
                onError: p
            }
        }
    case zr.ERROR_FROM_ACTIVATION:
        {
            var v = r.connector
              , w = r.error;
            return {
                connector: v,
                error: w
            }
        }
    case zr.DEACTIVATE_CONNECTOR:
        return {}
    }
}
function pY() {
    var n = be.useReducer(dY, {})
      , e = n[0]
      , t = n[1]
      , r = e.connector
      , i = e.provider
      , s = e.chainId
      , o = e.account
      , a = e.onError
      , l = e.error
      , c = be.useRef(-1);
    c.current += 1;
    var A = be.useCallback(function(g, p, v) {
        v === void 0 && (v = !1);
        try {
            var w = c.current
              , _ = !1;
            return Promise.resolve(RF(function() {
                return Promise.resolve(g.activate().then(function(x) {
                    return _ = !0,
                    x
                })).then(function(x) {
                    return Promise.resolve(UF(g, x)).then(function(b) {
                        if (c.current > w)
                            throw new X0;
                        t({
                            type: zr.ACTIVATE_CONNECTOR,
                            payload: hg({
                                connector: g
                            }, b, {
                                onError: p
                            })
                        })
                    })
                })
            }, function(x) {
                if (x instanceof X0)
                    _ && g.deactivate();
                else {
                    if (v)
                        throw _ && g.deactivate(),
                        x;
                    p ? (_ && g.deactivate(),
                    p(x)) : t({
                        type: zr.ERROR_FROM_ACTIVATION,
                        payload: {
                            connector: g,
                            error: x
                        }
                    })
                }
            }))
        } catch (x) {
            return Promise.reject(x)
        }
    }, [])
      , u = be.useCallback(function(g) {
        t({
            type: zr.ERROR,
            payload: {
                error: g
            }
        })
    }, [])
      , f = be.useCallback(function() {
        t({
            type: zr.DEACTIVATE_CONNECTOR
        })
    }, [])
      , h = be.useCallback(function(g) {
        try {
            if (!r)
                throw Error("This should never happen, it's just so Typescript stops complaining");
            var p = c.current;
            return Promise.resolve(function() {
                if (l)
                    return RF(function() {
                        return Promise.resolve(UF(r, g)).then(function(x) {
                            if (c.current > p)
                                throw new X0;
                            t({
                                type: zr.UPDATE_FROM_ERROR,
                                payload: x
                            })
                        })
                    }, function(x) {
                        x instanceof X0 || (a ? a(x) : t({
                            type: zr.ERROR,
                            payload: {
                                error: x
                            }
                        }))
                    });
                var v = g.chainId === void 0 ? void 0 : sH(g.chainId);
                if (v !== void 0 && r.supportedChainIds && !r.supportedChainIds.includes(v)) {
                    var w = new aH(v,r.supportedChainIds);
                    a ? a(w) : t({
                        type: zr.ERROR,
                        payload: {
                            error: w
                        }
                    })
                } else {
                    var _ = typeof g.account == "string" ? oH(g.account) : g.account;
                    t({
                        type: zr.UPDATE,
                        payload: {
                            provider: g.provider,
                            chainId: v,
                            account: _
                        }
                    })
                }
            }())
        } catch (v) {
            return Promise.reject(v)
        }
    }, [r, l, a])
      , d = be.useCallback(function(g) {
        a ? a(g) : t({
            type: zr.ERROR,
            payload: {
                error: g
            }
        })
    }, [a])
      , m = be.useCallback(function() {
        t({
            type: zr.DEACTIVATE_CONNECTOR
        })
    }, []);
    return be.useEffect(function() {
        return function() {
            r && r.deactivate()
        }
    }, [r]),
    be.useEffect(function() {
        return r && r.on(Yo.Update, h).on(Yo.Error, d).on(Yo.Deactivate, m),
        function() {
            r && r.off(Yo.Update, h).off(Yo.Error, d).off(Yo.Deactivate, m)
        }
    }, [r, h, d, m]),
    {
        connector: r,
        provider: i,
        chainId: s,
        account: o,
        activate: A,
        setError: u,
        deactivate: f,
        error: l
    }
}
var lH = "primary"
  , wh = {};
function mY(n) {
    wh[n] && kl(!1),
    wh[n] = be.createContext({
        activate: function() {
            try {
                return kl(!1),
                Promise.resolve()
            } catch (t) {
                return Promise.reject(t)
            }
        },
        setError: function() {
            kl(!1)
        },
        deactivate: function() {
            kl(!1)
        },
        active: !1
    }),
    wh[n].displayName = "Web3ReactContext - " + n;
    var e = wh[n].Provider;
    return function(r) {
        var i = r.getLibrary
          , s = r.children
          , o = pY()
          , a = o.connector
          , l = o.provider
          , c = o.chainId
          , A = o.account
          , u = o.activate
          , f = o.setError
          , h = o.deactivate
          , d = o.error
          , m = a !== void 0 && c !== void 0 && A !== void 0 && !d
          , g = be.useMemo(function() {
            return m && c !== void 0 && Number.isInteger(c) && a ? i(l, a) : void 0
        }, [m, i, l, a, c])
          , p = {
            connector: a,
            library: g,
            chainId: c,
            account: A,
            activate: u,
            setError: f,
            deactivate: h,
            active: m,
            error: d
        };
        return Z.createElement(e, {
            value: p
        }, s)
    }
}
var gY = mY(lH);
function vY(n) {
    return n === void 0 && (n = lH),
    Object.keys(wh).includes(n) || kl(!1),
    wh[n]
}
function yY(n) {
    return be.useContext(vY(n))
}
var QM = {}
  , cH = {
    exports: {}
}
  , js = {}
  , AH = {
    exports: {}
}
  , uH = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(n) {
    function e(O, z) {
        var j = O.length;
        O.push(z);
        e: for (; 0 < j; ) {
            var Q = j - 1 >>> 1
              , C = O[Q];
            if (0 < i(C, z))
                O[Q] = z,
                O[j] = C,
                j = Q;
            else
                break e
        }
    }
    function t(O) {
        return O.length === 0 ? null : O[0]
    }
    function r(O) {
        if (O.length === 0)
            return null;
        var z = O[0]
          , j = O.pop();
        if (j !== z) {
            O[0] = j;
            e: for (var Q = 0, C = O.length, W = C >>> 1; Q < W; ) {
                var ee = 2 * (Q + 1) - 1
                  , P = O[ee]
                  , re = ee + 1
                  , ue = O[re];
                if (0 > i(P, j))
                    re < C && 0 > i(ue, P) ? (O[Q] = ue,
                    O[re] = j,
                    Q = re) : (O[Q] = P,
                    O[ee] = j,
                    Q = ee);
                else if (re < C && 0 > i(ue, j))
                    O[Q] = ue,
                    O[re] = j,
                    Q = re;
                else
                    break e
            }
        }
        return z
    }
    function i(O, z) {
        var j = O.sortIndex - z.sortIndex;
        return j !== 0 ? j : O.id - z.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        n.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date
          , a = o.now();
        n.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , A = 1
      , u = null
      , f = 3
      , h = !1
      , d = !1
      , m = !1
      , g = typeof setTimeout == "function" ? setTimeout : null
      , p = typeof clearTimeout == "function" ? clearTimeout : null
      , v = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function w(O) {
        for (var z = t(c); z !== null; ) {
            if (z.callback === null)
                r(c);
            else if (z.startTime <= O)
                r(c),
                z.sortIndex = z.expirationTime,
                e(l, z);
            else
                break;
            z = t(c)
        }
    }
    function _(O) {
        if (m = !1,
        w(O),
        !d)
            if (t(l) !== null)
                d = !0,
                R(x);
            else {
                var z = t(c);
                z !== null && F(_, z.startTime - O)
            }
    }
    function x(O, z) {
        d = !1,
        m && (m = !1,
        p(S),
        S = -1),
        h = !0;
        var j = f;
        try {
            for (w(z),
            u = t(l); u !== null && (!(u.expirationTime > z) || O && !L()); ) {
                var Q = u.callback;
                if (typeof Q == "function") {
                    u.callback = null,
                    f = u.priorityLevel;
                    var C = Q(u.expirationTime <= z);
                    z = n.unstable_now(),
                    typeof C == "function" ? u.callback = C : u === t(l) && r(l),
                    w(z)
                } else
                    r(l);
                u = t(l)
            }
            if (u !== null)
                var W = !0;
            else {
                var ee = t(c);
                ee !== null && F(_, ee.startTime - z),
                W = !1
            }
            return W
        } finally {
            u = null,
            f = j,
            h = !1
        }
    }
    var b = !1
      , B = null
      , S = -1
      , I = 5
      , M = -1;
    function L() {
        return !(n.unstable_now() - M < I)
    }
    function D() {
        if (B !== null) {
            var O = n.unstable_now();
            M = O;
            var z = !0;
            try {
                z = B(!0, O)
            } finally {
                z ? T() : (b = !1,
                B = null)
            }
        } else
            b = !1
    }
    var T;
    if (typeof v == "function")
        T = function() {
            v(D)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var y = new MessageChannel
          , E = y.port2;
        y.port1.onmessage = D,
        T = function() {
            E.postMessage(null)
        }
    } else
        T = function() {
            g(D, 0)
        }
        ;
    function R(O) {
        B = O,
        b || (b = !0,
        T())
    }
    function F(O, z) {
        S = g(function() {
            O(n.unstable_now())
        }, z)
    }
    n.unstable_IdlePriority = 5,
    n.unstable_ImmediatePriority = 1,
    n.unstable_LowPriority = 4,
    n.unstable_NormalPriority = 3,
    n.unstable_Profiling = null,
    n.unstable_UserBlockingPriority = 2,
    n.unstable_cancelCallback = function(O) {
        O.callback = null
    }
    ,
    n.unstable_continueExecution = function() {
        d || h || (d = !0,
        R(x))
    }
    ,
    n.unstable_forceFrameRate = function(O) {
        0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < O ? Math.floor(1e3 / O) : 5
    }
    ,
    n.unstable_getCurrentPriorityLevel = function() {
        return f
    }
    ,
    n.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    n.unstable_next = function(O) {
        switch (f) {
        case 1:
        case 2:
        case 3:
            var z = 3;
            break;
        default:
            z = f
        }
        var j = f;
        f = z;
        try {
            return O()
        } finally {
            f = j
        }
    }
    ,
    n.unstable_pauseExecution = function() {}
    ,
    n.unstable_requestPaint = function() {}
    ,
    n.unstable_runWithPriority = function(O, z) {
        switch (O) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            O = 3
        }
        var j = f;
        f = O;
        try {
            return z()
        } finally {
            f = j
        }
    }
    ,
    n.unstable_scheduleCallback = function(O, z, j) {
        var Q = n.unstable_now();
        switch (typeof j == "object" && j !== null ? (j = j.delay,
        j = typeof j == "number" && 0 < j ? Q + j : Q) : j = Q,
        O) {
        case 1:
            var C = -1;
            break;
        case 2:
            C = 250;
            break;
        case 5:
            C = 1073741823;
            break;
        case 4:
            C = 1e4;
            break;
        default:
            C = 5e3
        }
        return C = j + C,
        O = {
            id: A++,
            callback: z,
            priorityLevel: O,
            startTime: j,
            expirationTime: C,
            sortIndex: -1
        },
        j > Q ? (O.sortIndex = j,
        e(c, O),
        t(l) === null && O === t(c) && (m ? (p(S),
        S = -1) : m = !0,
        F(_, j - Q))) : (O.sortIndex = C,
        e(l, O),
        d || h || (d = !0,
        R(x))),
        O
    }
    ,
    n.unstable_shouldYield = L,
    n.unstable_wrapCallback = function(O) {
        var z = f;
        return function() {
            var j = f;
            f = z;
            try {
                return O.apply(this, arguments)
            } finally {
                f = j
            }
        }
    }
}
)(uH);
AH.exports = uH;
var wY = AH.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _Y = be
  , ks = wY;
function Oe(n) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var fH = new Set
  , pg = {};
function Ku(n, e) {
    gd(n, e),
    gd(n + "Capture", e)
}
function gd(n, e) {
    for (pg[n] = e,
    n = 0; n < e.length; n++)
        fH.add(e[n])
}
var $l = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , HM = Object.prototype.hasOwnProperty
  , xY = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , FF = {}
  , PF = {};
function bY(n) {
    return HM.call(PF, n) ? !0 : HM.call(FF, n) ? !1 : xY.test(n) ? PF[n] = !0 : (FF[n] = !0,
    !1)
}
function EY(n, e, t, r) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return r ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5),
        n !== "data-" && n !== "aria-");
    default:
        return !1
    }
}
function BY(n, e, t, r) {
    if (e === null || typeof e > "u" || EY(n, e, t, r))
        return !0;
    if (r)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function Hi(n, e, t, r, i, s, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = r,
    this.attributeNamespace = i,
    this.mustUseProperty = t,
    this.propertyName = n,
    this.type = e,
    this.sanitizeURL = s,
    this.removeEmptyString = o
}
var li = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n) {
    li[n] = new Hi(n,0,!1,n,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
    var e = n[0];
    li[e] = new Hi(e,1,!1,n[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
    li[n] = new Hi(n,2,!1,n.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
    li[n] = new Hi(n,2,!1,n,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n) {
    li[n] = new Hi(n,3,!1,n.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(n) {
    li[n] = new Hi(n,3,!0,n,null,!1,!1)
});
["capture", "download"].forEach(function(n) {
    li[n] = new Hi(n,4,!1,n,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(n) {
    li[n] = new Hi(n,6,!1,n,null,!1,!1)
});
["rowSpan", "start"].forEach(function(n) {
    li[n] = new Hi(n,5,!1,n.toLowerCase(),null,!1,!1)
});
var wI = /[\-:]([a-z])/g;
function _I(n) {
    return n[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n) {
    var e = n.replace(wI, _I);
    li[e] = new Hi(e,1,!1,n,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n) {
    var e = n.replace(wI, _I);
    li[e] = new Hi(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n) {
    var e = n.replace(wI, _I);
    li[e] = new Hi(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(n) {
    li[n] = new Hi(n,1,!1,n.toLowerCase(),null,!1,!1)
});
li.xlinkHref = new Hi("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(n) {
    li[n] = new Hi(n,1,!1,n.toLowerCase(),null,!0,!0)
});
function xI(n, e, t, r) {
    var i = li.hasOwnProperty(e) ? li[e] : null;
    (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (BY(e, t, i, r) && (t = null),
    r || i === null ? bY(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : i.mustUseProperty ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : "" : t : (e = i.attributeName,
    r = i.attributeNamespace,
    t === null ? n.removeAttribute(e) : (i = i.type,
    t = i === 3 || i === 4 && t === !0 ? "" : "" + t,
    r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))))
}
var lc = _Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Y0 = Symbol.for("react.element")
  , _h = Symbol.for("react.portal")
  , xh = Symbol.for("react.fragment")
  , bI = Symbol.for("react.strict_mode")
  , zM = Symbol.for("react.profiler")
  , hH = Symbol.for("react.provider")
  , dH = Symbol.for("react.context")
  , EI = Symbol.for("react.forward_ref")
  , GM = Symbol.for("react.suspense")
  , VM = Symbol.for("react.suspense_list")
  , BI = Symbol.for("react.memo")
  , Dc = Symbol.for("react.lazy")
  , pH = Symbol.for("react.offscreen")
  , LF = Symbol.iterator;
function wp(n) {
    return n === null || typeof n != "object" ? null : (n = LF && n[LF] || n["@@iterator"],
    typeof n == "function" ? n : null)
}
var Yn = Object.assign, Db;
function mm(n) {
    if (Db === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            Db = e && e[1] || ""
        }
    return `
` + Db + n
}
var Nb = !1;
function Ob(n, e) {
    if (!n || Nb)
        return "";
    Nb = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var r = c
                }
                Reflect.construct(n, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    r = c
                }
                n.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                r = c
            }
            n()
        }
    } catch (c) {
        if (c && r && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Nb = !1,
        Error.prepareStackTrace = t
    }
    return (n = n ? n.displayName || n.name : "") ? mm(n) : ""
}
function MY(n) {
    switch (n.tag) {
    case 5:
        return mm(n.type);
    case 16:
        return mm("Lazy");
    case 13:
        return mm("Suspense");
    case 19:
        return mm("SuspenseList");
    case 0:
    case 2:
    case 15:
        return n = Ob(n.type, !1),
        n;
    case 11:
        return n = Ob(n.type.render, !1),
        n;
    case 1:
        return n = Ob(n.type, !0),
        n;
    default:
        return ""
    }
}
function jM(n) {
    if (n == null)
        return null;
    if (typeof n == "function")
        return n.displayName || n.name || null;
    if (typeof n == "string")
        return n;
    switch (n) {
    case xh:
        return "Fragment";
    case _h:
        return "Portal";
    case zM:
        return "Profiler";
    case bI:
        return "StrictMode";
    case GM:
        return "Suspense";
    case VM:
        return "SuspenseList"
    }
    if (typeof n == "object")
        switch (n.$$typeof) {
        case dH:
            return (n.displayName || "Context") + ".Consumer";
        case hH:
            return (n._context.displayName || "Context") + ".Provider";
        case EI:
            var e = n.render;
            return n = n.displayName,
            n || (n = e.displayName || e.name || "",
            n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"),
            n;
        case BI:
            return e = n.displayName || null,
            e !== null ? e : jM(n.type) || "Memo";
        case Dc:
            e = n._payload,
            n = n._init;
            try {
                return jM(n(e))
            } catch {}
        }
    return null
}
function SY(n) {
    var e = n.type;
    switch (n.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return n = e.render,
        n = n.displayName || n.name || "",
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return jM(e);
    case 8:
        return e === bI ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function mA(n) {
    switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return n;
    case "object":
        return n;
    default:
        return ""
    }
}
function mH(n) {
    var e = n.type;
    return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function CY(n) {
    var e = mH(n) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e)
      , r = "" + n[e];
    if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var i = t.get
          , s = t.set;
        return Object.defineProperty(n, e, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                r = "" + o,
                s.call(this, o)
            }
        }),
        Object.defineProperty(n, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return r
            },
            setValue: function(o) {
                r = "" + o
            },
            stopTracking: function() {
                n._valueTracker = null,
                delete n[e]
            }
        }
    }
}
function $0(n) {
    n._valueTracker || (n._valueTracker = CY(n))
}
function gH(n) {
    if (!n)
        return !1;
    var e = n._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , r = "";
    return n && (r = mH(n) ? n.checked ? "true" : "false" : n.value),
    n = r,
    n !== t ? (e.setValue(n),
    !0) : !1
}
function r_(n) {
    if (n = n || (typeof document < "u" ? document : void 0),
    typeof n > "u")
        return null;
    try {
        return n.activeElement || n.body
    } catch {
        return n.body
    }
}
function WM(n, e) {
    var t = e.checked;
    return Yn({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? n._wrapperState.initialChecked
    })
}
function DF(n, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , r = e.checked != null ? e.checked : e.defaultChecked;
    t = mA(e.value != null ? e.value : t),
    n._wrapperState = {
        initialChecked: r,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function vH(n, e) {
    e = e.checked,
    e != null && xI(n, "checked", e, !1)
}
function KM(n, e) {
    vH(n, e);
    var t = mA(e.value)
      , r = e.type;
    if (t != null)
        r === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t);
    else if (r === "submit" || r === "reset") {
        n.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? XM(n, e.type, t) : e.hasOwnProperty("defaultValue") && XM(n, e.type, mA(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked)
}
function NF(n, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var r = e.type;
        if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + n._wrapperState.initialValue,
        t || e === n.value || (n.value = e),
        n.defaultValue = e
    }
    t = n.name,
    t !== "" && (n.name = ""),
    n.defaultChecked = !!n._wrapperState.initialChecked,
    t !== "" && (n.name = t)
}
function XM(n, e, t) {
    (e !== "number" || r_(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t))
}
var gm = Array.isArray;
function Xh(n, e, t, r) {
    if (n = n.options,
    e) {
        e = {};
        for (var i = 0; i < t.length; i++)
            e["$" + t[i]] = !0;
        for (t = 0; t < n.length; t++)
            i = e.hasOwnProperty("$" + n[t].value),
            n[t].selected !== i && (n[t].selected = i),
            i && r && (n[t].defaultSelected = !0)
    } else {
        for (t = "" + mA(t),
        e = null,
        i = 0; i < n.length; i++) {
            if (n[i].value === t) {
                n[i].selected = !0,
                r && (n[i].defaultSelected = !0);
                return
            }
            e !== null || n[i].disabled || (e = n[i])
        }
        e !== null && (e.selected = !0)
    }
}
function YM(n, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(Oe(91));
    return Yn({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + n._wrapperState.initialValue
    })
}
function OF(n, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(Oe(92));
            if (gm(t)) {
                if (1 < t.length)
                    throw Error(Oe(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    n._wrapperState = {
        initialValue: mA(t)
    }
}
function yH(n, e) {
    var t = mA(e.value)
      , r = mA(e.defaultValue);
    t != null && (t = "" + t,
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    r != null && (n.defaultValue = "" + r)
}
function kF(n) {
    var e = n.textContent;
    e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e)
}
function wH(n) {
    switch (n) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function $M(n, e) {
    return n == null || n === "http://www.w3.org/1999/xhtml" ? wH(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n
}
var Z0, _H = function(n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, r, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return n(e, t, r, i)
        })
    }
    : n
}(function(n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in n)
        n.innerHTML = e;
    else {
        for (Z0 = Z0 || document.createElement("div"),
        Z0.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Z0.firstChild; n.firstChild; )
            n.removeChild(n.firstChild);
        for (; e.firstChild; )
            n.appendChild(e.firstChild)
    }
});
function mg(n, e) {
    if (e) {
        var t = n.firstChild;
        if (t && t === n.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    n.textContent = e
}
var Hm = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , TY = ["Webkit", "ms", "Moz", "O"];
Object.keys(Hm).forEach(function(n) {
    TY.forEach(function(e) {
        e = e + n.charAt(0).toUpperCase() + n.substring(1),
        Hm[e] = Hm[n]
    })
});
function xH(n, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Hm.hasOwnProperty(n) && Hm[n] ? ("" + e).trim() : e + "px"
}
function bH(n, e) {
    n = n.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var r = t.indexOf("--") === 0
              , i = xH(t, e[t], r);
            t === "float" && (t = "cssFloat"),
            r ? n.setProperty(t, i) : n[t] = i
        }
}
var IY = Yn({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ZM(n, e) {
    if (e) {
        if (IY[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(Oe(137, n));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(Oe(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(Oe(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(Oe(62))
    }
}
function JM(n, e) {
    if (n.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var qM = null;
function MI(n) {
    return n = n.target || n.srcElement || window,
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
}
var eS = null
  , Yh = null
  , $h = null;
function QF(n) {
    if (n = d0(n)) {
        if (typeof eS != "function")
            throw Error(Oe(280));
        var e = n.stateNode;
        e && (e = Xx(e),
        eS(n.stateNode, n.type, e))
    }
}
function EH(n) {
    Yh ? $h ? $h.push(n) : $h = [n] : Yh = n
}
function BH() {
    if (Yh) {
        var n = Yh
          , e = $h;
        if ($h = Yh = null,
        QF(n),
        e)
            for (n = 0; n < e.length; n++)
                QF(e[n])
    }
}
function MH(n, e) {
    return n(e)
}
function SH() {}
var kb = !1;
function CH(n, e, t) {
    if (kb)
        return n(e, t);
    kb = !0;
    try {
        return MH(n, e, t)
    } finally {
        kb = !1,
        (Yh !== null || $h !== null) && (SH(),
        BH())
    }
}
function gg(n, e) {
    var t = n.stateNode;
    if (t === null)
        return null;
    var r = Xx(t);
    if (r === null)
        return null;
    t = r[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (r = !r.disabled) || (n = n.type,
        r = !(n === "button" || n === "input" || n === "select" || n === "textarea")),
        n = !r;
        break e;
    default:
        n = !1
    }
    if (n)
        return null;
    if (t && typeof t != "function")
        throw Error(Oe(231, e, typeof t));
    return t
}
var tS = !1;
if ($l)
    try {
        var _p = {};
        Object.defineProperty(_p, "passive", {
            get: function() {
                tS = !0
            }
        }),
        window.addEventListener("test", _p, _p),
        window.removeEventListener("test", _p, _p)
    } catch {
        tS = !1
    }
function RY(n, e, t, r, i, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, c)
    } catch (A) {
        this.onError(A)
    }
}
var zm = !1
  , i_ = null
  , s_ = !1
  , nS = null
  , UY = {
    onError: function(n) {
        zm = !0,
        i_ = n
    }
};
function FY(n, e, t, r, i, s, o, a, l) {
    zm = !1,
    i_ = null,
    RY.apply(UY, arguments)
}
function PY(n, e, t, r, i, s, o, a, l) {
    if (FY.apply(this, arguments),
    zm) {
        if (zm) {
            var c = i_;
            zm = !1,
            i_ = null
        } else
            throw Error(Oe(198));
        s_ || (s_ = !0,
        nS = c)
    }
}
function Xu(n) {
    var e = n
      , t = n;
    if (n.alternate)
        for (; e.return; )
            e = e.return;
    else {
        n = e;
        do
            e = n,
            e.flags & 4098 && (t = e.return),
            n = e.return;
        while (n)
    }
    return e.tag === 3 ? t : null
}
function TH(n) {
    if (n.tag === 13) {
        var e = n.memoizedState;
        if (e === null && (n = n.alternate,
        n !== null && (e = n.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function HF(n) {
    if (Xu(n) !== n)
        throw Error(Oe(188))
}
function LY(n) {
    var e = n.alternate;
    if (!e) {
        if (e = Xu(n),
        e === null)
            throw Error(Oe(188));
        return e !== n ? null : n
    }
    for (var t = n, r = e; ; ) {
        var i = t.return;
        if (i === null)
            break;
        var s = i.alternate;
        if (s === null) {
            if (r = i.return,
            r !== null) {
                t = r;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s; ) {
                if (s === t)
                    return HF(i),
                    n;
                if (s === r)
                    return HF(i),
                    e;
                s = s.sibling
            }
            throw Error(Oe(188))
        }
        if (t.return !== r.return)
            t = i,
            r = s;
        else {
            for (var o = !1, a = i.child; a; ) {
                if (a === t) {
                    o = !0,
                    t = i,
                    r = s;
                    break
                }
                if (a === r) {
                    o = !0,
                    r = i,
                    t = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a; ) {
                    if (a === t) {
                        o = !0,
                        t = s,
                        r = i;
                        break
                    }
                    if (a === r) {
                        o = !0,
                        r = s,
                        t = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(Oe(189))
            }
        }
        if (t.alternate !== r)
            throw Error(Oe(190))
    }
    if (t.tag !== 3)
        throw Error(Oe(188));
    return t.stateNode.current === t ? n : e
}
function IH(n) {
    return n = LY(n),
    n !== null ? RH(n) : null
}
function RH(n) {
    if (n.tag === 5 || n.tag === 6)
        return n;
    for (n = n.child; n !== null; ) {
        var e = RH(n);
        if (e !== null)
            return e;
        n = n.sibling
    }
    return null
}
var UH = ks.unstable_scheduleCallback
  , zF = ks.unstable_cancelCallback
  , DY = ks.unstable_shouldYield
  , NY = ks.unstable_requestPaint
  , dr = ks.unstable_now
  , OY = ks.unstable_getCurrentPriorityLevel
  , SI = ks.unstable_ImmediatePriority
  , FH = ks.unstable_UserBlockingPriority
  , o_ = ks.unstable_NormalPriority
  , kY = ks.unstable_LowPriority
  , PH = ks.unstable_IdlePriority
  , Vx = null
  , Wa = null;
function QY(n) {
    if (Wa && typeof Wa.onCommitFiberRoot == "function")
        try {
            Wa.onCommitFiberRoot(Vx, n, void 0, (n.current.flags & 128) === 128)
        } catch {}
}
var na = Math.clz32 ? Math.clz32 : GY
  , HY = Math.log
  , zY = Math.LN2;
function GY(n) {
    return n >>>= 0,
    n === 0 ? 32 : 31 - (HY(n) / zY | 0) | 0
}
var J0 = 64
  , q0 = 4194304;
function vm(n) {
    switch (n & -n) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return n & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return n
    }
}
function a_(n, e) {
    var t = n.pendingLanes;
    if (t === 0)
        return 0;
    var r = 0
      , i = n.suspendedLanes
      , s = n.pingedLanes
      , o = t & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? r = vm(a) : (s &= o,
        s !== 0 && (r = vm(s)))
    } else
        o = t & ~i,
        o !== 0 ? r = vm(o) : s !== 0 && (r = vm(s));
    if (r === 0)
        return 0;
    if (e !== 0 && e !== r && !(e & i) && (i = r & -r,
    s = e & -e,
    i >= s || i === 16 && (s & 4194240) !== 0))
        return e;
    if (r & 4 && (r |= t & 16),
    e = n.entangledLanes,
    e !== 0)
        for (n = n.entanglements,
        e &= r; 0 < e; )
            t = 31 - na(e),
            i = 1 << t,
            r |= n[t],
            e &= ~i;
    return r
}
function VY(n, e) {
    switch (n) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function jY(n, e) {
    for (var t = n.suspendedLanes, r = n.pingedLanes, i = n.expirationTimes, s = n.pendingLanes; 0 < s; ) {
        var o = 31 - na(s)
          , a = 1 << o
          , l = i[o];
        l === -1 ? (!(a & t) || a & r) && (i[o] = VY(a, e)) : l <= e && (n.expiredLanes |= a),
        s &= ~a
    }
}
function rS(n) {
    return n = n.pendingLanes & -1073741825,
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
}
function LH() {
    var n = J0;
    return J0 <<= 1,
    !(J0 & 4194240) && (J0 = 64),
    n
}
function Qb(n) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(n);
    return e
}
function f0(n, e, t) {
    n.pendingLanes |= e,
    e !== 536870912 && (n.suspendedLanes = 0,
    n.pingedLanes = 0),
    n = n.eventTimes,
    e = 31 - na(e),
    n[e] = t
}
function WY(n, e) {
    var t = n.pendingLanes & ~e;
    n.pendingLanes = e,
    n.suspendedLanes = 0,
    n.pingedLanes = 0,
    n.expiredLanes &= e,
    n.mutableReadLanes &= e,
    n.entangledLanes &= e,
    e = n.entanglements;
    var r = n.eventTimes;
    for (n = n.expirationTimes; 0 < t; ) {
        var i = 31 - na(t)
          , s = 1 << i;
        e[i] = 0,
        r[i] = -1,
        n[i] = -1,
        t &= ~s
    }
}
function CI(n, e) {
    var t = n.entangledLanes |= e;
    for (n = n.entanglements; t; ) {
        var r = 31 - na(t)
          , i = 1 << r;
        i & e | n[r] & e && (n[r] |= e),
        t &= ~i
    }
}
var pn = 0;
function DH(n) {
    return n &= -n,
    1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1
}
var NH, TI, OH, kH, QH, iS = !1, ev = [], nA = null, rA = null, iA = null, vg = new Map, yg = new Map, zc = [], KY = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function GF(n, e) {
    switch (n) {
    case "focusin":
    case "focusout":
        nA = null;
        break;
    case "dragenter":
    case "dragleave":
        rA = null;
        break;
    case "mouseover":
    case "mouseout":
        iA = null;
        break;
    case "pointerover":
    case "pointerout":
        vg.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        yg.delete(e.pointerId)
    }
}
function xp(n, e, t, r, i, s) {
    return n === null || n.nativeEvent !== s ? (n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i]
    },
    e !== null && (e = d0(e),
    e !== null && TI(e)),
    n) : (n.eventSystemFlags |= r,
    e = n.targetContainers,
    i !== null && e.indexOf(i) === -1 && e.push(i),
    n)
}
function XY(n, e, t, r, i) {
    switch (e) {
    case "focusin":
        return nA = xp(nA, n, e, t, r, i),
        !0;
    case "dragenter":
        return rA = xp(rA, n, e, t, r, i),
        !0;
    case "mouseover":
        return iA = xp(iA, n, e, t, r, i),
        !0;
    case "pointerover":
        var s = i.pointerId;
        return vg.set(s, xp(vg.get(s) || null, n, e, t, r, i)),
        !0;
    case "gotpointercapture":
        return s = i.pointerId,
        yg.set(s, xp(yg.get(s) || null, n, e, t, r, i)),
        !0
    }
    return !1
}
function HH(n) {
    var e = Au(n.target);
    if (e !== null) {
        var t = Xu(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = TH(t),
                e !== null) {
                    n.blockedOn = e,
                    QH(n.priority, function() {
                        OH(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    n.blockedOn = null
}
function cw(n) {
    if (n.blockedOn !== null)
        return !1;
    for (var e = n.targetContainers; 0 < e.length; ) {
        var t = sS(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
        if (t === null) {
            t = n.nativeEvent;
            var r = new t.constructor(t.type,t);
            qM = r,
            t.target.dispatchEvent(r),
            qM = null
        } else
            return e = d0(t),
            e !== null && TI(e),
            n.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function VF(n, e, t) {
    cw(n) && t.delete(e)
}
function YY() {
    iS = !1,
    nA !== null && cw(nA) && (nA = null),
    rA !== null && cw(rA) && (rA = null),
    iA !== null && cw(iA) && (iA = null),
    vg.forEach(VF),
    yg.forEach(VF)
}
function bp(n, e) {
    n.blockedOn === e && (n.blockedOn = null,
    iS || (iS = !0,
    ks.unstable_scheduleCallback(ks.unstable_NormalPriority, YY)))
}
function wg(n) {
    function e(i) {
        return bp(i, n)
    }
    if (0 < ev.length) {
        bp(ev[0], n);
        for (var t = 1; t < ev.length; t++) {
            var r = ev[t];
            r.blockedOn === n && (r.blockedOn = null)
        }
    }
    for (nA !== null && bp(nA, n),
    rA !== null && bp(rA, n),
    iA !== null && bp(iA, n),
    vg.forEach(e),
    yg.forEach(e),
    t = 0; t < zc.length; t++)
        r = zc[t],
        r.blockedOn === n && (r.blockedOn = null);
    for (; 0 < zc.length && (t = zc[0],
    t.blockedOn === null); )
        HH(t),
        t.blockedOn === null && zc.shift()
}
var Zh = lc.ReactCurrentBatchConfig
  , l_ = !0;
function $Y(n, e, t, r) {
    var i = pn
      , s = Zh.transition;
    Zh.transition = null;
    try {
        pn = 1,
        II(n, e, t, r)
    } finally {
        pn = i,
        Zh.transition = s
    }
}
function ZY(n, e, t, r) {
    var i = pn
      , s = Zh.transition;
    Zh.transition = null;
    try {
        pn = 4,
        II(n, e, t, r)
    } finally {
        pn = i,
        Zh.transition = s
    }
}
function II(n, e, t, r) {
    if (l_) {
        var i = sS(n, e, t, r);
        if (i === null)
            $b(n, e, r, c_, t),
            GF(n, r);
        else if (XY(i, n, e, t, r))
            r.stopPropagation();
        else if (GF(n, r),
        e & 4 && -1 < KY.indexOf(n)) {
            for (; i !== null; ) {
                var s = d0(i);
                if (s !== null && NH(s),
                s = sS(n, e, t, r),
                s === null && $b(n, e, r, c_, t),
                s === i)
                    break;
                i = s
            }
            i !== null && r.stopPropagation()
        } else
            $b(n, e, r, null, t)
    }
}
var c_ = null;
function sS(n, e, t, r) {
    if (c_ = null,
    n = MI(r),
    n = Au(n),
    n !== null)
        if (e = Xu(n),
        e === null)
            n = null;
        else if (t = e.tag,
        t === 13) {
            if (n = TH(e),
            n !== null)
                return n;
            n = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            n = null
        } else
            e !== n && (n = null);
    return c_ = n,
    null
}
function zH(n) {
    switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (OY()) {
        case SI:
            return 1;
        case FH:
            return 4;
        case o_:
        case kY:
            return 16;
        case PH:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var jc = null
  , RI = null
  , Aw = null;
function GH() {
    if (Aw)
        return Aw;
    var n, e = RI, t = e.length, r, i = "value"in jc ? jc.value : jc.textContent, s = i.length;
    for (n = 0; n < t && e[n] === i[n]; n++)
        ;
    var o = t - n;
    for (r = 1; r <= o && e[t - r] === i[s - r]; r++)
        ;
    return Aw = i.slice(n, 1 < r ? 1 - r : void 0)
}
function uw(n) {
    var e = n.keyCode;
    return "charCode"in n ? (n = n.charCode,
    n === 0 && e === 13 && (n = 13)) : n = e,
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
}
function tv() {
    return !0
}
function jF() {
    return !1
}
function Ws(n) {
    function e(t, r, i, s, o) {
        this._reactName = t,
        this._targetInst = i,
        this.type = r,
        this.nativeEvent = s,
        this.target = o,
        this.currentTarget = null;
        for (var a in n)
            n.hasOwnProperty(a) && (t = n[a],
            this[a] = t ? t(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? tv : jF,
        this.isPropagationStopped = jF,
        this
    }
    return Yn(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = tv)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = tv)
        },
        persist: function() {},
        isPersistent: tv
    }),
    e
}
var jd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(n) {
        return n.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, UI = Ws(jd), h0 = Yn({}, jd, {
    view: 0,
    detail: 0
}), JY = Ws(h0), Hb, zb, Ep, jx = Yn({}, h0, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: FI,
    button: 0,
    buttons: 0,
    relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget
    },
    movementX: function(n) {
        return "movementX"in n ? n.movementX : (n !== Ep && (Ep && n.type === "mousemove" ? (Hb = n.screenX - Ep.screenX,
        zb = n.screenY - Ep.screenY) : zb = Hb = 0,
        Ep = n),
        Hb)
    },
    movementY: function(n) {
        return "movementY"in n ? n.movementY : zb
    }
}), WF = Ws(jx), qY = Yn({}, jx, {
    dataTransfer: 0
}), e$ = Ws(qY), t$ = Yn({}, h0, {
    relatedTarget: 0
}), Gb = Ws(t$), n$ = Yn({}, jd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), r$ = Ws(n$), i$ = Yn({}, jd, {
    clipboardData: function(n) {
        return "clipboardData"in n ? n.clipboardData : window.clipboardData
    }
}), s$ = Ws(i$), o$ = Yn({}, jd, {
    data: 0
}), KF = Ws(o$), a$ = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, l$ = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, c$ = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function A$(n) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(n) : (n = c$[n]) ? !!e[n] : !1
}
function FI() {
    return A$
}
var u$ = Yn({}, h0, {
    key: function(n) {
        if (n.key) {
            var e = a$[n.key] || n.key;
            if (e !== "Unidentified")
                return e
        }
        return n.type === "keypress" ? (n = uw(n),
        n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? l$[n.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: FI,
    charCode: function(n) {
        return n.type === "keypress" ? uw(n) : 0
    },
    keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    },
    which: function(n) {
        return n.type === "keypress" ? uw(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0
    }
})
  , f$ = Ws(u$)
  , h$ = Yn({}, jx, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , XF = Ws(h$)
  , d$ = Yn({}, h0, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: FI
})
  , p$ = Ws(d$)
  , m$ = Yn({}, jd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , g$ = Ws(m$)
  , v$ = Yn({}, jx, {
    deltaX: function(n) {
        return "deltaX"in n ? n.deltaX : "wheelDeltaX"in n ? -n.wheelDeltaX : 0
    },
    deltaY: function(n) {
        return "deltaY"in n ? n.deltaY : "wheelDeltaY"in n ? -n.wheelDeltaY : "wheelDelta"in n ? -n.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , y$ = Ws(v$)
  , w$ = [9, 13, 27, 32]
  , PI = $l && "CompositionEvent"in window
  , Gm = null;
$l && "documentMode"in document && (Gm = document.documentMode);
var _$ = $l && "TextEvent"in window && !Gm
  , VH = $l && (!PI || Gm && 8 < Gm && 11 >= Gm)
  , YF = String.fromCharCode(32)
  , $F = !1;
function jH(n, e) {
    switch (n) {
    case "keyup":
        return w$.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function WH(n) {
    return n = n.detail,
    typeof n == "object" && "data"in n ? n.data : null
}
var bh = !1;
function x$(n, e) {
    switch (n) {
    case "compositionend":
        return WH(e);
    case "keypress":
        return e.which !== 32 ? null : ($F = !0,
        YF);
    case "textInput":
        return n = e.data,
        n === YF && $F ? null : n;
    default:
        return null
    }
}
function b$(n, e) {
    if (bh)
        return n === "compositionend" || !PI && jH(n, e) ? (n = GH(),
        Aw = RI = jc = null,
        bh = !1,
        n) : null;
    switch (n) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return VH && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var E$ = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function ZF(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e === "input" ? !!E$[n.type] : e === "textarea"
}
function KH(n, e, t, r) {
    EH(r),
    e = A_(e, "onChange"),
    0 < e.length && (t = new UI("onChange","change",null,t,r),
    n.push({
        event: t,
        listeners: e
    }))
}
var Vm = null
  , _g = null;
function B$(n) {
    i5(n, 0)
}
function Wx(n) {
    var e = Mh(n);
    if (gH(e))
        return n
}
function M$(n, e) {
    if (n === "change")
        return e
}
var XH = !1;
if ($l) {
    var Vb;
    if ($l) {
        var jb = "oninput"in document;
        if (!jb) {
            var JF = document.createElement("div");
            JF.setAttribute("oninput", "return;"),
            jb = typeof JF.oninput == "function"
        }
        Vb = jb
    } else
        Vb = !1;
    XH = Vb && (!document.documentMode || 9 < document.documentMode)
}
function qF() {
    Vm && (Vm.detachEvent("onpropertychange", YH),
    _g = Vm = null)
}
function YH(n) {
    if (n.propertyName === "value" && Wx(_g)) {
        var e = [];
        KH(e, _g, n, MI(n)),
        CH(B$, e)
    }
}
function S$(n, e, t) {
    n === "focusin" ? (qF(),
    Vm = e,
    _g = t,
    Vm.attachEvent("onpropertychange", YH)) : n === "focusout" && qF()
}
function C$(n) {
    if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return Wx(_g)
}
function T$(n, e) {
    if (n === "click")
        return Wx(e)
}
function I$(n, e) {
    if (n === "input" || n === "change")
        return Wx(e)
}
function R$(n, e) {
    return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e
}
var la = typeof Object.is == "function" ? Object.is : R$;
function xg(n, e) {
    if (la(n, e))
        return !0;
    if (typeof n != "object" || n === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(n)
      , r = Object.keys(e);
    if (t.length !== r.length)
        return !1;
    for (r = 0; r < t.length; r++) {
        var i = t[r];
        if (!HM.call(e, i) || !la(n[i], e[i]))
            return !1
    }
    return !0
}
function eP(n) {
    for (; n && n.firstChild; )
        n = n.firstChild;
    return n
}
function tP(n, e) {
    var t = eP(n);
    n = 0;
    for (var r; t; ) {
        if (t.nodeType === 3) {
            if (r = n + t.textContent.length,
            n <= e && r >= e)
                return {
                    node: t,
                    offset: e - n
                };
            n = r
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = eP(t)
    }
}
function $H(n, e) {
    return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? $H(n, e.parentNode) : "contains"in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1
}
function ZH() {
    for (var n = window, e = r_(); e instanceof n.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            n = e.contentWindow;
        else
            break;
        e = r_(n.document)
    }
    return e
}
function LI(n) {
    var e = n && n.nodeName && n.nodeName.toLowerCase();
    return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true")
}
function U$(n) {
    var e = ZH()
      , t = n.focusedElem
      , r = n.selectionRange;
    if (e !== t && t && t.ownerDocument && $H(t.ownerDocument.documentElement, t)) {
        if (r !== null && LI(t)) {
            if (e = r.start,
            n = r.end,
            n === void 0 && (n = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window,
            n.getSelection) {
                n = n.getSelection();
                var i = t.textContent.length
                  , s = Math.min(r.start, i);
                r = r.end === void 0 ? s : Math.min(r.end, i),
                !n.extend && s > r && (i = r,
                r = s,
                s = i),
                i = tP(t, s);
                var o = tP(t, r);
                i && o && (n.rangeCount !== 1 || n.anchorNode !== i.node || n.anchorOffset !== i.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(i.node, i.offset),
                n.removeAllRanges(),
                s > r ? (n.addRange(e),
                n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                n.addRange(e)))
            }
        }
        for (e = [],
        n = t; n = n.parentNode; )
            n.nodeType === 1 && e.push({
                element: n,
                left: n.scrollLeft,
                top: n.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            n = e[t],
            n.element.scrollLeft = n.left,
            n.element.scrollTop = n.top
    }
}
var F$ = $l && "documentMode"in document && 11 >= document.documentMode
  , Eh = null
  , oS = null
  , jm = null
  , aS = !1;
function nP(n, e, t) {
    var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    aS || Eh == null || Eh !== r_(r) || (r = Eh,
    "selectionStart"in r && LI(r) ? r = {
        start: r.selectionStart,
        end: r.selectionEnd
    } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(),
    r = {
        anchorNode: r.anchorNode,
        anchorOffset: r.anchorOffset,
        focusNode: r.focusNode,
        focusOffset: r.focusOffset
    }),
    jm && xg(jm, r) || (jm = r,
    r = A_(oS, "onSelect"),
    0 < r.length && (e = new UI("onSelect","select",null,e,t),
    n.push({
        event: e,
        listeners: r
    }),
    e.target = Eh)))
}
function nv(n, e) {
    var t = {};
    return t[n.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + n] = "webkit" + e,
    t["Moz" + n] = "moz" + e,
    t
}
var Bh = {
    animationend: nv("Animation", "AnimationEnd"),
    animationiteration: nv("Animation", "AnimationIteration"),
    animationstart: nv("Animation", "AnimationStart"),
    transitionend: nv("Transition", "TransitionEnd")
}
  , Wb = {}
  , JH = {};
$l && (JH = document.createElement("div").style,
"AnimationEvent"in window || (delete Bh.animationend.animation,
delete Bh.animationiteration.animation,
delete Bh.animationstart.animation),
"TransitionEvent"in window || delete Bh.transitionend.transition);
function Kx(n) {
    if (Wb[n])
        return Wb[n];
    if (!Bh[n])
        return n;
    var e = Bh[n], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in JH)
            return Wb[n] = e[t];
    return n
}
var qH = Kx("animationend")
  , e5 = Kx("animationiteration")
  , t5 = Kx("animationstart")
  , n5 = Kx("transitionend")
  , r5 = new Map
  , rP = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function CA(n, e) {
    r5.set(n, e),
    Ku(e, [n])
}
for (var Kb = 0; Kb < rP.length; Kb++) {
    var Xb = rP[Kb]
      , P$ = Xb.toLowerCase()
      , L$ = Xb[0].toUpperCase() + Xb.slice(1);
    CA(P$, "on" + L$)
}
CA(qH, "onAnimationEnd");
CA(e5, "onAnimationIteration");
CA(t5, "onAnimationStart");
CA("dblclick", "onDoubleClick");
CA("focusin", "onFocus");
CA("focusout", "onBlur");
CA(n5, "onTransitionEnd");
gd("onMouseEnter", ["mouseout", "mouseover"]);
gd("onMouseLeave", ["mouseout", "mouseover"]);
gd("onPointerEnter", ["pointerout", "pointerover"]);
gd("onPointerLeave", ["pointerout", "pointerover"]);
Ku("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Ku("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Ku("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ku("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Ku("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Ku("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ym = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , D$ = new Set("cancel close invalid load scroll toggle".split(" ").concat(ym));
function iP(n, e, t) {
    var r = n.type || "unknown-event";
    n.currentTarget = t,
    PY(r, e, void 0, n),
    n.currentTarget = null
}
function i5(n, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < n.length; t++) {
        var r = n[t]
          , i = r.event;
        r = r.listeners;
        e: {
            var s = void 0;
            if (e)
                for (var o = r.length - 1; 0 <= o; o--) {
                    var a = r[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    iP(i, a, c),
                    s = l
                }
            else
                for (o = 0; o < r.length; o++) {
                    if (a = r[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== s && i.isPropagationStopped())
                        break e;
                    iP(i, a, c),
                    s = l
                }
        }
    }
    if (s_)
        throw n = nS,
        s_ = !1,
        nS = null,
        n
}
function Mn(n, e) {
    var t = e[fS];
    t === void 0 && (t = e[fS] = new Set);
    var r = n + "__bubble";
    t.has(r) || (s5(e, n, 2, !1),
    t.add(r))
}
function Yb(n, e, t) {
    var r = 0;
    e && (r |= 4),
    s5(t, n, r, e)
}
var rv = "_reactListening" + Math.random().toString(36).slice(2);
function bg(n) {
    if (!n[rv]) {
        n[rv] = !0,
        fH.forEach(function(t) {
            t !== "selectionchange" && (D$.has(t) || Yb(t, !1, n),
            Yb(t, !0, n))
        });
        var e = n.nodeType === 9 ? n : n.ownerDocument;
        e === null || e[rv] || (e[rv] = !0,
        Yb("selectionchange", !1, e))
    }
}
function s5(n, e, t, r) {
    switch (zH(e)) {
    case 1:
        var i = $Y;
        break;
    case 4:
        i = ZY;
        break;
    default:
        i = II
    }
    t = i.bind(null, e, t, n),
    i = void 0,
    !tS || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0),
    r ? i !== void 0 ? n.addEventListener(e, t, {
        capture: !0,
        passive: i
    }) : n.addEventListener(e, t, !0) : i !== void 0 ? n.addEventListener(e, t, {
        passive: i
    }) : n.addEventListener(e, t, !1)
}
function $b(n, e, t, r, i) {
    var s = r;
    if (!(e & 1) && !(e & 2) && r !== null)
        e: for (; ; ) {
            if (r === null)
                return;
            var o = r.tag;
            if (o === 3 || o === 4) {
                var a = r.stateNode.containerInfo;
                if (a === i || a.nodeType === 8 && a.parentNode === i)
                    break;
                if (o === 4)
                    for (o = r.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === i || l.nodeType === 8 && l.parentNode === i))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = Au(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        r = s = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            r = r.return
        }
    CH(function() {
        var c = s
          , A = MI(t)
          , u = [];
        e: {
            var f = r5.get(n);
            if (f !== void 0) {
                var h = UI
                  , d = n;
                switch (n) {
                case "keypress":
                    if (uw(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    h = f$;
                    break;
                case "focusin":
                    d = "focus",
                    h = Gb;
                    break;
                case "focusout":
                    d = "blur",
                    h = Gb;
                    break;
                case "beforeblur":
                case "afterblur":
                    h = Gb;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    h = WF;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    h = e$;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    h = p$;
                    break;
                case qH:
                case e5:
                case t5:
                    h = r$;
                    break;
                case n5:
                    h = g$;
                    break;
                case "scroll":
                    h = JY;
                    break;
                case "wheel":
                    h = y$;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    h = s$;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    h = XF
                }
                var m = (e & 4) !== 0
                  , g = !m && n === "scroll"
                  , p = m ? f !== null ? f + "Capture" : null : f;
                m = [];
                for (var v = c, w; v !== null; ) {
                    w = v;
                    var _ = w.stateNode;
                    if (w.tag === 5 && _ !== null && (w = _,
                    p !== null && (_ = gg(v, p),
                    _ != null && m.push(Eg(v, _, w)))),
                    g)
                        break;
                    v = v.return
                }
                0 < m.length && (f = new h(f,d,null,t,A),
                u.push({
                    event: f,
                    listeners: m
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (f = n === "mouseover" || n === "pointerover",
                h = n === "mouseout" || n === "pointerout",
                f && t !== qM && (d = t.relatedTarget || t.fromElement) && (Au(d) || d[Zl]))
                    break e;
                if ((h || f) && (f = A.window === A ? A : (f = A.ownerDocument) ? f.defaultView || f.parentWindow : window,
                h ? (d = t.relatedTarget || t.toElement,
                h = c,
                d = d ? Au(d) : null,
                d !== null && (g = Xu(d),
                d !== g || d.tag !== 5 && d.tag !== 6) && (d = null)) : (h = null,
                d = c),
                h !== d)) {
                    if (m = WF,
                    _ = "onMouseLeave",
                    p = "onMouseEnter",
                    v = "mouse",
                    (n === "pointerout" || n === "pointerover") && (m = XF,
                    _ = "onPointerLeave",
                    p = "onPointerEnter",
                    v = "pointer"),
                    g = h == null ? f : Mh(h),
                    w = d == null ? f : Mh(d),
                    f = new m(_,v + "leave",h,t,A),
                    f.target = g,
                    f.relatedTarget = w,
                    _ = null,
                    Au(A) === c && (m = new m(p,v + "enter",d,t,A),
                    m.target = w,
                    m.relatedTarget = g,
                    _ = m),
                    g = _,
                    h && d)
                        t: {
                            for (m = h,
                            p = d,
                            v = 0,
                            w = m; w; w = af(w))
                                v++;
                            for (w = 0,
                            _ = p; _; _ = af(_))
                                w++;
                            for (; 0 < v - w; )
                                m = af(m),
                                v--;
                            for (; 0 < w - v; )
                                p = af(p),
                                w--;
                            for (; v--; ) {
                                if (m === p || p !== null && m === p.alternate)
                                    break t;
                                m = af(m),
                                p = af(p)
                            }
                            m = null
                        }
                    else
                        m = null;
                    h !== null && sP(u, f, h, m, !1),
                    d !== null && g !== null && sP(u, g, d, m, !0)
                }
            }
            e: {
                if (f = c ? Mh(c) : window,
                h = f.nodeName && f.nodeName.toLowerCase(),
                h === "select" || h === "input" && f.type === "file")
                    var x = M$;
                else if (ZF(f))
                    if (XH)
                        x = I$;
                    else {
                        x = C$;
                        var b = S$
                    }
                else
                    (h = f.nodeName) && h.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (x = T$);
                if (x && (x = x(n, c))) {
                    KH(u, x, t, A);
                    break e
                }
                b && b(n, f, c),
                n === "focusout" && (b = f._wrapperState) && b.controlled && f.type === "number" && XM(f, "number", f.value)
            }
            switch (b = c ? Mh(c) : window,
            n) {
            case "focusin":
                (ZF(b) || b.contentEditable === "true") && (Eh = b,
                oS = c,
                jm = null);
                break;
            case "focusout":
                jm = oS = Eh = null;
                break;
            case "mousedown":
                aS = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                aS = !1,
                nP(u, t, A);
                break;
            case "selectionchange":
                if (F$)
                    break;
            case "keydown":
            case "keyup":
                nP(u, t, A)
            }
            var B;
            if (PI)
                e: {
                    switch (n) {
                    case "compositionstart":
                        var S = "onCompositionStart";
                        break e;
                    case "compositionend":
                        S = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        S = "onCompositionUpdate";
                        break e
                    }
                    S = void 0
                }
            else
                bh ? jH(n, t) && (S = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (S = "onCompositionStart");
            S && (VH && t.locale !== "ko" && (bh || S !== "onCompositionStart" ? S === "onCompositionEnd" && bh && (B = GH()) : (jc = A,
            RI = "value"in jc ? jc.value : jc.textContent,
            bh = !0)),
            b = A_(c, S),
            0 < b.length && (S = new KF(S,n,null,t,A),
            u.push({
                event: S,
                listeners: b
            }),
            B ? S.data = B : (B = WH(t),
            B !== null && (S.data = B)))),
            (B = _$ ? x$(n, t) : b$(n, t)) && (c = A_(c, "onBeforeInput"),
            0 < c.length && (A = new KF("onBeforeInput","beforeinput",null,t,A),
            u.push({
                event: A,
                listeners: c
            }),
            A.data = B))
        }
        i5(u, e)
    })
}
function Eg(n, e, t) {
    return {
        instance: n,
        listener: e,
        currentTarget: t
    }
}
function A_(n, e) {
    for (var t = e + "Capture", r = []; n !== null; ) {
        var i = n
          , s = i.stateNode;
        i.tag === 5 && s !== null && (i = s,
        s = gg(n, t),
        s != null && r.unshift(Eg(n, s, i)),
        s = gg(n, e),
        s != null && r.push(Eg(n, s, i))),
        n = n.return
    }
    return r
}
function af(n) {
    if (n === null)
        return null;
    do
        n = n.return;
    while (n && n.tag !== 5);
    return n || null
}
function sP(n, e, t, r, i) {
    for (var s = e._reactName, o = []; t !== null && t !== r; ) {
        var a = t
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === r)
            break;
        a.tag === 5 && c !== null && (a = c,
        i ? (l = gg(t, s),
        l != null && o.unshift(Eg(t, l, a))) : i || (l = gg(t, s),
        l != null && o.push(Eg(t, l, a)))),
        t = t.return
    }
    o.length !== 0 && n.push({
        event: e,
        listeners: o
    })
}
var N$ = /\r\n?/g
  , O$ = /\u0000|\uFFFD/g;
function oP(n) {
    return (typeof n == "string" ? n : "" + n).replace(N$, `
`).replace(O$, "")
}
function iv(n, e, t) {
    if (e = oP(e),
    oP(n) !== e && t)
        throw Error(Oe(425))
}
function u_() {}
var lS = null
  , cS = null;
function AS(n, e) {
    return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var uS = typeof setTimeout == "function" ? setTimeout : void 0
  , k$ = typeof clearTimeout == "function" ? clearTimeout : void 0
  , aP = typeof Promise == "function" ? Promise : void 0
  , Q$ = typeof queueMicrotask == "function" ? queueMicrotask : typeof aP < "u" ? function(n) {
    return aP.resolve(null).then(n).catch(H$)
}
: uS;
function H$(n) {
    setTimeout(function() {
        throw n
    })
}
function Zb(n, e) {
    var t = e
      , r = 0;
    do {
        var i = t.nextSibling;
        if (n.removeChild(t),
        i && i.nodeType === 8)
            if (t = i.data,
            t === "/$") {
                if (r === 0) {
                    n.removeChild(i),
                    wg(e);
                    return
                }
                r--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || r++;
        t = i
    } while (t);
    wg(e)
}
function sA(n) {
    for (; n != null; n = n.nextSibling) {
        var e = n.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = n.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return n
}
function lP(n) {
    n = n.previousSibling;
    for (var e = 0; n; ) {
        if (n.nodeType === 8) {
            var t = n.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return n;
                e--
            } else
                t === "/$" && e++
        }
        n = n.previousSibling
    }
    return null
}
var Wd = Math.random().toString(36).slice(2)
  , Fa = "__reactFiber$" + Wd
  , Bg = "__reactProps$" + Wd
  , Zl = "__reactContainer$" + Wd
  , fS = "__reactEvents$" + Wd
  , z$ = "__reactListeners$" + Wd
  , G$ = "__reactHandles$" + Wd;
function Au(n) {
    var e = n[Fa];
    if (e)
        return e;
    for (var t = n.parentNode; t; ) {
        if (e = t[Zl] || t[Fa]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (n = lP(n); n !== null; ) {
                    if (t = n[Fa])
                        return t;
                    n = lP(n)
                }
            return e
        }
        n = t,
        t = n.parentNode
    }
    return null
}
function d0(n) {
    return n = n[Fa] || n[Zl],
    !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n
}
function Mh(n) {
    if (n.tag === 5 || n.tag === 6)
        return n.stateNode;
    throw Error(Oe(33))
}
function Xx(n) {
    return n[Bg] || null
}
var hS = []
  , Sh = -1;
function TA(n) {
    return {
        current: n
    }
}
function Rn(n) {
    0 > Sh || (n.current = hS[Sh],
    hS[Sh] = null,
    Sh--)
}
function En(n, e) {
    Sh++,
    hS[Sh] = n.current,
    n.current = e
}
var gA = {}
  , Si = TA(gA)
  , es = TA(!1)
  , Tu = gA;
function vd(n, e) {
    var t = n.type.contextTypes;
    if (!t)
        return gA;
    var r = n.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
        return r.__reactInternalMemoizedMaskedChildContext;
    var i = {}, s;
    for (s in t)
        i[s] = e[s];
    return r && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = e,
    n.__reactInternalMemoizedMaskedChildContext = i),
    i
}
function ts(n) {
    return n = n.childContextTypes,
    n != null
}
function f_() {
    Rn(es),
    Rn(Si)
}
function cP(n, e, t) {
    if (Si.current !== gA)
        throw Error(Oe(168));
    En(Si, e),
    En(es, t)
}
function o5(n, e, t) {
    var r = n.stateNode;
    if (e = e.childContextTypes,
    typeof r.getChildContext != "function")
        return t;
    r = r.getChildContext();
    for (var i in r)
        if (!(i in e))
            throw Error(Oe(108, SY(n) || "Unknown", i));
    return Yn({}, t, r)
}
function h_(n) {
    return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || gA,
    Tu = Si.current,
    En(Si, n),
    En(es, es.current),
    !0
}
function AP(n, e, t) {
    var r = n.stateNode;
    if (!r)
        throw Error(Oe(169));
    t ? (n = o5(n, e, Tu),
    r.__reactInternalMemoizedMergedChildContext = n,
    Rn(es),
    Rn(Si),
    En(Si, n)) : Rn(es),
    En(es, t)
}
var Pl = null
  , Yx = !1
  , Jb = !1;
function a5(n) {
    Pl === null ? Pl = [n] : Pl.push(n)
}
function V$(n) {
    Yx = !0,
    a5(n)
}
function IA() {
    if (!Jb && Pl !== null) {
        Jb = !0;
        var n = 0
          , e = pn;
        try {
            var t = Pl;
            for (pn = 1; n < t.length; n++) {
                var r = t[n];
                do
                    r = r(!0);
                while (r !== null)
            }
            Pl = null,
            Yx = !1
        } catch (i) {
            throw Pl !== null && (Pl = Pl.slice(n + 1)),
            UH(SI, IA),
            i
        } finally {
            pn = e,
            Jb = !1
        }
    }
    return null
}
var Ch = []
  , Th = 0
  , d_ = null
  , p_ = 0
  , io = []
  , so = 0
  , Iu = null
  , Ql = 1
  , Hl = "";
function eu(n, e) {
    Ch[Th++] = p_,
    Ch[Th++] = d_,
    d_ = n,
    p_ = e
}
function l5(n, e, t) {
    io[so++] = Ql,
    io[so++] = Hl,
    io[so++] = Iu,
    Iu = n;
    var r = Ql;
    n = Hl;
    var i = 32 - na(r) - 1;
    r &= ~(1 << i),
    t += 1;
    var s = 32 - na(e) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (r & (1 << o) - 1).toString(32),
        r >>= o,
        i -= o,
        Ql = 1 << 32 - na(e) + i | t << i | r,
        Hl = s + n
    } else
        Ql = 1 << s | t << i | r,
        Hl = n
}
function DI(n) {
    n.return !== null && (eu(n, 1),
    l5(n, 1, 0))
}
function NI(n) {
    for (; n === d_; )
        d_ = Ch[--Th],
        Ch[Th] = null,
        p_ = Ch[--Th],
        Ch[Th] = null;
    for (; n === Iu; )
        Iu = io[--so],
        io[so] = null,
        Hl = io[--so],
        io[so] = null,
        Ql = io[--so],
        io[so] = null
}
var Ls = null
  , Ts = null
  , On = !1
  , $o = null;
function c5(n, e) {
    var t = co(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = n,
    e = n.deletions,
    e === null ? (n.deletions = [t],
    n.flags |= 16) : e.push(t)
}
function uP(n, e) {
    switch (n.tag) {
    case 5:
        var t = n.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (n.stateNode = e,
        Ls = n,
        Ts = sA(e.firstChild),
        !0) : !1;
    case 6:
        return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (n.stateNode = e,
        Ls = n,
        Ts = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = Iu !== null ? {
            id: Ql,
            overflow: Hl
        } : null,
        n.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = co(18, null, null, 0),
        t.stateNode = e,
        t.return = n,
        n.child = t,
        Ls = n,
        Ts = null,
        !0) : !1;
    default:
        return !1
    }
}
function dS(n) {
    return (n.mode & 1) !== 0 && (n.flags & 128) === 0
}
function pS(n) {
    if (On) {
        var e = Ts;
        if (e) {
            var t = e;
            if (!uP(n, e)) {
                if (dS(n))
                    throw Error(Oe(418));
                e = sA(t.nextSibling);
                var r = Ls;
                e && uP(n, e) ? c5(r, t) : (n.flags = n.flags & -4097 | 2,
                On = !1,
                Ls = n)
            }
        } else {
            if (dS(n))
                throw Error(Oe(418));
            n.flags = n.flags & -4097 | 2,
            On = !1,
            Ls = n
        }
    }
}
function fP(n) {
    for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
        n = n.return;
    Ls = n
}
function sv(n) {
    if (n !== Ls)
        return !1;
    if (!On)
        return fP(n),
        On = !0,
        !1;
    var e;
    if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type,
    e = e !== "head" && e !== "body" && !AS(n.type, n.memoizedProps)),
    e && (e = Ts)) {
        if (dS(n))
            throw A5(),
            Error(Oe(418));
        for (; e; )
            c5(n, e),
            e = sA(e.nextSibling)
    }
    if (fP(n),
    n.tag === 13) {
        if (n = n.memoizedState,
        n = n !== null ? n.dehydrated : null,
        !n)
            throw Error(Oe(317));
        e: {
            for (n = n.nextSibling,
            e = 0; n; ) {
                if (n.nodeType === 8) {
                    var t = n.data;
                    if (t === "/$") {
                        if (e === 0) {
                            Ts = sA(n.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                n = n.nextSibling
            }
            Ts = null
        }
    } else
        Ts = Ls ? sA(n.stateNode.nextSibling) : null;
    return !0
}
function A5() {
    for (var n = Ts; n; )
        n = sA(n.nextSibling)
}
function yd() {
    Ts = Ls = null,
    On = !1
}
function OI(n) {
    $o === null ? $o = [n] : $o.push(n)
}
var j$ = lc.ReactCurrentBatchConfig;
function Bp(n, e, t) {
    if (n = t.ref,
    n !== null && typeof n != "function" && typeof n != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(Oe(309));
                var r = t.stateNode
            }
            if (!r)
                throw Error(Oe(147, n));
            var i = r
              , s = "" + n;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
                var a = i.refs;
                o === null ? delete a[s] : a[s] = o
            }
            ,
            e._stringRef = s,
            e)
        }
        if (typeof n != "string")
            throw Error(Oe(284));
        if (!t._owner)
            throw Error(Oe(290, n))
    }
    return n
}
function ov(n, e) {
    throw n = Object.prototype.toString.call(e),
    Error(Oe(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n))
}
function hP(n) {
    var e = n._init;
    return e(n._payload)
}
function u5(n) {
    function e(p, v) {
        if (n) {
            var w = p.deletions;
            w === null ? (p.deletions = [v],
            p.flags |= 16) : w.push(v)
        }
    }
    function t(p, v) {
        if (!n)
            return null;
        for (; v !== null; )
            e(p, v),
            v = v.sibling;
        return null
    }
    function r(p, v) {
        for (p = new Map; v !== null; )
            v.key !== null ? p.set(v.key, v) : p.set(v.index, v),
            v = v.sibling;
        return p
    }
    function i(p, v) {
        return p = cA(p, v),
        p.index = 0,
        p.sibling = null,
        p
    }
    function s(p, v, w) {
        return p.index = w,
        n ? (w = p.alternate,
        w !== null ? (w = w.index,
        w < v ? (p.flags |= 2,
        v) : w) : (p.flags |= 2,
        v)) : (p.flags |= 1048576,
        v)
    }
    function o(p) {
        return n && p.alternate === null && (p.flags |= 2),
        p
    }
    function a(p, v, w, _) {
        return v === null || v.tag !== 6 ? (v = sE(w, p.mode, _),
        v.return = p,
        v) : (v = i(v, w),
        v.return = p,
        v)
    }
    function l(p, v, w, _) {
        var x = w.type;
        return x === xh ? A(p, v, w.props.children, _, w.key) : v !== null && (v.elementType === x || typeof x == "object" && x !== null && x.$$typeof === Dc && hP(x) === v.type) ? (_ = i(v, w.props),
        _.ref = Bp(p, v, w),
        _.return = p,
        _) : (_ = vw(w.type, w.key, w.props, null, p.mode, _),
        _.ref = Bp(p, v, w),
        _.return = p,
        _)
    }
    function c(p, v, w, _) {
        return v === null || v.tag !== 4 || v.stateNode.containerInfo !== w.containerInfo || v.stateNode.implementation !== w.implementation ? (v = oE(w, p.mode, _),
        v.return = p,
        v) : (v = i(v, w.children || []),
        v.return = p,
        v)
    }
    function A(p, v, w, _, x) {
        return v === null || v.tag !== 7 ? (v = yu(w, p.mode, _, x),
        v.return = p,
        v) : (v = i(v, w),
        v.return = p,
        v)
    }
    function u(p, v, w) {
        if (typeof v == "string" && v !== "" || typeof v == "number")
            return v = sE("" + v, p.mode, w),
            v.return = p,
            v;
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
            case Y0:
                return w = vw(v.type, v.key, v.props, null, p.mode, w),
                w.ref = Bp(p, null, v),
                w.return = p,
                w;
            case _h:
                return v = oE(v, p.mode, w),
                v.return = p,
                v;
            case Dc:
                var _ = v._init;
                return u(p, _(v._payload), w)
            }
            if (gm(v) || wp(v))
                return v = yu(v, p.mode, w, null),
                v.return = p,
                v;
            ov(p, v)
        }
        return null
    }
    function f(p, v, w, _) {
        var x = v !== null ? v.key : null;
        if (typeof w == "string" && w !== "" || typeof w == "number")
            return x !== null ? null : a(p, v, "" + w, _);
        if (typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Y0:
                return w.key === x ? l(p, v, w, _) : null;
            case _h:
                return w.key === x ? c(p, v, w, _) : null;
            case Dc:
                return x = w._init,
                f(p, v, x(w._payload), _)
            }
            if (gm(w) || wp(w))
                return x !== null ? null : A(p, v, w, _, null);
            ov(p, w)
        }
        return null
    }
    function h(p, v, w, _, x) {
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return p = p.get(w) || null,
            a(v, p, "" + _, x);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case Y0:
                return p = p.get(_.key === null ? w : _.key) || null,
                l(v, p, _, x);
            case _h:
                return p = p.get(_.key === null ? w : _.key) || null,
                c(v, p, _, x);
            case Dc:
                var b = _._init;
                return h(p, v, w, b(_._payload), x)
            }
            if (gm(_) || wp(_))
                return p = p.get(w) || null,
                A(v, p, _, x, null);
            ov(v, _)
        }
        return null
    }
    function d(p, v, w, _) {
        for (var x = null, b = null, B = v, S = v = 0, I = null; B !== null && S < w.length; S++) {
            B.index > S ? (I = B,
            B = null) : I = B.sibling;
            var M = f(p, B, w[S], _);
            if (M === null) {
                B === null && (B = I);
                break
            }
            n && B && M.alternate === null && e(p, B),
            v = s(M, v, S),
            b === null ? x = M : b.sibling = M,
            b = M,
            B = I
        }
        if (S === w.length)
            return t(p, B),
            On && eu(p, S),
            x;
        if (B === null) {
            for (; S < w.length; S++)
                B = u(p, w[S], _),
                B !== null && (v = s(B, v, S),
                b === null ? x = B : b.sibling = B,
                b = B);
            return On && eu(p, S),
            x
        }
        for (B = r(p, B); S < w.length; S++)
            I = h(B, p, S, w[S], _),
            I !== null && (n && I.alternate !== null && B.delete(I.key === null ? S : I.key),
            v = s(I, v, S),
            b === null ? x = I : b.sibling = I,
            b = I);
        return n && B.forEach(function(L) {
            return e(p, L)
        }),
        On && eu(p, S),
        x
    }
    function m(p, v, w, _) {
        var x = wp(w);
        if (typeof x != "function")
            throw Error(Oe(150));
        if (w = x.call(w),
        w == null)
            throw Error(Oe(151));
        for (var b = x = null, B = v, S = v = 0, I = null, M = w.next(); B !== null && !M.done; S++,
        M = w.next()) {
            B.index > S ? (I = B,
            B = null) : I = B.sibling;
            var L = f(p, B, M.value, _);
            if (L === null) {
                B === null && (B = I);
                break
            }
            n && B && L.alternate === null && e(p, B),
            v = s(L, v, S),
            b === null ? x = L : b.sibling = L,
            b = L,
            B = I
        }
        if (M.done)
            return t(p, B),
            On && eu(p, S),
            x;
        if (B === null) {
            for (; !M.done; S++,
            M = w.next())
                M = u(p, M.value, _),
                M !== null && (v = s(M, v, S),
                b === null ? x = M : b.sibling = M,
                b = M);
            return On && eu(p, S),
            x
        }
        for (B = r(p, B); !M.done; S++,
        M = w.next())
            M = h(B, p, S, M.value, _),
            M !== null && (n && M.alternate !== null && B.delete(M.key === null ? S : M.key),
            v = s(M, v, S),
            b === null ? x = M : b.sibling = M,
            b = M);
        return n && B.forEach(function(D) {
            return e(p, D)
        }),
        On && eu(p, S),
        x
    }
    function g(p, v, w, _) {
        if (typeof w == "object" && w !== null && w.type === xh && w.key === null && (w = w.props.children),
        typeof w == "object" && w !== null) {
            switch (w.$$typeof) {
            case Y0:
                e: {
                    for (var x = w.key, b = v; b !== null; ) {
                        if (b.key === x) {
                            if (x = w.type,
                            x === xh) {
                                if (b.tag === 7) {
                                    t(p, b.sibling),
                                    v = i(b, w.props.children),
                                    v.return = p,
                                    p = v;
                                    break e
                                }
                            } else if (b.elementType === x || typeof x == "object" && x !== null && x.$$typeof === Dc && hP(x) === b.type) {
                                t(p, b.sibling),
                                v = i(b, w.props),
                                v.ref = Bp(p, b, w),
                                v.return = p,
                                p = v;
                                break e
                            }
                            t(p, b);
                            break
                        } else
                            e(p, b);
                        b = b.sibling
                    }
                    w.type === xh ? (v = yu(w.props.children, p.mode, _, w.key),
                    v.return = p,
                    p = v) : (_ = vw(w.type, w.key, w.props, null, p.mode, _),
                    _.ref = Bp(p, v, w),
                    _.return = p,
                    p = _)
                }
                return o(p);
            case _h:
                e: {
                    for (b = w.key; v !== null; ) {
                        if (v.key === b)
                            if (v.tag === 4 && v.stateNode.containerInfo === w.containerInfo && v.stateNode.implementation === w.implementation) {
                                t(p, v.sibling),
                                v = i(v, w.children || []),
                                v.return = p,
                                p = v;
                                break e
                            } else {
                                t(p, v);
                                break
                            }
                        else
                            e(p, v);
                        v = v.sibling
                    }
                    v = oE(w, p.mode, _),
                    v.return = p,
                    p = v
                }
                return o(p);
            case Dc:
                return b = w._init,
                g(p, v, b(w._payload), _)
            }
            if (gm(w))
                return d(p, v, w, _);
            if (wp(w))
                return m(p, v, w, _);
            ov(p, w)
        }
        return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w,
        v !== null && v.tag === 6 ? (t(p, v.sibling),
        v = i(v, w),
        v.return = p,
        p = v) : (t(p, v),
        v = sE(w, p.mode, _),
        v.return = p,
        p = v),
        o(p)) : t(p, v)
    }
    return g
}
var wd = u5(!0)
  , f5 = u5(!1)
  , m_ = TA(null)
  , g_ = null
  , Ih = null
  , kI = null;
function QI() {
    kI = Ih = g_ = null
}
function HI(n) {
    var e = m_.current;
    Rn(m_),
    n._currentValue = e
}
function mS(n, e, t) {
    for (; n !== null; ) {
        var r = n.alternate;
        if ((n.childLanes & e) !== e ? (n.childLanes |= e,
        r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
        n === t)
            break;
        n = n.return
    }
}
function Jh(n, e) {
    g_ = n,
    kI = Ih = null,
    n = n.dependencies,
    n !== null && n.firstContext !== null && (n.lanes & e && (Ji = !0),
    n.firstContext = null)
}
function _o(n) {
    var e = n._currentValue;
    if (kI !== n)
        if (n = {
            context: n,
            memoizedValue: e,
            next: null
        },
        Ih === null) {
            if (g_ === null)
                throw Error(Oe(308));
            Ih = n,
            g_.dependencies = {
                lanes: 0,
                firstContext: n
            }
        } else
            Ih = Ih.next = n;
    return e
}
var uu = null;
function zI(n) {
    uu === null ? uu = [n] : uu.push(n)
}
function h5(n, e, t, r) {
    var i = e.interleaved;
    return i === null ? (t.next = t,
    zI(e)) : (t.next = i.next,
    i.next = t),
    e.interleaved = t,
    Jl(n, r)
}
function Jl(n, e) {
    n.lanes |= e;
    var t = n.alternate;
    for (t !== null && (t.lanes |= e),
    t = n,
    n = n.return; n !== null; )
        n.childLanes |= e,
        t = n.alternate,
        t !== null && (t.childLanes |= e),
        t = n,
        n = n.return;
    return t.tag === 3 ? t.stateNode : null
}
var Nc = !1;
function GI(n) {
    n.updateQueue = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function d5(n, e) {
    n = n.updateQueue,
    e.updateQueue === n && (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects
    })
}
function Vl(n, e) {
    return {
        eventTime: n,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function oA(n, e, t) {
    var r = n.updateQueue;
    if (r === null)
        return null;
    if (r = r.shared,
    Kt & 2) {
        var i = r.pending;
        return i === null ? e.next = e : (e.next = i.next,
        i.next = e),
        r.pending = e,
        Jl(n, t)
    }
    return i = r.interleaved,
    i === null ? (e.next = e,
    zI(r)) : (e.next = i.next,
    i.next = e),
    r.interleaved = e,
    Jl(n, t)
}
function fw(n, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var r = e.lanes;
        r &= n.pendingLanes,
        t |= r,
        e.lanes = t,
        CI(n, t)
    }
}
function dP(n, e) {
    var t = n.updateQueue
      , r = n.alternate;
    if (r !== null && (r = r.updateQueue,
    t === r)) {
        var i = null
          , s = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var o = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o,
                t = t.next
            } while (t !== null);
            s === null ? i = s = e : s = s.next = e
        } else
            i = s = e;
        t = {
            baseState: r.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: r.shared,
            effects: r.effects
        },
        n.updateQueue = t;
        return
    }
    n = t.lastBaseUpdate,
    n === null ? t.firstBaseUpdate = e : n.next = e,
    t.lastBaseUpdate = e
}
function v_(n, e, t, r) {
    var i = n.updateQueue;
    Nc = !1;
    var s = i.firstBaseUpdate
      , o = i.lastBaseUpdate
      , a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? s = c : o.next = c,
        o = l;
        var A = n.alternate;
        A !== null && (A = A.updateQueue,
        a = A.lastBaseUpdate,
        a !== o && (a === null ? A.firstBaseUpdate = c : a.next = c,
        A.lastBaseUpdate = l))
    }
    if (s !== null) {
        var u = i.baseState;
        o = 0,
        A = c = l = null,
        a = s;
        do {
            var f = a.lane
              , h = a.eventTime;
            if ((r & f) === f) {
                A !== null && (A = A.next = {
                    eventTime: h,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var d = n
                      , m = a;
                    switch (f = e,
                    h = t,
                    m.tag) {
                    case 1:
                        if (d = m.payload,
                        typeof d == "function") {
                            u = d.call(h, u, f);
                            break e
                        }
                        u = d;
                        break e;
                    case 3:
                        d.flags = d.flags & -65537 | 128;
                    case 0:
                        if (d = m.payload,
                        f = typeof d == "function" ? d.call(h, u, f) : d,
                        f == null)
                            break e;
                        u = Yn({}, u, f);
                        break e;
                    case 2:
                        Nc = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (n.flags |= 64,
                f = i.effects,
                f === null ? i.effects = [a] : f.push(a))
            } else
                h = {
                    eventTime: h,
                    lane: f,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                A === null ? (c = A = h,
                l = u) : A = A.next = h,
                o |= f;
            if (a = a.next,
            a === null) {
                if (a = i.shared.pending,
                a === null)
                    break;
                f = a,
                a = f.next,
                f.next = null,
                i.lastBaseUpdate = f,
                i.shared.pending = null
            }
        } while (1);
        if (A === null && (l = u),
        i.baseState = l,
        i.firstBaseUpdate = c,
        i.lastBaseUpdate = A,
        e = i.shared.interleaved,
        e !== null) {
            i = e;
            do
                o |= i.lane,
                i = i.next;
            while (i !== e)
        } else
            s === null && (i.shared.lanes = 0);
        Uu |= o,
        n.lanes = o,
        n.memoizedState = u
    }
}
function pP(n, e, t) {
    if (n = e.effects,
    e.effects = null,
    n !== null)
        for (e = 0; e < n.length; e++) {
            var r = n[e]
              , i = r.callback;
            if (i !== null) {
                if (r.callback = null,
                r = t,
                typeof i != "function")
                    throw Error(Oe(191, i));
                i.call(r)
            }
        }
}
var p0 = {}
  , Ka = TA(p0)
  , Mg = TA(p0)
  , Sg = TA(p0);
function fu(n) {
    if (n === p0)
        throw Error(Oe(174));
    return n
}
function VI(n, e) {
    switch (En(Sg, e),
    En(Mg, n),
    En(Ka, p0),
    n = e.nodeType,
    n) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : $M(null, "");
        break;
    default:
        n = n === 8 ? e.parentNode : e,
        e = n.namespaceURI || null,
        n = n.tagName,
        e = $M(e, n)
    }
    Rn(Ka),
    En(Ka, e)
}
function _d() {
    Rn(Ka),
    Rn(Mg),
    Rn(Sg)
}
function p5(n) {
    fu(Sg.current);
    var e = fu(Ka.current)
      , t = $M(e, n.type);
    e !== t && (En(Mg, n),
    En(Ka, t))
}
function jI(n) {
    Mg.current === n && (Rn(Ka),
    Rn(Mg))
}
var Vn = TA(0);
function y_(n) {
    for (var e = n; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === n)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === n)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var qb = [];
function WI() {
    for (var n = 0; n < qb.length; n++)
        qb[n]._workInProgressVersionPrimary = null;
    qb.length = 0
}
var hw = lc.ReactCurrentDispatcher
  , eE = lc.ReactCurrentBatchConfig
  , Ru = 0
  , Xn = null
  , Ur = null
  , Gr = null
  , w_ = !1
  , Wm = !1
  , Cg = 0
  , W$ = 0;
function Ai() {
    throw Error(Oe(321))
}
function KI(n, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < n.length; t++)
        if (!la(n[t], e[t]))
            return !1;
    return !0
}
function XI(n, e, t, r, i, s) {
    if (Ru = s,
    Xn = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    hw.current = n === null || n.memoizedState === null ? $$ : Z$,
    n = t(r, i),
    Wm) {
        s = 0;
        do {
            if (Wm = !1,
            Cg = 0,
            25 <= s)
                throw Error(Oe(301));
            s += 1,
            Gr = Ur = null,
            e.updateQueue = null,
            hw.current = J$,
            n = t(r, i)
        } while (Wm)
    }
    if (hw.current = __,
    e = Ur !== null && Ur.next !== null,
    Ru = 0,
    Gr = Ur = Xn = null,
    w_ = !1,
    e)
        throw Error(Oe(300));
    return n
}
function YI() {
    var n = Cg !== 0;
    return Cg = 0,
    n
}
function Ma() {
    var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Gr === null ? Xn.memoizedState = Gr = n : Gr = Gr.next = n,
    Gr
}
function xo() {
    if (Ur === null) {
        var n = Xn.alternate;
        n = n !== null ? n.memoizedState : null
    } else
        n = Ur.next;
    var e = Gr === null ? Xn.memoizedState : Gr.next;
    if (e !== null)
        Gr = e,
        Ur = n;
    else {
        if (n === null)
            throw Error(Oe(310));
        Ur = n,
        n = {
            memoizedState: Ur.memoizedState,
            baseState: Ur.baseState,
            baseQueue: Ur.baseQueue,
            queue: Ur.queue,
            next: null
        },
        Gr === null ? Xn.memoizedState = Gr = n : Gr = Gr.next = n
    }
    return Gr
}
function Tg(n, e) {
    return typeof e == "function" ? e(n) : e
}
function tE(n) {
    var e = xo()
      , t = e.queue;
    if (t === null)
        throw Error(Oe(311));
    t.lastRenderedReducer = n;
    var r = Ur
      , i = r.baseQueue
      , s = t.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next,
            s.next = o
        }
        r.baseQueue = i = s,
        t.pending = null
    }
    if (i !== null) {
        s = i.next,
        r = r.baseState;
        var a = o = null
          , l = null
          , c = s;
        do {
            var A = c.lane;
            if ((Ru & A) === A)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                r = c.hasEagerState ? c.eagerState : n(r, c.action);
            else {
                var u = {
                    lane: A,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = u,
                o = r) : l = l.next = u,
                Xn.lanes |= A,
                Uu |= A
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = r : l.next = a,
        la(r, e.memoizedState) || (Ji = !0),
        e.memoizedState = r,
        e.baseState = o,
        e.baseQueue = l,
        t.lastRenderedState = r
    }
    if (n = t.interleaved,
    n !== null) {
        i = n;
        do
            s = i.lane,
            Xn.lanes |= s,
            Uu |= s,
            i = i.next;
        while (i !== n)
    } else
        i === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function nE(n) {
    var e = xo()
      , t = e.queue;
    if (t === null)
        throw Error(Oe(311));
    t.lastRenderedReducer = n;
    var r = t.dispatch
      , i = t.pending
      , s = e.memoizedState;
    if (i !== null) {
        t.pending = null;
        var o = i = i.next;
        do
            s = n(s, o.action),
            o = o.next;
        while (o !== i);
        la(s, e.memoizedState) || (Ji = !0),
        e.memoizedState = s,
        e.baseQueue === null && (e.baseState = s),
        t.lastRenderedState = s
    }
    return [s, r]
}
function m5() {}
function g5(n, e) {
    var t = Xn
      , r = xo()
      , i = e()
      , s = !la(r.memoizedState, i);
    if (s && (r.memoizedState = i,
    Ji = !0),
    r = r.queue,
    $I(w5.bind(null, t, r, n), [n]),
    r.getSnapshot !== e || s || Gr !== null && Gr.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        Ig(9, y5.bind(null, t, r, i, e), void 0, null),
        Yr === null)
            throw Error(Oe(349));
        Ru & 30 || v5(t, e, i)
    }
    return i
}
function v5(n, e, t) {
    n.flags |= 16384,
    n = {
        getSnapshot: e,
        value: t
    },
    e = Xn.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    Xn.updateQueue = e,
    e.stores = [n]) : (t = e.stores,
    t === null ? e.stores = [n] : t.push(n))
}
function y5(n, e, t, r) {
    e.value = t,
    e.getSnapshot = r,
    _5(e) && x5(n)
}
function w5(n, e, t) {
    return t(function() {
        _5(e) && x5(n)
    })
}
function _5(n) {
    var e = n.getSnapshot;
    n = n.value;
    try {
        var t = e();
        return !la(n, t)
    } catch {
        return !0
    }
}
function x5(n) {
    var e = Jl(n, 1);
    e !== null && ra(e, n, 1, -1)
}
function mP(n) {
    var e = Ma();
    return typeof n == "function" && (n = n()),
    e.memoizedState = e.baseState = n,
    n = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Tg,
        lastRenderedState: n
    },
    e.queue = n,
    n = n.dispatch = Y$.bind(null, Xn, n),
    [e.memoizedState, n]
}
function Ig(n, e, t, r) {
    return n = {
        tag: n,
        create: e,
        destroy: t,
        deps: r,
        next: null
    },
    e = Xn.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    Xn.updateQueue = e,
    e.lastEffect = n.next = n) : (t = e.lastEffect,
    t === null ? e.lastEffect = n.next = n : (r = t.next,
    t.next = n,
    n.next = r,
    e.lastEffect = n)),
    n
}
function b5() {
    return xo().memoizedState
}
function dw(n, e, t, r) {
    var i = Ma();
    Xn.flags |= n,
    i.memoizedState = Ig(1 | e, t, void 0, r === void 0 ? null : r)
}
function $x(n, e, t, r) {
    var i = xo();
    r = r === void 0 ? null : r;
    var s = void 0;
    if (Ur !== null) {
        var o = Ur.memoizedState;
        if (s = o.destroy,
        r !== null && KI(r, o.deps)) {
            i.memoizedState = Ig(e, t, s, r);
            return
        }
    }
    Xn.flags |= n,
    i.memoizedState = Ig(1 | e, t, s, r)
}
function gP(n, e) {
    return dw(8390656, 8, n, e)
}
function $I(n, e) {
    return $x(2048, 8, n, e)
}
function E5(n, e) {
    return $x(4, 2, n, e)
}
function B5(n, e) {
    return $x(4, 4, n, e)
}
function M5(n, e) {
    if (typeof e == "function")
        return n = n(),
        e(n),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return n = n(),
        e.current = n,
        function() {
            e.current = null
        }
}
function S5(n, e, t) {
    return t = t != null ? t.concat([n]) : null,
    $x(4, 4, M5.bind(null, e, n), t)
}
function ZI() {}
function C5(n, e) {
    var t = xo();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && KI(e, r[1]) ? r[0] : (t.memoizedState = [n, e],
    n)
}
function T5(n, e) {
    var t = xo();
    e = e === void 0 ? null : e;
    var r = t.memoizedState;
    return r !== null && e !== null && KI(e, r[1]) ? r[0] : (n = n(),
    t.memoizedState = [n, e],
    n)
}
function I5(n, e, t) {
    return Ru & 21 ? (la(t, e) || (t = LH(),
    Xn.lanes |= t,
    Uu |= t,
    n.baseState = !0),
    e) : (n.baseState && (n.baseState = !1,
    Ji = !0),
    n.memoizedState = t)
}
function K$(n, e) {
    var t = pn;
    pn = t !== 0 && 4 > t ? t : 4,
    n(!0);
    var r = eE.transition;
    eE.transition = {};
    try {
        n(!1),
        e()
    } finally {
        pn = t,
        eE.transition = r
    }
}
function R5() {
    return xo().memoizedState
}
function X$(n, e, t) {
    var r = lA(n);
    if (t = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    U5(n))
        F5(e, t);
    else if (t = h5(n, e, t, r),
    t !== null) {
        var i = ki();
        ra(t, n, r, i),
        P5(t, e, r)
    }
}
function Y$(n, e, t) {
    var r = lA(n)
      , i = {
        lane: r,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (U5(n))
        F5(e, i);
    else {
        var s = n.alternate;
        if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer,
        s !== null))
            try {
                var o = e.lastRenderedState
                  , a = s(o, t);
                if (i.hasEagerState = !0,
                i.eagerState = a,
                la(a, o)) {
                    var l = e.interleaved;
                    l === null ? (i.next = i,
                    zI(e)) : (i.next = l.next,
                    l.next = i),
                    e.interleaved = i;
                    return
                }
            } catch {} finally {}
        t = h5(n, e, i, r),
        t !== null && (i = ki(),
        ra(t, n, r, i),
        P5(t, e, r))
    }
}
function U5(n) {
    var e = n.alternate;
    return n === Xn || e !== null && e === Xn
}
function F5(n, e) {
    Wm = w_ = !0;
    var t = n.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    n.pending = e
}
function P5(n, e, t) {
    if (t & 4194240) {
        var r = e.lanes;
        r &= n.pendingLanes,
        t |= r,
        e.lanes = t,
        CI(n, t)
    }
}
var __ = {
    readContext: _o,
    useCallback: Ai,
    useContext: Ai,
    useEffect: Ai,
    useImperativeHandle: Ai,
    useInsertionEffect: Ai,
    useLayoutEffect: Ai,
    useMemo: Ai,
    useReducer: Ai,
    useRef: Ai,
    useState: Ai,
    useDebugValue: Ai,
    useDeferredValue: Ai,
    useTransition: Ai,
    useMutableSource: Ai,
    useSyncExternalStore: Ai,
    useId: Ai,
    unstable_isNewReconciler: !1
}
  , $$ = {
    readContext: _o,
    useCallback: function(n, e) {
        return Ma().memoizedState = [n, e === void 0 ? null : e],
        n
    },
    useContext: _o,
    useEffect: gP,
    useImperativeHandle: function(n, e, t) {
        return t = t != null ? t.concat([n]) : null,
        dw(4194308, 4, M5.bind(null, e, n), t)
    },
    useLayoutEffect: function(n, e) {
        return dw(4194308, 4, n, e)
    },
    useInsertionEffect: function(n, e) {
        return dw(4, 2, n, e)
    },
    useMemo: function(n, e) {
        var t = Ma();
        return e = e === void 0 ? null : e,
        n = n(),
        t.memoizedState = [n, e],
        n
    },
    useReducer: function(n, e, t) {
        var r = Ma();
        return e = t !== void 0 ? t(e) : e,
        r.memoizedState = r.baseState = e,
        n = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: n,
            lastRenderedState: e
        },
        r.queue = n,
        n = n.dispatch = X$.bind(null, Xn, n),
        [r.memoizedState, n]
    },
    useRef: function(n) {
        var e = Ma();
        return n = {
            current: n
        },
        e.memoizedState = n
    },
    useState: mP,
    useDebugValue: ZI,
    useDeferredValue: function(n) {
        return Ma().memoizedState = n
    },
    useTransition: function() {
        var n = mP(!1)
          , e = n[0];
        return n = K$.bind(null, n[1]),
        Ma().memoizedState = n,
        [e, n]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(n, e, t) {
        var r = Xn
          , i = Ma();
        if (On) {
            if (t === void 0)
                throw Error(Oe(407));
            t = t()
        } else {
            if (t = e(),
            Yr === null)
                throw Error(Oe(349));
            Ru & 30 || v5(r, e, t)
        }
        i.memoizedState = t;
        var s = {
            value: t,
            getSnapshot: e
        };
        return i.queue = s,
        gP(w5.bind(null, r, s, n), [n]),
        r.flags |= 2048,
        Ig(9, y5.bind(null, r, s, t, e), void 0, null),
        t
    },
    useId: function() {
        var n = Ma()
          , e = Yr.identifierPrefix;
        if (On) {
            var t = Hl
              , r = Ql;
            t = (r & ~(1 << 32 - na(r) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = Cg++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = W$++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return n.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , Z$ = {
    readContext: _o,
    useCallback: C5,
    useContext: _o,
    useEffect: $I,
    useImperativeHandle: S5,
    useInsertionEffect: E5,
    useLayoutEffect: B5,
    useMemo: T5,
    useReducer: tE,
    useRef: b5,
    useState: function() {
        return tE(Tg)
    },
    useDebugValue: ZI,
    useDeferredValue: function(n) {
        var e = xo();
        return I5(e, Ur.memoizedState, n)
    },
    useTransition: function() {
        var n = tE(Tg)[0]
          , e = xo().memoizedState;
        return [n, e]
    },
    useMutableSource: m5,
    useSyncExternalStore: g5,
    useId: R5,
    unstable_isNewReconciler: !1
}
  , J$ = {
    readContext: _o,
    useCallback: C5,
    useContext: _o,
    useEffect: $I,
    useImperativeHandle: S5,
    useInsertionEffect: E5,
    useLayoutEffect: B5,
    useMemo: T5,
    useReducer: nE,
    useRef: b5,
    useState: function() {
        return nE(Tg)
    },
    useDebugValue: ZI,
    useDeferredValue: function(n) {
        var e = xo();
        return Ur === null ? e.memoizedState = n : I5(e, Ur.memoizedState, n)
    },
    useTransition: function() {
        var n = nE(Tg)[0]
          , e = xo().memoizedState;
        return [n, e]
    },
    useMutableSource: m5,
    useSyncExternalStore: g5,
    useId: R5,
    unstable_isNewReconciler: !1
};
function Wo(n, e) {
    if (n && n.defaultProps) {
        e = Yn({}, e),
        n = n.defaultProps;
        for (var t in n)
            e[t] === void 0 && (e[t] = n[t]);
        return e
    }
    return e
}
function gS(n, e, t, r) {
    e = n.memoizedState,
    t = t(r, e),
    t = t == null ? e : Yn({}, e, t),
    n.memoizedState = t,
    n.lanes === 0 && (n.updateQueue.baseState = t)
}
var Zx = {
    isMounted: function(n) {
        return (n = n._reactInternals) ? Xu(n) === n : !1
    },
    enqueueSetState: function(n, e, t) {
        n = n._reactInternals;
        var r = ki()
          , i = lA(n)
          , s = Vl(r, i);
        s.payload = e,
        t != null && (s.callback = t),
        e = oA(n, s, i),
        e !== null && (ra(e, n, i, r),
        fw(e, n, i))
    },
    enqueueReplaceState: function(n, e, t) {
        n = n._reactInternals;
        var r = ki()
          , i = lA(n)
          , s = Vl(r, i);
        s.tag = 1,
        s.payload = e,
        t != null && (s.callback = t),
        e = oA(n, s, i),
        e !== null && (ra(e, n, i, r),
        fw(e, n, i))
    },
    enqueueForceUpdate: function(n, e) {
        n = n._reactInternals;
        var t = ki()
          , r = lA(n)
          , i = Vl(t, r);
        i.tag = 2,
        e != null && (i.callback = e),
        e = oA(n, i, r),
        e !== null && (ra(e, n, r, t),
        fw(e, n, r))
    }
};
function vP(n, e, t, r, i, s, o) {
    return n = n.stateNode,
    typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(r, s, o) : e.prototype && e.prototype.isPureReactComponent ? !xg(t, r) || !xg(i, s) : !0
}
function L5(n, e, t) {
    var r = !1
      , i = gA
      , s = e.contextType;
    return typeof s == "object" && s !== null ? s = _o(s) : (i = ts(e) ? Tu : Si.current,
    r = e.contextTypes,
    s = (r = r != null) ? vd(n, i) : gA),
    e = new e(t,s),
    n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Zx,
    n.stateNode = e,
    e._reactInternals = n,
    r && (n = n.stateNode,
    n.__reactInternalMemoizedUnmaskedChildContext = i,
    n.__reactInternalMemoizedMaskedChildContext = s),
    e
}
function yP(n, e, t, r) {
    n = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, r),
    e.state !== n && Zx.enqueueReplaceState(e, e.state, null)
}
function vS(n, e, t, r) {
    var i = n.stateNode;
    i.props = t,
    i.state = n.memoizedState,
    i.refs = {},
    GI(n);
    var s = e.contextType;
    typeof s == "object" && s !== null ? i.context = _o(s) : (s = ts(e) ? Tu : Si.current,
    i.context = vd(n, s)),
    i.state = n.memoizedState,
    s = e.getDerivedStateFromProps,
    typeof s == "function" && (gS(n, e, s, t),
    i.state = n.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state,
    typeof i.componentWillMount == "function" && i.componentWillMount(),
    typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(),
    e !== i.state && Zx.enqueueReplaceState(i, i.state, null),
    v_(n, t, i, r),
    i.state = n.memoizedState),
    typeof i.componentDidMount == "function" && (n.flags |= 4194308)
}
function xd(n, e) {
    try {
        var t = ""
          , r = e;
        do
            t += MY(r),
            r = r.return;
        while (r);
        var i = t
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: n,
        source: e,
        stack: i,
        digest: null
    }
}
function rE(n, e, t) {
    return {
        value: n,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function yS(n, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var q$ = typeof WeakMap == "function" ? WeakMap : Map;
function D5(n, e, t) {
    t = Vl(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var r = e.value;
    return t.callback = function() {
        b_ || (b_ = !0,
        TS = r),
        yS(n, e)
    }
    ,
    t
}
function N5(n, e, t) {
    t = Vl(-1, t),
    t.tag = 3;
    var r = n.type.getDerivedStateFromError;
    if (typeof r == "function") {
        var i = e.value;
        t.payload = function() {
            return r(i)
        }
        ,
        t.callback = function() {
            yS(n, e)
        }
    }
    var s = n.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
        yS(n, e),
        typeof r != "function" && (aA === null ? aA = new Set([this]) : aA.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    t
}
function wP(n, e, t) {
    var r = n.pingCache;
    if (r === null) {
        r = n.pingCache = new q$;
        var i = new Set;
        r.set(e, i)
    } else
        i = r.get(e),
        i === void 0 && (i = new Set,
        r.set(e, i));
    i.has(t) || (i.add(t),
    n = hZ.bind(null, n, e, t),
    e.then(n, n))
}
function _P(n) {
    do {
        var e;
        if ((e = n.tag === 13) && (e = n.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return n;
        n = n.return
    } while (n !== null);
    return null
}
function xP(n, e, t, r, i) {
    return n.mode & 1 ? (n.flags |= 65536,
    n.lanes = i,
    n) : (n === e ? n.flags |= 65536 : (n.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Vl(-1, 1),
    e.tag = 2,
    oA(t, e, 1))),
    t.lanes |= 1),
    n)
}
var eZ = lc.ReactCurrentOwner
  , Ji = !1;
function Pi(n, e, t, r) {
    e.child = n === null ? f5(e, null, t, r) : wd(e, n.child, t, r)
}
function bP(n, e, t, r, i) {
    t = t.render;
    var s = e.ref;
    return Jh(e, i),
    r = XI(n, e, t, r, s, i),
    t = YI(),
    n !== null && !Ji ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~i,
    ql(n, e, i)) : (On && t && DI(e),
    e.flags |= 1,
    Pi(n, e, r, i),
    e.child)
}
function EP(n, e, t, r, i) {
    if (n === null) {
        var s = t.type;
        return typeof s == "function" && !sR(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = s,
        O5(n, e, s, r, i)) : (n = vw(t.type, null, r, e, e.mode, i),
        n.ref = e.ref,
        n.return = e,
        e.child = n)
    }
    if (s = n.child,
    !(n.lanes & i)) {
        var o = s.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : xg,
        t(o, r) && n.ref === e.ref)
            return ql(n, e, i)
    }
    return e.flags |= 1,
    n = cA(s, r),
    n.ref = e.ref,
    n.return = e,
    e.child = n
}
function O5(n, e, t, r, i) {
    if (n !== null) {
        var s = n.memoizedProps;
        if (xg(s, r) && n.ref === e.ref)
            if (Ji = !1,
            e.pendingProps = r = s,
            (n.lanes & i) !== 0)
                n.flags & 131072 && (Ji = !0);
            else
                return e.lanes = n.lanes,
                ql(n, e, i)
    }
    return wS(n, e, t, r, i)
}
function k5(n, e, t) {
    var r = e.pendingProps
      , i = r.children
      , s = n !== null ? n.memoizedState : null;
    if (r.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            En(Uh, xs),
            xs |= t;
        else {
            if (!(t & 1073741824))
                return n = s !== null ? s.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: n,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                En(Uh, xs),
                xs |= n,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            r = s !== null ? s.baseLanes : t,
            En(Uh, xs),
            xs |= r
        }
    else
        s !== null ? (r = s.baseLanes | t,
        e.memoizedState = null) : r = t,
        En(Uh, xs),
        xs |= r;
    return Pi(n, e, i, t),
    e.child
}
function Q5(n, e) {
    var t = e.ref;
    (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function wS(n, e, t, r, i) {
    var s = ts(t) ? Tu : Si.current;
    return s = vd(e, s),
    Jh(e, i),
    t = XI(n, e, t, r, s, i),
    r = YI(),
    n !== null && !Ji ? (e.updateQueue = n.updateQueue,
    e.flags &= -2053,
    n.lanes &= ~i,
    ql(n, e, i)) : (On && r && DI(e),
    e.flags |= 1,
    Pi(n, e, t, i),
    e.child)
}
function BP(n, e, t, r, i) {
    if (ts(t)) {
        var s = !0;
        h_(e)
    } else
        s = !1;
    if (Jh(e, i),
    e.stateNode === null)
        pw(n, e),
        L5(e, t, r),
        vS(e, t, r, i),
        r = !0;
    else if (n === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = t.contextType;
        typeof c == "object" && c !== null ? c = _o(c) : (c = ts(t) ? Tu : Si.current,
        c = vd(e, c));
        var A = t.getDerivedStateFromProps
          , u = typeof A == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        u || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || l !== c) && yP(e, o, r, c),
        Nc = !1;
        var f = e.memoizedState;
        o.state = f,
        v_(e, r, o, i),
        l = e.memoizedState,
        a !== r || f !== l || es.current || Nc ? (typeof A == "function" && (gS(e, t, A, r),
        l = e.memoizedState),
        (a = Nc || vP(e, t, a, r, f, l, c)) ? (u || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = r,
        e.memoizedState = l),
        o.props = r,
        o.state = l,
        o.context = c,
        r = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        r = !1)
    } else {
        o = e.stateNode,
        d5(n, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : Wo(e.type, a),
        o.props = c,
        u = e.pendingProps,
        f = o.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = _o(l) : (l = ts(t) ? Tu : Si.current,
        l = vd(e, l));
        var h = t.getDerivedStateFromProps;
        (A = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== u || f !== l) && yP(e, o, r, l),
        Nc = !1,
        f = e.memoizedState,
        o.state = f,
        v_(e, r, o, i);
        var d = e.memoizedState;
        a !== u || f !== d || es.current || Nc ? (typeof h == "function" && (gS(e, t, h, r),
        d = e.memoizedState),
        (c = Nc || vP(e, t, c, r, f, d, l) || !1) ? (A || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, d, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, d, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && f === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && f === n.memoizedState || (e.flags |= 1024),
        e.memoizedProps = r,
        e.memoizedState = d),
        o.props = r,
        o.state = d,
        o.context = l,
        r = c) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && f === n.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && f === n.memoizedState || (e.flags |= 1024),
        r = !1)
    }
    return _S(n, e, t, r, s, i)
}
function _S(n, e, t, r, i, s) {
    Q5(n, e);
    var o = (e.flags & 128) !== 0;
    if (!r && !o)
        return i && AP(e, t, !1),
        ql(n, e, s);
    r = e.stateNode,
    eZ.current = e;
    var a = o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
    return e.flags |= 1,
    n !== null && o ? (e.child = wd(e, n.child, null, s),
    e.child = wd(e, null, a, s)) : Pi(n, e, a, s),
    e.memoizedState = r.state,
    i && AP(e, t, !0),
    e.child
}
function H5(n) {
    var e = n.stateNode;
    e.pendingContext ? cP(n, e.pendingContext, e.pendingContext !== e.context) : e.context && cP(n, e.context, !1),
    VI(n, e.containerInfo)
}
function MP(n, e, t, r, i) {
    return yd(),
    OI(i),
    e.flags |= 256,
    Pi(n, e, t, r),
    e.child
}
var xS = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function bS(n) {
    return {
        baseLanes: n,
        cachePool: null,
        transitions: null
    }
}
function z5(n, e, t) {
    var r = e.pendingProps, i = Vn.current, s = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0),
    a ? (s = !0,
    e.flags &= -129) : (n === null || n.memoizedState !== null) && (i |= 1),
    En(Vn, i & 1),
    n === null)
        return pS(e),
        n = e.memoizedState,
        n !== null && (n = n.dehydrated,
        n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = r.children,
        n = r.fallback,
        s ? (r = e.mode,
        s = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(r & 1) && s !== null ? (s.childLanes = 0,
        s.pendingProps = o) : s = e1(o, r, 0, null),
        n = yu(n, r, t, null),
        s.return = e,
        n.return = e,
        s.sibling = n,
        e.child = s,
        e.child.memoizedState = bS(t),
        e.memoizedState = xS,
        n) : JI(e, o));
    if (i = n.memoizedState,
    i !== null && (a = i.dehydrated,
    a !== null))
        return tZ(n, e, o, r, a, i, t);
    if (s) {
        s = r.fallback,
        o = e.mode,
        i = n.child,
        a = i.sibling;
        var l = {
            mode: "hidden",
            children: r.children
        };
        return !(o & 1) && e.child !== i ? (r = e.child,
        r.childLanes = 0,
        r.pendingProps = l,
        e.deletions = null) : (r = cA(i, l),
        r.subtreeFlags = i.subtreeFlags & 14680064),
        a !== null ? s = cA(a, s) : (s = yu(s, o, t, null),
        s.flags |= 2),
        s.return = e,
        r.return = e,
        r.sibling = s,
        e.child = r,
        r = s,
        s = e.child,
        o = n.child.memoizedState,
        o = o === null ? bS(t) : {
            baseLanes: o.baseLanes | t,
            cachePool: null,
            transitions: o.transitions
        },
        s.memoizedState = o,
        s.childLanes = n.childLanes & ~t,
        e.memoizedState = xS,
        r
    }
    return s = n.child,
    n = s.sibling,
    r = cA(s, {
        mode: "visible",
        children: r.children
    }),
    !(e.mode & 1) && (r.lanes = t),
    r.return = e,
    r.sibling = null,
    n !== null && (t = e.deletions,
    t === null ? (e.deletions = [n],
    e.flags |= 16) : t.push(n)),
    e.child = r,
    e.memoizedState = null,
    r
}
function JI(n, e) {
    return e = e1({
        mode: "visible",
        children: e
    }, n.mode, 0, null),
    e.return = n,
    n.child = e
}
function av(n, e, t, r) {
    return r !== null && OI(r),
    wd(e, n.child, null, t),
    n = JI(e, e.pendingProps.children),
    n.flags |= 2,
    e.memoizedState = null,
    n
}
function tZ(n, e, t, r, i, s, o) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        r = rE(Error(Oe(422))),
        av(n, e, o, r)) : e.memoizedState !== null ? (e.child = n.child,
        e.flags |= 128,
        null) : (s = r.fallback,
        i = e.mode,
        r = e1({
            mode: "visible",
            children: r.children
        }, i, 0, null),
        s = yu(s, i, o, null),
        s.flags |= 2,
        r.return = e,
        s.return = e,
        r.sibling = s,
        e.child = r,
        e.mode & 1 && wd(e, n.child, null, o),
        e.child.memoizedState = bS(o),
        e.memoizedState = xS,
        s);
    if (!(e.mode & 1))
        return av(n, e, o, null);
    if (i.data === "$!") {
        if (r = i.nextSibling && i.nextSibling.dataset,
        r)
            var a = r.dgst;
        return r = a,
        s = Error(Oe(419)),
        r = rE(s, r, void 0),
        av(n, e, o, r)
    }
    if (a = (o & n.childLanes) !== 0,
    Ji || a) {
        if (r = Yr,
        r !== null) {
            switch (o & -o) {
            case 4:
                i = 2;
                break;
            case 16:
                i = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                i = 32;
                break;
            case 536870912:
                i = 268435456;
                break;
            default:
                i = 0
            }
            i = i & (r.suspendedLanes | o) ? 0 : i,
            i !== 0 && i !== s.retryLane && (s.retryLane = i,
            Jl(n, i),
            ra(r, n, i, -1))
        }
        return iR(),
        r = rE(Error(Oe(421))),
        av(n, e, o, r)
    }
    return i.data === "$?" ? (e.flags |= 128,
    e.child = n.child,
    e = dZ.bind(null, n),
    i._reactRetry = e,
    null) : (n = s.treeContext,
    Ts = sA(i.nextSibling),
    Ls = e,
    On = !0,
    $o = null,
    n !== null && (io[so++] = Ql,
    io[so++] = Hl,
    io[so++] = Iu,
    Ql = n.id,
    Hl = n.overflow,
    Iu = e),
    e = JI(e, r.children),
    e.flags |= 4096,
    e)
}
function SP(n, e, t) {
    n.lanes |= e;
    var r = n.alternate;
    r !== null && (r.lanes |= e),
    mS(n.return, e, t)
}
function iE(n, e, t, r, i) {
    var s = n.memoizedState;
    s === null ? n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i
    } : (s.isBackwards = e,
    s.rendering = null,
    s.renderingStartTime = 0,
    s.last = r,
    s.tail = t,
    s.tailMode = i)
}
function G5(n, e, t) {
    var r = e.pendingProps
      , i = r.revealOrder
      , s = r.tail;
    if (Pi(n, e, r.children, t),
    r = Vn.current,
    r & 2)
        r = r & 1 | 2,
        e.flags |= 128;
    else {
        if (n !== null && n.flags & 128)
            e: for (n = e.child; n !== null; ) {
                if (n.tag === 13)
                    n.memoizedState !== null && SP(n, t, e);
                else if (n.tag === 19)
                    SP(n, t, e);
                else if (n.child !== null) {
                    n.child.return = n,
                    n = n.child;
                    continue
                }
                if (n === e)
                    break e;
                for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e)
                        break e;
                    n = n.return
                }
                n.sibling.return = n.return,
                n = n.sibling
            }
        r &= 1
    }
    if (En(Vn, r),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (i) {
        case "forwards":
            for (t = e.child,
            i = null; t !== null; )
                n = t.alternate,
                n !== null && y_(n) === null && (i = t),
                t = t.sibling;
            t = i,
            t === null ? (i = e.child,
            e.child = null) : (i = t.sibling,
            t.sibling = null),
            iE(e, !1, i, t, s);
            break;
        case "backwards":
            for (t = null,
            i = e.child,
            e.child = null; i !== null; ) {
                if (n = i.alternate,
                n !== null && y_(n) === null) {
                    e.child = i;
                    break
                }
                n = i.sibling,
                i.sibling = t,
                t = i,
                i = n
            }
            iE(e, !0, t, null, s);
            break;
        case "together":
            iE(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function pw(n, e) {
    !(e.mode & 1) && n !== null && (n.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function ql(n, e, t) {
    if (n !== null && (e.dependencies = n.dependencies),
    Uu |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (n !== null && e.child !== n.child)
        throw Error(Oe(153));
    if (e.child !== null) {
        for (n = e.child,
        t = cA(n, n.pendingProps),
        e.child = t,
        t.return = e; n.sibling !== null; )
            n = n.sibling,
            t = t.sibling = cA(n, n.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function nZ(n, e, t) {
    switch (e.tag) {
    case 3:
        H5(e),
        yd();
        break;
    case 5:
        p5(e);
        break;
    case 1:
        ts(e.type) && h_(e);
        break;
    case 4:
        VI(e, e.stateNode.containerInfo);
        break;
    case 10:
        var r = e.type._context
          , i = e.memoizedProps.value;
        En(m_, r._currentValue),
        r._currentValue = i;
        break;
    case 13:
        if (r = e.memoizedState,
        r !== null)
            return r.dehydrated !== null ? (En(Vn, Vn.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? z5(n, e, t) : (En(Vn, Vn.current & 1),
            n = ql(n, e, t),
            n !== null ? n.sibling : null);
        En(Vn, Vn.current & 1);
        break;
    case 19:
        if (r = (t & e.childLanes) !== 0,
        n.flags & 128) {
            if (r)
                return G5(n, e, t);
            e.flags |= 128
        }
        if (i = e.memoizedState,
        i !== null && (i.rendering = null,
        i.tail = null,
        i.lastEffect = null),
        En(Vn, Vn.current),
        r)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        k5(n, e, t)
    }
    return ql(n, e, t)
}
var V5, ES, j5, W5;
V5 = function(n, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            n.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
ES = function() {}
;
j5 = function(n, e, t, r) {
    var i = n.memoizedProps;
    if (i !== r) {
        n = e.stateNode,
        fu(Ka.current);
        var s = null;
        switch (t) {
        case "input":
            i = WM(n, i),
            r = WM(n, r),
            s = [];
            break;
        case "select":
            i = Yn({}, i, {
                value: void 0
            }),
            r = Yn({}, r, {
                value: void 0
            }),
            s = [];
            break;
        case "textarea":
            i = YM(n, i),
            r = YM(n, r),
            s = [];
            break;
        default:
            typeof i.onClick != "function" && typeof r.onClick == "function" && (n.onclick = u_)
        }
        ZM(t, r);
        var o;
        t = null;
        for (c in i)
            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (t || (t = {}),
                        t[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (pg.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in r) {
            var l = r[c];
            if (a = i != null ? i[c] : void 0,
            r.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}),
                            t[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}),
                            t[o] = l[o])
                    } else
                        t || (s || (s = []),
                        s.push(c, t)),
                        t = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (pg.hasOwnProperty(c) ? (l != null && c === "onScroll" && Mn("scroll", n),
                    s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        t && (s = s || []).push("style", t);
        var c = s;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
W5 = function(n, e, t, r) {
    t !== r && (e.flags |= 4)
}
;
function Mp(n, e) {
    if (!On)
        switch (n.tailMode) {
        case "hidden":
            e = n.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? n.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = n.tail;
            for (var r = null; t !== null; )
                t.alternate !== null && (r = t),
                t = t.sibling;
            r === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : r.sibling = null
        }
}
function ui(n) {
    var e = n.alternate !== null && n.alternate.child === n.child
      , t = 0
      , r = 0;
    if (e)
        for (var i = n.child; i !== null; )
            t |= i.lanes | i.childLanes,
            r |= i.subtreeFlags & 14680064,
            r |= i.flags & 14680064,
            i.return = n,
            i = i.sibling;
    else
        for (i = n.child; i !== null; )
            t |= i.lanes | i.childLanes,
            r |= i.subtreeFlags,
            r |= i.flags,
            i.return = n,
            i = i.sibling;
    return n.subtreeFlags |= r,
    n.childLanes = t,
    e
}
function rZ(n, e, t) {
    var r = e.pendingProps;
    switch (NI(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return ui(e),
        null;
    case 1:
        return ts(e.type) && f_(),
        ui(e),
        null;
    case 3:
        return r = e.stateNode,
        _d(),
        Rn(es),
        Rn(Si),
        WI(),
        r.pendingContext && (r.context = r.pendingContext,
        r.pendingContext = null),
        (n === null || n.child === null) && (sv(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        $o !== null && (US($o),
        $o = null))),
        ES(n, e),
        ui(e),
        null;
    case 5:
        jI(e);
        var i = fu(Sg.current);
        if (t = e.type,
        n !== null && e.stateNode != null)
            j5(n, e, t, r, i),
            n.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!r) {
                if (e.stateNode === null)
                    throw Error(Oe(166));
                return ui(e),
                null
            }
            if (n = fu(Ka.current),
            sv(e)) {
                r = e.stateNode,
                t = e.type;
                var s = e.memoizedProps;
                switch (r[Fa] = e,
                r[Bg] = s,
                n = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    Mn("cancel", r),
                    Mn("close", r);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Mn("load", r);
                    break;
                case "video":
                case "audio":
                    for (i = 0; i < ym.length; i++)
                        Mn(ym[i], r);
                    break;
                case "source":
                    Mn("error", r);
                    break;
                case "img":
                case "image":
                case "link":
                    Mn("error", r),
                    Mn("load", r);
                    break;
                case "details":
                    Mn("toggle", r);
                    break;
                case "input":
                    DF(r, s),
                    Mn("invalid", r);
                    break;
                case "select":
                    r._wrapperState = {
                        wasMultiple: !!s.multiple
                    },
                    Mn("invalid", r);
                    break;
                case "textarea":
                    OF(r, s),
                    Mn("invalid", r)
                }
                ZM(t, s),
                i = null;
                for (var o in s)
                    if (s.hasOwnProperty(o)) {
                        var a = s[o];
                        o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && iv(r.textContent, a, n),
                        i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && iv(r.textContent, a, n),
                        i = ["children", "" + a]) : pg.hasOwnProperty(o) && a != null && o === "onScroll" && Mn("scroll", r)
                    }
                switch (t) {
                case "input":
                    $0(r),
                    NF(r, s, !0);
                    break;
                case "textarea":
                    $0(r),
                    kF(r);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof s.onClick == "function" && (r.onclick = u_)
                }
                r = i,
                e.updateQueue = r,
                r !== null && (e.flags |= 4)
            } else {
                o = i.nodeType === 9 ? i : i.ownerDocument,
                n === "http://www.w3.org/1999/xhtml" && (n = wH(t)),
                n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"),
                n.innerHTML = "<script><\/script>",
                n = n.removeChild(n.firstChild)) : typeof r.is == "string" ? n = o.createElement(t, {
                    is: r.is
                }) : (n = o.createElement(t),
                t === "select" && (o = n,
                r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : n = o.createElementNS(n, t),
                n[Fa] = e,
                n[Bg] = r,
                V5(n, e, !1, !1),
                e.stateNode = n;
                e: {
                    switch (o = JM(t, r),
                    t) {
                    case "dialog":
                        Mn("cancel", n),
                        Mn("close", n),
                        i = r;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Mn("load", n),
                        i = r;
                        break;
                    case "video":
                    case "audio":
                        for (i = 0; i < ym.length; i++)
                            Mn(ym[i], n);
                        i = r;
                        break;
                    case "source":
                        Mn("error", n),
                        i = r;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Mn("error", n),
                        Mn("load", n),
                        i = r;
                        break;
                    case "details":
                        Mn("toggle", n),
                        i = r;
                        break;
                    case "input":
                        DF(n, r),
                        i = WM(n, r),
                        Mn("invalid", n);
                        break;
                    case "option":
                        i = r;
                        break;
                    case "select":
                        n._wrapperState = {
                            wasMultiple: !!r.multiple
                        },
                        i = Yn({}, r, {
                            value: void 0
                        }),
                        Mn("invalid", n);
                        break;
                    case "textarea":
                        OF(n, r),
                        i = YM(n, r),
                        Mn("invalid", n);
                        break;
                    default:
                        i = r
                    }
                    ZM(t, i),
                    a = i;
                    for (s in a)
                        if (a.hasOwnProperty(s)) {
                            var l = a[s];
                            s === "style" ? bH(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && _H(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && mg(n, l) : typeof l == "number" && mg(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (pg.hasOwnProperty(s) ? l != null && s === "onScroll" && Mn("scroll", n) : l != null && xI(n, s, l, o))
                        }
                    switch (t) {
                    case "input":
                        $0(n),
                        NF(n, r, !1);
                        break;
                    case "textarea":
                        $0(n),
                        kF(n);
                        break;
                    case "option":
                        r.value != null && n.setAttribute("value", "" + mA(r.value));
                        break;
                    case "select":
                        n.multiple = !!r.multiple,
                        s = r.value,
                        s != null ? Xh(n, !!r.multiple, s, !1) : r.defaultValue != null && Xh(n, !!r.multiple, r.defaultValue, !0);
                        break;
                    default:
                        typeof i.onClick == "function" && (n.onclick = u_)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        r = !!r.autoFocus;
                        break e;
                    case "img":
                        r = !0;
                        break e;
                    default:
                        r = !1
                    }
                }
                r && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return ui(e),
        null;
    case 6:
        if (n && e.stateNode != null)
            W5(n, e, n.memoizedProps, r);
        else {
            if (typeof r != "string" && e.stateNode === null)
                throw Error(Oe(166));
            if (t = fu(Sg.current),
            fu(Ka.current),
            sv(e)) {
                if (r = e.stateNode,
                t = e.memoizedProps,
                r[Fa] = e,
                (s = r.nodeValue !== t) && (n = Ls,
                n !== null))
                    switch (n.tag) {
                    case 3:
                        iv(r.nodeValue, t, (n.mode & 1) !== 0);
                        break;
                    case 5:
                        n.memoizedProps.suppressHydrationWarning !== !0 && iv(r.nodeValue, t, (n.mode & 1) !== 0)
                    }
                s && (e.flags |= 4)
            } else
                r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r),
                r[Fa] = e,
                e.stateNode = r
        }
        return ui(e),
        null;
    case 13:
        if (Rn(Vn),
        r = e.memoizedState,
        n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            if (On && Ts !== null && e.mode & 1 && !(e.flags & 128))
                A5(),
                yd(),
                e.flags |= 98560,
                s = !1;
            else if (s = sv(e),
            r !== null && r.dehydrated !== null) {
                if (n === null) {
                    if (!s)
                        throw Error(Oe(318));
                    if (s = e.memoizedState,
                    s = s !== null ? s.dehydrated : null,
                    !s)
                        throw Error(Oe(317));
                    s[Fa] = e
                } else
                    yd(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                ui(e),
                s = !1
            } else
                $o !== null && (US($o),
                $o = null),
                s = !0;
            if (!s)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (r = r !== null,
        r !== (n !== null && n.memoizedState !== null) && r && (e.child.flags |= 8192,
        e.mode & 1 && (n === null || Vn.current & 1 ? Dr === 0 && (Dr = 3) : iR())),
        e.updateQueue !== null && (e.flags |= 4),
        ui(e),
        null);
    case 4:
        return _d(),
        ES(n, e),
        n === null && bg(e.stateNode.containerInfo),
        ui(e),
        null;
    case 10:
        return HI(e.type._context),
        ui(e),
        null;
    case 17:
        return ts(e.type) && f_(),
        ui(e),
        null;
    case 19:
        if (Rn(Vn),
        s = e.memoizedState,
        s === null)
            return ui(e),
            null;
        if (r = (e.flags & 128) !== 0,
        o = s.rendering,
        o === null)
            if (r)
                Mp(s, !1);
            else {
                if (Dr !== 0 || n !== null && n.flags & 128)
                    for (n = e.child; n !== null; ) {
                        if (o = y_(n),
                        o !== null) {
                            for (e.flags |= 128,
                            Mp(s, !1),
                            r = o.updateQueue,
                            r !== null && (e.updateQueue = r,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            r = t,
                            t = e.child; t !== null; )
                                s = t,
                                n = r,
                                s.flags &= 14680066,
                                o = s.alternate,
                                o === null ? (s.childLanes = 0,
                                s.lanes = n,
                                s.child = null,
                                s.subtreeFlags = 0,
                                s.memoizedProps = null,
                                s.memoizedState = null,
                                s.updateQueue = null,
                                s.dependencies = null,
                                s.stateNode = null) : (s.childLanes = o.childLanes,
                                s.lanes = o.lanes,
                                s.child = o.child,
                                s.subtreeFlags = 0,
                                s.deletions = null,
                                s.memoizedProps = o.memoizedProps,
                                s.memoizedState = o.memoizedState,
                                s.updateQueue = o.updateQueue,
                                s.type = o.type,
                                n = o.dependencies,
                                s.dependencies = n === null ? null : {
                                    lanes: n.lanes,
                                    firstContext: n.firstContext
                                }),
                                t = t.sibling;
                            return En(Vn, Vn.current & 1 | 2),
                            e.child
                        }
                        n = n.sibling
                    }
                s.tail !== null && dr() > bd && (e.flags |= 128,
                r = !0,
                Mp(s, !1),
                e.lanes = 4194304)
            }
        else {
            if (!r)
                if (n = y_(o),
                n !== null) {
                    if (e.flags |= 128,
                    r = !0,
                    t = n.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    Mp(s, !0),
                    s.tail === null && s.tailMode === "hidden" && !o.alternate && !On)
                        return ui(e),
                        null
                } else
                    2 * dr() - s.renderingStartTime > bd && t !== 1073741824 && (e.flags |= 128,
                    r = !0,
                    Mp(s, !1),
                    e.lanes = 4194304);
            s.isBackwards ? (o.sibling = e.child,
            e.child = o) : (t = s.last,
            t !== null ? t.sibling = o : e.child = o,
            s.last = o)
        }
        return s.tail !== null ? (e = s.tail,
        s.rendering = e,
        s.tail = e.sibling,
        s.renderingStartTime = dr(),
        e.sibling = null,
        t = Vn.current,
        En(Vn, r ? t & 1 | 2 : t & 1),
        e) : (ui(e),
        null);
    case 22:
    case 23:
        return rR(),
        r = e.memoizedState !== null,
        n !== null && n.memoizedState !== null !== r && (e.flags |= 8192),
        r && e.mode & 1 ? xs & 1073741824 && (ui(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : ui(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(Oe(156, e.tag))
}
function iZ(n, e) {
    switch (NI(e),
    e.tag) {
    case 1:
        return ts(e.type) && f_(),
        n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 3:
        return _d(),
        Rn(es),
        Rn(Si),
        WI(),
        n = e.flags,
        n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128,
        e) : null;
    case 5:
        return jI(e),
        null;
    case 13:
        if (Rn(Vn),
        n = e.memoizedState,
        n !== null && n.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(Oe(340));
            yd()
        }
        return n = e.flags,
        n & 65536 ? (e.flags = n & -65537 | 128,
        e) : null;
    case 19:
        return Rn(Vn),
        null;
    case 4:
        return _d(),
        null;
    case 10:
        return HI(e.type._context),
        null;
    case 22:
    case 23:
        return rR(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var lv = !1
  , yi = !1
  , sZ = typeof WeakSet == "function" ? WeakSet : Set
  , Je = null;
function Rh(n, e) {
    var t = n.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (r) {
                er(n, e, r)
            }
        else
            t.current = null
}
function BS(n, e, t) {
    try {
        t()
    } catch (r) {
        er(n, e, r)
    }
}
var CP = !1;
function oZ(n, e) {
    if (lS = l_,
    n = ZH(),
    LI(n)) {
        if ("selectionStart"in n)
            var t = {
                start: n.selectionStart,
                end: n.selectionEnd
            };
        else
            e: {
                t = (t = n.ownerDocument) && t.defaultView || window;
                var r = t.getSelection && t.getSelection();
                if (r && r.rangeCount !== 0) {
                    t = r.anchorNode;
                    var i = r.anchorOffset
                      , s = r.focusNode;
                    r = r.focusOffset;
                    try {
                        t.nodeType,
                        s.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , A = 0
                      , u = n
                      , f = null;
                    t: for (; ; ) {
                        for (var h; u !== t || i !== 0 && u.nodeType !== 3 || (a = o + i),
                        u !== s || r !== 0 && u.nodeType !== 3 || (l = o + r),
                        u.nodeType === 3 && (o += u.nodeValue.length),
                        (h = u.firstChild) !== null; )
                            f = u,
                            u = h;
                        for (; ; ) {
                            if (u === n)
                                break t;
                            if (f === t && ++c === i && (a = o),
                            f === s && ++A === r && (l = o),
                            (h = u.nextSibling) !== null)
                                break;
                            u = f,
                            f = u.parentNode
                        }
                        u = h
                    }
                    t = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (cS = {
        focusedElem: n,
        selectionRange: t
    },
    l_ = !1,
    Je = e; Je !== null; )
        if (e = Je,
        n = e.child,
        (e.subtreeFlags & 1028) !== 0 && n !== null)
            n.return = e,
            Je = n;
        else
            for (; Je !== null; ) {
                e = Je;
                try {
                    var d = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (d !== null) {
                                var m = d.memoizedProps
                                  , g = d.memoizedState
                                  , p = e.stateNode
                                  , v = p.getSnapshotBeforeUpdate(e.elementType === e.type ? m : Wo(e.type, m), g);
                                p.__reactInternalSnapshotBeforeUpdate = v
                            }
                            break;
                        case 3:
                            var w = e.stateNode.containerInfo;
                            w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(Oe(163))
                        }
                } catch (_) {
                    er(e, e.return, _)
                }
                if (n = e.sibling,
                n !== null) {
                    n.return = e.return,
                    Je = n;
                    break
                }
                Je = e.return
            }
    return d = CP,
    CP = !1,
    d
}
function Km(n, e, t) {
    var r = e.updateQueue;
    if (r = r !== null ? r.lastEffect : null,
    r !== null) {
        var i = r = r.next;
        do {
            if ((i.tag & n) === n) {
                var s = i.destroy;
                i.destroy = void 0,
                s !== void 0 && BS(e, t, s)
            }
            i = i.next
        } while (i !== r)
    }
}
function Jx(n, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & n) === n) {
                var r = t.create;
                t.destroy = r()
            }
            t = t.next
        } while (t !== e)
    }
}
function MS(n) {
    var e = n.ref;
    if (e !== null) {
        var t = n.stateNode;
        switch (n.tag) {
        case 5:
            n = t;
            break;
        default:
            n = t
        }
        typeof e == "function" ? e(n) : e.current = n
    }
}
function K5(n) {
    var e = n.alternate;
    e !== null && (n.alternate = null,
    K5(e)),
    n.child = null,
    n.deletions = null,
    n.sibling = null,
    n.tag === 5 && (e = n.stateNode,
    e !== null && (delete e[Fa],
    delete e[Bg],
    delete e[fS],
    delete e[z$],
    delete e[G$])),
    n.stateNode = null,
    n.return = null,
    n.dependencies = null,
    n.memoizedProps = null,
    n.memoizedState = null,
    n.pendingProps = null,
    n.stateNode = null,
    n.updateQueue = null
}
function X5(n) {
    return n.tag === 5 || n.tag === 3 || n.tag === 4
}
function TP(n) {
    e: for (; ; ) {
        for (; n.sibling === null; ) {
            if (n.return === null || X5(n.return))
                return null;
            n = n.return
        }
        for (n.sibling.return = n.return,
        n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18; ) {
            if (n.flags & 2 || n.child === null || n.tag === 4)
                continue e;
            n.child.return = n,
            n = n.child
        }
        if (!(n.flags & 2))
            return n.stateNode
    }
}
function SS(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6)
        n = n.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(n, t)) : (e = t,
        e.appendChild(n)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = u_));
    else if (r !== 4 && (n = n.child,
    n !== null))
        for (SS(n, e, t),
        n = n.sibling; n !== null; )
            SS(n, e, t),
            n = n.sibling
}
function CS(n, e, t) {
    var r = n.tag;
    if (r === 5 || r === 6)
        n = n.stateNode,
        e ? t.insertBefore(n, e) : t.appendChild(n);
    else if (r !== 4 && (n = n.child,
    n !== null))
        for (CS(n, e, t),
        n = n.sibling; n !== null; )
            CS(n, e, t),
            n = n.sibling
}
var ni = null
  , Xo = !1;
function vc(n, e, t) {
    for (t = t.child; t !== null; )
        Y5(n, e, t),
        t = t.sibling
}
function Y5(n, e, t) {
    if (Wa && typeof Wa.onCommitFiberUnmount == "function")
        try {
            Wa.onCommitFiberUnmount(Vx, t)
        } catch {}
    switch (t.tag) {
    case 5:
        yi || Rh(t, e);
    case 6:
        var r = ni
          , i = Xo;
        ni = null,
        vc(n, e, t),
        ni = r,
        Xo = i,
        ni !== null && (Xo ? (n = ni,
        t = t.stateNode,
        n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : ni.removeChild(t.stateNode));
        break;
    case 18:
        ni !== null && (Xo ? (n = ni,
        t = t.stateNode,
        n.nodeType === 8 ? Zb(n.parentNode, t) : n.nodeType === 1 && Zb(n, t),
        wg(n)) : Zb(ni, t.stateNode));
        break;
    case 4:
        r = ni,
        i = Xo,
        ni = t.stateNode.containerInfo,
        Xo = !0,
        vc(n, e, t),
        ni = r,
        Xo = i;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!yi && (r = t.updateQueue,
        r !== null && (r = r.lastEffect,
        r !== null))) {
            i = r = r.next;
            do {
                var s = i
                  , o = s.destroy;
                s = s.tag,
                o !== void 0 && (s & 2 || s & 4) && BS(t, e, o),
                i = i.next
            } while (i !== r)
        }
        vc(n, e, t);
        break;
    case 1:
        if (!yi && (Rh(t, e),
        r = t.stateNode,
        typeof r.componentWillUnmount == "function"))
            try {
                r.props = t.memoizedProps,
                r.state = t.memoizedState,
                r.componentWillUnmount()
            } catch (a) {
                er(t, e, a)
            }
        vc(n, e, t);
        break;
    case 21:
        vc(n, e, t);
        break;
    case 22:
        t.mode & 1 ? (yi = (r = yi) || t.memoizedState !== null,
        vc(n, e, t),
        yi = r) : vc(n, e, t);
        break;
    default:
        vc(n, e, t)
    }
}
function IP(n) {
    var e = n.updateQueue;
    if (e !== null) {
        n.updateQueue = null;
        var t = n.stateNode;
        t === null && (t = n.stateNode = new sZ),
        e.forEach(function(r) {
            var i = pZ.bind(null, n, r);
            t.has(r) || (t.add(r),
            r.then(i, i))
        })
    }
}
function Po(n, e) {
    var t = e.deletions;
    if (t !== null)
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            try {
                var s = n
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        ni = a.stateNode,
                        Xo = !1;
                        break e;
                    case 3:
                        ni = a.stateNode.containerInfo,
                        Xo = !0;
                        break e;
                    case 4:
                        ni = a.stateNode.containerInfo,
                        Xo = !0;
                        break e
                    }
                    a = a.return
                }
                if (ni === null)
                    throw Error(Oe(160));
                Y5(s, o, i),
                ni = null,
                Xo = !1;
                var l = i.alternate;
                l !== null && (l.return = null),
                i.return = null
            } catch (c) {
                er(i, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            $5(e, n),
            e = e.sibling
}
function $5(n, e) {
    var t = n.alternate
      , r = n.flags;
    switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Po(e, n),
        ga(n),
        r & 4) {
            try {
                Km(3, n, n.return),
                Jx(3, n)
            } catch (m) {
                er(n, n.return, m)
            }
            try {
                Km(5, n, n.return)
            } catch (m) {
                er(n, n.return, m)
            }
        }
        break;
    case 1:
        Po(e, n),
        ga(n),
        r & 512 && t !== null && Rh(t, t.return);
        break;
    case 5:
        if (Po(e, n),
        ga(n),
        r & 512 && t !== null && Rh(t, t.return),
        n.flags & 32) {
            var i = n.stateNode;
            try {
                mg(i, "")
            } catch (m) {
                er(n, n.return, m)
            }
        }
        if (r & 4 && (i = n.stateNode,
        i != null)) {
            var s = n.memoizedProps
              , o = t !== null ? t.memoizedProps : s
              , a = n.type
              , l = n.updateQueue;
            if (n.updateQueue = null,
            l !== null)
                try {
                    a === "input" && s.type === "radio" && s.name != null && vH(i, s),
                    JM(a, o);
                    var c = JM(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var A = l[o]
                          , u = l[o + 1];
                        A === "style" ? bH(i, u) : A === "dangerouslySetInnerHTML" ? _H(i, u) : A === "children" ? mg(i, u) : xI(i, A, u, c)
                    }
                    switch (a) {
                    case "input":
                        KM(i, s);
                        break;
                    case "textarea":
                        yH(i, s);
                        break;
                    case "select":
                        var f = i._wrapperState.wasMultiple;
                        i._wrapperState.wasMultiple = !!s.multiple;
                        var h = s.value;
                        h != null ? Xh(i, !!s.multiple, h, !1) : f !== !!s.multiple && (s.defaultValue != null ? Xh(i, !!s.multiple, s.defaultValue, !0) : Xh(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[Bg] = s
                } catch (m) {
                    er(n, n.return, m)
                }
        }
        break;
    case 6:
        if (Po(e, n),
        ga(n),
        r & 4) {
            if (n.stateNode === null)
                throw Error(Oe(162));
            i = n.stateNode,
            s = n.memoizedProps;
            try {
                i.nodeValue = s
            } catch (m) {
                er(n, n.return, m)
            }
        }
        break;
    case 3:
        if (Po(e, n),
        ga(n),
        r & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                wg(e.containerInfo)
            } catch (m) {
                er(n, n.return, m)
            }
        break;
    case 4:
        Po(e, n),
        ga(n);
        break;
    case 13:
        Po(e, n),
        ga(n),
        i = n.child,
        i.flags & 8192 && (s = i.memoizedState !== null,
        i.stateNode.isHidden = s,
        !s || i.alternate !== null && i.alternate.memoizedState !== null || (tR = dr())),
        r & 4 && IP(n);
        break;
    case 22:
        if (A = t !== null && t.memoizedState !== null,
        n.mode & 1 ? (yi = (c = yi) || A,
        Po(e, n),
        yi = c) : Po(e, n),
        ga(n),
        r & 8192) {
            if (c = n.memoizedState !== null,
            (n.stateNode.isHidden = c) && !A && n.mode & 1)
                for (Je = n,
                A = n.child; A !== null; ) {
                    for (u = Je = A; Je !== null; ) {
                        switch (f = Je,
                        h = f.child,
                        f.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Km(4, f, f.return);
                            break;
                        case 1:
                            Rh(f, f.return);
                            var d = f.stateNode;
                            if (typeof d.componentWillUnmount == "function") {
                                r = f,
                                t = f.return;
                                try {
                                    e = r,
                                    d.props = e.memoizedProps,
                                    d.state = e.memoizedState,
                                    d.componentWillUnmount()
                                } catch (m) {
                                    er(r, t, m)
                                }
                            }
                            break;
                        case 5:
                            Rh(f, f.return);
                            break;
                        case 22:
                            if (f.memoizedState !== null) {
                                UP(u);
                                continue
                            }
                        }
                        h !== null ? (h.return = f,
                        Je = h) : UP(u)
                    }
                    A = A.sibling
                }
            e: for (A = null,
            u = n; ; ) {
                if (u.tag === 5) {
                    if (A === null) {
                        A = u;
                        try {
                            i = u.stateNode,
                            c ? (s = i.style,
                            typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = u.stateNode,
                            l = u.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = xH("display", o))
                        } catch (m) {
                            er(n, n.return, m)
                        }
                    }
                } else if (u.tag === 6) {
                    if (A === null)
                        try {
                            u.stateNode.nodeValue = c ? "" : u.memoizedProps
                        } catch (m) {
                            er(n, n.return, m)
                        }
                } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === n) && u.child !== null) {
                    u.child.return = u,
                    u = u.child;
                    continue
                }
                if (u === n)
                    break e;
                for (; u.sibling === null; ) {
                    if (u.return === null || u.return === n)
                        break e;
                    A === u && (A = null),
                    u = u.return
                }
                A === u && (A = null),
                u.sibling.return = u.return,
                u = u.sibling
            }
        }
        break;
    case 19:
        Po(e, n),
        ga(n),
        r & 4 && IP(n);
        break;
    case 21:
        break;
    default:
        Po(e, n),
        ga(n)
    }
}
function ga(n) {
    var e = n.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = n.return; t !== null; ) {
                    if (X5(t)) {
                        var r = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(Oe(160))
            }
            switch (r.tag) {
            case 5:
                var i = r.stateNode;
                r.flags & 32 && (mg(i, ""),
                r.flags &= -33);
                var s = TP(n);
                CS(n, s, i);
                break;
            case 3:
            case 4:
                var o = r.stateNode.containerInfo
                  , a = TP(n);
                SS(n, a, o);
                break;
            default:
                throw Error(Oe(161))
            }
        } catch (l) {
            er(n, n.return, l)
        }
        n.flags &= -3
    }
    e & 4096 && (n.flags &= -4097)
}
function aZ(n, e, t) {
    Je = n,
    Z5(n)
}
function Z5(n, e, t) {
    for (var r = (n.mode & 1) !== 0; Je !== null; ) {
        var i = Je
          , s = i.child;
        if (i.tag === 22 && r) {
            var o = i.memoizedState !== null || lv;
            if (!o) {
                var a = i.alternate
                  , l = a !== null && a.memoizedState !== null || yi;
                a = lv;
                var c = yi;
                if (lv = o,
                (yi = l) && !c)
                    for (Je = i; Je !== null; )
                        o = Je,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? FP(i) : l !== null ? (l.return = o,
                        Je = l) : FP(i);
                for (; s !== null; )
                    Je = s,
                    Z5(s),
                    s = s.sibling;
                Je = i,
                lv = a,
                yi = c
            }
            RP(n)
        } else
            i.subtreeFlags & 8772 && s !== null ? (s.return = i,
            Je = s) : RP(n)
    }
}
function RP(n) {
    for (; Je !== null; ) {
        var e = Je;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        yi || Jx(5, e);
                        break;
                    case 1:
                        var r = e.stateNode;
                        if (e.flags & 4 && !yi)
                            if (t === null)
                                r.componentDidMount();
                            else {
                                var i = e.elementType === e.type ? t.memoizedProps : Wo(e.type, t.memoizedProps);
                                r.componentDidUpdate(i, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = e.updateQueue;
                        s !== null && pP(e, s, r);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            pP(e, o, t)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var A = c.memoizedState;
                                if (A !== null) {
                                    var u = A.dehydrated;
                                    u !== null && wg(u)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(Oe(163))
                    }
                yi || e.flags & 512 && MS(e)
            } catch (f) {
                er(e, e.return, f)
            }
        }
        if (e === n) {
            Je = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            Je = t;
            break
        }
        Je = e.return
    }
}
function UP(n) {
    for (; Je !== null; ) {
        var e = Je;
        if (e === n) {
            Je = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            Je = t;
            break
        }
        Je = e.return
    }
}
function FP(n) {
    for (; Je !== null; ) {
        var e = Je;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    Jx(4, e)
                } catch (l) {
                    er(e, t, l)
                }
                break;
            case 1:
                var r = e.stateNode;
                if (typeof r.componentDidMount == "function") {
                    var i = e.return;
                    try {
                        r.componentDidMount()
                    } catch (l) {
                        er(e, i, l)
                    }
                }
                var s = e.return;
                try {
                    MS(e)
                } catch (l) {
                    er(e, s, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    MS(e)
                } catch (l) {
                    er(e, o, l)
                }
            }
        } catch (l) {
            er(e, e.return, l)
        }
        if (e === n) {
            Je = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            Je = a;
            break
        }
        Je = e.return
    }
}
var lZ = Math.ceil
  , x_ = lc.ReactCurrentDispatcher
  , qI = lc.ReactCurrentOwner
  , yo = lc.ReactCurrentBatchConfig
  , Kt = 0
  , Yr = null
  , Br = null
  , si = 0
  , xs = 0
  , Uh = TA(0)
  , Dr = 0
  , Rg = null
  , Uu = 0
  , qx = 0
  , eR = 0
  , Xm = null
  , Yi = null
  , tR = 0
  , bd = 1 / 0
  , Il = null
  , b_ = !1
  , TS = null
  , aA = null
  , cv = !1
  , Wc = null
  , E_ = 0
  , Ym = 0
  , IS = null
  , mw = -1
  , gw = 0;
function ki() {
    return Kt & 6 ? dr() : mw !== -1 ? mw : mw = dr()
}
function lA(n) {
    return n.mode & 1 ? Kt & 2 && si !== 0 ? si & -si : j$.transition !== null ? (gw === 0 && (gw = LH()),
    gw) : (n = pn,
    n !== 0 || (n = window.event,
    n = n === void 0 ? 16 : zH(n.type)),
    n) : 1
}
function ra(n, e, t, r) {
    if (50 < Ym)
        throw Ym = 0,
        IS = null,
        Error(Oe(185));
    f0(n, t, r),
    (!(Kt & 2) || n !== Yr) && (n === Yr && (!(Kt & 2) && (qx |= t),
    Dr === 4 && Gc(n, si)),
    ns(n, r),
    t === 1 && Kt === 0 && !(e.mode & 1) && (bd = dr() + 500,
    Yx && IA()))
}
function ns(n, e) {
    var t = n.callbackNode;
    jY(n, e);
    var r = a_(n, n === Yr ? si : 0);
    if (r === 0)
        t !== null && zF(t),
        n.callbackNode = null,
        n.callbackPriority = 0;
    else if (e = r & -r,
    n.callbackPriority !== e) {
        if (t != null && zF(t),
        e === 1)
            n.tag === 0 ? V$(PP.bind(null, n)) : a5(PP.bind(null, n)),
            Q$(function() {
                !(Kt & 6) && IA()
            }),
            t = null;
        else {
            switch (DH(r)) {
            case 1:
                t = SI;
                break;
            case 4:
                t = FH;
                break;
            case 16:
                t = o_;
                break;
            case 536870912:
                t = PH;
                break;
            default:
                t = o_
            }
            t = s6(t, J5.bind(null, n))
        }
        n.callbackPriority = e,
        n.callbackNode = t
    }
}
function J5(n, e) {
    if (mw = -1,
    gw = 0,
    Kt & 6)
        throw Error(Oe(327));
    var t = n.callbackNode;
    if (qh() && n.callbackNode !== t)
        return null;
    var r = a_(n, n === Yr ? si : 0);
    if (r === 0)
        return null;
    if (r & 30 || r & n.expiredLanes || e)
        e = B_(n, r);
    else {
        e = r;
        var i = Kt;
        Kt |= 2;
        var s = e6();
        (Yr !== n || si !== e) && (Il = null,
        bd = dr() + 500,
        vu(n, e));
        do
            try {
                uZ();
                break
            } catch (a) {
                q5(n, a)
            }
        while (1);
        QI(),
        x_.current = s,
        Kt = i,
        Br !== null ? e = 0 : (Yr = null,
        si = 0,
        e = Dr)
    }
    if (e !== 0) {
        if (e === 2 && (i = rS(n),
        i !== 0 && (r = i,
        e = RS(n, i))),
        e === 1)
            throw t = Rg,
            vu(n, 0),
            Gc(n, r),
            ns(n, dr()),
            t;
        if (e === 6)
            Gc(n, r);
        else {
            if (i = n.current.alternate,
            !(r & 30) && !cZ(i) && (e = B_(n, r),
            e === 2 && (s = rS(n),
            s !== 0 && (r = s,
            e = RS(n, s))),
            e === 1))
                throw t = Rg,
                vu(n, 0),
                Gc(n, r),
                ns(n, dr()),
                t;
            switch (n.finishedWork = i,
            n.finishedLanes = r,
            e) {
            case 0:
            case 1:
                throw Error(Oe(345));
            case 2:
                tu(n, Yi, Il);
                break;
            case 3:
                if (Gc(n, r),
                (r & 130023424) === r && (e = tR + 500 - dr(),
                10 < e)) {
                    if (a_(n, 0) !== 0)
                        break;
                    if (i = n.suspendedLanes,
                    (i & r) !== r) {
                        ki(),
                        n.pingedLanes |= n.suspendedLanes & i;
                        break
                    }
                    n.timeoutHandle = uS(tu.bind(null, n, Yi, Il), e);
                    break
                }
                tu(n, Yi, Il);
                break;
            case 4:
                if (Gc(n, r),
                (r & 4194240) === r)
                    break;
                for (e = n.eventTimes,
                i = -1; 0 < r; ) {
                    var o = 31 - na(r);
                    s = 1 << o,
                    o = e[o],
                    o > i && (i = o),
                    r &= ~s
                }
                if (r = i,
                r = dr() - r,
                r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * lZ(r / 1960)) - r,
                10 < r) {
                    n.timeoutHandle = uS(tu.bind(null, n, Yi, Il), r);
                    break
                }
                tu(n, Yi, Il);
                break;
            case 5:
                tu(n, Yi, Il);
                break;
            default:
                throw Error(Oe(329))
            }
        }
    }
    return ns(n, dr()),
    n.callbackNode === t ? J5.bind(null, n) : null
}
function RS(n, e) {
    var t = Xm;
    return n.current.memoizedState.isDehydrated && (vu(n, e).flags |= 256),
    n = B_(n, e),
    n !== 2 && (e = Yi,
    Yi = t,
    e !== null && US(e)),
    n
}
function US(n) {
    Yi === null ? Yi = n : Yi.push.apply(Yi, n)
}
function cZ(n) {
    for (var e = n; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var r = 0; r < t.length; r++) {
                    var i = t[r]
                      , s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!la(s(), i))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === n)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === n)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Gc(n, e) {
    for (e &= ~eR,
    e &= ~qx,
    n.suspendedLanes |= e,
    n.pingedLanes &= ~e,
    n = n.expirationTimes; 0 < e; ) {
        var t = 31 - na(e)
          , r = 1 << t;
        n[t] = -1,
        e &= ~r
    }
}
function PP(n) {
    if (Kt & 6)
        throw Error(Oe(327));
    qh();
    var e = a_(n, 0);
    if (!(e & 1))
        return ns(n, dr()),
        null;
    var t = B_(n, e);
    if (n.tag !== 0 && t === 2) {
        var r = rS(n);
        r !== 0 && (e = r,
        t = RS(n, r))
    }
    if (t === 1)
        throw t = Rg,
        vu(n, 0),
        Gc(n, e),
        ns(n, dr()),
        t;
    if (t === 6)
        throw Error(Oe(345));
    return n.finishedWork = n.current.alternate,
    n.finishedLanes = e,
    tu(n, Yi, Il),
    ns(n, dr()),
    null
}
function nR(n, e) {
    var t = Kt;
    Kt |= 1;
    try {
        return n(e)
    } finally {
        Kt = t,
        Kt === 0 && (bd = dr() + 500,
        Yx && IA())
    }
}
function Fu(n) {
    Wc !== null && Wc.tag === 0 && !(Kt & 6) && qh();
    var e = Kt;
    Kt |= 1;
    var t = yo.transition
      , r = pn;
    try {
        if (yo.transition = null,
        pn = 1,
        n)
            return n()
    } finally {
        pn = r,
        yo.transition = t,
        Kt = e,
        !(Kt & 6) && IA()
    }
}
function rR() {
    xs = Uh.current,
    Rn(Uh)
}
function vu(n, e) {
    n.finishedWork = null,
    n.finishedLanes = 0;
    var t = n.timeoutHandle;
    if (t !== -1 && (n.timeoutHandle = -1,
    k$(t)),
    Br !== null)
        for (t = Br.return; t !== null; ) {
            var r = t;
            switch (NI(r),
            r.tag) {
            case 1:
                r = r.type.childContextTypes,
                r != null && f_();
                break;
            case 3:
                _d(),
                Rn(es),
                Rn(Si),
                WI();
                break;
            case 5:
                jI(r);
                break;
            case 4:
                _d();
                break;
            case 13:
                Rn(Vn);
                break;
            case 19:
                Rn(Vn);
                break;
            case 10:
                HI(r.type._context);
                break;
            case 22:
            case 23:
                rR()
            }
            t = t.return
        }
    if (Yr = n,
    Br = n = cA(n.current, null),
    si = xs = e,
    Dr = 0,
    Rg = null,
    eR = qx = Uu = 0,
    Yi = Xm = null,
    uu !== null) {
        for (e = 0; e < uu.length; e++)
            if (t = uu[e],
            r = t.interleaved,
            r !== null) {
                t.interleaved = null;
                var i = r.next
                  , s = t.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i,
                    r.next = o
                }
                t.pending = r
            }
        uu = null
    }
    return n
}
function q5(n, e) {
    do {
        var t = Br;
        try {
            if (QI(),
            hw.current = __,
            w_) {
                for (var r = Xn.memoizedState; r !== null; ) {
                    var i = r.queue;
                    i !== null && (i.pending = null),
                    r = r.next
                }
                w_ = !1
            }
            if (Ru = 0,
            Gr = Ur = Xn = null,
            Wm = !1,
            Cg = 0,
            qI.current = null,
            t === null || t.return === null) {
                Dr = 1,
                Rg = e,
                Br = null;
                break
            }
            e: {
                var s = n
                  , o = t.return
                  , a = t
                  , l = e;
                if (e = si,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , A = a
                      , u = A.tag;
                    if (!(A.mode & 1) && (u === 0 || u === 11 || u === 15)) {
                        var f = A.alternate;
                        f ? (A.updateQueue = f.updateQueue,
                        A.memoizedState = f.memoizedState,
                        A.lanes = f.lanes) : (A.updateQueue = null,
                        A.memoizedState = null)
                    }
                    var h = _P(o);
                    if (h !== null) {
                        h.flags &= -257,
                        xP(h, o, a, s, e),
                        h.mode & 1 && wP(s, c, e),
                        e = h,
                        l = c;
                        var d = e.updateQueue;
                        if (d === null) {
                            var m = new Set;
                            m.add(l),
                            e.updateQueue = m
                        } else
                            d.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            wP(s, c, e),
                            iR();
                            break e
                        }
                        l = Error(Oe(426))
                    }
                } else if (On && a.mode & 1) {
                    var g = _P(o);
                    if (g !== null) {
                        !(g.flags & 65536) && (g.flags |= 256),
                        xP(g, o, a, s, e),
                        OI(xd(l, a));
                        break e
                    }
                }
                s = l = xd(l, a),
                Dr !== 4 && (Dr = 2),
                Xm === null ? Xm = [s] : Xm.push(s),
                s = o;
                do {
                    switch (s.tag) {
                    case 3:
                        s.flags |= 65536,
                        e &= -e,
                        s.lanes |= e;
                        var p = D5(s, l, e);
                        dP(s, p);
                        break e;
                    case 1:
                        a = l;
                        var v = s.type
                          , w = s.stateNode;
                        if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (aA === null || !aA.has(w)))) {
                            s.flags |= 65536,
                            e &= -e,
                            s.lanes |= e;
                            var _ = N5(s, a, e);
                            dP(s, _);
                            break e
                        }
                    }
                    s = s.return
                } while (s !== null)
            }
            n6(t)
        } catch (x) {
            e = x,
            Br === t && t !== null && (Br = t = t.return);
            continue
        }
        break
    } while (1)
}
function e6() {
    var n = x_.current;
    return x_.current = __,
    n === null ? __ : n
}
function iR() {
    (Dr === 0 || Dr === 3 || Dr === 2) && (Dr = 4),
    Yr === null || !(Uu & 268435455) && !(qx & 268435455) || Gc(Yr, si)
}
function B_(n, e) {
    var t = Kt;
    Kt |= 2;
    var r = e6();
    (Yr !== n || si !== e) && (Il = null,
    vu(n, e));
    do
        try {
            AZ();
            break
        } catch (i) {
            q5(n, i)
        }
    while (1);
    if (QI(),
    Kt = t,
    x_.current = r,
    Br !== null)
        throw Error(Oe(261));
    return Yr = null,
    si = 0,
    Dr
}
function AZ() {
    for (; Br !== null; )
        t6(Br)
}
function uZ() {
    for (; Br !== null && !DY(); )
        t6(Br)
}
function t6(n) {
    var e = i6(n.alternate, n, xs);
    n.memoizedProps = n.pendingProps,
    e === null ? n6(n) : Br = e,
    qI.current = null
}
function n6(n) {
    var e = n;
    do {
        var t = e.alternate;
        if (n = e.return,
        e.flags & 32768) {
            if (t = iZ(t, e),
            t !== null) {
                t.flags &= 32767,
                Br = t;
                return
            }
            if (n !== null)
                n.flags |= 32768,
                n.subtreeFlags = 0,
                n.deletions = null;
            else {
                Dr = 6,
                Br = null;
                return
            }
        } else if (t = rZ(t, e, xs),
        t !== null) {
            Br = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Br = e;
            return
        }
        Br = e = n
    } while (e !== null);
    Dr === 0 && (Dr = 5)
}
function tu(n, e, t) {
    var r = pn
      , i = yo.transition;
    try {
        yo.transition = null,
        pn = 1,
        fZ(n, e, t, r)
    } finally {
        yo.transition = i,
        pn = r
    }
    return null
}
function fZ(n, e, t, r) {
    do
        qh();
    while (Wc !== null);
    if (Kt & 6)
        throw Error(Oe(327));
    t = n.finishedWork;
    var i = n.finishedLanes;
    if (t === null)
        return null;
    if (n.finishedWork = null,
    n.finishedLanes = 0,
    t === n.current)
        throw Error(Oe(177));
    n.callbackNode = null,
    n.callbackPriority = 0;
    var s = t.lanes | t.childLanes;
    if (WY(n, s),
    n === Yr && (Br = Yr = null,
    si = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || cv || (cv = !0,
    s6(o_, function() {
        return qh(),
        null
    })),
    s = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || s) {
        s = yo.transition,
        yo.transition = null;
        var o = pn;
        pn = 1;
        var a = Kt;
        Kt |= 4,
        qI.current = null,
        oZ(n, t),
        $5(t, n),
        U$(cS),
        l_ = !!lS,
        cS = lS = null,
        n.current = t,
        aZ(t),
        NY(),
        Kt = a,
        pn = o,
        yo.transition = s
    } else
        n.current = t;
    if (cv && (cv = !1,
    Wc = n,
    E_ = i),
    s = n.pendingLanes,
    s === 0 && (aA = null),
    QY(t.stateNode),
    ns(n, dr()),
    e !== null)
        for (r = n.onRecoverableError,
        t = 0; t < e.length; t++)
            i = e[t],
            r(i.value, {
                componentStack: i.stack,
                digest: i.digest
            });
    if (b_)
        throw b_ = !1,
        n = TS,
        TS = null,
        n;
    return E_ & 1 && n.tag !== 0 && qh(),
    s = n.pendingLanes,
    s & 1 ? n === IS ? Ym++ : (Ym = 0,
    IS = n) : Ym = 0,
    IA(),
    null
}
function qh() {
    if (Wc !== null) {
        var n = DH(E_)
          , e = yo.transition
          , t = pn;
        try {
            if (yo.transition = null,
            pn = 16 > n ? 16 : n,
            Wc === null)
                var r = !1;
            else {
                if (n = Wc,
                Wc = null,
                E_ = 0,
                Kt & 6)
                    throw Error(Oe(331));
                var i = Kt;
                for (Kt |= 4,
                Je = n.current; Je !== null; ) {
                    var s = Je
                      , o = s.child;
                    if (Je.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (Je = c; Je !== null; ) {
                                    var A = Je;
                                    switch (A.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Km(8, A, s)
                                    }
                                    var u = A.child;
                                    if (u !== null)
                                        u.return = A,
                                        Je = u;
                                    else
                                        for (; Je !== null; ) {
                                            A = Je;
                                            var f = A.sibling
                                              , h = A.return;
                                            if (K5(A),
                                            A === c) {
                                                Je = null;
                                                break
                                            }
                                            if (f !== null) {
                                                f.return = h,
                                                Je = f;
                                                break
                                            }
                                            Je = h
                                        }
                                }
                            }
                            var d = s.alternate;
                            if (d !== null) {
                                var m = d.child;
                                if (m !== null) {
                                    d.child = null;
                                    do {
                                        var g = m.sibling;
                                        m.sibling = null,
                                        m = g
                                    } while (m !== null)
                                }
                            }
                            Je = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null)
                        o.return = s,
                        Je = o;
                    else
                        e: for (; Je !== null; ) {
                            if (s = Je,
                            s.flags & 2048)
                                switch (s.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Km(9, s, s.return)
                                }
                            var p = s.sibling;
                            if (p !== null) {
                                p.return = s.return,
                                Je = p;
                                break e
                            }
                            Je = s.return
                        }
                }
                var v = n.current;
                for (Je = v; Je !== null; ) {
                    o = Je;
                    var w = o.child;
                    if (o.subtreeFlags & 2064 && w !== null)
                        w.return = o,
                        Je = w;
                    else
                        e: for (o = v; Je !== null; ) {
                            if (a = Je,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Jx(9, a)
                                    }
                                } catch (x) {
                                    er(a, a.return, x)
                                }
                            if (a === o) {
                                Je = null;
                                break e
                            }
                            var _ = a.sibling;
                            if (_ !== null) {
                                _.return = a.return,
                                Je = _;
                                break e
                            }
                            Je = a.return
                        }
                }
                if (Kt = i,
                IA(),
                Wa && typeof Wa.onPostCommitFiberRoot == "function")
                    try {
                        Wa.onPostCommitFiberRoot(Vx, n)
                    } catch {}
                r = !0
            }
            return r
        } finally {
            pn = t,
            yo.transition = e
        }
    }
    return !1
}
function LP(n, e, t) {
    e = xd(t, e),
    e = D5(n, e, 1),
    n = oA(n, e, 1),
    e = ki(),
    n !== null && (f0(n, 1, e),
    ns(n, e))
}
function er(n, e, t) {
    if (n.tag === 3)
        LP(n, n, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                LP(e, n, t);
                break
            } else if (e.tag === 1) {
                var r = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (aA === null || !aA.has(r))) {
                    n = xd(t, n),
                    n = N5(e, n, 1),
                    e = oA(e, n, 1),
                    n = ki(),
                    e !== null && (f0(e, 1, n),
                    ns(e, n));
                    break
                }
            }
            e = e.return
        }
}
function hZ(n, e, t) {
    var r = n.pingCache;
    r !== null && r.delete(e),
    e = ki(),
    n.pingedLanes |= n.suspendedLanes & t,
    Yr === n && (si & t) === t && (Dr === 4 || Dr === 3 && (si & 130023424) === si && 500 > dr() - tR ? vu(n, 0) : eR |= t),
    ns(n, e)
}
function r6(n, e) {
    e === 0 && (n.mode & 1 ? (e = q0,
    q0 <<= 1,
    !(q0 & 130023424) && (q0 = 4194304)) : e = 1);
    var t = ki();
    n = Jl(n, e),
    n !== null && (f0(n, e, t),
    ns(n, t))
}
function dZ(n) {
    var e = n.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    r6(n, t)
}
function pZ(n, e) {
    var t = 0;
    switch (n.tag) {
    case 13:
        var r = n.stateNode
          , i = n.memoizedState;
        i !== null && (t = i.retryLane);
        break;
    case 19:
        r = n.stateNode;
        break;
    default:
        throw Error(Oe(314))
    }
    r !== null && r.delete(e),
    r6(n, t)
}
var i6;
i6 = function(n, e, t) {
    if (n !== null)
        if (n.memoizedProps !== e.pendingProps || es.current)
            Ji = !0;
        else {
            if (!(n.lanes & t) && !(e.flags & 128))
                return Ji = !1,
                nZ(n, e, t);
            Ji = !!(n.flags & 131072)
        }
    else
        Ji = !1,
        On && e.flags & 1048576 && l5(e, p_, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var r = e.type;
        pw(n, e),
        n = e.pendingProps;
        var i = vd(e, Si.current);
        Jh(e, t),
        i = XI(null, e, r, n, i, t);
        var s = YI();
        return e.flags |= 1,
        typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        ts(r) ? (s = !0,
        h_(e)) : s = !1,
        e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
        GI(e),
        i.updater = Zx,
        e.stateNode = i,
        i._reactInternals = e,
        vS(e, r, n, t),
        e = _S(null, e, r, !0, s, t)) : (e.tag = 0,
        On && s && DI(e),
        Pi(null, e, i, t),
        e = e.child),
        e;
    case 16:
        r = e.elementType;
        e: {
            switch (pw(n, e),
            n = e.pendingProps,
            i = r._init,
            r = i(r._payload),
            e.type = r,
            i = e.tag = gZ(r),
            n = Wo(r, n),
            i) {
            case 0:
                e = wS(null, e, r, n, t);
                break e;
            case 1:
                e = BP(null, e, r, n, t);
                break e;
            case 11:
                e = bP(null, e, r, n, t);
                break e;
            case 14:
                e = EP(null, e, r, Wo(r.type, n), t);
                break e
            }
            throw Error(Oe(306, r, ""))
        }
        return e;
    case 0:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Wo(r, i),
        wS(n, e, r, i, t);
    case 1:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Wo(r, i),
        BP(n, e, r, i, t);
    case 3:
        e: {
            if (H5(e),
            n === null)
                throw Error(Oe(387));
            r = e.pendingProps,
            s = e.memoizedState,
            i = s.element,
            d5(n, e),
            v_(e, r, null, t);
            var o = e.memoizedState;
            if (r = o.element,
            s.isDehydrated)
                if (s = {
                    element: r,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = s,
                e.memoizedState = s,
                e.flags & 256) {
                    i = xd(Error(Oe(423)), e),
                    e = MP(n, e, r, t, i);
                    break e
                } else if (r !== i) {
                    i = xd(Error(Oe(424)), e),
                    e = MP(n, e, r, t, i);
                    break e
                } else
                    for (Ts = sA(e.stateNode.containerInfo.firstChild),
                    Ls = e,
                    On = !0,
                    $o = null,
                    t = f5(e, null, r, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (yd(),
                r === i) {
                    e = ql(n, e, t);
                    break e
                }
                Pi(n, e, r, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return p5(e),
        n === null && pS(e),
        r = e.type,
        i = e.pendingProps,
        s = n !== null ? n.memoizedProps : null,
        o = i.children,
        AS(r, i) ? o = null : s !== null && AS(r, s) && (e.flags |= 32),
        Q5(n, e),
        Pi(n, e, o, t),
        e.child;
    case 6:
        return n === null && pS(e),
        null;
    case 13:
        return z5(n, e, t);
    case 4:
        return VI(e, e.stateNode.containerInfo),
        r = e.pendingProps,
        n === null ? e.child = wd(e, null, r, t) : Pi(n, e, r, t),
        e.child;
    case 11:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Wo(r, i),
        bP(n, e, r, i, t);
    case 7:
        return Pi(n, e, e.pendingProps, t),
        e.child;
    case 8:
        return Pi(n, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return Pi(n, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (r = e.type._context,
            i = e.pendingProps,
            s = e.memoizedProps,
            o = i.value,
            En(m_, r._currentValue),
            r._currentValue = o,
            s !== null)
                if (la(s.value, o)) {
                    if (s.children === i.children && !es.current) {
                        e = ql(n, e, t);
                        break e
                    }
                } else
                    for (s = e.child,
                    s !== null && (s.return = e); s !== null; ) {
                        var a = s.dependencies;
                        if (a !== null) {
                            o = s.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === r) {
                                    if (s.tag === 1) {
                                        l = Vl(-1, t & -t),
                                        l.tag = 2;
                                        var c = s.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var A = c.pending;
                                            A === null ? l.next = l : (l.next = A.next,
                                            A.next = l),
                                            c.pending = l
                                        }
                                    }
                                    s.lanes |= t,
                                    l = s.alternate,
                                    l !== null && (l.lanes |= t),
                                    mS(s.return, t, e),
                                    a.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (s.tag === 10)
                            o = s.type === e.type ? null : s.child;
                        else if (s.tag === 18) {
                            if (o = s.return,
                            o === null)
                                throw Error(Oe(341));
                            o.lanes |= t,
                            a = o.alternate,
                            a !== null && (a.lanes |= t),
                            mS(o, t, e),
                            o = s.sibling
                        } else
                            o = s.child;
                        if (o !== null)
                            o.return = s;
                        else
                            for (o = s; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (s = o.sibling,
                                s !== null) {
                                    s.return = o.return,
                                    o = s;
                                    break
                                }
                                o = o.return
                            }
                        s = o
                    }
            Pi(n, e, i.children, t),
            e = e.child
        }
        return e;
    case 9:
        return i = e.type,
        r = e.pendingProps.children,
        Jh(e, t),
        i = _o(i),
        r = r(i),
        e.flags |= 1,
        Pi(n, e, r, t),
        e.child;
    case 14:
        return r = e.type,
        i = Wo(r, e.pendingProps),
        i = Wo(r.type, i),
        EP(n, e, r, i, t);
    case 15:
        return O5(n, e, e.type, e.pendingProps, t);
    case 17:
        return r = e.type,
        i = e.pendingProps,
        i = e.elementType === r ? i : Wo(r, i),
        pw(n, e),
        e.tag = 1,
        ts(r) ? (n = !0,
        h_(e)) : n = !1,
        Jh(e, t),
        L5(e, r, i),
        vS(e, r, i, t),
        _S(null, e, r, !0, n, t);
    case 19:
        return G5(n, e, t);
    case 22:
        return k5(n, e, t)
    }
    throw Error(Oe(156, e.tag))
}
;
function s6(n, e) {
    return UH(n, e)
}
function mZ(n, e, t, r) {
    this.tag = n,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = r,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function co(n, e, t, r) {
    return new mZ(n,e,t,r)
}
function sR(n) {
    return n = n.prototype,
    !(!n || !n.isReactComponent)
}
function gZ(n) {
    if (typeof n == "function")
        return sR(n) ? 1 : 0;
    if (n != null) {
        if (n = n.$$typeof,
        n === EI)
            return 11;
        if (n === BI)
            return 14
    }
    return 2
}
function cA(n, e) {
    var t = n.alternate;
    return t === null ? (t = co(n.tag, e, n.key, n.mode),
    t.elementType = n.elementType,
    t.type = n.type,
    t.stateNode = n.stateNode,
    t.alternate = n,
    n.alternate = t) : (t.pendingProps = e,
    t.type = n.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = n.flags & 14680064,
    t.childLanes = n.childLanes,
    t.lanes = n.lanes,
    t.child = n.child,
    t.memoizedProps = n.memoizedProps,
    t.memoizedState = n.memoizedState,
    t.updateQueue = n.updateQueue,
    e = n.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = n.sibling,
    t.index = n.index,
    t.ref = n.ref,
    t
}
function vw(n, e, t, r, i, s) {
    var o = 2;
    if (r = n,
    typeof n == "function")
        sR(n) && (o = 1);
    else if (typeof n == "string")
        o = 5;
    else
        e: switch (n) {
        case xh:
            return yu(t.children, i, s, e);
        case bI:
            o = 8,
            i |= 8;
            break;
        case zM:
            return n = co(12, t, e, i | 2),
            n.elementType = zM,
            n.lanes = s,
            n;
        case GM:
            return n = co(13, t, e, i),
            n.elementType = GM,
            n.lanes = s,
            n;
        case VM:
            return n = co(19, t, e, i),
            n.elementType = VM,
            n.lanes = s,
            n;
        case pH:
            return e1(t, i, s, e);
        default:
            if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                case hH:
                    o = 10;
                    break e;
                case dH:
                    o = 9;
                    break e;
                case EI:
                    o = 11;
                    break e;
                case BI:
                    o = 14;
                    break e;
                case Dc:
                    o = 16,
                    r = null;
                    break e
                }
            throw Error(Oe(130, n == null ? n : typeof n, ""))
        }
    return e = co(o, t, e, i),
    e.elementType = n,
    e.type = r,
    e.lanes = s,
    e
}
function yu(n, e, t, r) {
    return n = co(7, n, r, e),
    n.lanes = t,
    n
}
function e1(n, e, t, r) {
    return n = co(22, n, r, e),
    n.elementType = pH,
    n.lanes = t,
    n.stateNode = {
        isHidden: !1
    },
    n
}
function sE(n, e, t) {
    return n = co(6, n, null, e),
    n.lanes = t,
    n
}
function oE(n, e, t) {
    return e = co(4, n.children !== null ? n.children : [], n.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
    },
    e
}
function vZ(n, e, t, r, i) {
    this.tag = e,
    this.containerInfo = n,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Qb(0),
    this.expirationTimes = Qb(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Qb(0),
    this.identifierPrefix = r,
    this.onRecoverableError = i,
    this.mutableSourceEagerHydrationData = null
}
function oR(n, e, t, r, i, s, o, a, l) {
    return n = new vZ(n,e,t,a,l),
    e === 1 ? (e = 1,
    s === !0 && (e |= 8)) : e = 0,
    s = co(3, null, null, e),
    n.current = s,
    s.stateNode = n,
    s.memoizedState = {
        element: r,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    GI(s),
    n
}
function yZ(n, e, t) {
    var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: _h,
        key: r == null ? null : "" + r,
        children: n,
        containerInfo: e,
        implementation: t
    }
}
function o6(n) {
    if (!n)
        return gA;
    n = n._reactInternals;
    e: {
        if (Xu(n) !== n || n.tag !== 1)
            throw Error(Oe(170));
        var e = n;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (ts(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(Oe(171))
    }
    if (n.tag === 1) {
        var t = n.type;
        if (ts(t))
            return o5(n, t, e)
    }
    return e
}
function a6(n, e, t, r, i, s, o, a, l) {
    return n = oR(t, r, !0, n, i, s, o, a, l),
    n.context = o6(null),
    t = n.current,
    r = ki(),
    i = lA(t),
    s = Vl(r, i),
    s.callback = e ?? null,
    oA(t, s, i),
    n.current.lanes = i,
    f0(n, i, r),
    ns(n, r),
    n
}
function t1(n, e, t, r) {
    var i = e.current
      , s = ki()
      , o = lA(i);
    return t = o6(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = Vl(s, o),
    e.payload = {
        element: n
    },
    r = r === void 0 ? null : r,
    r !== null && (e.callback = r),
    n = oA(i, e, o),
    n !== null && (ra(n, i, o, s),
    fw(n, i, o)),
    o
}
function M_(n) {
    if (n = n.current,
    !n.child)
        return null;
    switch (n.child.tag) {
    case 5:
        return n.child.stateNode;
    default:
        return n.child.stateNode
    }
}
function DP(n, e) {
    if (n = n.memoizedState,
    n !== null && n.dehydrated !== null) {
        var t = n.retryLane;
        n.retryLane = t !== 0 && t < e ? t : e
    }
}
function aR(n, e) {
    DP(n, e),
    (n = n.alternate) && DP(n, e)
}
function wZ() {
    return null
}
var l6 = typeof reportError == "function" ? reportError : function(n) {
    console.error(n)
}
;
function lR(n) {
    this._internalRoot = n
}
n1.prototype.render = lR.prototype.render = function(n) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(Oe(409));
    t1(n, e, null, null)
}
;
n1.prototype.unmount = lR.prototype.unmount = function() {
    var n = this._internalRoot;
    if (n !== null) {
        this._internalRoot = null;
        var e = n.containerInfo;
        Fu(function() {
            t1(null, n, null, null)
        }),
        e[Zl] = null
    }
}
;
function n1(n) {
    this._internalRoot = n
}
n1.prototype.unstable_scheduleHydration = function(n) {
    if (n) {
        var e = kH();
        n = {
            blockedOn: null,
            target: n,
            priority: e
        };
        for (var t = 0; t < zc.length && e !== 0 && e < zc[t].priority; t++)
            ;
        zc.splice(t, 0, n),
        t === 0 && HH(n)
    }
}
;
function cR(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11)
}
function r1(n) {
    return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
}
function NP() {}
function _Z(n, e, t, r, i) {
    if (i) {
        if (typeof r == "function") {
            var s = r;
            r = function() {
                var c = M_(o);
                s.call(c)
            }
        }
        var o = a6(e, r, n, 0, null, !1, !1, "", NP);
        return n._reactRootContainer = o,
        n[Zl] = o.current,
        bg(n.nodeType === 8 ? n.parentNode : n),
        Fu(),
        o
    }
    for (; i = n.lastChild; )
        n.removeChild(i);
    if (typeof r == "function") {
        var a = r;
        r = function() {
            var c = M_(l);
            a.call(c)
        }
    }
    var l = oR(n, 0, !1, null, null, !1, !1, "", NP);
    return n._reactRootContainer = l,
    n[Zl] = l.current,
    bg(n.nodeType === 8 ? n.parentNode : n),
    Fu(function() {
        t1(e, l, t, r)
    }),
    l
}
function i1(n, e, t, r, i) {
    var s = t._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = M_(o);
                a.call(l)
            }
        }
        t1(e, o, n, i)
    } else
        o = _Z(t, e, n, i, r);
    return M_(o)
}
NH = function(n) {
    switch (n.tag) {
    case 3:
        var e = n.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = vm(e.pendingLanes);
            t !== 0 && (CI(e, t | 1),
            ns(e, dr()),
            !(Kt & 6) && (bd = dr() + 500,
            IA()))
        }
        break;
    case 13:
        Fu(function() {
            var r = Jl(n, 1);
            if (r !== null) {
                var i = ki();
                ra(r, n, 1, i)
            }
        }),
        aR(n, 1)
    }
}
;
TI = function(n) {
    if (n.tag === 13) {
        var e = Jl(n, 134217728);
        if (e !== null) {
            var t = ki();
            ra(e, n, 134217728, t)
        }
        aR(n, 134217728)
    }
}
;
OH = function(n) {
    if (n.tag === 13) {
        var e = lA(n)
          , t = Jl(n, e);
        if (t !== null) {
            var r = ki();
            ra(t, n, e, r)
        }
        aR(n, e)
    }
}
;
kH = function() {
    return pn
}
;
QH = function(n, e) {
    var t = pn;
    try {
        return pn = n,
        e()
    } finally {
        pn = t
    }
}
;
eS = function(n, e, t) {
    switch (e) {
    case "input":
        if (KM(n, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = n; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var r = t[e];
                if (r !== n && r.form === n.form) {
                    var i = Xx(r);
                    if (!i)
                        throw Error(Oe(90));
                    gH(r),
                    KM(r, i)
                }
            }
        }
        break;
    case "textarea":
        yH(n, t);
        break;
    case "select":
        e = t.value,
        e != null && Xh(n, !!t.multiple, e, !1)
    }
}
;
MH = nR;
SH = Fu;
var xZ = {
    usingClientEntryPoint: !1,
    Events: [d0, Mh, Xx, EH, BH, nR]
}
  , Sp = {
    findFiberByHostInstance: Au,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , bZ = {
    bundleType: Sp.bundleType,
    version: Sp.version,
    rendererPackageName: Sp.rendererPackageName,
    rendererConfig: Sp.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: lc.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(n) {
        return n = IH(n),
        n === null ? null : n.stateNode
    },
    findFiberByHostInstance: Sp.findFiberByHostInstance || wZ,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Av = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Av.isDisabled && Av.supportsFiber)
        try {
            Vx = Av.inject(bZ),
            Wa = Av
        } catch {}
}
js.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = xZ;
js.createPortal = function(n, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!cR(e))
        throw Error(Oe(200));
    return yZ(n, e, null, t)
}
;
js.createRoot = function(n, e) {
    if (!cR(n))
        throw Error(Oe(299));
    var t = !1
      , r = ""
      , i = l6;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    e = oR(n, 1, !1, null, null, t, !1, r, i),
    n[Zl] = e.current,
    bg(n.nodeType === 8 ? n.parentNode : n),
    new lR(e)
}
;
js.findDOMNode = function(n) {
    if (n == null)
        return null;
    if (n.nodeType === 1)
        return n;
    var e = n._reactInternals;
    if (e === void 0)
        throw typeof n.render == "function" ? Error(Oe(188)) : (n = Object.keys(n).join(","),
        Error(Oe(268, n)));
    return n = IH(e),
    n = n === null ? null : n.stateNode,
    n
}
;
js.flushSync = function(n) {
    return Fu(n)
}
;
js.hydrate = function(n, e, t) {
    if (!r1(e))
        throw Error(Oe(200));
    return i1(null, n, e, !0, t)
}
;
js.hydrateRoot = function(n, e, t) {
    if (!cR(n))
        throw Error(Oe(405));
    var r = t != null && t.hydratedSources || null
      , i = !1
      , s = ""
      , o = l6;
    if (t != null && (t.unstable_strictMode === !0 && (i = !0),
    t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    e = a6(e, null, n, 1, t ?? null, i, !1, s, o),
    n[Zl] = e.current,
    bg(n),
    r)
        for (n = 0; n < r.length; n++)
            t = r[n],
            i = t._getVersion,
            i = i(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, i] : e.mutableSourceEagerHydrationData.push(t, i);
    return new n1(e)
}
;
js.render = function(n, e, t) {
    if (!r1(e))
        throw Error(Oe(200));
    return i1(null, n, e, !1, t)
}
;
js.unmountComponentAtNode = function(n) {
    if (!r1(n))
        throw Error(Oe(40));
    return n._reactRootContainer ? (Fu(function() {
        i1(null, null, n, !1, function() {
            n._reactRootContainer = null,
            n[Zl] = null
        })
    }),
    !0) : !1
}
;
js.unstable_batchedUpdates = nR;
js.unstable_renderSubtreeIntoContainer = function(n, e, t, r) {
    if (!r1(t))
        throw Error(Oe(200));
    if (n == null || n._reactInternals === void 0)
        throw Error(Oe(38));
    return i1(n, e, t, !1, r)
}
;
js.version = "18.3.1-next-f1338f8080-20240426";
function c6() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c6)
        } catch (n) {
            console.error(n)
        }
}
c6(),
cH.exports = js;
var EZ = cH.exports
  , OP = EZ;
QM.createRoot = OP.createRoot,
QM.hydrateRoot = OP.hydrateRoot;
const BZ = "/public/assets/cc_bgm_balanced.wav"
  , So = be.createContext()
  , MZ = ({children: n}) => {
    const [e,t] = be.useState(!1)
      , r = Z.useRef(null)
      , i = () => {
        t(!1);
        const o = r.current;
        o.src = BZ,
        o.loop = !0,
        o.volume = 0,
        o.play();
        let a = 0;
        const l = 5
          , c = setInterval( () => {
            a = Math.max(a + 1 / (10 * l * 60), 1),
            a >= 1 && clearInterval(c),
            o.volume = a
        }
        , 1e3 / 60)
    }
      , s = () => {
        t(!0),
        r.current.pause()
    }
    ;
    return k.jsxs(So.Provider, {
        value: {
            isMute: e,
            setMute: t,
            enableAudio: i,
            disableAudio: s
        },
        children: [k.jsx("audio", {
            ref: r
        }), n]
    })
}
  , SZ = be.createContext()
  , CZ = n => {
    const [e,t] = be.useState(null)
      , [r,i] = be.useState(null)
      , [s,o] = be.useState(!1)
      , [a,l] = be.useState([]);
    return k.jsx(SZ.Provider, {
        value: {
            walletAddress: e,
            setWalletAddress: t,
            ensName: r,
            setEnsName: i,
            connected: s,
            setConnected: o,
            OTTokens: a,
            setOTTokens: l
        },
        children: n.children
    })
}
;
function Rl(n) {
    if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return n
}
function A6(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    n.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Ds = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
        lineHeight: ""
    }
}, Ed = {
    duration: .5,
    overwrite: !1,
    delay: 0
}, AR, Ei, kn, Ao = 1e8, _n = 1 / Ao, FS = Math.PI * 2, TZ = FS / 4, IZ = 0, u6 = Math.sqrt, RZ = Math.cos, UZ = Math.sin, $r = function(e) {
    return typeof e == "string"
}, rr = function(e) {
    return typeof e == "function"
}, ec = function(e) {
    return typeof e == "number"
}, uR = function(e) {
    return typeof e > "u"
}, el = function(e) {
    return typeof e == "object"
}, rs = function(e) {
    return e !== !1
}, fR = function() {
    return typeof window < "u"
}, uv = function(e) {
    return rr(e) || $r(e)
}, f6 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
, Bi = Array.isArray, PS = /(?:-?\.?\d|\.)+/gi, h6 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Fh = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, aE = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, d6 = /[+-]=-?[.\d]+/, p6 = /[^,'"\[\]\s]+/gi, FZ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, jn, Ta, LS, hR, Qs = {}, S_ = {}, m6, g6 = function(e) {
    return (S_ = Pu(e, Qs)) && As
}, dR = function(e, t) {
    return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
}, Ug = function(e, t) {
    return !t && console.warn(e)
}, v6 = function(e, t) {
    return e && (Qs[e] = t) && S_ && (S_[e] = t) || Qs
}, Fg = function() {
    return 0
}, PZ = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1
}, yw = {
    suppressEvents: !0,
    kill: !1
}, LZ = {
    suppressEvents: !0
}, pR = {}, AA = [], DS = {}, y6, Bs = {}, lE = {}, kP = 30, ww = [], mR = "", gR = function(e) {
    var t = e[0], r, i;
    if (el(t) || rr(t) || (e = [e]),
    !(r = (t._gsap || {}).harness)) {
        for (i = ww.length; i-- && !ww[i].targetTest(t); )
            ;
        r = ww[i]
    }
    for (i = e.length; i--; )
        e[i] && (e[i]._gsap || (e[i]._gsap = new G6(e[i],r))) || e.splice(i, 1);
    return e
}, wu = function(e) {
    return e._gsap || gR(uo(e))[0]._gsap
}, w6 = function(e, t, r) {
    return (r = e[t]) && rr(r) ? e[t]() : uR(r) && e.getAttribute && e.getAttribute(t) || r
}, is = function(e, t) {
    return (e = e.split(",")).forEach(t) || e
}, hr = function(e) {
    return Math.round(e * 1e5) / 1e5 || 0
}, jr = function(e) {
    return Math.round(e * 1e7) / 1e7 || 0
}, ed = function(e, t) {
    var r = t.charAt(0)
      , i = parseFloat(t.substr(2));
    return e = parseFloat(e),
    r === "+" ? e + i : r === "-" ? e - i : r === "*" ? e * i : e / i
}, DZ = function(e, t) {
    for (var r = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < r; )
        ;
    return i < r
}, C_ = function() {
    var e = AA.length, t = AA.slice(0), r, i;
    for (DS = {},
    AA.length = 0,
    r = 0; r < e; r++)
        i = t[r],
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
}, _6 = function(e, t, r, i) {
    AA.length && !Ei && C_(),
    e.render(t, r, i || Ei && t < 0 && (e._initted || e._startAt)),
    AA.length && !Ei && C_()
}, x6 = function(e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(p6).length < 2 ? t : $r(e) ? e.trim() : e
}, b6 = function(e) {
    return e
}, bo = function(e, t) {
    for (var r in t)
        r in e || (e[r] = t[r]);
    return e
}, NZ = function(e) {
    return function(t, r) {
        for (var i in r)
            i in t || i === "duration" && e || i === "ease" || (t[i] = r[i])
    }
}, Pu = function(e, t) {
    for (var r in t)
        e[r] = t[r];
    return e
}, QP = function n(e, t) {
    for (var r in t)
        r !== "__proto__" && r !== "constructor" && r !== "prototype" && (e[r] = el(t[r]) ? n(e[r] || (e[r] = {}), t[r]) : t[r]);
    return e
}, T_ = function(e, t) {
    var r = {}, i;
    for (i in e)
        i in t || (r[i] = e[i]);
    return r
}, $m = function(e) {
    var t = e.parent || jn
      , r = e.keyframes ? NZ(Bi(e.keyframes)) : bo;
    if (rs(e.inherit))
        for (; t; )
            r(e, t.vars.defaults),
            t = t.parent || t._dp;
    return e
}, OZ = function(e, t) {
    for (var r = e.length, i = r === t.length; i && r-- && e[r] === t[r]; )
        ;
    return r < 0
}, E6 = function(e, t, r, i, s) {
    r === void 0 && (r = "_first"),
    i === void 0 && (i = "_last");
    var o = e[i], a;
    if (s)
        for (a = t[s]; o && o[s] > a; )
            o = o._prev;
    return o ? (t._next = o._next,
    o._next = t) : (t._next = e[r],
    e[r] = t),
    t._next ? t._next._prev = t : e[i] = t,
    t._prev = o,
    t.parent = t._dp = e,
    t
}, s1 = function(e, t, r, i) {
    r === void 0 && (r = "_first"),
    i === void 0 && (i = "_last");
    var s = t._prev
      , o = t._next;
    s ? s._next = o : e[r] === t && (e[r] = o),
    o ? o._prev = s : e[i] === t && (e[i] = s),
    t._next = t._prev = t.parent = null
}, vA = function(e, t) {
    e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
    e._act = 0
}, _u = function(e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
        for (var r = e; r; )
            r._dirty = 1,
            r = r.parent;
    return e
}, kZ = function(e) {
    for (var t = e.parent; t && t.parent; )
        t._dirty = 1,
        t.totalDuration(),
        t = t.parent;
    return e
}, NS = function(e, t, r, i) {
    return e._startAt && (Ei ? e._startAt.revert(yw) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
}, QZ = function n(e) {
    return !e || e._ts && n(e.parent)
}, HP = function(e) {
    return e._repeat ? Bd(e._tTime, e = e.duration() + e._rDelay) * e : 0
}, Bd = function(e, t) {
    var r = Math.floor(e /= t);
    return e && r === e ? r - 1 : r
}, I_ = function(e, t) {
    return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
}, o1 = function(e) {
    return e._end = jr(e._start + (e._tDur / Math.abs(e._ts || e._rts || _n) || 0))
}, a1 = function(e, t) {
    var r = e._dp;
    return r && r.smoothChildTiming && e._ts && (e._start = jr(r._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
    o1(e),
    r._dirty || _u(r, e)),
    e
}, B6 = function(e, t) {
    var r;
    if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (r = I_(e.rawTime(), t),
    (!t._dur || m0(0, t.totalDuration(), r) - t._tTime > _n) && t.render(r, !0)),
    _u(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
        if (e._dur < e.duration())
            for (r = e; r._dp; )
                r.rawTime() >= 0 && r.totalTime(r._tTime),
                r = r._dp;
        e._zTime = -_n
    }
}, Pa = function(e, t, r, i) {
    return t.parent && vA(t),
    t._start = jr((ec(r) ? r : r || e !== jn ? eo(e, r, t) : e._time) + t._delay),
    t._end = jr(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
    E6(e, t, "_first", "_last", e._sort ? "_start" : 0),
    OS(t) || (e._recent = t),
    i || B6(e, t),
    e._ts < 0 && a1(e, e._tTime),
    e
}, M6 = function(e, t) {
    return (Qs.ScrollTrigger || dR("scrollTrigger", t)) && Qs.ScrollTrigger.create(t, e)
}, S6 = function(e, t, r, i, s) {
    if (yR(e, t, s),
    !e._initted)
        return 1;
    if (!r && e._pt && !Ei && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && y6 !== Ms.frame)
        return AA.push(e),
        e._lazy = [s, i],
        1
}, HZ = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t))
}, OS = function(e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart"
}, zZ = function(e, t, r, i) {
    var s = e.ratio, o = t < 0 || !t && (!e._start && HZ(e) && !(!e._initted && OS(e)) || (e._ts < 0 || e._dp._ts < 0) && !OS(e)) ? 0 : 1, a = e._rDelay, l = 0, c, A, u;
    if (a && e._repeat && (l = m0(0, e._tDur, t),
    A = Bd(l, a),
    e._yoyo && A & 1 && (o = 1 - o),
    A !== Bd(e._tTime, a) && (s = 1 - o,
    e.vars.repeatRefresh && e._initted && e.invalidate())),
    o !== s || Ei || i || e._zTime === _n || !t && e._zTime) {
        if (!e._initted && S6(e, t, i, r, l))
            return;
        for (u = e._zTime,
        e._zTime = t || (r ? _n : 0),
        r || (r = t && !u),
        e.ratio = o,
        e._from && (o = 1 - o),
        e._time = 0,
        e._tTime = l,
        c = e._pt; c; )
            c.r(o, c.d),
            c = c._next;
        t < 0 && NS(e, t, r, !0),
        e._onUpdate && !r && Is(e, "onUpdate"),
        l && e._repeat && !r && e.parent && Is(e, "onRepeat"),
        (t >= e._tDur || t < 0) && e.ratio === o && (o && vA(e, 1),
        !r && !Ei && (Is(e, o ? "onComplete" : "onReverseComplete", !0),
        e._prom && e._prom()))
    } else
        e._zTime || (e._zTime = t)
}, GZ = function(e, t, r) {
    var i;
    if (r > t)
        for (i = e._first; i && i._start <= r; ) {
            if (i.data === "isPause" && i._start > t)
                return i;
            i = i._next
        }
    else
        for (i = e._last; i && i._start >= r; ) {
            if (i.data === "isPause" && i._start < t)
                return i;
            i = i._prev
        }
}, Md = function(e, t, r, i) {
    var s = e._repeat
      , o = jr(t) || 0
      , a = e._tTime / e._tDur;
    return a && !i && (e._time *= o / e._dur),
    e._dur = o,
    e._tDur = s ? s < 0 ? 1e10 : jr(o * (s + 1) + e._rDelay * s) : o,
    a > 0 && !i && a1(e, e._tTime = e._tDur * a),
    e.parent && o1(e),
    r || _u(e.parent, e),
    e
}, zP = function(e) {
    return e instanceof Ni ? _u(e) : Md(e, e._dur)
}, VZ = {
    _start: 0,
    endTime: Fg,
    totalDuration: Fg
}, eo = function n(e, t, r) {
    var i = e.labels, s = e._recent || VZ, o = e.duration() >= Ao ? s.endTime(!1) : e._dur, a, l, c;
    return $r(t) && (isNaN(t) || t in i) ? (l = t.charAt(0),
    c = t.substr(-1) === "%",
    a = t.indexOf("="),
    l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")),
    (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? s : r).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = o),
    i[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)),
    c && r && (l = l / 100 * (Bi(r) ? r[0] : r).totalDuration()),
    a > 1 ? n(e, t.substr(0, a - 1), r) + l : o + l)) : t == null ? o : +t
}, Zm = function(e, t, r) {
    var i = ec(t[1]), s = (i ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, l;
    if (i && (o.duration = t[1]),
    o.parent = r,
    e) {
        for (a = o,
        l = r; l && !("immediateRender"in a); )
            a = l.vars.defaults || {},
            l = rs(l.vars.inherit) && l.parent;
        o.immediateRender = rs(a.immediateRender),
        e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
    }
    return new xr(t[0],o,t[s + 1])
}, RA = function(e, t) {
    return e || e === 0 ? t(e) : t
}, m0 = function(e, t, r) {
    return r < e ? e : r > t ? t : r
}, wi = function(e, t) {
    return !$r(e) || !(t = FZ.exec(e)) ? "" : t[1]
}, jZ = function(e, t, r) {
    return RA(r, function(i) {
        return m0(e, t, i)
    })
}, kS = [].slice, C6 = function(e, t) {
    return e && el(e) && "length"in e && (!t && !e.length || e.length - 1 in e && el(e[0])) && !e.nodeType && e !== Ta
}, WZ = function(e, t, r) {
    return r === void 0 && (r = []),
    e.forEach(function(i) {
        var s;
        return $r(i) && !t || C6(i, 1) ? (s = r).push.apply(s, uo(i)) : r.push(i)
    }) || r
}, uo = function(e, t, r) {
    return kn && !t && kn.selector ? kn.selector(e) : $r(e) && !r && (LS || !Sd()) ? kS.call((t || hR).querySelectorAll(e), 0) : Bi(e) ? WZ(e, r) : C6(e) ? kS.call(e, 0) : e ? [e] : []
}, QS = function(e) {
    return e = uo(e)[0] || Ug("Invalid scope") || {},
    function(t) {
        var r = e.current || e.nativeElement || e;
        return uo(t, r.querySelectorAll ? r : r === e ? Ug("Invalid scope") || hR.createElement("div") : e)
    }
}, T6 = function(e) {
    return e.sort(function() {
        return .5 - Math.random()
    })
}, I6 = function(e) {
    if (rr(e))
        return e;
    var t = el(e) ? e : {
        each: e
    }
      , r = xu(t.ease)
      , i = t.from || 0
      , s = parseFloat(t.base) || 0
      , o = {}
      , a = i > 0 && i < 1
      , l = isNaN(i) || a
      , c = t.axis
      , A = i
      , u = i;
    return $r(i) ? A = u = {
        center: .5,
        edges: .5,
        end: 1
    }[i] || 0 : !a && l && (A = i[0],
    u = i[1]),
    function(f, h, d) {
        var m = (d || t).length, g = o[m], p, v, w, _, x, b, B, S, I;
        if (!g) {
            if (I = t.grid === "auto" ? 0 : (t.grid || [1, Ao])[1],
            !I) {
                for (B = -Ao; B < (B = d[I++].getBoundingClientRect().left) && I < m; )
                    ;
                I < m && I--
            }
            for (g = o[m] = [],
            p = l ? Math.min(I, m) * A - .5 : i % I,
            v = I === Ao ? 0 : l ? m * u / I - .5 : i / I | 0,
            B = 0,
            S = Ao,
            b = 0; b < m; b++)
                w = b % I - p,
                _ = v - (b / I | 0),
                g[b] = x = c ? Math.abs(c === "y" ? _ : w) : u6(w * w + _ * _),
                x > B && (B = x),
                x < S && (S = x);
            i === "random" && T6(g),
            g.max = B - S,
            g.min = S,
            g.v = m = (parseFloat(t.amount) || parseFloat(t.each) * (I > m ? m - 1 : c ? c === "y" ? m / I : I : Math.max(I, m / I)) || 0) * (i === "edges" ? -1 : 1),
            g.b = m < 0 ? s - m : s,
            g.u = wi(t.amount || t.each) || 0,
            r = r && m < 0 ? Q6(r) : r
        }
        return m = (g[f] - g.min) / g.max || 0,
        jr(g.b + (r ? r(m) : m) * g.v) + g.u
    }
}, HS = function(e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function(r) {
        var i = jr(Math.round(parseFloat(r) / e) * e * t);
        return (i - i % 1) / t + (ec(r) ? 0 : wi(r))
    }
}, R6 = function(e, t) {
    var r = Bi(e), i, s;
    return !r && el(e) && (i = r = e.radius || Ao,
    e.values ? (e = uo(e.values),
    (s = !ec(e[0])) && (i *= i)) : e = HS(e.increment)),
    RA(t, r ? rr(e) ? function(o) {
        return s = e(o),
        Math.abs(s - o) <= i ? s : o
    }
    : function(o) {
        for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = Ao, A = 0, u = e.length, f, h; u--; )
            s ? (f = e[u].x - a,
            h = e[u].y - l,
            f = f * f + h * h) : f = Math.abs(e[u] - a),
            f < c && (c = f,
            A = u);
        return A = !i || c <= i ? e[A] : o,
        s || A === o || ec(o) ? A : A + wi(o)
    }
    : HS(e))
}, U6 = function(e, t, r, i) {
    return RA(Bi(e) ? !t : r === !0 ? !!(r = 0) : !i, function() {
        return Bi(e) ? e[~~(Math.random() * e.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((e - r / 2 + Math.random() * (t - e + r * .99)) / r) * r * i) / i
    })
}, KZ = function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
    return function(i) {
        return t.reduce(function(s, o) {
            return o(s)
        }, i)
    }
}, XZ = function(e, t) {
    return function(r) {
        return e(parseFloat(r)) + (t || wi(r))
    }
}, YZ = function(e, t, r) {
    return P6(e, t, 0, 1, r)
}, F6 = function(e, t, r) {
    return RA(r, function(i) {
        return e[~~t(i)]
    })
}, $Z = function n(e, t, r) {
    var i = t - e;
    return Bi(e) ? F6(e, n(0, e.length), t) : RA(r, function(s) {
        return (i + (s - e) % i) % i + e
    })
}, ZZ = function n(e, t, r) {
    var i = t - e
      , s = i * 2;
    return Bi(e) ? F6(e, n(0, e.length - 1), t) : RA(r, function(o) {
        return o = (s + (o - e) % s) % s || 0,
        e + (o > i ? s - o : o)
    })
}, Pg = function(e) {
    for (var t = 0, r = "", i, s, o, a; ~(i = e.indexOf("random(", t)); )
        o = e.indexOf(")", i),
        a = e.charAt(i + 7) === "[",
        s = e.substr(i + 7, o - i - 7).match(a ? p6 : PS),
        r += e.substr(t, i - t) + U6(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5),
        t = o + 1;
    return r + e.substr(t, e.length - t)
}, P6 = function(e, t, r, i, s) {
    var o = t - e
      , a = i - r;
    return RA(s, function(l) {
        return r + ((l - e) / o * a || 0)
    })
}, JZ = function n(e, t, r, i) {
    var s = isNaN(e + t) ? 0 : function(h) {
        return (1 - h) * e + h * t
    }
    ;
    if (!s) {
        var o = $r(e), a = {}, l, c, A, u, f;
        if (r === !0 && (i = 1) && (r = null),
        o)
            e = {
                p: e
            },
            t = {
                p: t
            };
        else if (Bi(e) && !Bi(t)) {
            for (A = [],
            u = e.length,
            f = u - 2,
            c = 1; c < u; c++)
                A.push(n(e[c - 1], e[c]));
            u--,
            s = function(d) {
                d *= u;
                var m = Math.min(f, ~~d);
                return A[m](d - m)
            }
            ,
            r = t
        } else
            i || (e = Pu(Bi(e) ? [] : {}, e));
        if (!A) {
            for (l in t)
                vR.call(a, e, l, "get", t[l]);
            s = function(d) {
                return xR(d, a) || (o ? e.p : e)
            }
        }
    }
    return RA(r, s)
}, GP = function(e, t, r) {
    var i = e.labels, s = Ao, o, a, l;
    for (o in i)
        a = i[o] - t,
        a < 0 == !!r && a && s > (a = Math.abs(a)) && (l = o,
        s = a);
    return l
}, Is = function(e, t, r) {
    var i = e.vars, s = i[t], o = kn, a = e._ctx, l, c, A;
    if (s)
        return l = i[t + "Params"],
        c = i.callbackScope || e,
        r && AA.length && C_(),
        a && (kn = a),
        A = l ? s.apply(c, l) : s.call(c),
        kn = o,
        A
}, wm = function(e) {
    return vA(e),
    e.scrollTrigger && e.scrollTrigger.kill(!!Ei),
    e.progress() < 1 && Is(e, "onInterrupt"),
    e
}, Ph, L6 = [], D6 = function(e) {
    if (e)
        if (e = !e.name && e.default || e,
        fR() || e.headless) {
            var t = e.name
              , r = rr(e)
              , i = t && !r && e.init ? function() {
                this._props = []
            }
            : e
              , s = {
                init: Fg,
                render: xR,
                add: vR,
                kill: dJ,
                modifier: hJ,
                rawVars: 0
            }
              , o = {
                targetTest: 0,
                get: 0,
                getSetter: _R,
                aliases: {},
                register: 0
            };
            if (Sd(),
            e !== i) {
                if (Bs[t])
                    return;
                bo(i, bo(T_(e, s), o)),
                Pu(i.prototype, Pu(s, T_(e, o))),
                Bs[i.prop = t] = i,
                e.targetTest && (ww.push(i),
                pR[t] = 1),
                t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            v6(t, i),
            e.register && e.register(As, i, ss)
        } else
            L6.push(e)
}, vn = 255, _m = {
    aqua: [0, vn, vn],
    lime: [0, vn, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, vn],
    navy: [0, 0, 128],
    white: [vn, vn, vn],
    olive: [128, 128, 0],
    yellow: [vn, vn, 0],
    orange: [vn, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [vn, 0, 0],
    pink: [vn, 192, 203],
    cyan: [0, vn, vn],
    transparent: [vn, vn, vn, 0]
}, cE = function(e, t, r) {
    return e += e < 0 ? 1 : e > 1 ? -1 : 0,
    (e * 6 < 1 ? t + (r - t) * e * 6 : e < .5 ? r : e * 3 < 2 ? t + (r - t) * (2 / 3 - e) * 6 : t) * vn + .5 | 0
}, N6 = function(e, t, r) {
    var i = e ? ec(e) ? [e >> 16, e >> 8 & vn, e & vn] : 0 : _m.black, s, o, a, l, c, A, u, f, h, d;
    if (!i) {
        if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        _m[e])
            i = _m[e];
        else if (e.charAt(0) === "#") {
            if (e.length < 6 && (s = e.charAt(1),
            o = e.charAt(2),
            a = e.charAt(3),
            e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")),
            e.length === 9)
                return i = parseInt(e.substr(1, 6), 16),
                [i >> 16, i >> 8 & vn, i & vn, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16),
            i = [e >> 16, e >> 8 & vn, e & vn]
        } else if (e.substr(0, 3) === "hsl") {
            if (i = d = e.match(PS),
            !t)
                l = +i[0] % 360 / 360,
                c = +i[1] / 100,
                A = +i[2] / 100,
                o = A <= .5 ? A * (c + 1) : A + c - A * c,
                s = A * 2 - o,
                i.length > 3 && (i[3] *= 1),
                i[0] = cE(l + 1 / 3, s, o),
                i[1] = cE(l, s, o),
                i[2] = cE(l - 1 / 3, s, o);
            else if (~e.indexOf("="))
                return i = e.match(h6),
                r && i.length < 4 && (i[3] = 1),
                i
        } else
            i = e.match(PS) || _m.transparent;
        i = i.map(Number)
    }
    return t && !d && (s = i[0] / vn,
    o = i[1] / vn,
    a = i[2] / vn,
    u = Math.max(s, o, a),
    f = Math.min(s, o, a),
    A = (u + f) / 2,
    u === f ? l = c = 0 : (h = u - f,
    c = A > .5 ? h / (2 - u - f) : h / (u + f),
    l = u === s ? (o - a) / h + (o < a ? 6 : 0) : u === o ? (a - s) / h + 2 : (s - o) / h + 4,
    l *= 60),
    i[0] = ~~(l + .5),
    i[1] = ~~(c * 100 + .5),
    i[2] = ~~(A * 100 + .5)),
    r && i.length < 4 && (i[3] = 1),
    i
}, O6 = function(e) {
    var t = []
      , r = []
      , i = -1;
    return e.split(uA).forEach(function(s) {
        var o = s.match(Fh) || [];
        t.push.apply(t, o),
        r.push(i += o.length + 1)
    }),
    t.c = r,
    t
}, VP = function(e, t, r) {
    var i = "", s = (e + i).match(uA), o = t ? "hsla(" : "rgba(", a = 0, l, c, A, u;
    if (!s)
        return e;
    if (s = s.map(function(f) {
        return (f = N6(f, t, 1)) && o + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")"
    }),
    r && (A = O6(e),
    l = r.c,
    l.join(i) !== A.c.join(i)))
        for (c = e.replace(uA, "1").split(Fh),
        u = c.length - 1; a < u; a++)
            i += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (A.length ? A : s.length ? s : r).shift());
    if (!c)
        for (c = e.split(uA),
        u = c.length - 1; a < u; a++)
            i += c[a] + s[a];
    return i + c[u]
}, uA = function() {
    var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
    for (e in _m)
        n += "|" + e + "\\b";
    return new RegExp(n + ")","gi")
}(), qZ = /hsl[a]?\(/, k6 = function(e) {
    var t = e.join(" "), r;
    if (uA.lastIndex = 0,
    uA.test(t))
        return r = qZ.test(t),
        e[1] = VP(e[1], r),
        e[0] = VP(e[0], r, O6(e[1])),
        !0
}, Lg, Ms = function() {
    var n = Date.now, e = 500, t = 33, r = n(), i = r, s = 1e3 / 240, o = s, a = [], l, c, A, u, f, h, d = function m(g) {
        var p = n() - i, v = g === !0, w, _, x, b;
        if ((p > e || p < 0) && (r += p - t),
        i += p,
        x = i - r,
        w = x - o,
        (w > 0 || v) && (b = ++u.frame,
        f = x - u.time * 1e3,
        u.time = x = x / 1e3,
        o += w + (w >= s ? 4 : s - w),
        _ = 1),
        v || (l = c(m)),
        _)
            for (h = 0; h < a.length; h++)
                a[h](x, f, b, g)
    };
    return u = {
        time: 0,
        frame: 0,
        tick: function() {
            d(!0)
        },
        deltaRatio: function(g) {
            return f / (1e3 / (g || 60))
        },
        wake: function() {
            m6 && (!LS && fR() && (Ta = LS = window,
            hR = Ta.document || {},
            Qs.gsap = As,
            (Ta.gsapVersions || (Ta.gsapVersions = [])).push(As.version),
            g6(S_ || Ta.GreenSockGlobals || !Ta.gsap && Ta || {}),
            L6.forEach(D6)),
            A = typeof requestAnimationFrame < "u" && requestAnimationFrame,
            l && u.sleep(),
            c = A || function(g) {
                return setTimeout(g, o - u.time * 1e3 + 1 | 0)
            }
            ,
            Lg = 1,
            d(2))
        },
        sleep: function() {
            (A ? cancelAnimationFrame : clearTimeout)(l),
            Lg = 0,
            c = Fg
        },
        lagSmoothing: function(g, p) {
            e = g || 1 / 0,
            t = Math.min(p || 33, e)
        },
        fps: function(g) {
            s = 1e3 / (g || 240),
            o = u.time * 1e3 + s
        },
        add: function(g, p, v) {
            var w = p ? function(_, x, b, B) {
                g(_, x, b, B),
                u.remove(w)
            }
            : g;
            return u.remove(g),
            a[v ? "unshift" : "push"](w),
            Sd(),
            w
        },
        remove: function(g, p) {
            ~(p = a.indexOf(g)) && a.splice(p, 1) && h >= p && h--
        },
        _listeners: a
    },
    u
}(), Sd = function() {
    return !Lg && Ms.wake()
}, Gt = {}, eJ = /^[\d.\-M][\d.\-,\s]/, tJ = /["']/g, nJ = function(e) {
    for (var t = {}, r = e.substr(1, e.length - 3).split(":"), i = r[0], s = 1, o = r.length, a, l, c; s < o; s++)
        l = r[s],
        a = s !== o - 1 ? l.lastIndexOf(",") : l.length,
        c = l.substr(0, a),
        t[i] = isNaN(c) ? c.replace(tJ, "").trim() : +c,
        i = l.substr(a + 1).trim();
    return t
}, rJ = function(e) {
    var t = e.indexOf("(") + 1
      , r = e.indexOf(")")
      , i = e.indexOf("(", t);
    return e.substring(t, ~i && i < r ? e.indexOf(")", r + 1) : r)
}, iJ = function(e) {
    var t = (e + "").split("(")
      , r = Gt[t[0]];
    return r && t.length > 1 && r.config ? r.config.apply(null, ~e.indexOf("{") ? [nJ(t[1])] : rJ(e).split(",").map(x6)) : Gt._CE && eJ.test(e) ? Gt._CE("", e) : r
}, Q6 = function(e) {
    return function(t) {
        return 1 - e(1 - t)
    }
}, H6 = function n(e, t) {
    for (var r = e._first, i; r; )
        r instanceof Ni ? n(r, t) : r.vars.yoyoEase && (!r._yoyo || !r._repeat) && r._yoyo !== t && (r.timeline ? n(r.timeline, t) : (i = r._ease,
        r._ease = r._yEase,
        r._yEase = i,
        r._yoyo = t)),
        r = r._next
}, xu = function(e, t) {
    return e && (rr(e) ? e : Gt[e] || iJ(e)) || t
}, Yu = function(e, t, r, i) {
    r === void 0 && (r = function(l) {
        return 1 - t(1 - l)
    }
    ),
    i === void 0 && (i = function(l) {
        return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
    }
    );
    var s = {
        easeIn: t,
        easeOut: r,
        easeInOut: i
    }, o;
    return is(e, function(a) {
        Gt[a] = Qs[a] = s,
        Gt[o = a.toLowerCase()] = r;
        for (var l in s)
            Gt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Gt[a + "." + l] = s[l]
    }),
    s
}, z6 = function(e) {
    return function(t) {
        return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
    }
}, AE = function n(e, t, r) {
    var i = t >= 1 ? t : 1
      , s = (r || (e ? .3 : .45)) / (t < 1 ? t : 1)
      , o = s / FS * (Math.asin(1 / i) || 0)
      , a = function(A) {
        return A === 1 ? 1 : i * Math.pow(2, -10 * A) * UZ((A - o) * s) + 1
    }
      , l = e === "out" ? a : e === "in" ? function(c) {
        return 1 - a(1 - c)
    }
    : z6(a);
    return s = FS / s,
    l.config = function(c, A) {
        return n(e, c, A)
    }
    ,
    l
}, uE = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var r = function(o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0
    }
      , i = e === "out" ? r : e === "in" ? function(s) {
        return 1 - r(1 - s)
    }
    : z6(r);
    return i.config = function(s) {
        return n(e, s)
    }
    ,
    i
};
is("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, e) {
    var t = e < 5 ? e + 1 : e;
    Yu(n + ",Power" + (t - 1), e ? function(r) {
        return Math.pow(r, t)
    }
    : function(r) {
        return r
    }
    , function(r) {
        return 1 - Math.pow(1 - r, t)
    }, function(r) {
        return r < .5 ? Math.pow(r * 2, t) / 2 : 1 - Math.pow((1 - r) * 2, t) / 2
    })
});
Gt.Linear.easeNone = Gt.none = Gt.Linear.easeIn;
Yu("Elastic", AE("in"), AE("out"), AE());
(function(n, e) {
    var t = 1 / e
      , r = 2 * t
      , i = 2.5 * t
      , s = function(a) {
        return a < t ? n * a * a : a < r ? n * Math.pow(a - 1.5 / e, 2) + .75 : a < i ? n * (a -= 2.25 / e) * a + .9375 : n * Math.pow(a - 2.625 / e, 2) + .984375
    };
    Yu("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
}
)(7.5625, 2.75);
Yu("Expo", function(n) {
    return n ? Math.pow(2, 10 * (n - 1)) : 0
});
Yu("Circ", function(n) {
    return -(u6(1 - n * n) - 1)
});
Yu("Sine", function(n) {
    return n === 1 ? 1 : -RZ(n * TZ) + 1
});
Yu("Back", uE("in"), uE("out"), uE());
Gt.SteppedEase = Gt.steps = Qs.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var r = 1 / e
          , i = e + (t ? 0 : 1)
          , s = t ? 1 : 0
          , o = 1 - _n;
        return function(a) {
            return ((i * m0(0, o, a) | 0) + s) * r
        }
    }
};
Ed.ease = Gt["quad.out"];
is("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
    return mR += n + "," + n + "Params,"
});
var G6 = function(e, t) {
    this.id = IZ++,
    e._gsap = this,
    this.target = e,
    this.harness = t,
    this.get = t ? t.get : w6,
    this.set = t ? t.getSetter : _R
}
  , Dg = function() {
    function n(t) {
        this.vars = t,
        this._delay = +t.delay || 0,
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
        this._yoyo = !!t.yoyo || !!t.yoyoEase),
        this._ts = 1,
        Md(this, +t.duration, 1, 1),
        this.data = t.data,
        kn && (this._ctx = kn,
        kn.data.push(this)),
        Lg || Ms.wake()
    }
    var e = n.prototype;
    return e.delay = function(r) {
        return r || r === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + r - this._delay),
        this._delay = r,
        this) : this._delay
    }
    ,
    e.duration = function(r) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r) : this.totalDuration() && this._dur
    }
    ,
    e.totalDuration = function(r) {
        return arguments.length ? (this._dirty = 0,
        Md(this, this._repeat < 0 ? r : (r - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
    }
    ,
    e.totalTime = function(r, i) {
        if (Sd(),
        !arguments.length)
            return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
            for (a1(this, r),
            !s._dp || s.parent || B6(s, this); s && s.parent; )
                s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0),
                s = s.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && r < this._tDur || this._ts < 0 && r > 0 || !this._tDur && !r) && Pa(this._dp, this, this._start - this._delay)
        }
        return (this._tTime !== r || !this._dur && !i || this._initted && Math.abs(this._zTime) === _n || !r && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = r),
        _6(this, r, i)),
        this
    }
    ,
    e.time = function(r, i) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), r + HP(this)) % (this._dur + this._rDelay) || (r ? this._dur : 0), i) : this._time
    }
    ,
    e.totalProgress = function(r, i) {
        return arguments.length ? this.totalTime(this.totalDuration() * r, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.progress = function(r, i) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) + HP(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
    }
    ,
    e.iteration = function(r, i) {
        var s = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (r - 1) * s, i) : this._repeat ? Bd(this._tTime, s) + 1 : 1
    }
    ,
    e.timeScale = function(r, i) {
        if (!arguments.length)
            return this._rts === -_n ? 0 : this._rts;
        if (this._rts === r)
            return this;
        var s = this.parent && this._ts ? I_(this.parent._time, this) : this._tTime;
        return this._rts = +r || 0,
        this._ts = this._ps || r === -_n ? 0 : this._rts,
        this.totalTime(m0(-Math.abs(this._delay), this._tDur, s), i !== !1),
        o1(this),
        kZ(this)
    }
    ,
    e.paused = function(r) {
        return arguments.length ? (this._ps !== r && (this._ps = r,
        r ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
        this._ts = this._act = 0) : (Sd(),
        this._ts = this._rts,
        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _n && (this._tTime -= _n)))),
        this) : this._ps
    }
    ,
    e.startTime = function(r) {
        if (arguments.length) {
            this._start = r;
            var i = this.parent || this._dp;
            return i && (i._sort || !this.parent) && Pa(i, this, r - this._delay),
            this
        }
        return this._start
    }
    ,
    e.endTime = function(r) {
        return this._start + (rs(r) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
    }
    ,
    e.rawTime = function(r) {
        var i = this.parent || this._dp;
        return i ? r && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? I_(i.rawTime(r), this) : this._tTime : this._tTime
    }
    ,
    e.revert = function(r) {
        r === void 0 && (r = LZ);
        var i = Ei;
        return Ei = r,
        (this._initted || this._startAt) && (this.timeline && this.timeline.revert(r),
        this.totalTime(-.01, r.suppressEvents)),
        this.data !== "nested" && r.kill !== !1 && this.kill(),
        Ei = i,
        this
    }
    ,
    e.globalTime = function(r) {
        for (var i = this, s = arguments.length ? r : i.rawTime(); i; )
            s = i._start + s / (Math.abs(i._ts) || 1),
            i = i._dp;
        return !this.parent && this._sat ? this._sat.globalTime(r) : s
    }
    ,
    e.repeat = function(r) {
        return arguments.length ? (this._repeat = r === 1 / 0 ? -2 : r,
        zP(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
    }
    ,
    e.repeatDelay = function(r) {
        if (arguments.length) {
            var i = this._time;
            return this._rDelay = r,
            zP(this),
            i ? this.time(i) : this
        }
        return this._rDelay
    }
    ,
    e.yoyo = function(r) {
        return arguments.length ? (this._yoyo = r,
        this) : this._yoyo
    }
    ,
    e.seek = function(r, i) {
        return this.totalTime(eo(this, r), rs(i))
    }
    ,
    e.restart = function(r, i) {
        return this.play().totalTime(r ? -this._delay : 0, rs(i))
    }
    ,
    e.play = function(r, i) {
        return r != null && this.seek(r, i),
        this.reversed(!1).paused(!1)
    }
    ,
    e.reverse = function(r, i) {
        return r != null && this.seek(r || this.totalDuration(), i),
        this.reversed(!0).paused(!1)
    }
    ,
    e.pause = function(r, i) {
        return r != null && this.seek(r, i),
        this.paused(!0)
    }
    ,
    e.resume = function() {
        return this.paused(!1)
    }
    ,
    e.reversed = function(r) {
        return arguments.length ? (!!r !== this.reversed() && this.timeScale(-this._rts || (r ? -_n : 0)),
        this) : this._rts < 0
    }
    ,
    e.invalidate = function() {
        return this._initted = this._act = 0,
        this._zTime = -_n,
        this
    }
    ,
    e.isActive = function() {
        var r = this.parent || this._dp, i = this._start, s;
        return !!(!r || this._ts && this._initted && r.isActive() && (s = r.rawTime(!0)) >= i && s < this.endTime(!0) - _n)
    }
    ,
    e.eventCallback = function(r, i, s) {
        var o = this.vars;
        return arguments.length > 1 ? (i ? (o[r] = i,
        s && (o[r + "Params"] = s),
        r === "onUpdate" && (this._onUpdate = i)) : delete o[r],
        this) : o[r]
    }
    ,
    e.then = function(r) {
        var i = this;
        return new Promise(function(s) {
            var o = rr(r) ? r : b6
              , a = function() {
                var c = i.then;
                i.then = null,
                rr(o) && (o = o(i)) && (o.then || o === i) && (i.then = c),
                s(o),
                i.then = c
            };
            i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a
        }
        )
    }
    ,
    e.kill = function() {
        wm(this)
    }
    ,
    n
}();
bo(Dg.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_n,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Ni = function(n) {
    A6(e, n);
    function e(r, i) {
        var s;
        return r === void 0 && (r = {}),
        s = n.call(this, r) || this,
        s.labels = {},
        s.smoothChildTiming = !!r.smoothChildTiming,
        s.autoRemoveChildren = !!r.autoRemoveChildren,
        s._sort = rs(r.sortChildren),
        jn && Pa(r.parent || jn, Rl(s), i),
        r.reversed && s.reverse(),
        r.paused && s.paused(!0),
        r.scrollTrigger && M6(Rl(s), r.scrollTrigger),
        s
    }
    var t = e.prototype;
    return t.to = function(i, s, o) {
        return Zm(0, arguments, this),
        this
    }
    ,
    t.from = function(i, s, o) {
        return Zm(1, arguments, this),
        this
    }
    ,
    t.fromTo = function(i, s, o, a) {
        return Zm(2, arguments, this),
        this
    }
    ,
    t.set = function(i, s, o) {
        return s.duration = 0,
        s.parent = this,
        $m(s).repeatDelay || (s.repeat = 0),
        s.immediateRender = !!s.immediateRender,
        new xr(i,s,eo(this, o),1),
        this
    }
    ,
    t.call = function(i, s, o) {
        return Pa(this, xr.delayedCall(0, i, s), o)
    }
    ,
    t.staggerTo = function(i, s, o, a, l, c, A) {
        return o.duration = s,
        o.stagger = o.stagger || a,
        o.onComplete = c,
        o.onCompleteParams = A,
        o.parent = this,
        new xr(i,o,eo(this, l)),
        this
    }
    ,
    t.staggerFrom = function(i, s, o, a, l, c, A) {
        return o.runBackwards = 1,
        $m(o).immediateRender = rs(o.immediateRender),
        this.staggerTo(i, s, o, a, l, c, A)
    }
    ,
    t.staggerFromTo = function(i, s, o, a, l, c, A, u) {
        return a.startAt = o,
        $m(a).immediateRender = rs(a.immediateRender),
        this.staggerTo(i, s, a, l, c, A, u)
    }
    ,
    t.render = function(i, s, o) {
        var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, A = i <= 0 ? 0 : jr(i), u = this._zTime < 0 != i < 0 && (this._initted || !c), f, h, d, m, g, p, v, w, _, x, b, B;
        if (this !== jn && A > l && i >= 0 && (A = l),
        A !== this._tTime || o || u) {
            if (a !== this._time && c && (A += this._time - a,
            i += this._time - a),
            f = A,
            _ = this._start,
            w = this._ts,
            p = !w,
            u && (c || (a = this._zTime),
            (i || !s) && (this._zTime = i)),
            this._repeat) {
                if (b = this._yoyo,
                g = c + this._rDelay,
                this._repeat < -1 && i < 0)
                    return this.totalTime(g * 100 + i, s, o);
                if (f = jr(A % g),
                A === l ? (m = this._repeat,
                f = c) : (m = ~~(A / g),
                m && m === A / g && (f = c,
                m--),
                f > c && (f = c)),
                x = Bd(this._tTime, g),
                !a && this._tTime && x !== m && this._tTime - x * g - this._dur <= 0 && (x = m),
                b && m & 1 && (f = c - f,
                B = 1),
                m !== x && !this._lock) {
                    var S = b && x & 1
                      , I = S === (b && m & 1);
                    if (m < x && (S = !S),
                    a = S ? 0 : A % c ? c : A,
                    this._lock = 1,
                    this.render(a || (B ? 0 : jr(m * g)), s, !c)._lock = 0,
                    this._tTime = A,
                    !s && this.parent && Is(this, "onRepeat"),
                    this.vars.repeatRefresh && !B && (this.invalidate()._lock = 1),
                    a && a !== this._time || p !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                        return this;
                    if (c = this._dur,
                    l = this._tDur,
                    I && (this._lock = 2,
                    a = S ? c : -1e-4,
                    this.render(a, !0),
                    this.vars.repeatRefresh && !B && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !p)
                        return this;
                    H6(this, B)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (v = GZ(this, jr(a), jr(f)),
            v && (A -= f - (f = v._start))),
            this._tTime = A,
            this._time = f,
            this._act = !w,
            this._initted || (this._onUpdate = this.vars.onUpdate,
            this._initted = 1,
            this._zTime = i,
            a = 0),
            !a && f && !s && !m && (Is(this, "onStart"),
            this._tTime !== A))
                return this;
            if (f >= a && i >= 0)
                for (h = this._first; h; ) {
                    if (d = h._next,
                    (h._act || f >= h._start) && h._ts && v !== h) {
                        if (h.parent !== this)
                            return this.render(i, s, o);
                        if (h.render(h._ts > 0 ? (f - h._start) * h._ts : (h._dirty ? h.totalDuration() : h._tDur) + (f - h._start) * h._ts, s, o),
                        f !== this._time || !this._ts && !p) {
                            v = 0,
                            d && (A += this._zTime = -_n);
                            break
                        }
                    }
                    h = d
                }
            else {
                h = this._last;
                for (var M = i < 0 ? i : f; h; ) {
                    if (d = h._prev,
                    (h._act || M <= h._end) && h._ts && v !== h) {
                        if (h.parent !== this)
                            return this.render(i, s, o);
                        if (h.render(h._ts > 0 ? (M - h._start) * h._ts : (h._dirty ? h.totalDuration() : h._tDur) + (M - h._start) * h._ts, s, o || Ei && (h._initted || h._startAt)),
                        f !== this._time || !this._ts && !p) {
                            v = 0,
                            d && (A += this._zTime = M ? -_n : _n);
                            break
                        }
                    }
                    h = d
                }
            }
            if (v && !s && (this.pause(),
            v.render(f >= a ? 0 : -_n)._zTime = f >= a ? 1 : -1,
            this._ts))
                return this._start = _,
                o1(this),
                this.render(i, s, o);
            this._onUpdate && !s && Is(this, "onUpdate", !0),
            (A === l && this._tTime >= this.totalDuration() || !A && a) && (_ === this._start || Math.abs(w) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (A === l && this._ts > 0 || !A && this._ts < 0) && vA(this, 1),
            !s && !(i < 0 && !a) && (A || a || !l) && (Is(this, A === l && i >= 0 ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(A < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }
    ,
    t.add = function(i, s) {
        var o = this;
        if (ec(s) || (s = eo(this, s, i)),
        !(i instanceof Dg)) {
            if (Bi(i))
                return i.forEach(function(a) {
                    return o.add(a, s)
                }),
                this;
            if ($r(i))
                return this.addLabel(i, s);
            if (rr(i))
                i = xr.delayedCall(0, i);
            else
                return this
        }
        return this !== i ? Pa(this, i, s) : this
    }
    ,
    t.getChildren = function(i, s, o, a) {
        i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -Ao);
        for (var l = [], c = this._first; c; )
            c._start >= a && (c instanceof xr ? s && l.push(c) : (o && l.push(c),
            i && l.push.apply(l, c.getChildren(!0, s, o)))),
            c = c._next;
        return l
    }
    ,
    t.getById = function(i) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
            if (s[o].vars.id === i)
                return s[o]
    }
    ,
    t.remove = function(i) {
        return $r(i) ? this.removeLabel(i) : rr(i) ? this.killTweensOf(i) : (s1(this, i),
        i === this._recent && (this._recent = this._last),
        _u(this))
    }
    ,
    t.totalTime = function(i, s) {
        return arguments.length ? (this._forcing = 1,
        !this._dp && this._ts && (this._start = jr(Ms.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))),
        n.prototype.totalTime.call(this, i, s),
        this._forcing = 0,
        this) : this._tTime
    }
    ,
    t.addLabel = function(i, s) {
        return this.labels[i] = eo(this, s),
        this
    }
    ,
    t.removeLabel = function(i) {
        return delete this.labels[i],
        this
    }
    ,
    t.addPause = function(i, s, o) {
        var a = xr.delayedCall(0, s || Fg, o);
        return a.data = "isPause",
        this._hasPause = 1,
        Pa(this, a, eo(this, i))
    }
    ,
    t.removePause = function(i) {
        var s = this._first;
        for (i = eo(this, i); s; )
            s._start === i && s.data === "isPause" && vA(s),
            s = s._next
    }
    ,
    t.killTweensOf = function(i, s, o) {
        for (var a = this.getTweensOf(i, o), l = a.length; l--; )
            Kc !== a[l] && a[l].kill(i, s);
        return this
    }
    ,
    t.getTweensOf = function(i, s) {
        for (var o = [], a = uo(i), l = this._first, c = ec(s), A; l; )
            l instanceof xr ? DZ(l._targets, a) && (c ? (!Kc || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (A = l.getTweensOf(a, s)).length && o.push.apply(o, A),
            l = l._next;
        return o
    }
    ,
    t.tweenTo = function(i, s) {
        s = s || {};
        var o = this, a = eo(o, i), l = s, c = l.startAt, A = l.onStart, u = l.onStartParams, f = l.immediateRender, h, d = xr.to(o, bo({
            ease: s.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: a,
            overwrite: "auto",
            duration: s.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale()) || _n,
            onStart: function() {
                if (o.pause(),
                !h) {
                    var g = s.duration || Math.abs((a - (c && "time"in c ? c.time : o._time)) / o.timeScale());
                    d._dur !== g && Md(d, g, 0, 1).render(d._time, !0, !0),
                    h = 1
                }
                A && A.apply(d, u || [])
            }
        }, s));
        return f ? d.render(0) : d
    }
    ,
    t.tweenFromTo = function(i, s, o) {
        return this.tweenTo(s, bo({
            startAt: {
                time: eo(this, i)
            }
        }, o))
    }
    ,
    t.recent = function() {
        return this._recent
    }
    ,
    t.nextLabel = function(i) {
        return i === void 0 && (i = this._time),
        GP(this, eo(this, i))
    }
    ,
    t.previousLabel = function(i) {
        return i === void 0 && (i = this._time),
        GP(this, eo(this, i), 1)
    }
    ,
    t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + _n)
    }
    ,
    t.shiftChildren = function(i, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a; )
            a._start >= o && (a._start += i,
            a._end += i),
            a = a._next;
        if (s)
            for (c in l)
                l[c] >= o && (l[c] += i);
        return _u(this)
    }
    ,
    t.invalidate = function(i) {
        var s = this._first;
        for (this._lock = 0; s; )
            s.invalidate(i),
            s = s._next;
        return n.prototype.invalidate.call(this, i)
    }
    ,
    t.clear = function(i) {
        i === void 0 && (i = !0);
        for (var s = this._first, o; s; )
            o = s._next,
            this.remove(s),
            s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        _u(this)
    }
    ,
    t.totalDuration = function(i) {
        var s = 0, o = this, a = o._last, l = Ao, c, A, u;
        if (arguments.length)
            return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
        if (o._dirty) {
            for (u = o.parent; a; )
                c = a._prev,
                a._dirty && a.totalDuration(),
                A = a._start,
                A > l && o._sort && a._ts && !o._lock ? (o._lock = 1,
                Pa(o, a, A - a._delay, 1)._lock = 0) : l = A,
                A < 0 && a._ts && (s -= A,
                (!u && !o._dp || u && u.smoothChildTiming) && (o._start += A / o._ts,
                o._time -= A,
                o._tTime -= A),
                o.shiftChildren(-A, !1, -1 / 0),
                l = 0),
                a._end > s && a._ts && (s = a._end),
                a = c;
            Md(o, o === jn && o._time > s ? o._time : s, 1, 1),
            o._dirty = 0
        }
        return o._tDur
    }
    ,
    e.updateRoot = function(i) {
        if (jn._ts && (_6(jn, I_(i, jn)),
        y6 = Ms.frame),
        Ms.frame >= kP) {
            kP += Ds.autoSleep || 120;
            var s = jn._first;
            if ((!s || !s._ts) && Ds.autoSleep && Ms._listeners.length < 2) {
                for (; s && !s._ts; )
                    s = s._next;
                s || Ms.sleep()
            }
        }
    }
    ,
    e
}(Dg);
bo(Ni.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var sJ = function(e, t, r, i, s, o, a) {
    var l = new ss(this._pt,e,t,0,1,Y6,null,s), c = 0, A = 0, u, f, h, d, m, g, p, v;
    for (l.b = r,
    l.e = i,
    r += "",
    i += "",
    (p = ~i.indexOf("random(")) && (i = Pg(i)),
    o && (v = [r, i],
    o(v, e, t),
    r = v[0],
    i = v[1]),
    f = r.match(aE) || []; u = aE.exec(i); )
        d = u[0],
        m = i.substring(c, u.index),
        h ? h = (h + 1) % 5 : m.substr(-5) === "rgba(" && (h = 1),
        d !== f[A++] && (g = parseFloat(f[A - 1]) || 0,
        l._pt = {
            _next: l._pt,
            p: m || A === 1 ? m : ",",
            s: g,
            c: d.charAt(1) === "=" ? ed(g, d) - g : parseFloat(d) - g,
            m: h && h < 4 ? Math.round : 0
        },
        c = aE.lastIndex);
    return l.c = c < i.length ? i.substring(c, i.length) : "",
    l.fp = a,
    (d6.test(i) || p) && (l.e = 0),
    this._pt = l,
    l
}, vR = function(e, t, r, i, s, o, a, l, c, A) {
    rr(i) && (i = i(s || 0, e, o));
    var u = e[t], f = r !== "get" ? r : rr(u) ? c ? e[t.indexOf("set") || !rr(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : u, h = rr(u) ? c ? AJ : K6 : wR, d;
    if ($r(i) && (~i.indexOf("random(") && (i = Pg(i)),
    i.charAt(1) === "=" && (d = ed(f, i) + (wi(f) || 0),
    (d || d === 0) && (i = d))),
    !A || f !== i || zS)
        return !isNaN(f * i) && i !== "" ? (d = new ss(this._pt,e,t,+f || 0,i - (f || 0),typeof u == "boolean" ? fJ : X6,0,h),
        c && (d.fp = c),
        a && d.modifier(a, this, e),
        this._pt = d) : (!u && !(t in e) && dR(t, i),
        sJ.call(this, e, t, f, i, h, l || Ds.stringFilter, c))
}, oJ = function(e, t, r, i, s) {
    if (rr(e) && (e = Jm(e, s, t, r, i)),
    !el(e) || e.style && e.nodeType || Bi(e) || f6(e))
        return $r(e) ? Jm(e, s, t, r, i) : e;
    var o = {}, a;
    for (a in e)
        o[a] = Jm(e[a], s, t, r, i);
    return o
}, V6 = function(e, t, r, i, s, o) {
    var a, l, c, A;
    if (Bs[e] && (a = new Bs[e]).init(s, a.rawVars ? t[e] : oJ(t[e], i, s, o, r), r, i, o) !== !1 && (r._pt = l = new ss(r._pt,s,e,0,1,a.render,a,0,a.priority),
    r !== Ph))
        for (c = r._ptLookup[r._targets.indexOf(s)],
        A = a._props.length; A--; )
            c[a._props[A]] = l;
    return a
}, Kc, zS, yR = function n(e, t, r) {
    var i = e.vars, s = i.ease, o = i.startAt, a = i.immediateRender, l = i.lazy, c = i.onUpdate, A = i.runBackwards, u = i.yoyoEase, f = i.keyframes, h = i.autoRevert, d = e._dur, m = e._startAt, g = e._targets, p = e.parent, v = p && p.data === "nested" ? p.vars.targets : g, w = e._overwrite === "auto" && !AR, _ = e.timeline, x, b, B, S, I, M, L, D, T, y, E, R, F;
    if (_ && (!f || !s) && (s = "none"),
    e._ease = xu(s, Ed.ease),
    e._yEase = u ? Q6(xu(u === !0 ? s : u, Ed.ease)) : 0,
    u && e._yoyo && !e._repeat && (u = e._yEase,
    e._yEase = e._ease,
    e._ease = u),
    e._from = !_ && !!i.runBackwards,
    !_ || f && !i.stagger) {
        if (D = g[0] ? wu(g[0]).harness : 0,
        R = D && i[D.prop],
        x = T_(i, pR),
        m && (m._zTime < 0 && m.progress(1),
        t < 0 && A && a && !h ? m.render(-1, !0) : m.revert(A && d ? yw : PZ),
        m._lazy = 0),
        o) {
            if (vA(e._startAt = xr.set(g, bo({
                data: "isStart",
                overwrite: !1,
                parent: p,
                immediateRender: !0,
                lazy: !m && rs(l),
                startAt: null,
                delay: 0,
                onUpdate: c && function() {
                    return Is(e, "onUpdate")
                }
                ,
                stagger: 0
            }, o))),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Ei || !a && !h) && e._startAt.revert(yw),
            a && d && t <= 0 && r <= 0) {
                t && (e._zTime = t);
                return
            }
        } else if (A && d && !m) {
            if (t && (a = !1),
            B = bo({
                overwrite: !1,
                data: "isFromStart",
                lazy: a && !m && rs(l),
                immediateRender: a,
                stagger: 0,
                parent: p
            }, x),
            R && (B[D.prop] = R),
            vA(e._startAt = xr.set(g, B)),
            e._startAt._dp = 0,
            e._startAt._sat = e,
            t < 0 && (Ei ? e._startAt.revert(yw) : e._startAt.render(-1, !0)),
            e._zTime = t,
            !a)
                n(e._startAt, _n, _n);
            else if (!t)
                return
        }
        for (e._pt = e._ptCache = 0,
        l = d && rs(l) || l && !d,
        b = 0; b < g.length; b++) {
            if (I = g[b],
            L = I._gsap || gR(g)[b]._gsap,
            e._ptLookup[b] = y = {},
            DS[L.id] && AA.length && C_(),
            E = v === g ? b : v.indexOf(I),
            D && (T = new D).init(I, R || x, e, E, v) !== !1 && (e._pt = S = new ss(e._pt,I,T.name,0,1,T.render,T,0,T.priority),
            T._props.forEach(function(O) {
                y[O] = S
            }),
            T.priority && (M = 1)),
            !D || R)
                for (B in x)
                    Bs[B] && (T = V6(B, x, e, E, I, v)) ? T.priority && (M = 1) : y[B] = S = vR.call(e, I, B, "get", x[B], E, v, 0, i.stringFilter);
            e._op && e._op[b] && e.kill(I, e._op[b]),
            w && e._pt && (Kc = e,
            jn.killTweensOf(I, y, e.globalTime(t)),
            F = !e.parent,
            Kc = 0),
            e._pt && l && (DS[L.id] = 1)
        }
        M && $6(e),
        e._onInit && e._onInit(e)
    }
    e._onUpdate = c,
    e._initted = (!e._op || e._pt) && !F,
    f && t <= 0 && _.render(Ao, !0, !0)
}, aJ = function(e, t, r, i, s, o, a, l) {
    var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], A, u, f, h;
    if (!c)
        for (c = e._ptCache[t] = [],
        f = e._ptLookup,
        h = e._targets.length; h--; ) {
            if (A = f[h][t],
            A && A.d && A.d._pt)
                for (A = A.d._pt; A && A.p !== t && A.fp !== t; )
                    A = A._next;
            if (!A)
                return zS = 1,
                e.vars[t] = "+=0",
                yR(e, a),
                zS = 0,
                l ? Ug(t + " not eligible for reset") : 1;
            c.push(A)
        }
    for (h = c.length; h--; )
        u = c[h],
        A = u._pt || u,
        A.s = (i || i === 0) && !s ? i : A.s + (i || 0) + o * A.c,
        A.c = r - A.s,
        u.e && (u.e = hr(r) + wi(u.e)),
        u.b && (u.b = A.s + wi(u.b))
}, lJ = function(e, t) {
    var r = e[0] ? wu(e[0]).harness : 0, i = r && r.aliases, s, o, a, l;
    if (!i)
        return t;
    s = Pu({}, t);
    for (o in i)
        if (o in s)
            for (l = i[o].split(","),
            a = l.length; a--; )
                s[l[a]] = s[o];
    return s
}, cJ = function(e, t, r, i) {
    var s = t.ease || i || "power1.inOut", o, a;
    if (Bi(t))
        a = r[e] || (r[e] = []),
        t.forEach(function(l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: s
            })
        });
    else
        for (o in t)
            a = r[o] || (r[o] = []),
            o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: s
            })
}, Jm = function(e, t, r, i, s) {
    return rr(e) ? e.call(t, r, i, s) : $r(e) && ~e.indexOf("random(") ? Pg(e) : e
}, j6 = mR + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", W6 = {};
is(j6 + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
    return W6[n] = 1
});
var xr = function(n) {
    A6(e, n);
    function e(r, i, s, o) {
        var a;
        typeof i == "number" && (s.duration = i,
        i = s,
        s = null),
        a = n.call(this, o ? i : $m(i)) || this;
        var l = a.vars, c = l.duration, A = l.delay, u = l.immediateRender, f = l.stagger, h = l.overwrite, d = l.keyframes, m = l.defaults, g = l.scrollTrigger, p = l.yoyoEase, v = i.parent || jn, w = (Bi(r) || f6(r) ? ec(r[0]) : "length"in i) ? [r] : uo(r), _, x, b, B, S, I, M, L;
        if (a._targets = w.length ? gR(w) : Ug("GSAP target " + r + " not found. https://gsap.com", !Ds.nullTargetWarn) || [],
        a._ptLookup = [],
        a._overwrite = h,
        d || f || uv(c) || uv(A)) {
            if (i = a.vars,
            _ = a.timeline = new Ni({
                data: "nested",
                defaults: m || {},
                targets: v && v.data === "nested" ? v.vars.targets : w
            }),
            _.kill(),
            _.parent = _._dp = Rl(a),
            _._start = 0,
            f || uv(c) || uv(A)) {
                if (B = w.length,
                M = f && I6(f),
                el(f))
                    for (S in f)
                        ~j6.indexOf(S) && (L || (L = {}),
                        L[S] = f[S]);
                for (x = 0; x < B; x++)
                    b = T_(i, W6),
                    b.stagger = 0,
                    p && (b.yoyoEase = p),
                    L && Pu(b, L),
                    I = w[x],
                    b.duration = +Jm(c, Rl(a), x, I, w),
                    b.delay = (+Jm(A, Rl(a), x, I, w) || 0) - a._delay,
                    !f && B === 1 && b.delay && (a._delay = A = b.delay,
                    a._start += A,
                    b.delay = 0),
                    _.to(I, b, M ? M(x, I, w) : 0),
                    _._ease = Gt.none;
                _.duration() ? c = A = 0 : a.timeline = 0
            } else if (d) {
                $m(bo(_.vars.defaults, {
                    ease: "none"
                })),
                _._ease = xu(d.ease || i.ease || "none");
                var D = 0, T, y, E;
                if (Bi(d))
                    d.forEach(function(R) {
                        return _.to(w, R, ">")
                    }),
                    _.duration();
                else {
                    b = {};
                    for (S in d)
                        S === "ease" || S === "easeEach" || cJ(S, d[S], b, d.easeEach);
                    for (S in b)
                        for (T = b[S].sort(function(R, F) {
                            return R.t - F.t
                        }),
                        D = 0,
                        x = 0; x < T.length; x++)
                            y = T[x],
                            E = {
                                ease: y.e,
                                duration: (y.t - (x ? T[x - 1].t : 0)) / 100 * c
                            },
                            E[S] = y.v,
                            _.to(w, E, D),
                            D += E.duration;
                    _.duration() < c && _.to({}, {
                        duration: c - _.duration()
                    })
                }
            }
            c || a.duration(c = _.duration())
        } else
            a.timeline = 0;
        return h === !0 && !AR && (Kc = Rl(a),
        jn.killTweensOf(w),
        Kc = 0),
        Pa(v, Rl(a), s),
        i.reversed && a.reverse(),
        i.paused && a.paused(!0),
        (u || !c && !d && a._start === jr(v._time) && rs(u) && QZ(Rl(a)) && v.data !== "nested") && (a._tTime = -_n,
        a.render(Math.max(0, -A) || 0)),
        g && M6(Rl(a), g),
        a
    }
    var t = e.prototype;
    return t.render = function(i, s, o) {
        var a = this._time, l = this._tDur, c = this._dur, A = i < 0, u = i > l - _n && !A ? l : i < _n ? 0 : i, f, h, d, m, g, p, v, w, _;
        if (!c)
            zZ(this, i, s, o);
        else if (u !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== A) {
            if (f = u,
            w = this.timeline,
            this._repeat) {
                if (m = c + this._rDelay,
                this._repeat < -1 && A)
                    return this.totalTime(m * 100 + i, s, o);
                if (f = jr(u % m),
                u === l ? (d = this._repeat,
                f = c) : (d = ~~(u / m),
                d && d === jr(u / m) && (f = c,
                d--),
                f > c && (f = c)),
                p = this._yoyo && d & 1,
                p && (_ = this._yEase,
                f = c - f),
                g = Bd(this._tTime, m),
                f === a && !o && this._initted && d === g)
                    return this._tTime = u,
                    this;
                d !== g && (w && this._yEase && H6(w, p),
                this.vars.repeatRefresh && !p && !this._lock && this._time !== m && this._initted && (this._lock = o = 1,
                this.render(jr(m * d), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (S6(this, A ? i : f, o, s, u))
                    return this._tTime = 0,
                    this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && d !== g))
                    return this;
                if (c !== this._dur)
                    return this.render(i, s, o)
            }
            if (this._tTime = u,
            this._time = f,
            !this._act && this._ts && (this._act = 1,
            this._lazy = 0),
            this.ratio = v = (_ || this._ease)(f / c),
            this._from && (this.ratio = v = 1 - v),
            f && !a && !s && !d && (Is(this, "onStart"),
            this._tTime !== u))
                return this;
            for (h = this._pt; h; )
                h.r(v, h.d),
                h = h._next;
            w && w.render(i < 0 ? i : w._dur * w._ease(f / this._dur), s, o) || this._startAt && (this._zTime = i),
            this._onUpdate && !s && (A && NS(this, i, s, o),
            Is(this, "onUpdate")),
            this._repeat && d !== g && this.vars.onRepeat && !s && this.parent && Is(this, "onRepeat"),
            (u === this._tDur || !u) && this._tTime === u && (A && !this._onUpdate && NS(this, i, !0, !0),
            (i || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && vA(this, 1),
            !s && !(A && !a) && (u || a || p) && (Is(this, u === l ? "onComplete" : "onReverseComplete", !0),
            this._prom && !(u < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }
    ,
    t.targets = function() {
        return this._targets
    }
    ,
    t.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0),
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
        this._ptLookup = [],
        this.timeline && this.timeline.invalidate(i),
        n.prototype.invalidate.call(this, i)
    }
    ,
    t.resetTo = function(i, s, o, a, l) {
        Lg || Ms.wake(),
        this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), A;
        return this._initted || yR(this, c),
        A = this._ease(c / this._dur),
        aJ(this, i, s, o, a, A, c, l) ? this.resetTo(i, s, o, a, 1) : (a1(this, 0),
        this.parent || E6(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
        this.render(0))
    }
    ,
    t.kill = function(i, s) {
        if (s === void 0 && (s = "all"),
        !i && (!s || s === "all"))
            return this._lazy = this._pt = 0,
            this.parent ? wm(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, s, Kc && Kc.vars.overwrite !== !0)._first || wm(this),
            this.parent && o !== this.timeline.totalDuration() && Md(this, this._dur * this.timeline._tDur / o, 0, 1),
            this
        }
        var a = this._targets, l = i ? uo(i) : a, c = this._ptLookup, A = this._pt, u, f, h, d, m, g, p;
        if ((!s || s === "all") && OZ(a, l))
            return s === "all" && (this._pt = 0),
            wm(this);
        for (u = this._op = this._op || [],
        s !== "all" && ($r(s) && (m = {},
        is(s, function(v) {
            return m[v] = 1
        }),
        s = m),
        s = lJ(a, s)),
        p = a.length; p--; )
            if (~l.indexOf(a[p])) {
                f = c[p],
                s === "all" ? (u[p] = s,
                d = f,
                h = {}) : (h = u[p] = u[p] || {},
                d = s);
                for (m in d)
                    g = f && f[m],
                    g && ((!("kill"in g.d) || g.d.kill(m) === !0) && s1(this, g, "_pt"),
                    delete f[m]),
                    h !== "all" && (h[m] = 1)
            }
        return this._initted && !this._pt && A && wm(this),
        this
    }
    ,
    e.to = function(i, s) {
        return new e(i,s,arguments[2])
    }
    ,
    e.from = function(i, s) {
        return Zm(1, arguments)
    }
    ,
    e.delayedCall = function(i, s, o, a) {
        return new e(s,0,{
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }
    ,
    e.fromTo = function(i, s, o) {
        return Zm(2, arguments)
    }
    ,
    e.set = function(i, s) {
        return s.duration = 0,
        s.repeatDelay || (s.repeat = 0),
        new e(i,s)
    }
    ,
    e.killTweensOf = function(i, s, o) {
        return jn.killTweensOf(i, s, o)
    }
    ,
    e
}(Dg);
bo(xr.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
is("staggerTo,staggerFrom,staggerFromTo", function(n) {
    xr[n] = function() {
        var e = new Ni
          , t = kS.call(arguments, 0);
        return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0),
        e[n].apply(e, t)
    }
});
var wR = function(e, t, r) {
    return e[t] = r
}
  , K6 = function(e, t, r) {
    return e[t](r)
}
  , AJ = function(e, t, r, i) {
    return e[t](i.fp, r)
}
  , uJ = function(e, t, r) {
    return e.setAttribute(t, r)
}
  , _R = function(e, t) {
    return rr(e[t]) ? K6 : uR(e[t]) && e.setAttribute ? uJ : wR
}
  , X6 = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
}
  , fJ = function(e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t)
}
  , Y6 = function(e, t) {
    var r = t._pt
      , i = "";
    if (!e && t.b)
        i = t.b;
    else if (e === 1 && t.e)
        i = t.e;
    else {
        for (; r; )
            i = r.p + (r.m ? r.m(r.s + r.c * e) : Math.round((r.s + r.c * e) * 1e4) / 1e4) + i,
            r = r._next;
        i += t.c
    }
    t.set(t.t, t.p, i, t)
}
  , xR = function(e, t) {
    for (var r = t._pt; r; )
        r.r(e, r.d),
        r = r._next
}
  , hJ = function(e, t, r, i) {
    for (var s = this._pt, o; s; )
        o = s._next,
        s.p === i && s.modifier(e, t, r),
        s = o
}
  , dJ = function(e) {
    for (var t = this._pt, r, i; t; )
        i = t._next,
        t.p === e && !t.op || t.op === e ? s1(this, t, "_pt") : t.dep || (r = 1),
        t = i;
    return !r
}
  , pJ = function(e, t, r, i) {
    i.mSet(e, t, i.m.call(i.tween, r, i.mt), i)
}
  , $6 = function(e) {
    for (var t = e._pt, r, i, s, o; t; ) {
        for (r = t._next,
        i = s; i && i.pr > t.pr; )
            i = i._next;
        (t._prev = i ? i._prev : o) ? t._prev._next = t : s = t,
        (t._next = i) ? i._prev = t : o = t,
        t = r
    }
    e._pt = s
}
  , ss = function() {
    function n(t, r, i, s, o, a, l, c, A) {
        this.t = r,
        this.s = s,
        this.c = o,
        this.p = i,
        this.r = a || X6,
        this.d = l || this,
        this.set = c || wR,
        this.pr = A || 0,
        this._next = t,
        t && (t._prev = this)
    }
    var e = n.prototype;
    return e.modifier = function(r, i, s) {
        this.mSet = this.mSet || this.set,
        this.set = pJ,
        this.m = r,
        this.mt = s,
        this.tween = i
    }
    ,
    n
}();
is(mR + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
    return pR[n] = 1
});
Qs.TweenMax = Qs.TweenLite = xr;
Qs.TimelineLite = Qs.TimelineMax = Ni;
jn = new Ni({
    sortChildren: !1,
    defaults: Ed,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
Ds.stringFilter = k6;
var bu = []
  , _w = {}
  , mJ = []
  , jP = 0
  , gJ = 0
  , fE = function(e) {
    return (_w[e] || mJ).map(function(t) {
        return t()
    })
}
  , GS = function() {
    var e = Date.now()
      , t = [];
    e - jP > 2 && (fE("matchMediaInit"),
    bu.forEach(function(r) {
        var i = r.queries, s = r.conditions, o, a, l, c;
        for (a in i)
            o = Ta.matchMedia(i[a]).matches,
            o && (l = 1),
            o !== s[a] && (s[a] = o,
            c = 1);
        c && (r.revert(),
        l && t.push(r))
    }),
    fE("matchMediaRevert"),
    t.forEach(function(r) {
        return r.onMatch(r, function(i) {
            return r.add(null, i)
        })
    }),
    jP = e,
    fE("matchMedia"))
}
  , Z6 = function() {
    function n(t, r) {
        this.selector = r && QS(r),
        this.data = [],
        this._r = [],
        this.isReverted = !1,
        this.id = gJ++,
        t && this.add(t)
    }
    var e = n.prototype;
    return e.add = function(r, i, s) {
        rr(r) && (s = i,
        i = r,
        r = rr);
        var o = this
          , a = function() {
            var c = kn, A = o.selector, u;
            return c && c !== o && c.data.push(o),
            s && (o.selector = QS(s)),
            kn = o,
            u = i.apply(o, arguments),
            rr(u) && o._r.push(u),
            kn = c,
            o.selector = A,
            o.isReverted = !1,
            u
        };
        return o.last = a,
        r === rr ? a(o, function(l) {
            return o.add(null, l)
        }) : r ? o[r] = a : a
    }
    ,
    e.ignore = function(r) {
        var i = kn;
        kn = null,
        r(this),
        kn = i
    }
    ,
    e.getTweens = function() {
        var r = [];
        return this.data.forEach(function(i) {
            return i instanceof n ? r.push.apply(r, i.getTweens()) : i instanceof xr && !(i.parent && i.parent.data === "nested") && r.push(i)
        }),
        r
    }
    ,
    e.clear = function() {
        this._r.length = this.data.length = 0
    }
    ,
    e.kill = function(r, i) {
        var s = this;
        if (r ? function() {
            for (var a = s.getTweens(), l = s.data.length, c; l--; )
                c = s.data[l],
                c.data === "isFlip" && (c.revert(),
                c.getChildren(!0, !0, !1).forEach(function(A) {
                    return a.splice(a.indexOf(A), 1)
                }));
            for (a.map(function(A) {
                return {
                    g: A._dur || A._delay || A._sat && !A._sat.vars.immediateRender ? A.globalTime(0) : -1 / 0,
                    t: A
                }
            }).sort(function(A, u) {
                return u.g - A.g || -1 / 0
            }).forEach(function(A) {
                return A.t.revert(r)
            }),
            l = s.data.length; l--; )
                c = s.data[l],
                c instanceof Ni ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(),
                c.kill()) : !(c instanceof xr) && c.revert && c.revert(r);
            s._r.forEach(function(A) {
                return A(r, s)
            }),
            s.isReverted = !0
        }() : this.data.forEach(function(a) {
            return a.kill && a.kill()
        }),
        this.clear(),
        i)
            for (var o = bu.length; o--; )
                bu[o].id === this.id && bu.splice(o, 1)
    }
    ,
    e.revert = function(r) {
        this.kill(r || {})
    }
    ,
    n
}()
  , vJ = function() {
    function n(t) {
        this.contexts = [],
        this.scope = t,
        kn && kn.data.push(this)
    }
    var e = n.prototype;
    return e.add = function(r, i, s) {
        el(r) || (r = {
            matches: r
        });
        var o = new Z6(0,s || this.scope), a = o.conditions = {}, l, c, A;
        kn && !o.selector && (o.selector = kn.selector),
        this.contexts.push(o),
        i = o.add("onMatch", i),
        o.queries = r;
        for (c in r)
            c === "all" ? A = 1 : (l = Ta.matchMedia(r[c]),
            l && (bu.indexOf(o) < 0 && bu.push(o),
            (a[c] = l.matches) && (A = 1),
            l.addListener ? l.addListener(GS) : l.addEventListener("change", GS)));
        return A && i(o, function(u) {
            return o.add(null, u)
        }),
        this
    }
    ,
    e.revert = function(r) {
        this.kill(r || {})
    }
    ,
    e.kill = function(r) {
        this.contexts.forEach(function(i) {
            return i.kill(r, !0)
        })
    }
    ,
    n
}()
  , R_ = {
    registerPlugin: function() {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
            t[r] = arguments[r];
        t.forEach(function(i) {
            return D6(i)
        })
    },
    timeline: function(e) {
        return new Ni(e)
    },
    getTweensOf: function(e, t) {
        return jn.getTweensOf(e, t)
    },
    getProperty: function(e, t, r, i) {
        $r(e) && (e = uo(e)[0]);
        var s = wu(e || {}).get
          , o = r ? b6 : x6;
        return r === "native" && (r = ""),
        e && (t ? o((Bs[t] && Bs[t].get || s)(e, t, r, i)) : function(a, l, c) {
            return o((Bs[a] && Bs[a].get || s)(e, a, l, c))
        }
        )
    },
    quickSetter: function(e, t, r) {
        if (e = uo(e),
        e.length > 1) {
            var i = e.map(function(A) {
                return As.quickSetter(A, t, r)
            })
              , s = i.length;
            return function(A) {
                for (var u = s; u--; )
                    i[u](A)
            }
        }
        e = e[0] || {};
        var o = Bs[t]
          , a = wu(e)
          , l = a.harness && (a.harness.aliases || {})[t] || t
          , c = o ? function(A) {
            var u = new o;
            Ph._pt = 0,
            u.init(e, r ? A + r : A, Ph, 0, [e]),
            u.render(1, u),
            Ph._pt && xR(1, Ph)
        }
        : a.set(e, l);
        return o ? c : function(A) {
            return c(e, l, r ? A + r : A, a, 1)
        }
    },
    quickTo: function(e, t, r) {
        var i, s = As.to(e, Pu((i = {},
        i[t] = "+=0.1",
        i.paused = !0,
        i), r || {})), o = function(l, c, A) {
            return s.resetTo(t, l, c, A)
        };
        return o.tween = s,
        o
    },
    isTweening: function(e) {
        return jn.getTweensOf(e, !0).length > 0
    },
    defaults: function(e) {
        return e && e.ease && (e.ease = xu(e.ease, Ed.ease)),
        QP(Ed, e || {})
    },
    config: function(e) {
        return QP(Ds, e || {})
    },
    registerEffect: function(e) {
        var t = e.name
          , r = e.effect
          , i = e.plugins
          , s = e.defaults
          , o = e.extendTimeline;
        (i || "").split(",").forEach(function(a) {
            return a && !Bs[a] && !Qs[a] && Ug(t + " effect requires " + a + " plugin.")
        }),
        lE[t] = function(a, l, c) {
            return r(uo(a), bo(l || {}, s), c)
        }
        ,
        o && (Ni.prototype[t] = function(a, l, c) {
            return this.add(lE[t](a, el(l) ? l : (c = l) && {}, this), c)
        }
        )
    },
    registerEase: function(e, t) {
        Gt[e] = xu(t)
    },
    parseEase: function(e, t) {
        return arguments.length ? xu(e, t) : Gt
    },
    getById: function(e) {
        return jn.getById(e)
    },
    exportRoot: function(e, t) {
        e === void 0 && (e = {});
        var r = new Ni(e), i, s;
        for (r.smoothChildTiming = rs(e.smoothChildTiming),
        jn.remove(r),
        r._dp = 0,
        r._time = r._tTime = jn._time,
        i = jn._first; i; )
            s = i._next,
            (t || !(!i._dur && i instanceof xr && i.vars.onComplete === i._targets[0])) && Pa(r, i, i._start - i._delay),
            i = s;
        return Pa(jn, r, 0),
        r
    },
    context: function(e, t) {
        return e ? new Z6(e,t) : kn
    },
    matchMedia: function(e) {
        return new vJ(e)
    },
    matchMediaRefresh: function() {
        return bu.forEach(function(e) {
            var t = e.conditions, r, i;
            for (i in t)
                t[i] && (t[i] = !1,
                r = 1);
            r && e.revert()
        }) || GS()
    },
    addEventListener: function(e, t) {
        var r = _w[e] || (_w[e] = []);
        ~r.indexOf(t) || r.push(t)
    },
    removeEventListener: function(e, t) {
        var r = _w[e]
          , i = r && r.indexOf(t);
        i >= 0 && r.splice(i, 1)
    },
    utils: {
        wrap: $Z,
        wrapYoyo: ZZ,
        distribute: I6,
        random: U6,
        snap: R6,
        normalize: YZ,
        getUnit: wi,
        clamp: jZ,
        splitColor: N6,
        toArray: uo,
        selector: QS,
        mapRange: P6,
        pipe: KZ,
        unitize: XZ,
        interpolate: JZ,
        shuffle: T6
    },
    install: g6,
    effects: lE,
    ticker: Ms,
    updateRoot: Ni.updateRoot,
    plugins: Bs,
    globalTimeline: jn,
    core: {
        PropTween: ss,
        globals: v6,
        Tween: xr,
        Timeline: Ni,
        Animation: Dg,
        getCache: wu,
        _removeLinkedListItem: s1,
        reverting: function() {
            return Ei
        },
        context: function(e) {
            return e && kn && (kn.data.push(e),
            e._ctx = kn),
            kn
        },
        suppressOverwrites: function(e) {
            return AR = e
        }
    }
};
is("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
    return R_[n] = xr[n]
});
Ms.add(Ni.updateRoot);
Ph = R_.to({}, {
    duration: 0
});
var yJ = function(e, t) {
    for (var r = e._pt; r && r.p !== t && r.op !== t && r.fp !== t; )
        r = r._next;
    return r
}
  , wJ = function(e, t) {
    var r = e._targets, i, s, o;
    for (i in t)
        for (s = r.length; s--; )
            o = e._ptLookup[s][i],
            o && (o = o.d) && (o._pt && (o = yJ(o, i)),
            o && o.modifier && o.modifier(t[i], e, r[s], i))
}
  , hE = function(e, t) {
    return {
        name: e,
        rawVars: 1,
        init: function(i, s, o) {
            o._onInit = function(a) {
                var l, c;
                if ($r(s) && (l = {},
                is(s, function(A) {
                    return l[A] = 1
                }),
                s = l),
                t) {
                    l = {};
                    for (c in s)
                        l[c] = t(s[c]);
                    s = l
                }
                wJ(a, s)
            }
        }
    }
}
  , As = R_.registerPlugin({
    name: "attr",
    init: function(e, t, r, i, s) {
        var o, a, l;
        this.tween = r;
        for (o in t)
            l = e.getAttribute(o) || "",
            a = this.add(e, "setAttribute", (l || 0) + "", t[o], i, s, 0, 0, o),
            a.op = o,
            a.b = l,
            this._props.push(o)
    },
    render: function(e, t) {
        for (var r = t._pt; r; )
            Ei ? r.set(r.t, r.p, r.b, r) : r.r(e, r.d),
            r = r._next
    }
}, {
    name: "endArray",
    init: function(e, t) {
        for (var r = t.length; r--; )
            this.add(e, r, e[r] || 0, t[r], 0, 0, 0, 0, 0, 1)
    }
}, hE("roundProps", HS), hE("modifiers"), hE("snap", R6)) || R_;
xr.version = Ni.version = As.version = "3.12.5";
m6 = 1;
fR() && Sd();
Gt.Power0;
Gt.Power1;
Gt.Power2;
Gt.Power3;
Gt.Power4;
Gt.Linear;
Gt.Quad;
Gt.Cubic;
Gt.Quart;
Gt.Quint;
Gt.Strong;
Gt.Elastic;
Gt.Back;
Gt.SteppedEase;
Gt.Bounce;
Gt.Sine;
Gt.Expo;
Gt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var WP, Xc, td, bR, hu, KP, ER, _J = function() {
    return typeof window < "u"
}, tc = {}, nu = 180 / Math.PI, nd = Math.PI / 180, lf = Math.atan2, XP = 1e8, BR = /([A-Z])/g, xJ = /(left|right|width|margin|padding|x)/i, bJ = /[\s,\(]\S/, Qa = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
}, VS = function(e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, EJ = function(e, t) {
    return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
}, BJ = function(e, t) {
    return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
}, MJ = function(e, t) {
    var r = t.s + t.c * e;
    t.set(t.t, t.p, ~~(r + (r < 0 ? -.5 : .5)) + t.u, t)
}, J6 = function(e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t)
}, q6 = function(e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
}, SJ = function(e, t, r) {
    return e.style[t] = r
}, CJ = function(e, t, r) {
    return e.style.setProperty(t, r)
}, TJ = function(e, t, r) {
    return e._gsap[t] = r
}, IJ = function(e, t, r) {
    return e._gsap.scaleX = e._gsap.scaleY = r
}, RJ = function(e, t, r, i, s) {
    var o = e._gsap;
    o.scaleX = o.scaleY = r,
    o.renderTransform(s, o)
}, UJ = function(e, t, r, i, s) {
    var o = e._gsap;
    o[t] = r,
    o.renderTransform(s, o)
}, Wn = "transform", os = Wn + "Origin", FJ = function n(e, t) {
    var r = this
      , i = this.target
      , s = i.style
      , o = i._gsap;
    if (e in tc && s) {
        if (this.tfm = this.tfm || {},
        e !== "transform")
            e = Qa[e] || e,
            ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return r.tfm[a] = Ll(i, a)
            }) : this.tfm[e] = o.x ? o[e] : Ll(i, e),
            e === os && (this.tfm.zOrigin = o.zOrigin);
        else
            return Qa.transform.split(",").forEach(function(a) {
                return n.call(r, a, t)
            });
        if (this.props.indexOf(Wn) >= 0)
            return;
        o.svg && (this.svgo = i.getAttribute("data-svg-origin"),
        this.props.push(os, t, "")),
        e = Wn
    }
    (s || t) && this.props.push(e, t, s[e])
}, ez = function(e) {
    e.translate && (e.removeProperty("translate"),
    e.removeProperty("scale"),
    e.removeProperty("rotate"))
}, PJ = function() {
    var e = this.props, t = this.target, r = t.style, i = t._gsap, s, o;
    for (s = 0; s < e.length; s += 3)
        e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? r[e[s]] = e[s + 2] : r.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(BR, "-$1").toLowerCase());
    if (this.tfm) {
        for (o in this.tfm)
            i[o] = this.tfm[o];
        i.svg && (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        s = ER(),
        (!s || !s.isStart) && !r[Wn] && (ez(r),
        i.zOrigin && r[os] && (r[os] += " " + i.zOrigin + "px",
        i.zOrigin = 0,
        i.renderTransform()),
        i.uncache = 1)
    }
}, tz = function(e, t) {
    var r = {
        target: e,
        props: [],
        revert: PJ,
        save: FJ
    };
    return e._gsap || As.core.getCache(e),
    t && t.split(",").forEach(function(i) {
        return r.save(i)
    }),
    r
}, nz, jS = function(e, t) {
    var r = Xc.createElementNS ? Xc.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Xc.createElement(e);
    return r && r.style ? r : Xc.createElement(e)
}, Xa = function n(e, t, r) {
    var i = getComputedStyle(e);
    return i[t] || i.getPropertyValue(t.replace(BR, "-$1").toLowerCase()) || i.getPropertyValue(t) || !r && n(e, Cd(t) || t, 1) || ""
}, YP = "O,Moz,ms,Ms,Webkit".split(","), Cd = function(e, t, r) {
    var i = t || hu
      , s = i.style
      , o = 5;
    if (e in s && !r)
        return e;
    for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(YP[o] + e in s); )
        ;
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? YP[o] : "") + e
}, WS = function() {
    _J() && window.document && (WP = window,
    Xc = WP.document,
    td = Xc.documentElement,
    hu = jS("div") || {
        style: {}
    },
    jS("div"),
    Wn = Cd(Wn),
    os = Wn + "Origin",
    hu.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
    nz = !!Cd("perspective"),
    ER = As.core.reverting,
    bR = 1)
}, dE = function n(e) {
    var t = jS("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, i = this.nextSibling, s = this.style.cssText, o;
    if (td.appendChild(t),
    t.appendChild(this),
    this.style.display = "block",
    e)
        try {
            o = this.getBBox(),
            this._gsapBBox = this.getBBox,
            this.getBBox = n
        } catch {}
    else
        this._gsapBBox && (o = this._gsapBBox());
    return r && (i ? r.insertBefore(this, i) : r.appendChild(this)),
    td.removeChild(t),
    this.style.cssText = s,
    o
}, $P = function(e, t) {
    for (var r = t.length; r--; )
        if (e.hasAttribute(t[r]))
            return e.getAttribute(t[r])
}, rz = function(e) {
    var t;
    try {
        t = e.getBBox()
    } catch {
        t = dE.call(e, !0)
    }
    return t && (t.width || t.height) || e.getBBox === dE || (t = dE.call(e, !0)),
    t && !t.width && !t.x && !t.y ? {
        x: +$P(e, ["x", "cx", "x1"]) || 0,
        y: +$P(e, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
    } : t
}, iz = function(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && rz(e))
}, Lu = function(e, t) {
    if (t) {
        var r = e.style, i;
        t in tc && t !== os && (t = Wn),
        r.removeProperty ? (i = t.substr(0, 2),
        (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
        r.removeProperty(i === "--" ? t : t.replace(BR, "-$1").toLowerCase())) : r.removeAttribute(t)
    }
}, Yc = function(e, t, r, i, s, o) {
    var a = new ss(e._pt,t,r,0,1,o ? q6 : J6);
    return e._pt = a,
    a.b = i,
    a.e = s,
    e._props.push(r),
    a
}, ZP = {
    deg: 1,
    rad: 1,
    turn: 1
}, LJ = {
    grid: 1,
    flex: 1
}, yA = function n(e, t, r, i) {
    var s = parseFloat(r) || 0, o = (r + "").trim().substr((s + "").length) || "px", a = hu.style, l = xJ.test(t), c = e.tagName.toLowerCase() === "svg", A = (c ? "client" : "offset") + (l ? "Width" : "Height"), u = 100, f = i === "px", h = i === "%", d, m, g, p;
    if (i === o || !s || ZP[i] || ZP[o])
        return s;
    if (o !== "px" && !f && (s = n(e, t, r, "px")),
    p = e.getCTM && iz(e),
    (h || o === "%") && (tc[t] || ~t.indexOf("adius")))
        return d = p ? e.getBBox()[l ? "width" : "height"] : e[A],
        hr(h ? s / d * u : s / 100 * d);
    if (a[l ? "width" : "height"] = u + (f ? o : i),
    m = ~t.indexOf("adius") || i === "em" && e.appendChild && !c ? e : e.parentNode,
    p && (m = (e.ownerSVGElement || {}).parentNode),
    (!m || m === Xc || !m.appendChild) && (m = Xc.body),
    g = m._gsap,
    g && h && g.width && l && g.time === Ms.time && !g.uncache)
        return hr(s / g.width * u);
    if (h && (t === "height" || t === "width")) {
        var v = e.style[t];
        e.style[t] = u + i,
        d = e[A],
        v ? e.style[t] = v : Lu(e, t)
    } else
        (h || o === "%") && !LJ[Xa(m, "display")] && (a.position = Xa(e, "position")),
        m === e && (a.position = "static"),
        m.appendChild(hu),
        d = hu[A],
        m.removeChild(hu),
        a.position = "absolute";
    return l && h && (g = wu(m),
    g.time = Ms.time,
    g.width = m[A]),
    hr(f ? d * s / u : d && s ? u / d * s : 0)
}, Ll = function(e, t, r, i) {
    var s;
    return bR || WS(),
    t in Qa && t !== "transform" && (t = Qa[t],
    ~t.indexOf(",") && (t = t.split(",")[0])),
    tc[t] && t !== "transform" ? (s = Og(e, i),
    s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : F_(Xa(e, os)) + " " + s.zOrigin + "px") : (s = e.style[t],
    (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = U_[t] && U_[t](e, t, r) || Xa(e, t) || w6(e, t) || (t === "opacity" ? 1 : 0))),
    r && !~(s + "").trim().indexOf(" ") ? yA(e, t, s, r) + r : s
}, DJ = function(e, t, r, i) {
    if (!r || r === "none") {
        var s = Cd(t, e, 1)
          , o = s && Xa(e, s, 1);
        o && o !== r ? (t = s,
        r = o) : t === "borderColor" && (r = Xa(e, "borderTopColor"))
    }
    var a = new ss(this._pt,e.style,t,0,1,Y6), l = 0, c = 0, A, u, f, h, d, m, g, p, v, w, _, x;
    if (a.b = r,
    a.e = i,
    r += "",
    i += "",
    i === "auto" && (m = e.style[t],
    e.style[t] = i,
    i = Xa(e, t) || i,
    m ? e.style[t] = m : Lu(e, t)),
    A = [r, i],
    k6(A),
    r = A[0],
    i = A[1],
    f = r.match(Fh) || [],
    x = i.match(Fh) || [],
    x.length) {
        for (; u = Fh.exec(i); )
            g = u[0],
            v = i.substring(l, u.index),
            d ? d = (d + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (d = 1),
            g !== (m = f[c++] || "") && (h = parseFloat(m) || 0,
            _ = m.substr((h + "").length),
            g.charAt(1) === "=" && (g = ed(h, g) + _),
            p = parseFloat(g),
            w = g.substr((p + "").length),
            l = Fh.lastIndex - w.length,
            w || (w = w || Ds.units[t] || _,
            l === i.length && (i += w,
            a.e += w)),
            _ !== w && (h = yA(e, t, m, w) || 0),
            a._pt = {
                _next: a._pt,
                p: v || c === 1 ? v : ",",
                s: h,
                c: p - h,
                m: d && d < 4 || t === "zIndex" ? Math.round : 0
            });
        a.c = l < i.length ? i.substring(l, i.length) : ""
    } else
        a.r = t === "display" && i === "none" ? q6 : J6;
    return d6.test(i) && (a.e = 0),
    this._pt = a,
    a
}, JP = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
}, NJ = function(e) {
    var t = e.split(" ")
      , r = t[0]
      , i = t[1] || "50%";
    return (r === "top" || r === "bottom" || i === "left" || i === "right") && (e = r,
    r = i,
    i = e),
    t[0] = JP[r] || r,
    t[1] = JP[i] || i,
    t.join(" ")
}, OJ = function(e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
        var r = t.t, i = r.style, s = t.u, o = r._gsap, a, l, c;
        if (s === "all" || s === !0)
            i.cssText = "",
            l = 1;
        else
            for (s = s.split(","),
            c = s.length; --c > -1; )
                a = s[c],
                tc[a] && (l = 1,
                a = a === "transformOrigin" ? os : Wn),
                Lu(r, a);
        l && (Lu(r, Wn),
        o && (o.svg && r.removeAttribute("transform"),
        Og(r, 1),
        o.uncache = 1,
        ez(i)))
    }
}, U_ = {
    clearProps: function(e, t, r, i, s) {
        if (s.data !== "isFromStart") {
            var o = e._pt = new ss(e._pt,t,r,0,0,OJ);
            return o.u = i,
            o.pr = -10,
            o.tween = s,
            e._props.push(r),
            1
        }
    }
}, Ng = [1, 0, 0, 1, 0, 0], sz = {}, oz = function(e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
}, qP = function(e) {
    var t = Xa(e, Wn);
    return oz(t) ? Ng : t.substr(7).match(h6).map(hr)
}, MR = function(e, t) {
    var r = e._gsap || wu(e), i = e.style, s = qP(e), o, a, l, c;
    return r.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix,
    s = [l.a, l.b, l.c, l.d, l.e, l.f],
    s.join(",") === "1,0,0,1,0,0" ? Ng : s) : (s === Ng && !e.offsetParent && e !== td && !r.svg && (l = i.display,
    i.display = "block",
    o = e.parentNode,
    (!o || !e.offsetParent) && (c = 1,
    a = e.nextElementSibling,
    td.appendChild(e)),
    s = qP(e),
    l ? i.display = l : Lu(e, "display"),
    c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : td.removeChild(e))),
    t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
}, KS = function(e, t, r, i, s, o) {
    var a = e._gsap, l = s || MR(e, !0), c = a.xOrigin || 0, A = a.yOrigin || 0, u = a.xOffset || 0, f = a.yOffset || 0, h = l[0], d = l[1], m = l[2], g = l[3], p = l[4], v = l[5], w = t.split(" "), _ = parseFloat(w[0]) || 0, x = parseFloat(w[1]) || 0, b, B, S, I;
    r ? l !== Ng && (B = h * g - d * m) && (S = _ * (g / B) + x * (-m / B) + (m * v - g * p) / B,
    I = _ * (-d / B) + x * (h / B) - (h * v - d * p) / B,
    _ = S,
    x = I) : (b = rz(e),
    _ = b.x + (~w[0].indexOf("%") ? _ / 100 * b.width : _),
    x = b.y + (~(w[1] || w[0]).indexOf("%") ? x / 100 * b.height : x)),
    i || i !== !1 && a.smooth ? (p = _ - c,
    v = x - A,
    a.xOffset = u + (p * h + v * m) - p,
    a.yOffset = f + (p * d + v * g) - v) : a.xOffset = a.yOffset = 0,
    a.xOrigin = _,
    a.yOrigin = x,
    a.smooth = !!i,
    a.origin = t,
    a.originIsAbsolute = !!r,
    e.style[os] = "0px 0px",
    o && (Yc(o, a, "xOrigin", c, _),
    Yc(o, a, "yOrigin", A, x),
    Yc(o, a, "xOffset", u, a.xOffset),
    Yc(o, a, "yOffset", f, a.yOffset)),
    e.setAttribute("data-svg-origin", _ + " " + x)
}, Og = function(e, t) {
    var r = e._gsap || new G6(e);
    if ("x"in r && !t && !r.uncache)
        return r;
    var i = e.style, s = r.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), c = Xa(e, os) || "0", A, u, f, h, d, m, g, p, v, w, _, x, b, B, S, I, M, L, D, T, y, E, R, F, O, z, j, Q, C, W, ee, P;
    return A = u = f = m = g = p = v = w = _ = 0,
    h = d = 1,
    r.svg = !!(e.getCTM && iz(e)),
    l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[Wn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[Wn] !== "none" ? l[Wn] : "")),
    i.scale = i.rotate = i.translate = "none"),
    B = MR(e, r.svg),
    r.svg && (r.uncache ? (O = e.getBBox(),
    c = r.xOrigin - O.x + "px " + (r.yOrigin - O.y) + "px",
    F = "") : F = !t && e.getAttribute("data-svg-origin"),
    KS(e, F || c, !!F || r.originIsAbsolute, r.smooth !== !1, B)),
    x = r.xOrigin || 0,
    b = r.yOrigin || 0,
    B !== Ng && (L = B[0],
    D = B[1],
    T = B[2],
    y = B[3],
    A = E = B[4],
    u = R = B[5],
    B.length === 6 ? (h = Math.sqrt(L * L + D * D),
    d = Math.sqrt(y * y + T * T),
    m = L || D ? lf(D, L) * nu : 0,
    v = T || y ? lf(T, y) * nu + m : 0,
    v && (d *= Math.abs(Math.cos(v * nd))),
    r.svg && (A -= x - (x * L + b * T),
    u -= b - (x * D + b * y))) : (P = B[6],
    W = B[7],
    j = B[8],
    Q = B[9],
    C = B[10],
    ee = B[11],
    A = B[12],
    u = B[13],
    f = B[14],
    S = lf(P, C),
    g = S * nu,
    S && (I = Math.cos(-S),
    M = Math.sin(-S),
    F = E * I + j * M,
    O = R * I + Q * M,
    z = P * I + C * M,
    j = E * -M + j * I,
    Q = R * -M + Q * I,
    C = P * -M + C * I,
    ee = W * -M + ee * I,
    E = F,
    R = O,
    P = z),
    S = lf(-T, C),
    p = S * nu,
    S && (I = Math.cos(-S),
    M = Math.sin(-S),
    F = L * I - j * M,
    O = D * I - Q * M,
    z = T * I - C * M,
    ee = y * M + ee * I,
    L = F,
    D = O,
    T = z),
    S = lf(D, L),
    m = S * nu,
    S && (I = Math.cos(S),
    M = Math.sin(S),
    F = L * I + D * M,
    O = E * I + R * M,
    D = D * I - L * M,
    R = R * I - E * M,
    L = F,
    E = O),
    g && Math.abs(g) + Math.abs(m) > 359.9 && (g = m = 0,
    p = 180 - p),
    h = hr(Math.sqrt(L * L + D * D + T * T)),
    d = hr(Math.sqrt(R * R + P * P)),
    S = lf(E, R),
    v = Math.abs(S) > 2e-4 ? S * nu : 0,
    _ = ee ? 1 / (ee < 0 ? -ee : ee) : 0),
    r.svg && (F = e.getAttribute("transform"),
    r.forceCSS = e.setAttribute("transform", "") || !oz(Xa(e, Wn)),
    F && e.setAttribute("transform", F))),
    Math.abs(v) > 90 && Math.abs(v) < 270 && (s ? (h *= -1,
    v += m <= 0 ? 180 : -180,
    m += m <= 0 ? 180 : -180) : (d *= -1,
    v += v <= 0 ? 180 : -180)),
    t = t || r.uncache,
    r.x = A - ((r.xPercent = A && (!t && r.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-A) ? -50 : 0))) ? e.offsetWidth * r.xPercent / 100 : 0) + o,
    r.y = u - ((r.yPercent = u && (!t && r.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * r.yPercent / 100 : 0) + o,
    r.z = f + o,
    r.scaleX = hr(h),
    r.scaleY = hr(d),
    r.rotation = hr(m) + a,
    r.rotationX = hr(g) + a,
    r.rotationY = hr(p) + a,
    r.skewX = v + a,
    r.skewY = w + a,
    r.transformPerspective = _ + o,
    (r.zOrigin = parseFloat(c.split(" ")[2]) || !t && r.zOrigin || 0) && (i[os] = F_(c)),
    r.xOffset = r.yOffset = 0,
    r.force3D = Ds.force3D,
    r.renderTransform = r.svg ? QJ : nz ? az : kJ,
    r.uncache = 0,
    r
}, F_ = function(e) {
    return (e = e.split(" "))[0] + " " + e[1]
}, pE = function(e, t, r) {
    var i = wi(t);
    return hr(parseFloat(t) + parseFloat(yA(e, "x", r + "px", i))) + i
}, kJ = function(e, t) {
    t.z = "0px",
    t.rotationY = t.rotationX = "0deg",
    t.force3D = 0,
    az(e, t)
}, DA = "0deg", Cp = "0px", NA = ") ", az = function(e, t) {
    var r = t || this
      , i = r.xPercent
      , s = r.yPercent
      , o = r.x
      , a = r.y
      , l = r.z
      , c = r.rotation
      , A = r.rotationY
      , u = r.rotationX
      , f = r.skewX
      , h = r.skewY
      , d = r.scaleX
      , m = r.scaleY
      , g = r.transformPerspective
      , p = r.force3D
      , v = r.target
      , w = r.zOrigin
      , _ = ""
      , x = p === "auto" && e && e !== 1 || p === !0;
    if (w && (u !== DA || A !== DA)) {
        var b = parseFloat(A) * nd, B = Math.sin(b), S = Math.cos(b), I;
        b = parseFloat(u) * nd,
        I = Math.cos(b),
        o = pE(v, o, B * I * -w),
        a = pE(v, a, -Math.sin(b) * -w),
        l = pE(v, l, S * I * -w + w)
    }
    g !== Cp && (_ += "perspective(" + g + NA),
    (i || s) && (_ += "translate(" + i + "%, " + s + "%) "),
    (x || o !== Cp || a !== Cp || l !== Cp) && (_ += l !== Cp || x ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + NA),
    c !== DA && (_ += "rotate(" + c + NA),
    A !== DA && (_ += "rotateY(" + A + NA),
    u !== DA && (_ += "rotateX(" + u + NA),
    (f !== DA || h !== DA) && (_ += "skew(" + f + ", " + h + NA),
    (d !== 1 || m !== 1) && (_ += "scale(" + d + ", " + m + NA),
    v.style[Wn] = _ || "translate(0, 0)"
}, QJ = function(e, t) {
    var r = t || this, i = r.xPercent, s = r.yPercent, o = r.x, a = r.y, l = r.rotation, c = r.skewX, A = r.skewY, u = r.scaleX, f = r.scaleY, h = r.target, d = r.xOrigin, m = r.yOrigin, g = r.xOffset, p = r.yOffset, v = r.forceCSS, w = parseFloat(o), _ = parseFloat(a), x, b, B, S, I;
    l = parseFloat(l),
    c = parseFloat(c),
    A = parseFloat(A),
    A && (A = parseFloat(A),
    c += A,
    l += A),
    l || c ? (l *= nd,
    c *= nd,
    x = Math.cos(l) * u,
    b = Math.sin(l) * u,
    B = Math.sin(l - c) * -f,
    S = Math.cos(l - c) * f,
    c && (A *= nd,
    I = Math.tan(c - A),
    I = Math.sqrt(1 + I * I),
    B *= I,
    S *= I,
    A && (I = Math.tan(A),
    I = Math.sqrt(1 + I * I),
    x *= I,
    b *= I)),
    x = hr(x),
    b = hr(b),
    B = hr(B),
    S = hr(S)) : (x = u,
    S = f,
    b = B = 0),
    (w && !~(o + "").indexOf("px") || _ && !~(a + "").indexOf("px")) && (w = yA(h, "x", o, "px"),
    _ = yA(h, "y", a, "px")),
    (d || m || g || p) && (w = hr(w + d - (d * x + m * B) + g),
    _ = hr(_ + m - (d * b + m * S) + p)),
    (i || s) && (I = h.getBBox(),
    w = hr(w + i / 100 * I.width),
    _ = hr(_ + s / 100 * I.height)),
    I = "matrix(" + x + "," + b + "," + B + "," + S + "," + w + "," + _ + ")",
    h.setAttribute("transform", I),
    v && (h.style[Wn] = I)
}, HJ = function(e, t, r, i, s) {
    var o = 360, a = $r(s), l = parseFloat(s) * (a && ~s.indexOf("rad") ? nu : 1), c = l - i, A = i + c + "deg", u, f;
    return a && (u = s.split("_")[1],
    u === "short" && (c %= o,
    c !== c % (o / 2) && (c += c < 0 ? o : -o)),
    u === "cw" && c < 0 ? c = (c + o * XP) % o - ~~(c / o) * o : u === "ccw" && c > 0 && (c = (c - o * XP) % o - ~~(c / o) * o)),
    e._pt = f = new ss(e._pt,t,r,i,c,EJ),
    f.e = A,
    f.u = "deg",
    e._props.push(r),
    f
}, eL = function(e, t) {
    for (var r in t)
        e[r] = t[r];
    return e
}, zJ = function(e, t, r) {
    var i = eL({}, r._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = r.style, a, l, c, A, u, f, h, d;
    i.svg ? (c = r.getAttribute("transform"),
    r.setAttribute("transform", ""),
    o[Wn] = t,
    a = Og(r, 1),
    Lu(r, Wn),
    r.setAttribute("transform", c)) : (c = getComputedStyle(r)[Wn],
    o[Wn] = t,
    a = Og(r, 1),
    o[Wn] = c);
    for (l in tc)
        c = i[l],
        A = a[l],
        c !== A && s.indexOf(l) < 0 && (h = wi(c),
        d = wi(A),
        u = h !== d ? yA(r, l, c, d) : parseFloat(c),
        f = parseFloat(A),
        e._pt = new ss(e._pt,a,l,u,f - u,VS),
        e._pt.u = d || 0,
        e._props.push(l));
    eL(a, i)
};
is("padding,margin,Width,Radius", function(n, e) {
    var t = "Top"
      , r = "Right"
      , i = "Bottom"
      , s = "Left"
      , o = (e < 3 ? [t, r, i, s] : [t + s, t + r, i + r, i + s]).map(function(a) {
        return e < 2 ? n + a : "border" + a + n
    });
    U_[e > 1 ? "border" + n : n] = function(a, l, c, A, u) {
        var f, h;
        if (arguments.length < 4)
            return f = o.map(function(d) {
                return Ll(a, d, c)
            }),
            h = f.join(" "),
            h.split(f[0]).length === 5 ? f[0] : h;
        f = (A + "").split(" "),
        h = {},
        o.forEach(function(d, m) {
            return h[d] = f[m] = f[m] || f[(m - 1) / 2 | 0]
        }),
        a.init(l, h, u)
    }
});
var lz = {
    name: "css",
    register: WS,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, r, i, s) {
        var o = this._props, a = e.style, l = r.vars.startAt, c, A, u, f, h, d, m, g, p, v, w, _, x, b, B, S;
        bR || WS(),
        this.styles = this.styles || tz(e),
        S = this.styles.props,
        this.tween = r;
        for (m in t)
            if (m !== "autoRound" && (A = t[m],
            !(Bs[m] && V6(m, t, r, i, e, s)))) {
                if (h = typeof A,
                d = U_[m],
                h === "function" && (A = A.call(r, i, e, s),
                h = typeof A),
                h === "string" && ~A.indexOf("random(") && (A = Pg(A)),
                d)
                    d(this, e, m, A, r) && (B = 1);
                else if (m.substr(0, 2) === "--")
                    c = (getComputedStyle(e).getPropertyValue(m) + "").trim(),
                    A += "",
                    uA.lastIndex = 0,
                    uA.test(c) || (g = wi(c),
                    p = wi(A)),
                    p ? g !== p && (c = yA(e, m, c, p) + p) : g && (A += g),
                    this.add(a, "setProperty", c, A, i, s, 0, 0, m),
                    o.push(m),
                    S.push(m, 0, a[m]);
                else if (h !== "undefined") {
                    if (l && m in l ? (c = typeof l[m] == "function" ? l[m].call(r, i, e, s) : l[m],
                    $r(c) && ~c.indexOf("random(") && (c = Pg(c)),
                    wi(c + "") || c === "auto" || (c += Ds.units[m] || wi(Ll(e, m)) || ""),
                    (c + "").charAt(1) === "=" && (c = Ll(e, m))) : c = Ll(e, m),
                    f = parseFloat(c),
                    v = h === "string" && A.charAt(1) === "=" && A.substr(0, 2),
                    v && (A = A.substr(2)),
                    u = parseFloat(A),
                    m in Qa && (m === "autoAlpha" && (f === 1 && Ll(e, "visibility") === "hidden" && u && (f = 0),
                    S.push("visibility", 0, a.visibility),
                    Yc(this, a, "visibility", f ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)),
                    m !== "scale" && m !== "transform" && (m = Qa[m],
                    ~m.indexOf(",") && (m = m.split(",")[0]))),
                    w = m in tc,
                    w) {
                        if (this.styles.save(m),
                        _ || (x = e._gsap,
                        x.renderTransform && !t.parseTransform || Og(e, t.parseTransform),
                        b = t.smoothOrigin !== !1 && x.smooth,
                        _ = this._pt = new ss(this._pt,a,Wn,0,1,x.renderTransform,x,0,-1),
                        _.dep = 1),
                        m === "scale")
                            this._pt = new ss(this._pt,x,"scaleY",x.scaleY,(v ? ed(x.scaleY, v + u) : u) - x.scaleY || 0,VS),
                            this._pt.u = 0,
                            o.push("scaleY", m),
                            m += "X";
                        else if (m === "transformOrigin") {
                            S.push(os, 0, a[os]),
                            A = NJ(A),
                            x.svg ? KS(e, A, 0, b, 0, this) : (p = parseFloat(A.split(" ")[2]) || 0,
                            p !== x.zOrigin && Yc(this, x, "zOrigin", x.zOrigin, p),
                            Yc(this, a, m, F_(c), F_(A)));
                            continue
                        } else if (m === "svgOrigin") {
                            KS(e, A, 1, b, 0, this);
                            continue
                        } else if (m in sz) {
                            HJ(this, x, m, f, v ? ed(f, v + A) : A);
                            continue
                        } else if (m === "smoothOrigin") {
                            Yc(this, x, "smooth", x.smooth, A);
                            continue
                        } else if (m === "force3D") {
                            x[m] = A;
                            continue
                        } else if (m === "transform") {
                            zJ(this, A, e);
                            continue
                        }
                    } else
                        m in a || (m = Cd(m) || m);
                    if (w || (u || u === 0) && (f || f === 0) && !bJ.test(A) && m in a)
                        g = (c + "").substr((f + "").length),
                        u || (u = 0),
                        p = wi(A) || (m in Ds.units ? Ds.units[m] : g),
                        g !== p && (f = yA(e, m, c, p)),
                        this._pt = new ss(this._pt,w ? x : a,m,f,(v ? ed(f, v + u) : u) - f,!w && (p === "px" || m === "zIndex") && t.autoRound !== !1 ? MJ : VS),
                        this._pt.u = p || 0,
                        g !== p && p !== "%" && (this._pt.b = c,
                        this._pt.r = BJ);
                    else if (m in a)
                        DJ.call(this, e, m, c, v ? v + A : A);
                    else if (m in e)
                        this.add(e, m, c || e[m], v ? v + A : A, i, s);
                    else if (m !== "parseTransform") {
                        dR(m, A);
                        continue
                    }
                    w || (m in a ? S.push(m, 0, a[m]) : S.push(m, 1, c || e[m])),
                    o.push(m)
                }
            }
        B && $6(this)
    },
    render: function(e, t) {
        if (t.tween._time || !ER())
            for (var r = t._pt; r; )
                r.r(e, r.d),
                r = r._next;
        else
            t.styles.revert()
    },
    get: Ll,
    aliases: Qa,
    getSetter: function(e, t, r) {
        var i = Qa[t];
        return i && i.indexOf(",") < 0 && (t = i),
        t in tc && t !== os && (e._gsap.x || Ll(e, "x")) ? r && KP === r ? t === "scale" ? IJ : TJ : (KP = r || {}) && (t === "scale" ? RJ : UJ) : e.style && !uR(e.style[t]) ? SJ : ~t.indexOf("-") ? CJ : _R(e, t)
    },
    core: {
        _removeProperty: Lu,
        _getMatrix: MR
    }
};
As.utils.checkPrefix = Cd;
As.core.getStyleSaver = tz;
(function(n, e, t, r) {
    var i = is(n + "," + e + "," + t, function(s) {
        tc[s] = 1
    });
    is(e, function(s) {
        Ds.units[s] = "deg",
        sz[s] = 1
    }),
    Qa[i[13]] = n + "," + e,
    is(r, function(s) {
        var o = s.split(":");
        Qa[o[1]] = i[o[0]]
    })
}
)("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
is("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
    Ds.units[n] = "px"
});
As.registerPlugin(lz);
var XS = As.registerPlugin(lz) || As;
XS.core.Tween;
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const nc = "169"
  , rd = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , Lh = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , GJ = 0
  , tL = 1
  , VJ = 2
  , cz = 1
  , jJ = 2
  , Bl = 3
  , Hs = 0
  , oi = 1
  , _i = 2
  , jl = 0
  , id = 1
  , Du = 2
  , nL = 3
  , rL = 4
  , WJ = 5
  , au = 100
  , KJ = 101
  , XJ = 102
  , YJ = 103
  , $J = 104
  , ZJ = 200
  , JJ = 201
  , qJ = 202
  , eq = 203
  , YS = 204
  , $S = 205
  , tq = 206
  , nq = 207
  , rq = 208
  , iq = 209
  , sq = 210
  , oq = 211
  , aq = 212
  , lq = 213
  , cq = 214
  , ZS = 0
  , JS = 1
  , qS = 2
  , Td = 3
  , eC = 4
  , tC = 5
  , nC = 6
  , rC = 7
  , l1 = 0
  , Aq = 1
  , uq = 2
  , fA = 0
  , fq = 1
  , hq = 2
  , dq = 3
  , pq = 4
  , mq = 5
  , gq = 6
  , vq = 7
  , iL = "attached"
  , yq = "detached"
  , Az = 300
  , Id = 301
  , Rd = 302
  , kg = 303
  , iC = 304
  , c1 = 306
  , zs = 1e3
  , Rs = 1001
  , Qg = 1002
  , Xr = 1003
  , SR = 1004
  , Dh = 1005
  , Lr = 1006
  , qm = 1007
  , ea = 1008
  , rc = 1009
  , uz = 1010
  , fz = 1011
  , Hg = 1012
  , CR = 1013
  , wA = 1014
  , xi = 1015
  , Ha = 1016
  , TR = 1017
  , IR = 1018
  , Ud = 1020
  , hz = 35902
  , dz = 1021
  , pz = 1022
  , Nr = 1023
  , mz = 1024
  , gz = 1025
  , sd = 1026
  , Fd = 1027
  , RR = 1028
  , A1 = 1029
  , vz = 1030
  , UR = 1031
  , FR = 1033
  , xw = 33776
  , bw = 33777
  , Ew = 33778
  , Bw = 33779
  , sC = 35840
  , oC = 35841
  , aC = 35842
  , lC = 35843
  , cC = 36196
  , AC = 37492
  , uC = 37496
  , fC = 37808
  , hC = 37809
  , dC = 37810
  , pC = 37811
  , mC = 37812
  , gC = 37813
  , vC = 37814
  , yC = 37815
  , wC = 37816
  , _C = 37817
  , xC = 37818
  , bC = 37819
  , EC = 37820
  , BC = 37821
  , Mw = 36492
  , MC = 36494
  , SC = 36495
  , yz = 36283
  , CC = 36284
  , TC = 36285
  , IC = 36286
  , wq = 2200
  , _q = 2201
  , xq = 2202
  , Pd = 2300
  , Ld = 2301
  , mE = 2302
  , Nh = 2400
  , Oh = 2401
  , P_ = 2402
  , PR = 2500
  , bq = 2501
  , Eq = 0
  , wz = 1
  , RC = 2
  , Bq = 3200
  , Mq = 3201
  , Kd = 0
  , Sq = 1
  , La = ""
  , Ut = "srgb"
  , Sr = "srgb-linear"
  , LR = "display-p3"
  , u1 = "display-p3-linear"
  , L_ = "linear"
  , Sn = "srgb"
  , D_ = "rec709"
  , N_ = "p3"
  , cf = 7680
  , sL = 519
  , Cq = 512
  , Tq = 513
  , Iq = 514
  , _z = 515
  , Rq = 516
  , Uq = 517
  , Fq = 518
  , Pq = 519
  , UC = 35044
  , Lq = 35048
  , oL = "300 es"
  , zl = 2e3
  , O_ = 2001;
class UA {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(t) === -1 && r[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            const i = r.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, e);
            e.target = null
        }
    }
}
const fi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let aL = 1234567;
const eg = Math.PI / 180
  , Dd = 180 / Math.PI;
function ia() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , r = Math.random() * 4294967295 | 0;
    return (fi[n & 255] + fi[n >> 8 & 255] + fi[n >> 16 & 255] + fi[n >> 24 & 255] + "-" + fi[e & 255] + fi[e >> 8 & 255] + "-" + fi[e >> 16 & 15 | 64] + fi[e >> 24 & 255] + "-" + fi[t & 63 | 128] + fi[t >> 8 & 255] + "-" + fi[t >> 16 & 255] + fi[t >> 24 & 255] + fi[r & 255] + fi[r >> 8 & 255] + fi[r >> 16 & 255] + fi[r >> 24 & 255]).toLowerCase()
}
function pr(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function DR(n, e) {
    return (n % e + e) % e
}
function Dq(n, e, t, r, i) {
    return r + (n - e) * (i - r) / (t - e)
}
function Nq(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function tg(n, e, t) {
    return (1 - t) * n + t * e
}
function Oq(n, e, t, r) {
    return tg(n, e, 1 - Math.exp(-t * r))
}
function kq(n, e=1) {
    return e - Math.abs(DR(n, e * 2) - e)
}
function Qq(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function Hq(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function zq(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function Gq(n, e) {
    return n + Math.random() * (e - n)
}
function Vq(n) {
    return n * (.5 - Math.random())
}
function jq(n) {
    n !== void 0 && (aL = n);
    let e = aL += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function Wq(n) {
    return n * eg
}
function Kq(n) {
    return n * Dd
}
function Xq(n) {
    return (n & n - 1) === 0 && n !== 0
}
function Yq(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function $q(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function Zq(n, e, t, r, i) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , c = s((e + r) / 2)
      , A = o((e + r) / 2)
      , u = s((e - r) / 2)
      , f = o((e - r) / 2)
      , h = s((r - e) / 2)
      , d = o((r - e) / 2);
    switch (i) {
    case "XYX":
        n.set(a * A, l * u, l * f, a * c);
        break;
    case "YZY":
        n.set(l * f, a * A, l * u, a * c);
        break;
    case "ZXZ":
        n.set(l * u, l * f, a * A, a * c);
        break;
    case "XZX":
        n.set(a * A, l * d, l * h, a * c);
        break;
    case "YXY":
        n.set(l * h, a * A, l * d, a * c);
        break;
    case "ZYZ":
        n.set(l * d, l * h, a * A, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function Zo(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function hn(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Bt = {
    DEG2RAD: eg,
    RAD2DEG: Dd,
    generateUUID: ia,
    clamp: pr,
    euclideanModulo: DR,
    mapLinear: Dq,
    inverseLerp: Nq,
    lerp: tg,
    damp: Oq,
    pingpong: kq,
    smoothstep: Qq,
    smootherstep: Hq,
    randInt: zq,
    randFloat: Gq,
    randFloatSpread: Vq,
    seededRandom: jq,
    degToRad: Wq,
    radToDeg: Kq,
    isPowerOfTwo: Xq,
    ceilPowerOfTwo: Yq,
    floorPowerOfTwo: $q,
    setQuaternionFromProperEuler: Zq,
    normalize: hn,
    denormalize: Zo
};
class We {
    constructor(e=0, t=0) {
        We.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * r + i[6],
        this.y = i[1] * t + i[4] * r + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos(pr(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y;
        return t * t + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const r = Math.cos(t)
          , i = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * r - o * i + e.x,
        this.y = s * i + o * r + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class dt {
    constructor(e, t, r, i, s, o, a, l, c) {
        dt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, r, i, s, o, a, l, c)
    }
    set(e, t, r, i, s, o, a, l, c) {
        const A = this.elements;
        return A[0] = e,
        A[1] = i,
        A[2] = a,
        A[3] = t,
        A[4] = s,
        A[5] = l,
        A[6] = r,
        A[7] = o,
        A[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , i = t.elements
          , s = this.elements
          , o = r[0]
          , a = r[3]
          , l = r[6]
          , c = r[1]
          , A = r[4]
          , u = r[7]
          , f = r[2]
          , h = r[5]
          , d = r[8]
          , m = i[0]
          , g = i[3]
          , p = i[6]
          , v = i[1]
          , w = i[4]
          , _ = i[7]
          , x = i[2]
          , b = i[5]
          , B = i[8];
        return s[0] = o * m + a * v + l * x,
        s[3] = o * g + a * w + l * b,
        s[6] = o * p + a * _ + l * B,
        s[1] = c * m + A * v + u * x,
        s[4] = c * g + A * w + u * b,
        s[7] = c * p + A * _ + u * B,
        s[2] = f * m + h * v + d * x,
        s[5] = f * g + h * w + d * b,
        s[8] = f * p + h * _ + d * B,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , A = e[8];
        return t * o * A - t * a * c - r * s * A + r * a * l + i * s * c - i * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , A = e[8]
          , u = A * o - a * c
          , f = a * l - A * s
          , h = c * s - o * l
          , d = t * u + r * f + i * h;
        if (d === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / d;
        return e[0] = u * m,
        e[1] = (i * c - A * r) * m,
        e[2] = (a * r - i * o) * m,
        e[3] = f * m,
        e[4] = (A * t - i * l) * m,
        e[5] = (i * s - a * t) * m,
        e[6] = h * m,
        e[7] = (r * l - c * t) * m,
        e[8] = (o * t - r * s) * m,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, r, i, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(r * l, r * c, -r * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(gE.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(gE.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(gE.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, r, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== r[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 9; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const gE = new dt;
function xz(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
function zg(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function Jq() {
    const n = zg("canvas");
    return n.style.display = "block",
    n
}
const lL = {};
function Sw(n) {
    n in lL || (lL[n] = !0,
    console.warn(n))
}
function qq(n, e, t) {
    return new Promise(function(r, i) {
        function s() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case n.WAIT_FAILED:
                i();
                break;
            case n.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
            default:
                r()
            }
        }
        setTimeout(s, t)
    }
    )
}
function eee(n) {
    const e = n.elements;
    e[2] = .5 * e[2] + .5 * e[3],
    e[6] = .5 * e[6] + .5 * e[7],
    e[10] = .5 * e[10] + .5 * e[11],
    e[14] = .5 * e[14] + .5 * e[15]
}
function tee(n) {
    const e = n.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1,
    e[14] = -e[14]) : (e[10] = -e[10],
    e[14] = -e[14] + 1)
}
const cL = new dt().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , AL = new dt().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , Tp = {
    [Sr]: {
        transfer: L_,
        primaries: D_,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: n => n,
        fromReference: n => n
    },
    [Ut]: {
        transfer: Sn,
        primaries: D_,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: n => n.convertSRGBToLinear(),
        fromReference: n => n.convertLinearToSRGB()
    },
    [u1]: {
        transfer: L_,
        primaries: N_,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: n => n.applyMatrix3(AL),
        fromReference: n => n.applyMatrix3(cL)
    },
    [LR]: {
        transfer: Sn,
        primaries: N_,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: n => n.convertSRGBToLinear().applyMatrix3(AL),
        fromReference: n => n.applyMatrix3(cL).convertLinearToSRGB()
    }
}
  , nee = new Set([Sr, u1])
  , Et = {
    enabled: !0,
    _workingColorSpace: Sr,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!nee.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const r = Tp[e].toReference
          , i = Tp[t].fromReference;
        return i(r(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return Tp[n].primaries
    },
    getTransfer: function(n) {
        return n === La ? L_ : Tp[n].transfer
    },
    getLuminanceCoefficients: function(n, e=this._workingColorSpace) {
        return n.fromArray(Tp[e].luminanceCoefficients)
    }
};
function od(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function vE(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Af;
class ree {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Af === void 0 && (Af = zg("canvas")),
            Af.width = e.width,
            Af.height = e.height;
            const r = Af.getContext("2d");
            e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height),
            t = Af
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = zg("canvas");
            t.width = e.width,
            t.height = e.height;
            const r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const i = r.getImageData(0, 0, e.width, e.height)
              , s = i.data;
            for (let o = 0; o < s.length; o++)
                s[o] = od(s[o] / 255) * 255;
            return r.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let r = 0; r < t.length; r++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(od(t[r] / 255) * 255) : t[r] = od(t[r]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let iee = 0;
class NR {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: iee++
        }),
        this.uuid = ia(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const r = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? s.push(yE(i[o].image)) : s.push(yE(i[o]))
            } else
                s = yE(i);
            r.url = s
        }
        return t || (e.images[this.uuid] = r),
        r
    }
}
function yE(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? ree.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let see = 0;
class Un extends UA {
    constructor(e=Un.DEFAULT_IMAGE, t=Un.DEFAULT_MAPPING, r=Rs, i=Rs, s=Lr, o=ea, a=Nr, l=rc, c=Un.DEFAULT_ANISOTROPY, A=La) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: see++
        }),
        this.uuid = ia(),
        this.name = "",
        this.source = new NR(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = r,
        this.wrapT = i,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new We(0,0),
        this.repeat = new We(1,1),
        this.center = new We(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new dt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = A,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== Az)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case zs:
                e.x = e.x - Math.floor(e.x);
                break;
            case Rs:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Qg:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case zs:
                e.y = e.y - Math.floor(e.y);
                break;
            case Rs:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Qg:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
Un.DEFAULT_IMAGE = null;
Un.DEFAULT_MAPPING = Az;
Un.DEFAULT_ANISOTROPY = 1;
class Pt {
    constructor(e=0, t=0, r=0, i=1) {
        Pt.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = r,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, r, i) {
        return this.x = e,
        this.y = t,
        this.z = r,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s,
        this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s,
        this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s,
        this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, r, i, s;
        const l = e.elements
          , c = l[0]
          , A = l[4]
          , u = l[8]
          , f = l[1]
          , h = l[5]
          , d = l[9]
          , m = l[2]
          , g = l[6]
          , p = l[10];
        if (Math.abs(A - f) < .01 && Math.abs(u - m) < .01 && Math.abs(d - g) < .01) {
            if (Math.abs(A + f) < .1 && Math.abs(u + m) < .1 && Math.abs(d + g) < .1 && Math.abs(c + h + p - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const w = (c + 1) / 2
              , _ = (h + 1) / 2
              , x = (p + 1) / 2
              , b = (A + f) / 4
              , B = (u + m) / 4
              , S = (d + g) / 4;
            return w > _ && w > x ? w < .01 ? (r = 0,
            i = .707106781,
            s = .707106781) : (r = Math.sqrt(w),
            i = b / r,
            s = B / r) : _ > x ? _ < .01 ? (r = .707106781,
            i = 0,
            s = .707106781) : (i = Math.sqrt(_),
            r = b / i,
            s = S / i) : x < .01 ? (r = .707106781,
            i = .707106781,
            s = 0) : (s = Math.sqrt(x),
            r = B / s,
            i = S / s),
            this.set(r, i, s, t),
            this
        }
        let v = Math.sqrt((g - d) * (g - d) + (u - m) * (u - m) + (f - A) * (f - A));
        return Math.abs(v) < .001 && (v = 1),
        this.x = (g - d) / v,
        this.y = (u - m) / v,
        this.z = (f - A) / v,
        this.w = Math.acos((c + h + p - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this.w = e.w + (t.w - e.w) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class oee extends UA {
    constructor(e=1, t=1, r={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Pt(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Pt(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        r = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Lr,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, r);
        const s = new Un(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace);
        s.flipY = !1,
        s.generateMipmaps = r.generateMipmaps,
        s.internalFormat = r.internalFormat,
        this.textures = [];
        const o = r.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = r.depthBuffer,
        this.stencilBuffer = r.stencilBuffer,
        this.resolveDepthBuffer = r.resolveDepthBuffer,
        this.resolveStencilBuffer = r.resolveStencilBuffer,
        this.depthTexture = r.depthTexture,
        this.samples = r.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, r=1) {
        if (this.width !== e || this.height !== t || this.depth !== r) {
            this.width = e,
            this.height = t,
            this.depth = r;
            for (let i = 0, s = this.textures.length; i < s; i++)
                this.textures[i].image.width = e,
                this.textures[i].image.height = t,
                this.textures[i].image.depth = r;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let r = 0, i = e.textures.length; r < i; r++)
            this.textures[r] = e.textures[r].clone(),
            this.textures[r].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new NR(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class tl extends oee {
    constructor(e=1, t=1, r={}) {
        super(e, t, r),
        this.isWebGLRenderTarget = !0
    }
}
class bz extends Un {
    constructor(e=null, t=1, r=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Xr,
        this.minFilter = Xr,
        this.wrapR = Rs,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class aee extends Un {
    constructor(e=null, t=1, r=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: i
        },
        this.magFilter = Xr,
        this.minFilter = Xr,
        this.wrapR = Rs,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class nt {
    constructor(e=0, t=0, r=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._w = i
    }
    static slerpFlat(e, t, r, i, s, o, a) {
        let l = r[i + 0]
          , c = r[i + 1]
          , A = r[i + 2]
          , u = r[i + 3];
        const f = s[o + 0]
          , h = s[o + 1]
          , d = s[o + 2]
          , m = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = A,
            e[t + 3] = u;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = h,
            e[t + 2] = d,
            e[t + 3] = m;
            return
        }
        if (u !== m || l !== f || c !== h || A !== d) {
            let g = 1 - a;
            const p = l * f + c * h + A * d + u * m
              , v = p >= 0 ? 1 : -1
              , w = 1 - p * p;
            if (w > Number.EPSILON) {
                const x = Math.sqrt(w)
                  , b = Math.atan2(x, p * v);
                g = Math.sin(g * b) / x,
                a = Math.sin(a * b) / x
            }
            const _ = a * v;
            if (l = l * g + f * _,
            c = c * g + h * _,
            A = A * g + d * _,
            u = u * g + m * _,
            g === 1 - a) {
                const x = 1 / Math.sqrt(l * l + c * c + A * A + u * u);
                l *= x,
                c *= x,
                A *= x,
                u *= x
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = A,
        e[t + 3] = u
    }
    static multiplyQuaternionsFlat(e, t, r, i, s, o) {
        const a = r[i]
          , l = r[i + 1]
          , c = r[i + 2]
          , A = r[i + 3]
          , u = s[o]
          , f = s[o + 1]
          , h = s[o + 2]
          , d = s[o + 3];
        return e[t] = a * d + A * u + l * h - c * f,
        e[t + 1] = l * d + A * f + c * u - a * h,
        e[t + 2] = c * d + A * h + a * f - l * u,
        e[t + 3] = A * d - a * u - l * f - c * h,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, r, i) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const r = e._x
          , i = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(r / 2)
          , A = a(i / 2)
          , u = a(s / 2)
          , f = l(r / 2)
          , h = l(i / 2)
          , d = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = f * A * u + c * h * d,
            this._y = c * h * u - f * A * d,
            this._z = c * A * d + f * h * u,
            this._w = c * A * u - f * h * d;
            break;
        case "YXZ":
            this._x = f * A * u + c * h * d,
            this._y = c * h * u - f * A * d,
            this._z = c * A * d - f * h * u,
            this._w = c * A * u + f * h * d;
            break;
        case "ZXY":
            this._x = f * A * u - c * h * d,
            this._y = c * h * u + f * A * d,
            this._z = c * A * d + f * h * u,
            this._w = c * A * u - f * h * d;
            break;
        case "ZYX":
            this._x = f * A * u - c * h * d,
            this._y = c * h * u + f * A * d,
            this._z = c * A * d - f * h * u,
            this._w = c * A * u + f * h * d;
            break;
        case "YZX":
            this._x = f * A * u + c * h * d,
            this._y = c * h * u + f * A * d,
            this._z = c * A * d - f * h * u,
            this._w = c * A * u - f * h * d;
            break;
        case "XZY":
            this._x = f * A * u - c * h * d,
            this._y = c * h * u - f * A * d,
            this._z = c * A * d + f * h * u,
            this._w = c * A * u + f * h * d;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const r = t / 2
          , i = Math.sin(r);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , r = t[0]
          , i = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , A = t[6]
          , u = t[10]
          , f = r + a + u;
        if (f > 0) {
            const h = .5 / Math.sqrt(f + 1);
            this._w = .25 / h,
            this._x = (A - l) * h,
            this._y = (s - c) * h,
            this._z = (o - i) * h
        } else if (r > a && r > u) {
            const h = 2 * Math.sqrt(1 + r - a - u);
            this._w = (A - l) / h,
            this._x = .25 * h,
            this._y = (i + o) / h,
            this._z = (s + c) / h
        } else if (a > u) {
            const h = 2 * Math.sqrt(1 + a - r - u);
            this._w = (s - c) / h,
            this._x = (i + o) / h,
            this._y = .25 * h,
            this._z = (l + A) / h
        } else {
            const h = 2 * Math.sqrt(1 + u - r - a);
            this._w = (o - i) / h,
            this._x = (s + c) / h,
            this._y = (l + A) / h,
            this._z = .25 * h
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let r = e.dot(t) + 1;
        return r < Number.EPSILON ? (r = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = r) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = r),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(pr(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const r = this.angleTo(e);
        if (r === 0)
            return this;
        const i = Math.min(1, t / r);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const r = e._x
          , i = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , A = t._w;
        return this._x = r * A + o * a + i * c - s * l,
        this._y = i * A + o * l + s * a - r * c,
        this._z = s * A + o * c + r * l - i * a,
        this._w = o * A - r * a - i * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const r = this._x
          , i = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + r * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = r,
            this._y = i,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const h = 1 - t;
            return this._w = h * o + t * this._w,
            this._x = h * r + t * this._x,
            this._y = h * i + t * this._y,
            this._z = h * s + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , A = Math.atan2(c, a)
          , u = Math.sin((1 - t) * A) / c
          , f = Math.sin(t * A) / c;
        return this._w = o * u + this._w * f,
        this._x = r * u + this._x * f,
        this._y = i * u + this._y * f,
        this._z = s * u + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, r) {
        return this.copy(e).slerp(t, r)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , r = Math.random()
          , i = Math.sqrt(1 - r)
          , s = Math.sqrt(r);
        return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class $ {
    constructor(e=0, t=0, r=0) {
        $.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = r
    }
    set(e, t, r) {
        return r === void 0 && (r = this.z),
        this.x = e,
        this.y = t,
        this.z = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(uL.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(uL.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * r + s[6] * i,
        this.y = s[1] * t + s[4] * r + s[7] * i,
        this.z = s[2] * t + s[5] * r + s[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
        return this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o,
        this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o,
        this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * i - a * r)
          , A = 2 * (a * t - s * i)
          , u = 2 * (s * r - o * t);
        return this.x = t + l * c + o * u - a * A,
        this.y = r + l * A + a * c - s * u,
        this.z = i + l * u + s * A - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , r = this.y
          , i = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * r + s[8] * i,
        this.y = s[1] * t + s[5] * r + s[9] * i,
        this.z = s[2] * t + s[6] * r + s[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const r = e.x
          , i = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = i * l - s * a,
        this.y = s * o - r * l,
        this.z = r * a - i * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const r = e.dot(this) / t;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return wE.copy(this).projectOnVector(e),
        this.sub(wE)
    }
    reflect(e) {
        return this.sub(wE.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos(pr(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y
          , i = this.z - e.z;
        return t * t + r * r + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, r) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(r),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(r),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, r) {
        return this.x = e * Math.sin(t),
        this.y = r,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , r = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = r,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , r = Math.sqrt(1 - t * t);
        return this.x = r * Math.cos(e),
        this.y = t,
        this.z = r * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const wE = new $
  , uL = new nt;
class Hn {
    constructor(e=new $(1 / 0,1 / 0,1 / 0), t=new $(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t += 3)
            this.expandByPoint(Lo.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, r = e.count; t < r; t++)
            this.expandByPoint(Lo.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = Lo.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0) {
            const s = r.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, Lo) : Lo.fromBufferAttribute(s, o),
                    Lo.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Lo);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                fv.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(),
                fv.copy(r.boundingBox)),
                fv.applyMatrix4(e.matrixWorld),
                this.union(fv)
        }
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++)
            this.expandByObject(i[s], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Lo),
        Lo.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, r;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        r = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        r += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        r += e.normal.z * this.min.z),
        t <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Ip),
        hv.subVectors(this.max, Ip),
        uf.subVectors(e.a, Ip),
        ff.subVectors(e.b, Ip),
        hf.subVectors(e.c, Ip),
        yc.subVectors(ff, uf),
        wc.subVectors(hf, ff),
        OA.subVectors(uf, hf);
        let t = [0, -yc.z, yc.y, 0, -wc.z, wc.y, 0, -OA.z, OA.y, yc.z, 0, -yc.x, wc.z, 0, -wc.x, OA.z, 0, -OA.x, -yc.y, yc.x, 0, -wc.y, wc.x, 0, -OA.y, OA.x, 0];
        return !_E(t, uf, ff, hf, hv) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !_E(t, uf, ff, hf, hv)) ? !1 : (dv.crossVectors(yc, wc),
        t = [dv.x, dv.y, dv.z],
        _E(t, uf, ff, hf, hv))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Lo).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(Lo).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (fl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        fl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        fl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        fl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        fl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        fl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        fl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        fl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(fl),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const fl = [new $, new $, new $, new $, new $, new $, new $, new $]
  , Lo = new $
  , fv = new Hn
  , uf = new $
  , ff = new $
  , hf = new $
  , yc = new $
  , wc = new $
  , OA = new $
  , Ip = new $
  , hv = new $
  , dv = new $
  , kA = new $;
function _E(n, e, t, r, i) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        kA.fromArray(n, s);
        const a = i.x * Math.abs(kA.x) + i.y * Math.abs(kA.y) + i.z * Math.abs(kA.z)
          , l = e.dot(kA)
          , c = t.dot(kA)
          , A = r.dot(kA);
        if (Math.max(-Math.max(l, c, A), Math.min(l, c, A)) > a)
            return !1
    }
    return !0
}
const lee = new Hn
  , Rp = new $
  , xE = new $;
class Mi {
    constructor(e=new $, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const r = this.center;
        t !== void 0 ? r.copy(t) : lee.setFromPoints(e).getCenter(r);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++)
            i = Math.max(i, r.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const r = this.center.distanceToSquared(e);
        return t.copy(e),
        r > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Rp.subVectors(e, this.center);
        const t = Rp.lengthSq();
        if (t > this.radius * this.radius) {
            const r = Math.sqrt(t)
              , i = (r - this.radius) * .5;
            this.center.addScaledVector(Rp, i / r),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (xE.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Rp.copy(e.center).add(xE)),
        this.expandByPoint(Rp.copy(e.center).sub(xE))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const hl = new $
  , bE = new $
  , pv = new $
  , _c = new $
  , EE = new $
  , mv = new $
  , BE = new $;
class $u {
    constructor(e=new $, t=new $(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, hl)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const r = t.dot(this.direction);
        return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = hl.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (hl.copy(this.origin).addScaledVector(this.direction, t),
        hl.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, r, i) {
        bE.copy(e).add(t).multiplyScalar(.5),
        pv.copy(t).sub(e).normalize(),
        _c.copy(this.origin).sub(bE);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(pv)
          , a = _c.dot(this.direction)
          , l = -_c.dot(pv)
          , c = _c.lengthSq()
          , A = Math.abs(1 - o * o);
        let u, f, h, d;
        if (A > 0)
            if (u = o * l - a,
            f = o * a - l,
            d = s * A,
            u >= 0)
                if (f >= -d)
                    if (f <= d) {
                        const m = 1 / A;
                        u *= m,
                        f *= m,
                        h = u * (u + o * f + 2 * a) + f * (o * u + f + 2 * l) + c
                    } else
                        f = s,
                        u = Math.max(0, -(o * f + a)),
                        h = -u * u + f * (f + 2 * l) + c;
                else
                    f = -s,
                    u = Math.max(0, -(o * f + a)),
                    h = -u * u + f * (f + 2 * l) + c;
            else
                f <= -d ? (u = Math.max(0, -(-o * s + a)),
                f = u > 0 ? -s : Math.min(Math.max(-s, -l), s),
                h = -u * u + f * (f + 2 * l) + c) : f <= d ? (u = 0,
                f = Math.min(Math.max(-s, -l), s),
                h = f * (f + 2 * l) + c) : (u = Math.max(0, -(o * s + a)),
                f = u > 0 ? s : Math.min(Math.max(-s, -l), s),
                h = -u * u + f * (f + 2 * l) + c);
        else
            f = o > 0 ? -s : s,
            u = Math.max(0, -(o * f + a)),
            h = -u * u + f * (f + 2 * l) + c;
        return r && r.copy(this.origin).addScaledVector(this.direction, u),
        i && i.copy(bE).addScaledVector(pv, f),
        h
    }
    intersectSphere(e, t) {
        hl.subVectors(e.center, this.origin);
        const r = hl.dot(this.direction)
          , i = hl.dot(hl) - r * r
          , s = e.radius * e.radius;
        if (i > s)
            return null;
        const o = Math.sqrt(s - i)
          , a = r - o
          , l = r + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / t;
        return r >= 0 ? r : null
    }
    intersectPlane(e, t) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let r, i, s, o, a, l;
        const c = 1 / this.direction.x
          , A = 1 / this.direction.y
          , u = 1 / this.direction.z
          , f = this.origin;
        return c >= 0 ? (r = (e.min.x - f.x) * c,
        i = (e.max.x - f.x) * c) : (r = (e.max.x - f.x) * c,
        i = (e.min.x - f.x) * c),
        A >= 0 ? (s = (e.min.y - f.y) * A,
        o = (e.max.y - f.y) * A) : (s = (e.max.y - f.y) * A,
        o = (e.min.y - f.y) * A),
        r > o || s > i || ((s > r || isNaN(r)) && (r = s),
        (o < i || isNaN(i)) && (i = o),
        u >= 0 ? (a = (e.min.z - f.z) * u,
        l = (e.max.z - f.z) * u) : (a = (e.max.z - f.z) * u,
        l = (e.min.z - f.z) * u),
        r > l || a > i) || ((a > r || r !== r) && (r = a),
        (l < i || i !== i) && (i = l),
        i < 0) ? null : this.at(r >= 0 ? r : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, hl) !== null
    }
    intersectTriangle(e, t, r, i, s) {
        EE.subVectors(t, e),
        mv.subVectors(r, e),
        BE.crossVectors(EE, mv);
        let o = this.direction.dot(BE), a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        _c.subVectors(this.origin, e);
        const l = a * this.direction.dot(mv.crossVectors(_c, mv));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(EE.cross(_c));
        if (c < 0 || l + c > o)
            return null;
        const A = -a * _c.dot(BE);
        return A < 0 ? null : this.at(A / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class He {
    constructor(e, t, r, i, s, o, a, l, c, A, u, f, h, d, m, g) {
        He.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, r, i, s, o, a, l, c, A, u, f, h, d, m, g)
    }
    set(e, t, r, i, s, o, a, l, c, A, u, f, h, d, m, g) {
        const p = this.elements;
        return p[0] = e,
        p[4] = t,
        p[8] = r,
        p[12] = i,
        p[1] = s,
        p[5] = o,
        p[9] = a,
        p[13] = l,
        p[2] = c,
        p[6] = A,
        p[10] = u,
        p[14] = f,
        p[3] = h,
        p[7] = d,
        p[11] = m,
        p[15] = g,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new He().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        t[9] = r[9],
        t[10] = r[10],
        t[11] = r[11],
        t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        t[15] = r[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , r = e.elements;
        return t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, r) {
        return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , r = e.elements
          , i = 1 / df.setFromMatrixColumn(e, 0).length()
          , s = 1 / df.setFromMatrixColumn(e, 1).length()
          , o = 1 / df.setFromMatrixColumn(e, 2).length();
        return t[0] = r[0] * i,
        t[1] = r[1] * i,
        t[2] = r[2] * i,
        t[3] = 0,
        t[4] = r[4] * s,
        t[5] = r[5] * s,
        t[6] = r[6] * s,
        t[7] = 0,
        t[8] = r[8] * o,
        t[9] = r[9] * o,
        t[10] = r[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , r = e.x
          , i = e.y
          , s = e.z
          , o = Math.cos(r)
          , a = Math.sin(r)
          , l = Math.cos(i)
          , c = Math.sin(i)
          , A = Math.cos(s)
          , u = Math.sin(s);
        if (e.order === "XYZ") {
            const f = o * A
              , h = o * u
              , d = a * A
              , m = a * u;
            t[0] = l * A,
            t[4] = -l * u,
            t[8] = c,
            t[1] = h + d * c,
            t[5] = f - m * c,
            t[9] = -a * l,
            t[2] = m - f * c,
            t[6] = d + h * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const f = l * A
              , h = l * u
              , d = c * A
              , m = c * u;
            t[0] = f + m * a,
            t[4] = d * a - h,
            t[8] = o * c,
            t[1] = o * u,
            t[5] = o * A,
            t[9] = -a,
            t[2] = h * a - d,
            t[6] = m + f * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const f = l * A
              , h = l * u
              , d = c * A
              , m = c * u;
            t[0] = f - m * a,
            t[4] = -o * u,
            t[8] = d + h * a,
            t[1] = h + d * a,
            t[5] = o * A,
            t[9] = m - f * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const f = o * A
              , h = o * u
              , d = a * A
              , m = a * u;
            t[0] = l * A,
            t[4] = d * c - h,
            t[8] = f * c + m,
            t[1] = l * u,
            t[5] = m * c + f,
            t[9] = h * c - d,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const f = o * l
              , h = o * c
              , d = a * l
              , m = a * c;
            t[0] = l * A,
            t[4] = m - f * u,
            t[8] = d * u + h,
            t[1] = u,
            t[5] = o * A,
            t[9] = -a * A,
            t[2] = -c * A,
            t[6] = h * u + d,
            t[10] = f - m * u
        } else if (e.order === "XZY") {
            const f = o * l
              , h = o * c
              , d = a * l
              , m = a * c;
            t[0] = l * A,
            t[4] = -u,
            t[8] = c * A,
            t[1] = f * u + m,
            t[5] = o * A,
            t[9] = h * u - d,
            t[2] = d * u - h,
            t[6] = a * A,
            t[10] = m * u + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(cee, e, Aee)
    }
    lookAt(e, t, r) {
        const i = this.elements;
        return ps.subVectors(e, t),
        ps.lengthSq() === 0 && (ps.z = 1),
        ps.normalize(),
        xc.crossVectors(r, ps),
        xc.lengthSq() === 0 && (Math.abs(r.z) === 1 ? ps.x += 1e-4 : ps.z += 1e-4,
        ps.normalize(),
        xc.crossVectors(r, ps)),
        xc.normalize(),
        gv.crossVectors(ps, xc),
        i[0] = xc.x,
        i[4] = gv.x,
        i[8] = ps.x,
        i[1] = xc.y,
        i[5] = gv.y,
        i[9] = ps.y,
        i[2] = xc.z,
        i[6] = gv.z,
        i[10] = ps.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , i = t.elements
          , s = this.elements
          , o = r[0]
          , a = r[4]
          , l = r[8]
          , c = r[12]
          , A = r[1]
          , u = r[5]
          , f = r[9]
          , h = r[13]
          , d = r[2]
          , m = r[6]
          , g = r[10]
          , p = r[14]
          , v = r[3]
          , w = r[7]
          , _ = r[11]
          , x = r[15]
          , b = i[0]
          , B = i[4]
          , S = i[8]
          , I = i[12]
          , M = i[1]
          , L = i[5]
          , D = i[9]
          , T = i[13]
          , y = i[2]
          , E = i[6]
          , R = i[10]
          , F = i[14]
          , O = i[3]
          , z = i[7]
          , j = i[11]
          , Q = i[15];
        return s[0] = o * b + a * M + l * y + c * O,
        s[4] = o * B + a * L + l * E + c * z,
        s[8] = o * S + a * D + l * R + c * j,
        s[12] = o * I + a * T + l * F + c * Q,
        s[1] = A * b + u * M + f * y + h * O,
        s[5] = A * B + u * L + f * E + h * z,
        s[9] = A * S + u * D + f * R + h * j,
        s[13] = A * I + u * T + f * F + h * Q,
        s[2] = d * b + m * M + g * y + p * O,
        s[6] = d * B + m * L + g * E + p * z,
        s[10] = d * S + m * D + g * R + p * j,
        s[14] = d * I + m * T + g * F + p * Q,
        s[3] = v * b + w * M + _ * y + x * O,
        s[7] = v * B + w * L + _ * E + x * z,
        s[11] = v * S + w * D + _ * R + x * j,
        s[15] = v * I + w * T + _ * F + x * Q,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[4]
          , i = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , A = e[2]
          , u = e[6]
          , f = e[10]
          , h = e[14]
          , d = e[3]
          , m = e[7]
          , g = e[11]
          , p = e[15];
        return d * (+s * l * u - i * c * u - s * a * f + r * c * f + i * a * h - r * l * h) + m * (+t * l * h - t * c * f + s * o * f - i * o * h + i * c * A - s * l * A) + g * (+t * c * u - t * a * h - s * o * u + r * o * h + s * a * A - r * c * A) + p * (-i * a * A - t * l * u + t * a * f + i * o * u - r * o * f + r * l * A)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, r) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = r),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , i = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , A = e[8]
          , u = e[9]
          , f = e[10]
          , h = e[11]
          , d = e[12]
          , m = e[13]
          , g = e[14]
          , p = e[15]
          , v = u * g * c - m * f * c + m * l * h - a * g * h - u * l * p + a * f * p
          , w = d * f * c - A * g * c - d * l * h + o * g * h + A * l * p - o * f * p
          , _ = A * m * c - d * u * c + d * a * h - o * m * h - A * a * p + o * u * p
          , x = d * u * l - A * m * l - d * a * f + o * m * f + A * a * g - o * u * g
          , b = t * v + r * w + i * _ + s * x;
        if (b === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const B = 1 / b;
        return e[0] = v * B,
        e[1] = (m * f * s - u * g * s - m * i * h + r * g * h + u * i * p - r * f * p) * B,
        e[2] = (a * g * s - m * l * s + m * i * c - r * g * c - a * i * p + r * l * p) * B,
        e[3] = (u * l * s - a * f * s - u * i * c + r * f * c + a * i * h - r * l * h) * B,
        e[4] = w * B,
        e[5] = (A * g * s - d * f * s + d * i * h - t * g * h - A * i * p + t * f * p) * B,
        e[6] = (d * l * s - o * g * s - d * i * c + t * g * c + o * i * p - t * l * p) * B,
        e[7] = (o * f * s - A * l * s + A * i * c - t * f * c - o * i * h + t * l * h) * B,
        e[8] = _ * B,
        e[9] = (d * u * s - A * m * s - d * r * h + t * m * h + A * r * p - t * u * p) * B,
        e[10] = (o * m * s - d * a * s + d * r * c - t * m * c - o * r * p + t * a * p) * B,
        e[11] = (A * a * s - o * u * s - A * r * c + t * u * c + o * r * h - t * a * h) * B,
        e[12] = x * B,
        e[13] = (A * m * i - d * u * i + d * r * f - t * m * f - A * r * g + t * u * g) * B,
        e[14] = (d * a * i - o * m * i - d * r * l + t * m * l + o * r * g - t * a * g) * B,
        e[15] = (o * u * i - A * a * i + A * r * l - t * u * l - o * r * f + t * a * f) * B,
        this
    }
    scale(e) {
        const t = this.elements
          , r = e.x
          , i = e.y
          , s = e.z;
        return t[0] *= r,
        t[4] *= i,
        t[8] *= s,
        t[1] *= r,
        t[5] *= i,
        t[9] *= s,
        t[2] *= r,
        t[6] *= i,
        t[10] *= s,
        t[3] *= r,
        t[7] *= i,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, r, i))
    }
    makeTranslation(e, t, r) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const r = Math.cos(t)
          , i = Math.sin(t)
          , s = 1 - r
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , A = s * a;
        return this.set(c * o + r, c * a - i * l, c * l + i * a, 0, c * a + i * l, A * a + r, A * l - i * o, 0, c * l - i * a, A * l + i * o, s * l * l + r, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, r) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, r, i, s, o) {
        return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, r) {
        const i = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , A = o + o
          , u = a + a
          , f = s * c
          , h = s * A
          , d = s * u
          , m = o * A
          , g = o * u
          , p = a * u
          , v = l * c
          , w = l * A
          , _ = l * u
          , x = r.x
          , b = r.y
          , B = r.z;
        return i[0] = (1 - (m + p)) * x,
        i[1] = (h + _) * x,
        i[2] = (d - w) * x,
        i[3] = 0,
        i[4] = (h - _) * b,
        i[5] = (1 - (f + p)) * b,
        i[6] = (g + v) * b,
        i[7] = 0,
        i[8] = (d + w) * B,
        i[9] = (g - v) * B,
        i[10] = (1 - (f + m)) * B,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, r) {
        const i = this.elements;
        let s = df.set(i[0], i[1], i[2]).length();
        const o = df.set(i[4], i[5], i[6]).length()
          , a = df.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Do.copy(this);
        const c = 1 / s
          , A = 1 / o
          , u = 1 / a;
        return Do.elements[0] *= c,
        Do.elements[1] *= c,
        Do.elements[2] *= c,
        Do.elements[4] *= A,
        Do.elements[5] *= A,
        Do.elements[6] *= A,
        Do.elements[8] *= u,
        Do.elements[9] *= u,
        Do.elements[10] *= u,
        t.setFromRotationMatrix(Do),
        r.x = s,
        r.y = o,
        r.z = a,
        this
    }
    makePerspective(e, t, r, i, s, o, a=zl) {
        const l = this.elements
          , c = 2 * s / (t - e)
          , A = 2 * s / (r - i)
          , u = (t + e) / (t - e)
          , f = (r + i) / (r - i);
        let h, d;
        if (a === zl)
            h = -(o + s) / (o - s),
            d = -2 * o * s / (o - s);
        else if (a === O_)
            h = -o / (o - s),
            d = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = u,
        l[12] = 0,
        l[1] = 0,
        l[5] = A,
        l[9] = f,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = h,
        l[14] = d,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, r, i, s, o, a=zl) {
        const l = this.elements
          , c = 1 / (t - e)
          , A = 1 / (r - i)
          , u = 1 / (o - s)
          , f = (t + e) * c
          , h = (r + i) * A;
        let d, m;
        if (a === zl)
            d = (o + s) * u,
            m = -2 * u;
        else if (a === O_)
            d = s * u,
            m = -1 * u;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -f,
        l[1] = 0,
        l[5] = 2 * A,
        l[9] = 0,
        l[13] = -h,
        l[2] = 0,
        l[6] = 0,
        l[10] = m,
        l[14] = -d,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== r[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 16; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e[t + 9] = r[9],
        e[t + 10] = r[10],
        e[t + 11] = r[11],
        e[t + 12] = r[12],
        e[t + 13] = r[13],
        e[t + 14] = r[14],
        e[t + 15] = r[15],
        e
    }
}
const df = new $
  , Do = new He
  , cee = new $(0,0,0)
  , Aee = new $(1,1,1)
  , xc = new $
  , gv = new $
  , ps = new $
  , fL = new He
  , hL = new nt;
class nr {
    constructor(e=0, t=0, r=0, i=nr.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, r, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, r=!0) {
        const i = e.elements
          , s = i[0]
          , o = i[4]
          , a = i[8]
          , l = i[1]
          , c = i[5]
          , A = i[9]
          , u = i[2]
          , f = i[6]
          , h = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(pr(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-A, h),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-pr(A, -1, 1)),
            Math.abs(A) < .9999999 ? (this._y = Math.atan2(a, h),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(pr(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-u, h),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-pr(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(f, h),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(pr(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-A, c),
            this._y = Math.atan2(-u, s)) : (this._x = 0,
            this._y = Math.atan2(a, h));
            break;
        case "XZY":
            this._z = Math.asin(-pr(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-A, h),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        r === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, r) {
        return fL.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(fL, t, r)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return hL.setFromEuler(this),
        this.setFromQuaternion(hL, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
nr.DEFAULT_ORDER = "XYZ";
class OR {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let uee = 0;
const dL = new $
  , pf = new nt
  , dl = new He
  , vv = new $
  , Up = new $
  , fee = new $
  , hee = new nt
  , pL = new $(1,0,0)
  , mL = new $(0,1,0)
  , gL = new $(0,0,1)
  , vL = {
    type: "added"
}
  , dee = {
    type: "removed"
}
  , mf = {
    type: "childadded",
    child: null
}
  , ME = {
    type: "childremoved",
    child: null
};
class Lt extends UA {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: uee++
        }),
        this.uuid = ia(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Lt.DEFAULT_UP.clone();
        const e = new $
          , t = new nr
          , r = new nt
          , i = new $(1,1,1);
        function s() {
            r.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(r, void 0, !1)
        }
        t._onChange(s),
        r._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new He
            },
            normalMatrix: {
                value: new dt
            }
        }),
        this.matrix = new He,
        this.matrixWorld = new He,
        this.matrixAutoUpdate = Lt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = Lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new OR,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return pf.setFromAxisAngle(e, t),
        this.quaternion.multiply(pf),
        this
    }
    rotateOnWorldAxis(e, t) {
        return pf.setFromAxisAngle(e, t),
        this.quaternion.premultiply(pf),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(pL, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(mL, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(gL, e)
    }
    translateOnAxis(e, t) {
        return dL.copy(e).applyQuaternion(this.quaternion),
        this.position.add(dL.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(pL, e)
    }
    translateY(e) {
        return this.translateOnAxis(mL, e)
    }
    translateZ(e) {
        return this.translateOnAxis(gL, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(dl.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, r) {
        e.isVector3 ? vv.copy(e) : vv.set(e, t, r);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        Up.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? dl.lookAt(Up, vv, this.up) : dl.lookAt(vv, Up, this.up),
        this.quaternion.setFromRotationMatrix(dl),
        i && (dl.extractRotation(i.matrixWorld),
        pf.setFromRotationMatrix(dl),
        this.quaternion.premultiply(pf.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(vL),
        mf.child = e,
        this.dispatchEvent(mf),
        mf.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(dee),
        ME.child = e,
        this.dispatchEvent(ME),
        ME.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        dl.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        dl.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(dl),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(vL),
        mf.child = e,
        this.dispatchEvent(mf),
        mf.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let r = 0, i = this.children.length; r < i; r++) {
            const o = this.children[r].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, r=[]) {
        this[e] === t && r.push(this);
        const i = this.children;
        for (let s = 0, o = i.length; s < o; s++)
            i[s].getObjectsByProperty(e, t, r);
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Up, e, fee),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Up, hee, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let r = 0, i = t.length; r < i; r++)
            t[r].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const r = this.parent;
        if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++)
                i[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , r = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        r.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh",
        i.perObjectFrustumCulled = this.perObjectFrustumCulled,
        i.sortObjects = this.sortObjects,
        i.drawRanges = this._drawRanges,
        i.reservedRanges = this._reservedRanges,
        i.visibility = this._visibility,
        i.active = this._active,
        i.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        i.maxInstanceCount = this._maxInstanceCount,
        i.maxVertexCount = this._maxVertexCount,
        i.maxIndexCount = this._maxIndexCount,
        i.geometryInitialized = this._geometryInitialized,
        i.geometryCount = this._geometryCount,
        i.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius
        }),
        this.boundingBox !== null && (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray()
        }));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, A = l.length; c < A; c++) {
                        const u = l[c];
                        s(e.shapes, u)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                i.material = a
            } else
                i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , A = o(e.images)
              , u = o(e.shapes)
              , f = o(e.skeletons)
              , h = o(e.animations)
              , d = o(e.nodes);
            a.length > 0 && (r.geometries = a),
            l.length > 0 && (r.materials = l),
            c.length > 0 && (r.textures = c),
            A.length > 0 && (r.images = A),
            u.length > 0 && (r.shapes = u),
            f.length > 0 && (r.skeletons = f),
            h.length > 0 && (r.animations = h),
            d.length > 0 && (r.nodes = d)
        }
        return r.object = i,
        r;
        function o(a) {
            const l = [];
            for (const c in a) {
                const A = a[c];
                delete A.metadata,
                l.push(A)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let r = 0; r < e.children.length; r++) {
                const i = e.children[r];
                this.add(i.clone())
            }
        return this
    }
}
Lt.DEFAULT_UP = new $(0,1,0);
Lt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const No = new $
  , pl = new $
  , SE = new $
  , ml = new $
  , gf = new $
  , vf = new $
  , yL = new $
  , CE = new $
  , TE = new $
  , IE = new $
  , RE = new Pt
  , UE = new Pt
  , FE = new Pt;
class Kr {
    constructor(e=new $, t=new $, r=new $) {
        this.a = e,
        this.b = t,
        this.c = r
    }
    static getNormal(e, t, r, i) {
        i.subVectors(r, t),
        No.subVectors(e, t),
        i.cross(No);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, r, i, s) {
        No.subVectors(i, t),
        pl.subVectors(r, t),
        SE.subVectors(e, t);
        const o = No.dot(No)
          , a = No.dot(pl)
          , l = No.dot(SE)
          , c = pl.dot(pl)
          , A = pl.dot(SE)
          , u = o * c - a * a;
        if (u === 0)
            return s.set(0, 0, 0),
            null;
        const f = 1 / u
          , h = (c * l - a * A) * f
          , d = (o * A - a * l) * f;
        return s.set(1 - h - d, d, h)
    }
    static containsPoint(e, t, r, i) {
        return this.getBarycoord(e, t, r, i, ml) === null ? !1 : ml.x >= 0 && ml.y >= 0 && ml.x + ml.y <= 1
    }
    static getInterpolation(e, t, r, i, s, o, a, l) {
        return this.getBarycoord(e, t, r, i, ml) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(s, ml.x),
        l.addScaledVector(o, ml.y),
        l.addScaledVector(a, ml.z),
        l)
    }
    static getInterpolatedAttribute(e, t, r, i, s, o) {
        return RE.setScalar(0),
        UE.setScalar(0),
        FE.setScalar(0),
        RE.fromBufferAttribute(e, t),
        UE.fromBufferAttribute(e, r),
        FE.fromBufferAttribute(e, i),
        o.setScalar(0),
        o.addScaledVector(RE, s.x),
        o.addScaledVector(UE, s.y),
        o.addScaledVector(FE, s.z),
        o
    }
    static isFrontFacing(e, t, r, i) {
        return No.subVectors(r, t),
        pl.subVectors(e, t),
        No.cross(pl).dot(i) < 0
    }
    set(e, t, r) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(r),
        this
    }
    setFromPointsAndIndices(e, t, r, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[r]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, r, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return No.subVectors(this.c, this.b),
        pl.subVectors(this.a, this.b),
        No.cross(pl).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Kr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Kr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, r, i, s) {
        return Kr.getInterpolation(e, this.a, this.b, this.c, t, r, i, s)
    }
    containsPoint(e) {
        return Kr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Kr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const r = this.a
          , i = this.b
          , s = this.c;
        let o, a;
        gf.subVectors(i, r),
        vf.subVectors(s, r),
        CE.subVectors(e, r);
        const l = gf.dot(CE)
          , c = vf.dot(CE);
        if (l <= 0 && c <= 0)
            return t.copy(r);
        TE.subVectors(e, i);
        const A = gf.dot(TE)
          , u = vf.dot(TE);
        if (A >= 0 && u <= A)
            return t.copy(i);
        const f = l * u - A * c;
        if (f <= 0 && l >= 0 && A <= 0)
            return o = l / (l - A),
            t.copy(r).addScaledVector(gf, o);
        IE.subVectors(e, s);
        const h = gf.dot(IE)
          , d = vf.dot(IE);
        if (d >= 0 && h <= d)
            return t.copy(s);
        const m = h * c - l * d;
        if (m <= 0 && c >= 0 && d <= 0)
            return a = c / (c - d),
            t.copy(r).addScaledVector(vf, a);
        const g = A * d - h * u;
        if (g <= 0 && u - A >= 0 && h - d >= 0)
            return yL.subVectors(s, i),
            a = (u - A) / (u - A + (h - d)),
            t.copy(i).addScaledVector(yL, a);
        const p = 1 / (g + m + f);
        return o = m * p,
        a = f * p,
        t.copy(r).addScaledVector(gf, o).addScaledVector(vf, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Ez = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , bc = {
    h: 0,
    s: 0,
    l: 0
}
  , yv = {
    h: 0,
    s: 0,
    l: 0
};
function PE(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Qe {
    constructor(e, t, r) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, r)
    }
    set(e, t, r) {
        if (t === void 0 && r === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(e, t, r);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Ut) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        Et.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, r, i=Et.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = r,
        Et.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, r, i=Et.workingColorSpace) {
        if (e = DR(e, 1),
        t = pr(t, 0, 1),
        r = pr(r, 0, 1),
        t === 0)
            this.r = this.g = this.b = r;
        else {
            const s = r <= .5 ? r * (1 + t) : r + t - r * t
              , o = 2 * r - s;
            this.r = PE(o, s, e + 1 / 3),
            this.g = PE(o, s, e),
            this.b = PE(o, s, e - 1 / 3)
        }
        return Et.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=Ut) {
        function r(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1]
              , a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return r(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return r(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return r(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Ut) {
        const r = Ez[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = od(e.r),
        this.g = od(e.g),
        this.b = od(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = vE(e.r),
        this.g = vE(e.g),
        this.b = vE(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Ut) {
        return Et.fromWorkingColorSpace(hi.copy(this), e),
        Math.round(pr(hi.r * 255, 0, 255)) * 65536 + Math.round(pr(hi.g * 255, 0, 255)) * 256 + Math.round(pr(hi.b * 255, 0, 255))
    }
    getHexString(e=Ut) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=Et.workingColorSpace) {
        Et.fromWorkingColorSpace(hi.copy(this), t);
        const r = hi.r
          , i = hi.g
          , s = hi.b
          , o = Math.max(r, i, s)
          , a = Math.min(r, i, s);
        let l, c;
        const A = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const u = o - a;
            switch (c = A <= .5 ? u / (o + a) : u / (2 - o - a),
            o) {
            case r:
                l = (i - s) / u + (i < s ? 6 : 0);
                break;
            case i:
                l = (s - r) / u + 2;
                break;
            case s:
                l = (r - i) / u + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = A,
        e
    }
    getRGB(e, t=Et.workingColorSpace) {
        return Et.fromWorkingColorSpace(hi.copy(this), t),
        e.r = hi.r,
        e.g = hi.g,
        e.b = hi.b,
        e
    }
    getStyle(e=Ut) {
        Et.fromWorkingColorSpace(hi.copy(this), e);
        const t = hi.r
          , r = hi.g
          , i = hi.b;
        return e !== Ut ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(e, t, r) {
        return this.getHSL(bc),
        this.setHSL(bc.h + e, bc.s + t, bc.l + r)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, r) {
        return this.r = e.r + (t.r - e.r) * r,
        this.g = e.g + (t.g - e.g) * r,
        this.b = e.b + (t.b - e.b) * r,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(bc),
        e.getHSL(yv);
        const r = tg(bc.h, yv.h, t)
          , i = tg(bc.s, yv.s, t)
          , s = tg(bc.l, yv.l, t);
        return this.setHSL(r, i, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , r = this.g
          , i = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * r + s[6] * i,
        this.g = s[1] * t + s[4] * r + s[7] * i,
        this.b = s[2] * t + s[5] * r + s[8] * i,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const hi = new Qe;
Qe.NAMES = Ez;
let pee = 0
  , as = class extends UA {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: pee++
        }),
        this.uuid = ia(),
        this.name = "",
        this.type = "Material",
        this.blending = id,
        this.side = Hs,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = YS,
        this.blendDst = $S,
        this.blendEquation = au,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Qe(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Td,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = sL,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = cf,
        this.stencilZFail = cf,
        this.stencilZPass = cf,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const r = e[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (r.dispersion = this.dispersion),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
        r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
        r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
        r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
        r.normalMapType = this.normalMapType,
        r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
        r.displacementScale = this.displacementScale,
        r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== id && (r.blending = this.blending),
        this.side !== Hs && (r.side = this.side),
        this.vertexColors === !0 && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = !0),
        this.blendSrc !== YS && (r.blendSrc = this.blendSrc),
        this.blendDst !== $S && (r.blendDst = this.blendDst),
        this.blendEquation !== au && (r.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
        this.depthFunc !== Td && (r.depthFunc = this.depthFunc),
        this.depthTest === !1 && (r.depthTest = this.depthTest),
        this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== sL && (r.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== cf && (r.stencilFail = this.stencilFail),
        this.stencilZFail !== cf && (r.stencilZFail = this.stencilZFail),
        this.stencilZPass !== cf && (r.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (r.alphaHash = !0),
        this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (r.forceSinglePass = !0),
        this.wireframe === !0 && (r.wireframe = !0),
        this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = !0),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData);
        function i(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = i(e.textures)
              , o = i(e.images);
            s.length > 0 && (r.textures = s),
            o.length > 0 && (r.images = o)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let r = null;
        if (t !== null) {
            const i = t.length;
            r = new Array(i);
            for (let s = 0; s !== i; ++s)
                r[s] = t[s].clone()
        }
        return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
;
class qi extends as {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Qe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new nr,
        this.combine = l1,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Dl = mee();
function mee() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , r = new Uint32Array(512)
      , i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (r[l] = 0,
        r[l | 256] = 32768,
        i[l] = 24,
        i[l | 256] = 24) : c < -14 ? (r[l] = 1024 >> -c - 14,
        r[l | 256] = 1024 >> -c - 14 | 32768,
        i[l] = -c - 1,
        i[l | 256] = -c - 1) : c <= 15 ? (r[l] = c + 15 << 10,
        r[l | 256] = c + 15 << 10 | 32768,
        i[l] = 13,
        i[l | 256] = 13) : c < 128 ? (r[l] = 31744,
        r[l | 256] = 64512,
        i[l] = 24,
        i[l | 256] = 24) : (r[l] = 31744,
        r[l | 256] = 64512,
        i[l] = 13,
        i[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , A = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            A -= 8388608;
        c &= -8388609,
        A += 947912704,
        s[l] = c | A
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: r,
        shiftTable: i,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function gee(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = pr(n, -65504, 65504),
    Dl.floatView[0] = n;
    const e = Dl.uint32View[0]
      , t = e >> 23 & 511;
    return Dl.baseTable[t] + ((e & 8388607) >> Dl.shiftTable[t])
}
function vee(n) {
    const e = n >> 10;
    return Dl.uint32View[0] = Dl.mantissaTable[Dl.offsetTable[e] + (n & 1023)] + Dl.exponentTable[e],
    Dl.floatView[0]
}
const wv = {
    toHalfFloat: gee,
    fromHalfFloat: vee
}
  , gr = new $
  , _v = new We;
class ct {
    constructor(e, t, r=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = r,
        this.usage = UC,
        this.updateRanges = [],
        this.gpuType = xi,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, r) {
        e *= this.itemSize,
        r *= t.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++)
            this.array[e + i] = t.array[r + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, r = this.count; t < r; t++)
                _v.fromBufferAttribute(this, t),
                _v.applyMatrix3(e),
                this.setXY(t, _v.x, _v.y);
        else if (this.itemSize === 3)
            for (let t = 0, r = this.count; t < r; t++)
                gr.fromBufferAttribute(this, t),
                gr.applyMatrix3(e),
                this.setXYZ(t, gr.x, gr.y, gr.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.count; t < r; t++)
            gr.fromBufferAttribute(this, t),
            gr.applyMatrix4(e),
            this.setXYZ(t, gr.x, gr.y, gr.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            gr.fromBufferAttribute(this, t),
            gr.applyNormalMatrix(e),
            this.setXYZ(t, gr.x, gr.y, gr.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            gr.fromBufferAttribute(this, t),
            gr.transformDirection(e),
            this.setXYZ(t, gr.x, gr.y, gr.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let r = this.array[e * this.itemSize + t];
        return this.normalized && (r = Zo(r, this.array)),
        r
    }
    setComponent(e, t, r) {
        return this.normalized && (r = hn(r, this.array)),
        this.array[e * this.itemSize + t] = r,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, r) {
        return e *= this.itemSize,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, i) {
        return e *= this.itemSize,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array),
        i = hn(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, r, i, s) {
        return e *= this.itemSize,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array),
        i = hn(i, this.array),
        s = hn(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = i,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== UC && (e.usage = this.usage),
        e
    }
}
class f1 extends ct {
    constructor(e, t, r) {
        super(new Uint16Array(e), t, r)
    }
}
class Bz extends ct {
    constructor(e, t, r) {
        super(new Uint32Array(e), t, r)
    }
}
class xn extends ct {
    constructor(e, t, r) {
        super(new Float32Array(e), t, r)
    }
}
let yee = 0;
const $s = new He
  , LE = new Lt
  , yf = new $
  , ms = new Hn
  , Fp = new Hn
  , Qr = new $;
class Jt extends UA {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: yee++
        }),
        this.uuid = ia(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (xz(e) ? Bz : f1)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, r=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const s = new dt().getNormalMatrix(e);
            r.applyNormalMatrix(s),
            r.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return $s.makeRotationFromQuaternion(e),
        this.applyMatrix4($s),
        this
    }
    rotateX(e) {
        return $s.makeRotationX(e),
        this.applyMatrix4($s),
        this
    }
    rotateY(e) {
        return $s.makeRotationY(e),
        this.applyMatrix4($s),
        this
    }
    rotateZ(e) {
        return $s.makeRotationZ(e),
        this.applyMatrix4($s),
        this
    }
    translate(e, t, r) {
        return $s.makeTranslation(e, t, r),
        this.applyMatrix4($s),
        this
    }
    scale(e, t, r) {
        return $s.makeScale(e, t, r),
        this.applyMatrix4($s),
        this
    }
    lookAt(e) {
        return LE.lookAt(e),
        LE.updateMatrix(),
        this.applyMatrix4(LE.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(yf).negate(),
        this.translate(yf.x, yf.y, yf.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let r = 0, i = e.length; r < i; r++) {
            const s = e[r];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new xn(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Hn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new $(-1 / 0,-1 / 0,-1 / 0), new $(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let r = 0, i = t.length; r < i; r++) {
                    const s = t[r];
                    ms.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? (Qr.addVectors(this.boundingBox.min, ms.min),
                    this.boundingBox.expandByPoint(Qr),
                    Qr.addVectors(this.boundingBox.max, ms.max),
                    this.boundingBox.expandByPoint(Qr)) : (this.boundingBox.expandByPoint(ms.min),
                    this.boundingBox.expandByPoint(ms.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Mi);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new $, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (ms.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Fp.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Qr.addVectors(ms.min, Fp.min),
                    ms.expandByPoint(Qr),
                    Qr.addVectors(ms.max, Fp.max),
                    ms.expandByPoint(Qr)) : (ms.expandByPoint(Fp.min),
                    ms.expandByPoint(Fp.max))
                }
            ms.getCenter(r);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++)
                Qr.fromBufferAttribute(e, s),
                i = Math.max(i, r.distanceToSquared(Qr));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, A = a.count; c < A; c++)
                        Qr.fromBufferAttribute(a, c),
                        l && (yf.fromBufferAttribute(e, c),
                        Qr.add(yf)),
                        i = Math.max(i, r.distanceToSquared(Qr))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = t.position
          , i = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ct(new Float32Array(4 * r.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let S = 0; S < r.count; S++)
            a[S] = new $,
            l[S] = new $;
        const c = new $
          , A = new $
          , u = new $
          , f = new We
          , h = new We
          , d = new We
          , m = new $
          , g = new $;
        function p(S, I, M) {
            c.fromBufferAttribute(r, S),
            A.fromBufferAttribute(r, I),
            u.fromBufferAttribute(r, M),
            f.fromBufferAttribute(s, S),
            h.fromBufferAttribute(s, I),
            d.fromBufferAttribute(s, M),
            A.sub(c),
            u.sub(c),
            h.sub(f),
            d.sub(f);
            const L = 1 / (h.x * d.y - d.x * h.y);
            isFinite(L) && (m.copy(A).multiplyScalar(d.y).addScaledVector(u, -h.y).multiplyScalar(L),
            g.copy(u).multiplyScalar(h.x).addScaledVector(A, -d.x).multiplyScalar(L),
            a[S].add(m),
            a[I].add(m),
            a[M].add(m),
            l[S].add(g),
            l[I].add(g),
            l[M].add(g))
        }
        let v = this.groups;
        v.length === 0 && (v = [{
            start: 0,
            count: e.count
        }]);
        for (let S = 0, I = v.length; S < I; ++S) {
            const M = v[S]
              , L = M.start
              , D = M.count;
            for (let T = L, y = L + D; T < y; T += 3)
                p(e.getX(T + 0), e.getX(T + 1), e.getX(T + 2))
        }
        const w = new $
          , _ = new $
          , x = new $
          , b = new $;
        function B(S) {
            x.fromBufferAttribute(i, S),
            b.copy(x);
            const I = a[S];
            w.copy(I),
            w.sub(x.multiplyScalar(x.dot(I))).normalize(),
            _.crossVectors(b, I);
            const L = _.dot(l[S]) < 0 ? -1 : 1;
            o.setXYZW(S, w.x, w.y, w.z, L)
        }
        for (let S = 0, I = v.length; S < I; ++S) {
            const M = v[S]
              , L = M.start
              , D = M.count;
            for (let T = L, y = L + D; T < y; T += 3)
                B(e.getX(T + 0)),
                B(e.getX(T + 1)),
                B(e.getX(T + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0)
                r = new ct(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", r);
            else
                for (let f = 0, h = r.count; f < h; f++)
                    r.setXYZ(f, 0, 0, 0);
            const i = new $
              , s = new $
              , o = new $
              , a = new $
              , l = new $
              , c = new $
              , A = new $
              , u = new $;
            if (e)
                for (let f = 0, h = e.count; f < h; f += 3) {
                    const d = e.getX(f + 0)
                      , m = e.getX(f + 1)
                      , g = e.getX(f + 2);
                    i.fromBufferAttribute(t, d),
                    s.fromBufferAttribute(t, m),
                    o.fromBufferAttribute(t, g),
                    A.subVectors(o, s),
                    u.subVectors(i, s),
                    A.cross(u),
                    a.fromBufferAttribute(r, d),
                    l.fromBufferAttribute(r, m),
                    c.fromBufferAttribute(r, g),
                    a.add(A),
                    l.add(A),
                    c.add(A),
                    r.setXYZ(d, a.x, a.y, a.z),
                    r.setXYZ(m, l.x, l.y, l.z),
                    r.setXYZ(g, c.x, c.y, c.z)
                }
            else
                for (let f = 0, h = t.count; f < h; f += 3)
                    i.fromBufferAttribute(t, f + 0),
                    s.fromBufferAttribute(t, f + 1),
                    o.fromBufferAttribute(t, f + 2),
                    A.subVectors(o, s),
                    u.subVectors(i, s),
                    A.cross(u),
                    r.setXYZ(f + 0, A.x, A.y, A.z),
                    r.setXYZ(f + 1, A.x, A.y, A.z),
                    r.setXYZ(f + 2, A.x, A.y, A.z);
            this.normalizeNormals(),
            r.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, r = e.count; t < r; t++)
            Qr.fromBufferAttribute(e, t),
            Qr.normalize(),
            e.setXYZ(t, Qr.x, Qr.y, Qr.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , A = a.itemSize
              , u = a.normalized
              , f = new c.constructor(l.length * A);
            let h = 0
              , d = 0;
            for (let m = 0, g = l.length; m < g; m++) {
                a.isInterleavedBufferAttribute ? h = l[m] * a.data.stride + a.offset : h = l[m] * A;
                for (let p = 0; p < A; p++)
                    f[d++] = c[h++]
            }
            return new ct(f,A,u)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Jt
          , r = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const l = i[a]
              , c = e(l, r);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let A = 0, u = c.length; A < u; A++) {
                const f = c[A]
                  , h = e(f, r);
                l.push(h)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const r = this.attributes;
        for (const l in r) {
            const c = r[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , A = [];
            for (let u = 0, f = c.length; u < f; u++) {
                const h = c[u];
                A.push(h.toJSON(e.data))
            }
            A.length > 0 && (i[l] = A,
            s = !0)
        }
        s && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone(t));
        const i = e.attributes;
        for (const c in i) {
            const A = i[c];
            this.setAttribute(c, A.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const A = []
              , u = s[c];
            for (let f = 0, h = u.length; f < h; f++)
                A.push(u[f].clone(t));
            this.morphAttributes[c] = A
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, A = o.length; c < A; c++) {
            const u = o[c];
            this.addGroup(u.start, u.count, u.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const wL = new He
  , QA = new $u
  , xv = new Mi
  , _L = new $
  , bv = new $
  , Ev = new $
  , Bv = new $
  , DE = new $
  , Mv = new $
  , xL = new $
  , Sv = new $;
class dn extends Lt {
    constructor(e=new Jt, t=new qi) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const r = this.geometry
          , i = r.attributes.position
          , s = r.morphAttributes.position
          , o = r.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Mv.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const A = a[l]
                  , u = s[l];
                A !== 0 && (DE.fromBufferAttribute(u, e),
                o ? Mv.addScaledVector(DE, A) : Mv.addScaledVector(DE.sub(t), A))
            }
            t.add(Mv)
        }
        return t
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.material
          , s = this.matrixWorld;
        i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(),
        xv.copy(r.boundingSphere),
        xv.applyMatrix4(s),
        QA.copy(e.ray).recast(e.near),
        !(xv.containsPoint(QA.origin) === !1 && (QA.intersectSphere(xv, _L) === null || QA.origin.distanceToSquared(_L) > (e.far - e.near) ** 2)) && (wL.copy(s).invert(),
        QA.copy(e.ray).applyMatrix4(wL),
        !(r.boundingBox !== null && QA.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, QA)))
    }
    _computeIntersections(e, t, r) {
        let i;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , l = s.attributes.position
          , c = s.attributes.uv
          , A = s.attributes.uv1
          , u = s.attributes.normal
          , f = s.groups
          , h = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let d = 0, m = f.length; d < m; d++) {
                    const g = f[d]
                      , p = o[g.materialIndex]
                      , v = Math.max(g.start, h.start)
                      , w = Math.min(a.count, Math.min(g.start + g.count, h.start + h.count));
                    for (let _ = v, x = w; _ < x; _ += 3) {
                        const b = a.getX(_)
                          , B = a.getX(_ + 1)
                          , S = a.getX(_ + 2);
                        i = Cv(this, p, e, r, c, A, u, b, B, S),
                        i && (i.faceIndex = Math.floor(_ / 3),
                        i.face.materialIndex = g.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const d = Math.max(0, h.start)
                  , m = Math.min(a.count, h.start + h.count);
                for (let g = d, p = m; g < p; g += 3) {
                    const v = a.getX(g)
                      , w = a.getX(g + 1)
                      , _ = a.getX(g + 2);
                    i = Cv(this, o, e, r, c, A, u, v, w, _),
                    i && (i.faceIndex = Math.floor(g / 3),
                    t.push(i))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let d = 0, m = f.length; d < m; d++) {
                    const g = f[d]
                      , p = o[g.materialIndex]
                      , v = Math.max(g.start, h.start)
                      , w = Math.min(l.count, Math.min(g.start + g.count, h.start + h.count));
                    for (let _ = v, x = w; _ < x; _ += 3) {
                        const b = _
                          , B = _ + 1
                          , S = _ + 2;
                        i = Cv(this, p, e, r, c, A, u, b, B, S),
                        i && (i.faceIndex = Math.floor(_ / 3),
                        i.face.materialIndex = g.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const d = Math.max(0, h.start)
                  , m = Math.min(l.count, h.start + h.count);
                for (let g = d, p = m; g < p; g += 3) {
                    const v = g
                      , w = g + 1
                      , _ = g + 2;
                    i = Cv(this, o, e, r, c, A, u, v, w, _),
                    i && (i.faceIndex = Math.floor(g / 3),
                    t.push(i))
                }
            }
    }
}
function wee(n, e, t, r, i, s, o, a) {
    let l;
    if (e.side === oi ? l = r.intersectTriangle(o, s, i, !0, a) : l = r.intersectTriangle(i, s, o, e.side === Hs, a),
    l === null)
        return null;
    Sv.copy(a),
    Sv.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(Sv);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Sv.clone(),
        object: n
    }
}
function Cv(n, e, t, r, i, s, o, a, l, c) {
    n.getVertexPosition(a, bv),
    n.getVertexPosition(l, Ev),
    n.getVertexPosition(c, Bv);
    const A = wee(n, e, t, r, bv, Ev, Bv, xL);
    if (A) {
        const u = new $;
        Kr.getBarycoord(xL, bv, Ev, Bv, u),
        i && (A.uv = Kr.getInterpolatedAttribute(i, a, l, c, u, new We)),
        s && (A.uv1 = Kr.getInterpolatedAttribute(s, a, l, c, u, new We)),
        o && (A.normal = Kr.getInterpolatedAttribute(o, a, l, c, u, new $),
        A.normal.dot(r.direction) > 0 && A.normal.multiplyScalar(-1));
        const f = {
            a,
            b: l,
            c,
            normal: new $,
            materialIndex: 0
        };
        Kr.getNormal(bv, Ev, Bv, f.normal),
        A.face = f,
        A.barycoord = u
    }
    return A
}
class g0 extends Jt {
    constructor(e=1, t=1, r=1, i=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , A = []
          , u = [];
        let f = 0
          , h = 0;
        d("z", "y", "x", -1, -1, r, t, e, o, s, 0),
        d("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
        d("x", "z", "y", 1, 1, e, r, t, i, o, 2),
        d("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
        d("x", "y", "z", 1, -1, e, t, r, i, s, 4),
        d("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new xn(c,3)),
        this.setAttribute("normal", new xn(A,3)),
        this.setAttribute("uv", new xn(u,2));
        function d(m, g, p, v, w, _, x, b, B, S, I) {
            const M = _ / B
              , L = x / S
              , D = _ / 2
              , T = x / 2
              , y = b / 2
              , E = B + 1
              , R = S + 1;
            let F = 0
              , O = 0;
            const z = new $;
            for (let j = 0; j < R; j++) {
                const Q = j * L - T;
                for (let C = 0; C < E; C++) {
                    const W = C * M - D;
                    z[m] = W * v,
                    z[g] = Q * w,
                    z[p] = y,
                    c.push(z.x, z.y, z.z),
                    z[m] = 0,
                    z[g] = 0,
                    z[p] = b > 0 ? 1 : -1,
                    A.push(z.x, z.y, z.z),
                    u.push(C / B),
                    u.push(1 - j / S),
                    F += 1
                }
            }
            for (let j = 0; j < S; j++)
                for (let Q = 0; Q < B; Q++) {
                    const C = f + Q + E * j
                      , W = f + Q + E * (j + 1)
                      , ee = f + (Q + 1) + E * (j + 1)
                      , P = f + (Q + 1) + E * j;
                    l.push(C, W, P),
                    l.push(W, ee, P),
                    O += 6
                }
            a.addGroup(h, O, I),
            h += O,
            f += F
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new g0(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function Nd(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const r in n[t]) {
            const i = n[t][r];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][r] = null) : e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i
        }
    }
    return e
}
function Ui(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const r = Nd(n[t]);
        for (const i in r)
            e[i] = r[i]
    }
    return e
}
function _ee(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function Mz(n) {
    const e = n.getRenderTarget();
    return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Et.workingColorSpace
}
const kR = {
    clone: Nd,
    merge: Ui
};
var xee = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , bee = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class mr extends as {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = xee,
        this.fragmentShader = bee,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Nd(e.uniforms),
        this.uniformsGroups = _ee(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const r = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (r[i] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
}
class Sz extends Lt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new He,
        this.projectionMatrix = new He,
        this.projectionMatrixInverse = new He,
        this.coordinateSystem = zl
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ec = new $
  , bL = new We
  , EL = new We;
class Fr extends Sz {
    constructor(e=50, t=1, r=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Dd * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(eg * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Dd * 2 * Math.atan(Math.tan(eg * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, r) {
        Ec.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Ec.x, Ec.y).multiplyScalar(-e / Ec.z),
        Ec.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        r.set(Ec.x, Ec.y).multiplyScalar(-e / Ec.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, bL, EL),
        t.subVectors(EL, bL)
    }
    setViewOffset(e, t, r, i, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(eg * .5 * this.fov) / this.zoom
          , r = 2 * t
          , i = this.aspect * r
          , s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * i / l,
            t -= o.offsetY * r / c,
            i *= o.width / l,
            r *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + i, t, t - r, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const wf = -90
  , _f = 1;
class Eee extends Lt {
    constructor(e, t, r) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = r,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new Fr(wf,_f,e,t);
        i.layers = this.layers,
        this.add(i);
        const s = new Fr(wf,_f,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new Fr(wf,_f,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Fr(wf,_f,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new Fr(wf,_f,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new Fr(wf,_f,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [r,i,s,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === zl)
            r.up.set(0, 1, 0),
            r.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === O_)
            r.up.set(0, -1, 0),
            r.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: r, activeMipmapLevel: i} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,l,c,A] = this.children
          , u = e.getRenderTarget()
          , f = e.getActiveCubeFace()
          , h = e.getActiveMipmapLevel()
          , d = e.xr.enabled;
        e.xr.enabled = !1;
        const m = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0, i),
        e.render(t, s),
        e.setRenderTarget(r, 1, i),
        e.render(t, o),
        e.setRenderTarget(r, 2, i),
        e.render(t, a),
        e.setRenderTarget(r, 3, i),
        e.render(t, l),
        e.setRenderTarget(r, 4, i),
        e.render(t, c),
        r.texture.generateMipmaps = m,
        e.setRenderTarget(r, 5, i),
        e.render(t, A),
        e.setRenderTarget(u, f, h),
        e.xr.enabled = d,
        r.texture.needsPMREMUpdate = !0
    }
}
class Cz extends Un {
    constructor(e, t, r, i, s, o, a, l, c, A) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Id,
        super(e, t, r, i, s, o, a, l, c, A),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class Bee extends tl {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const r = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [r, r, r, r, r, r];
        this.texture = new Cz(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Lr
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new g0(5,5,5)
          , s = new mr({
            name: "CubemapFromEquirect",
            uniforms: Nd(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: oi,
            blending: jl
        });
        s.uniforms.tEquirect.value = t;
        const o = new dn(i,s)
          , a = t.minFilter;
        return t.minFilter === ea && (t.minFilter = Lr),
        new Eee(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, r, i) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, r, i);
        e.setRenderTarget(s)
    }
}
const NE = new $
  , Mee = new $
  , See = new dt;
class Ra {
    constructor(e=new $(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, r, i) {
        return this.normal.set(e, t, r),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, r) {
        const i = NE.subVectors(r, t).cross(Mee.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const r = e.delta(NE)
          , i = this.normal.dot(r);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , r = this.distanceToPoint(e.end);
        return t < 0 && r > 0 || r < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const r = t || See.getNormalMatrix(e)
          , i = this.coplanarPoint(NE).applyMatrix4(e)
          , s = this.normal.applyMatrix3(r).normalize();
        return this.constant = -i.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const HA = new Mi
  , Tv = new $;
class h1 {
    constructor(e=new Ra, t=new Ra, r=new Ra, i=new Ra, s=new Ra, o=new Ra) {
        this.planes = [e, t, r, i, s, o]
    }
    set(e, t, r, i, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(r),
        a[3].copy(i),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            t[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e, t=zl) {
        const r = this.planes
          , i = e.elements
          , s = i[0]
          , o = i[1]
          , a = i[2]
          , l = i[3]
          , c = i[4]
          , A = i[5]
          , u = i[6]
          , f = i[7]
          , h = i[8]
          , d = i[9]
          , m = i[10]
          , g = i[11]
          , p = i[12]
          , v = i[13]
          , w = i[14]
          , _ = i[15];
        if (r[0].setComponents(l - s, f - c, g - h, _ - p).normalize(),
        r[1].setComponents(l + s, f + c, g + h, _ + p).normalize(),
        r[2].setComponents(l + o, f + A, g + d, _ + v).normalize(),
        r[3].setComponents(l - o, f - A, g - d, _ - v).normalize(),
        r[4].setComponents(l - a, f - u, g - m, _ - w).normalize(),
        t === zl)
            r[5].setComponents(l + a, f + u, g + m, _ + w).normalize();
        else if (t === O_)
            r[5].setComponents(a, u, m, w).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            HA.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            HA.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(HA)
    }
    intersectsSprite(e) {
        return HA.center.set(0, 0, 0),
        HA.radius = .7071067811865476,
        HA.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(HA)
    }
    intersectsSphere(e) {
        const t = this.planes
          , r = e.center
          , i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(r) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++) {
            const i = t[r];
            if (Tv.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Tv.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Tv.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Tv) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function Tz() {
    let n = null
      , e = !1
      , t = null
      , r = null;
    function i(s, o) {
        t(s, o),
        r = n.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (r = n.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(r),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function Cee(n) {
    const e = new WeakMap;
    function t(a, l) {
        const c = a.array
          , A = a.usage
          , u = c.byteLength
          , f = n.createBuffer();
        n.bindBuffer(l, f),
        n.bufferData(l, c, A),
        a.onUploadCallback();
        let h;
        if (c instanceof Float32Array)
            h = n.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? h = n.HALF_FLOAT : h = n.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            h = n.SHORT;
        else if (c instanceof Uint32Array)
            h = n.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            h = n.INT;
        else if (c instanceof Int8Array)
            h = n.BYTE;
        else if (c instanceof Uint8Array)
            h = n.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            h = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: f,
            type: h,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: u
        }
    }
    function r(a, l, c) {
        const A = l.array
          , u = l.updateRanges;
        if (n.bindBuffer(c, a),
        u.length === 0)
            n.bufferSubData(c, 0, A);
        else {
            u.sort( (h, d) => h.start - d.start);
            let f = 0;
            for (let h = 1; h < u.length; h++) {
                const d = u[f]
                  , m = u[h];
                m.start <= d.start + d.count + 1 ? d.count = Math.max(d.count, m.start + m.count - d.start) : (++f,
                u[f] = m)
            }
            u.length = f + 1;
            for (let h = 0, d = u.length; h < d; h++) {
                const m = u[h];
                n.bufferSubData(c, m.start * A.BYTES_PER_ELEMENT, A, m.start, m.count)
            }
            l.clearUpdateRanges()
        }
        l.onUploadCallback()
    }
    function i(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (n.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const A = e.get(a);
            (!A || A.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            r(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: i,
        remove: s,
        update: o
    }
}
class cc extends Jt {
    constructor(e=1, t=1, r=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: i
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(r)
          , l = Math.floor(i)
          , c = a + 1
          , A = l + 1
          , u = e / a
          , f = t / l
          , h = []
          , d = []
          , m = []
          , g = [];
        for (let p = 0; p < A; p++) {
            const v = p * f - o;
            for (let w = 0; w < c; w++) {
                const _ = w * u - s;
                d.push(_, -v, 0),
                m.push(0, 0, 1),
                g.push(w / a),
                g.push(1 - p / l)
            }
        }
        for (let p = 0; p < l; p++)
            for (let v = 0; v < a; v++) {
                const w = v + c * p
                  , _ = v + c * (p + 1)
                  , x = v + 1 + c * (p + 1)
                  , b = v + 1 + c * p;
                h.push(w, _, b),
                h.push(_, x, b)
            }
        this.setIndex(h),
        this.setAttribute("position", new xn(d,3)),
        this.setAttribute("normal", new xn(m,3)),
        this.setAttribute("uv", new xn(g,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new cc(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var Tee = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , Iee = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , Ree = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , Uee = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Fee = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , Pee = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , Lee = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , Dee = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , Nee = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , Oee = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , kee = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , Qee = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , Hee = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , zee = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , Gee = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , Vee = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , jee = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , Wee = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , Kee = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , Xee = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , Yee = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , $ee = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , Zee = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , Jee = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , qee = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , ete = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , tte = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , nte = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , rte = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , ite = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , ste = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , ote = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , ate = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , lte = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , cte = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , Ate = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , ute = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , fte = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , hte = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , dte = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , pte = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , mte = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , gte = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , vte = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , yte = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , wte = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , _te = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , xte = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , bte = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , Ete = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , Bte = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , Mte = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , Ste = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , Cte = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , Tte = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , Ite = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , Rte = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , Ute = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Fte = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , Pte = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , Lte = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , Dte = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , Nte = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , Ote = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , kte = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , Qte = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , Hte = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , zte = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , Gte = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , Vte = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , jte = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , Wte = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , Kte = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , Xte = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Yte = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , $te = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , Zte = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , Jte = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , qte = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , ene = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , tne = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , nne = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , rne = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , ine = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , sne = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , one = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , ane = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , lne = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , cne = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Ane = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , une = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , fne = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , hne = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , dne = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , pne = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , mne = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , gne = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , vne = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , yne = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , wne = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , _ne = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , xne = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , bne = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , Ene = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Bne = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Mne = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , Sne = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Cne = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , Tne = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Ine = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , Rne = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Une = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , Fne = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Pne = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , Lne = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , Dne = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , Nne = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , One = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , kne = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , Qne = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , Hne = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , zne = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , Gne = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Vne = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , jne = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Wne = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , Kne = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Xne = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , Yne = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , $ne = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Zne = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Jne = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , qne = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , ere = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , tre = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , nre = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , rre = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , ire = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , sre = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , ore = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , are = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Mt = {
    alphahash_fragment: Tee,
    alphahash_pars_fragment: Iee,
    alphamap_fragment: Ree,
    alphamap_pars_fragment: Uee,
    alphatest_fragment: Fee,
    alphatest_pars_fragment: Pee,
    aomap_fragment: Lee,
    aomap_pars_fragment: Dee,
    batching_pars_vertex: Nee,
    batching_vertex: Oee,
    begin_vertex: kee,
    beginnormal_vertex: Qee,
    bsdfs: Hee,
    iridescence_fragment: zee,
    bumpmap_pars_fragment: Gee,
    clipping_planes_fragment: Vee,
    clipping_planes_pars_fragment: jee,
    clipping_planes_pars_vertex: Wee,
    clipping_planes_vertex: Kee,
    color_fragment: Xee,
    color_pars_fragment: Yee,
    color_pars_vertex: $ee,
    color_vertex: Zee,
    common: Jee,
    cube_uv_reflection_fragment: qee,
    defaultnormal_vertex: ete,
    displacementmap_pars_vertex: tte,
    displacementmap_vertex: nte,
    emissivemap_fragment: rte,
    emissivemap_pars_fragment: ite,
    colorspace_fragment: ste,
    colorspace_pars_fragment: ote,
    envmap_fragment: ate,
    envmap_common_pars_fragment: lte,
    envmap_pars_fragment: cte,
    envmap_pars_vertex: Ate,
    envmap_physical_pars_fragment: _te,
    envmap_vertex: ute,
    fog_vertex: fte,
    fog_pars_vertex: hte,
    fog_fragment: dte,
    fog_pars_fragment: pte,
    gradientmap_pars_fragment: mte,
    lightmap_pars_fragment: gte,
    lights_lambert_fragment: vte,
    lights_lambert_pars_fragment: yte,
    lights_pars_begin: wte,
    lights_toon_fragment: xte,
    lights_toon_pars_fragment: bte,
    lights_phong_fragment: Ete,
    lights_phong_pars_fragment: Bte,
    lights_physical_fragment: Mte,
    lights_physical_pars_fragment: Ste,
    lights_fragment_begin: Cte,
    lights_fragment_maps: Tte,
    lights_fragment_end: Ite,
    logdepthbuf_fragment: Rte,
    logdepthbuf_pars_fragment: Ute,
    logdepthbuf_pars_vertex: Fte,
    logdepthbuf_vertex: Pte,
    map_fragment: Lte,
    map_pars_fragment: Dte,
    map_particle_fragment: Nte,
    map_particle_pars_fragment: Ote,
    metalnessmap_fragment: kte,
    metalnessmap_pars_fragment: Qte,
    morphinstance_vertex: Hte,
    morphcolor_vertex: zte,
    morphnormal_vertex: Gte,
    morphtarget_pars_vertex: Vte,
    morphtarget_vertex: jte,
    normal_fragment_begin: Wte,
    normal_fragment_maps: Kte,
    normal_pars_fragment: Xte,
    normal_pars_vertex: Yte,
    normal_vertex: $te,
    normalmap_pars_fragment: Zte,
    clearcoat_normal_fragment_begin: Jte,
    clearcoat_normal_fragment_maps: qte,
    clearcoat_pars_fragment: ene,
    iridescence_pars_fragment: tne,
    opaque_fragment: nne,
    packing: rne,
    premultiplied_alpha_fragment: ine,
    project_vertex: sne,
    dithering_fragment: one,
    dithering_pars_fragment: ane,
    roughnessmap_fragment: lne,
    roughnessmap_pars_fragment: cne,
    shadowmap_pars_fragment: Ane,
    shadowmap_pars_vertex: une,
    shadowmap_vertex: fne,
    shadowmask_pars_fragment: hne,
    skinbase_vertex: dne,
    skinning_pars_vertex: pne,
    skinning_vertex: mne,
    skinnormal_vertex: gne,
    specularmap_fragment: vne,
    specularmap_pars_fragment: yne,
    tonemapping_fragment: wne,
    tonemapping_pars_fragment: _ne,
    transmission_fragment: xne,
    transmission_pars_fragment: bne,
    uv_pars_fragment: Ene,
    uv_pars_vertex: Bne,
    uv_vertex: Mne,
    worldpos_vertex: Sne,
    background_vert: Cne,
    background_frag: Tne,
    backgroundCube_vert: Ine,
    backgroundCube_frag: Rne,
    cube_vert: Une,
    cube_frag: Fne,
    depth_vert: Pne,
    depth_frag: Lne,
    distanceRGBA_vert: Dne,
    distanceRGBA_frag: Nne,
    equirect_vert: One,
    equirect_frag: kne,
    linedashed_vert: Qne,
    linedashed_frag: Hne,
    meshbasic_vert: zne,
    meshbasic_frag: Gne,
    meshlambert_vert: Vne,
    meshlambert_frag: jne,
    meshmatcap_vert: Wne,
    meshmatcap_frag: Kne,
    meshnormal_vert: Xne,
    meshnormal_frag: Yne,
    meshphong_vert: $ne,
    meshphong_frag: Zne,
    meshphysical_vert: Jne,
    meshphysical_frag: qne,
    meshtoon_vert: ere,
    meshtoon_frag: tre,
    points_vert: nre,
    points_frag: rre,
    shadow_vert: ire,
    shadow_frag: sre,
    sprite_vert: ore,
    sprite_frag: are
}
  , Ge = {
    common: {
        diffuse: {
            value: new Qe(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new dt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new dt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new dt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new dt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new dt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new dt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new dt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new dt
        },
        normalScale: {
            value: new We(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new dt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new dt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new dt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new dt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Qe(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Qe(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new dt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new dt
        }
    },
    sprite: {
        diffuse: {
            value: new Qe(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new We(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new dt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new dt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Ua = {
    basic: {
        uniforms: Ui([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.fog]),
        vertexShader: Mt.meshbasic_vert,
        fragmentShader: Mt.meshbasic_frag
    },
    lambert: {
        uniforms: Ui([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, Ge.lights, {
            emissive: {
                value: new Qe(0)
            }
        }]),
        vertexShader: Mt.meshlambert_vert,
        fragmentShader: Mt.meshlambert_frag
    },
    phong: {
        uniforms: Ui([Ge.common, Ge.specularmap, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, Ge.lights, {
            emissive: {
                value: new Qe(0)
            },
            specular: {
                value: new Qe(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Mt.meshphong_vert,
        fragmentShader: Mt.meshphong_frag
    },
    standard: {
        uniforms: Ui([Ge.common, Ge.envmap, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.roughnessmap, Ge.metalnessmap, Ge.fog, Ge.lights, {
            emissive: {
                value: new Qe(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Mt.meshphysical_vert,
        fragmentShader: Mt.meshphysical_frag
    },
    toon: {
        uniforms: Ui([Ge.common, Ge.aomap, Ge.lightmap, Ge.emissivemap, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.gradientmap, Ge.fog, Ge.lights, {
            emissive: {
                value: new Qe(0)
            }
        }]),
        vertexShader: Mt.meshtoon_vert,
        fragmentShader: Mt.meshtoon_frag
    },
    matcap: {
        uniforms: Ui([Ge.common, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, Ge.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Mt.meshmatcap_vert,
        fragmentShader: Mt.meshmatcap_frag
    },
    points: {
        uniforms: Ui([Ge.points, Ge.fog]),
        vertexShader: Mt.points_vert,
        fragmentShader: Mt.points_frag
    },
    dashed: {
        uniforms: Ui([Ge.common, Ge.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Mt.linedashed_vert,
        fragmentShader: Mt.linedashed_frag
    },
    depth: {
        uniforms: Ui([Ge.common, Ge.displacementmap]),
        vertexShader: Mt.depth_vert,
        fragmentShader: Mt.depth_frag
    },
    normal: {
        uniforms: Ui([Ge.common, Ge.bumpmap, Ge.normalmap, Ge.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Mt.meshnormal_vert,
        fragmentShader: Mt.meshnormal_frag
    },
    sprite: {
        uniforms: Ui([Ge.sprite, Ge.fog]),
        vertexShader: Mt.sprite_vert,
        fragmentShader: Mt.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new dt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Mt.background_vert,
        fragmentShader: Mt.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new dt
            }
        },
        vertexShader: Mt.backgroundCube_vert,
        fragmentShader: Mt.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Mt.cube_vert,
        fragmentShader: Mt.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Mt.equirect_vert,
        fragmentShader: Mt.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ui([Ge.common, Ge.displacementmap, {
            referencePosition: {
                value: new $
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Mt.distanceRGBA_vert,
        fragmentShader: Mt.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ui([Ge.lights, Ge.fog, {
            color: {
                value: new Qe(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Mt.shadow_vert,
        fragmentShader: Mt.shadow_frag
    }
};
Ua.physical = {
    uniforms: Ui([Ua.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new dt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new dt
        },
        clearcoatNormalScale: {
            value: new We(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new dt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new dt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new dt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Qe(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new dt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new dt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new dt
        },
        transmissionSamplerSize: {
            value: new We
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new dt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Qe(0)
        },
        specularColor: {
            value: new Qe(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new dt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new dt
        },
        anisotropyVector: {
            value: new We
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new dt
        }
    }]),
    vertexShader: Mt.meshphysical_vert,
    fragmentShader: Mt.meshphysical_frag
};
const Iv = {
    r: 0,
    b: 0,
    g: 0
}
  , zA = new nr
  , lre = new He;
function cre(n, e, t, r, i, s, o) {
    const a = new Qe(0);
    let l = s === !0 ? 0 : 1, c, A, u = null, f = 0, h = null;
    function d(v) {
        let w = v.isScene === !0 ? v.background : null;
        return w && w.isTexture && (w = (v.backgroundBlurriness > 0 ? t : e).get(w)),
        w
    }
    function m(v) {
        let w = !1;
        const _ = d(v);
        _ === null ? p(a, l) : _ && _.isColor && (p(_, 1),
        w = !0);
        const x = n.xr.getEnvironmentBlendMode();
        x === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, o) : x === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || w) && (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
    }
    function g(v, w) {
        const _ = d(w);
        _ && (_.isCubeTexture || _.mapping === c1) ? (A === void 0 && (A = new dn(new g0(1,1,1),new mr({
            name: "BackgroundCubeMaterial",
            uniforms: Nd(Ua.backgroundCube.uniforms),
            vertexShader: Ua.backgroundCube.vertexShader,
            fragmentShader: Ua.backgroundCube.fragmentShader,
            side: oi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        A.geometry.deleteAttribute("normal"),
        A.geometry.deleteAttribute("uv"),
        A.onBeforeRender = function(x, b, B) {
            this.matrixWorld.copyPosition(B.matrixWorld)
        }
        ,
        Object.defineProperty(A.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(A)),
        zA.copy(w.backgroundRotation),
        zA.x *= -1,
        zA.y *= -1,
        zA.z *= -1,
        _.isCubeTexture && _.isRenderTargetTexture === !1 && (zA.y *= -1,
        zA.z *= -1),
        A.material.uniforms.envMap.value = _,
        A.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        A.material.uniforms.backgroundBlurriness.value = w.backgroundBlurriness,
        A.material.uniforms.backgroundIntensity.value = w.backgroundIntensity,
        A.material.uniforms.backgroundRotation.value.setFromMatrix4(lre.makeRotationFromEuler(zA)),
        A.material.toneMapped = Et.getTransfer(_.colorSpace) !== Sn,
        (u !== _ || f !== _.version || h !== n.toneMapping) && (A.material.needsUpdate = !0,
        u = _,
        f = _.version,
        h = n.toneMapping),
        A.layers.enableAll(),
        v.unshift(A, A.geometry, A.material, 0, 0, null)) : _ && _.isTexture && (c === void 0 && (c = new dn(new cc(2,2),new mr({
            name: "BackgroundMaterial",
            uniforms: Nd(Ua.background.uniforms),
            vertexShader: Ua.background.vertexShader,
            fragmentShader: Ua.background.fragmentShader,
            side: Hs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(c)),
        c.material.uniforms.t2D.value = _,
        c.material.uniforms.backgroundIntensity.value = w.backgroundIntensity,
        c.material.toneMapped = Et.getTransfer(_.colorSpace) !== Sn,
        _.matrixAutoUpdate === !0 && _.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(_.matrix),
        (u !== _ || f !== _.version || h !== n.toneMapping) && (c.material.needsUpdate = !0,
        u = _,
        f = _.version,
        h = n.toneMapping),
        c.layers.enableAll(),
        v.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function p(v, w) {
        v.getRGB(Iv, Mz(n)),
        r.buffers.color.setClear(Iv.r, Iv.g, Iv.b, w, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(v, w=1) {
            a.set(v),
            l = w,
            p(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(v) {
            l = v,
            p(a, l)
        },
        render: m,
        addToRenderList: g
    }
}
function Are(n, e) {
    const t = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , r = {}
      , i = f(null);
    let s = i
      , o = !1;
    function a(M, L, D, T, y) {
        let E = !1;
        const R = u(T, D, L);
        s !== R && (s = R,
        c(s.object)),
        E = h(M, T, D, y),
        E && d(M, T, D, y),
        y !== null && e.update(y, n.ELEMENT_ARRAY_BUFFER),
        (E || o) && (o = !1,
        _(M, L, D, T),
        y !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(y).buffer))
    }
    function l() {
        return n.createVertexArray()
    }
    function c(M) {
        return n.bindVertexArray(M)
    }
    function A(M) {
        return n.deleteVertexArray(M)
    }
    function u(M, L, D) {
        const T = D.wireframe === !0;
        let y = r[M.id];
        y === void 0 && (y = {},
        r[M.id] = y);
        let E = y[L.id];
        E === void 0 && (E = {},
        y[L.id] = E);
        let R = E[T];
        return R === void 0 && (R = f(l()),
        E[T] = R),
        R
    }
    function f(M) {
        const L = []
          , D = []
          , T = [];
        for (let y = 0; y < t; y++)
            L[y] = 0,
            D[y] = 0,
            T[y] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: L,
            enabledAttributes: D,
            attributeDivisors: T,
            object: M,
            attributes: {},
            index: null
        }
    }
    function h(M, L, D, T) {
        const y = s.attributes
          , E = L.attributes;
        let R = 0;
        const F = D.getAttributes();
        for (const O in F)
            if (F[O].location >= 0) {
                const j = y[O];
                let Q = E[O];
                if (Q === void 0 && (O === "instanceMatrix" && M.instanceMatrix && (Q = M.instanceMatrix),
                O === "instanceColor" && M.instanceColor && (Q = M.instanceColor)),
                j === void 0 || j.attribute !== Q || Q && j.data !== Q.data)
                    return !0;
                R++
            }
        return s.attributesNum !== R || s.index !== T
    }
    function d(M, L, D, T) {
        const y = {}
          , E = L.attributes;
        let R = 0;
        const F = D.getAttributes();
        for (const O in F)
            if (F[O].location >= 0) {
                let j = E[O];
                j === void 0 && (O === "instanceMatrix" && M.instanceMatrix && (j = M.instanceMatrix),
                O === "instanceColor" && M.instanceColor && (j = M.instanceColor));
                const Q = {};
                Q.attribute = j,
                j && j.data && (Q.data = j.data),
                y[O] = Q,
                R++
            }
        s.attributes = y,
        s.attributesNum = R,
        s.index = T
    }
    function m() {
        const M = s.newAttributes;
        for (let L = 0, D = M.length; L < D; L++)
            M[L] = 0
    }
    function g(M) {
        p(M, 0)
    }
    function p(M, L) {
        const D = s.newAttributes
          , T = s.enabledAttributes
          , y = s.attributeDivisors;
        D[M] = 1,
        T[M] === 0 && (n.enableVertexAttribArray(M),
        T[M] = 1),
        y[M] !== L && (n.vertexAttribDivisor(M, L),
        y[M] = L)
    }
    function v() {
        const M = s.newAttributes
          , L = s.enabledAttributes;
        for (let D = 0, T = L.length; D < T; D++)
            L[D] !== M[D] && (n.disableVertexAttribArray(D),
            L[D] = 0)
    }
    function w(M, L, D, T, y, E, R) {
        R === !0 ? n.vertexAttribIPointer(M, L, D, y, E) : n.vertexAttribPointer(M, L, D, T, y, E)
    }
    function _(M, L, D, T) {
        m();
        const y = T.attributes
          , E = D.getAttributes()
          , R = L.defaultAttributeValues;
        for (const F in E) {
            const O = E[F];
            if (O.location >= 0) {
                let z = y[F];
                if (z === void 0 && (F === "instanceMatrix" && M.instanceMatrix && (z = M.instanceMatrix),
                F === "instanceColor" && M.instanceColor && (z = M.instanceColor)),
                z !== void 0) {
                    const j = z.normalized
                      , Q = z.itemSize
                      , C = e.get(z);
                    if (C === void 0)
                        continue;
                    const W = C.buffer
                      , ee = C.type
                      , P = C.bytesPerElement
                      , re = ee === n.INT || ee === n.UNSIGNED_INT || z.gpuType === CR;
                    if (z.isInterleavedBufferAttribute) {
                        const ue = z.data
                          , le = ue.stride
                          , me = z.offset;
                        if (ue.isInstancedInterleavedBuffer) {
                            for (let ie = 0; ie < O.locationSize; ie++)
                                p(O.location + ie, ue.meshPerAttribute);
                            M.isInstancedMesh !== !0 && T._maxInstanceCount === void 0 && (T._maxInstanceCount = ue.meshPerAttribute * ue.count)
                        } else
                            for (let ie = 0; ie < O.locationSize; ie++)
                                g(O.location + ie);
                        n.bindBuffer(n.ARRAY_BUFFER, W);
                        for (let ie = 0; ie < O.locationSize; ie++)
                            w(O.location + ie, Q / O.locationSize, ee, j, le * P, (me + Q / O.locationSize * ie) * P, re)
                    } else {
                        if (z.isInstancedBufferAttribute) {
                            for (let ue = 0; ue < O.locationSize; ue++)
                                p(O.location + ue, z.meshPerAttribute);
                            M.isInstancedMesh !== !0 && T._maxInstanceCount === void 0 && (T._maxInstanceCount = z.meshPerAttribute * z.count)
                        } else
                            for (let ue = 0; ue < O.locationSize; ue++)
                                g(O.location + ue);
                        n.bindBuffer(n.ARRAY_BUFFER, W);
                        for (let ue = 0; ue < O.locationSize; ue++)
                            w(O.location + ue, Q / O.locationSize, ee, j, Q * P, Q / O.locationSize * ue * P, re)
                    }
                } else if (R !== void 0) {
                    const j = R[F];
                    if (j !== void 0)
                        switch (j.length) {
                        case 2:
                            n.vertexAttrib2fv(O.location, j);
                            break;
                        case 3:
                            n.vertexAttrib3fv(O.location, j);
                            break;
                        case 4:
                            n.vertexAttrib4fv(O.location, j);
                            break;
                        default:
                            n.vertexAttrib1fv(O.location, j)
                        }
                }
            }
        }
        v()
    }
    function x() {
        S();
        for (const M in r) {
            const L = r[M];
            for (const D in L) {
                const T = L[D];
                for (const y in T)
                    A(T[y].object),
                    delete T[y];
                delete L[D]
            }
            delete r[M]
        }
    }
    function b(M) {
        if (r[M.id] === void 0)
            return;
        const L = r[M.id];
        for (const D in L) {
            const T = L[D];
            for (const y in T)
                A(T[y].object),
                delete T[y];
            delete L[D]
        }
        delete r[M.id]
    }
    function B(M) {
        for (const L in r) {
            const D = r[L];
            if (D[M.id] === void 0)
                continue;
            const T = D[M.id];
            for (const y in T)
                A(T[y].object),
                delete T[y];
            delete D[M.id]
        }
    }
    function S() {
        I(),
        o = !0,
        s !== i && (s = i,
        c(s.object))
    }
    function I() {
        i.geometry = null,
        i.program = null,
        i.wireframe = !1
    }
    return {
        setup: a,
        reset: S,
        resetDefaultState: I,
        dispose: x,
        releaseStatesOfGeometry: b,
        releaseStatesOfProgram: B,
        initAttributes: m,
        enableAttribute: g,
        disableUnusedAttributes: v
    }
}
function ure(n, e, t) {
    let r;
    function i(c) {
        r = c
    }
    function s(c, A) {
        n.drawArrays(r, c, A),
        t.update(A, r, 1)
    }
    function o(c, A, u) {
        u !== 0 && (n.drawArraysInstanced(r, c, A, u),
        t.update(A, r, u))
    }
    function a(c, A, u) {
        if (u === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, c, 0, A, 0, u);
        let h = 0;
        for (let d = 0; d < u; d++)
            h += A[d];
        t.update(h, r, 1)
    }
    function l(c, A, u, f) {
        if (u === 0)
            return;
        const h = e.get("WEBGL_multi_draw");
        if (h === null)
            for (let d = 0; d < c.length; d++)
                o(c[d], A[d], f[d]);
        else {
            h.multiDrawArraysInstancedWEBGL(r, c, 0, A, 0, f, 0, u);
            let d = 0;
            for (let m = 0; m < u; m++)
                d += A[m];
            for (let m = 0; m < f.length; m++)
                t.update(d, r, f[m])
        }
    }
    this.setMode = i,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function fre(n, e, t, r) {
    let i;
    function s() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const B = e.get("EXT_texture_filter_anisotropic");
            i = n.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function o(B) {
        return !(B !== Nr && r.convert(B) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(B) {
        const S = B === Ha && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(B !== rc && r.convert(B) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && B !== xi && !S)
    }
    function l(B) {
        if (B === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            B = "mediump"
        }
        return B === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const A = l(c);
    A !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", A, "instead."),
    c = A);
    const u = t.logarithmicDepthBuffer === !0
      , f = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control");
    if (f === !0) {
        const B = e.get("EXT_clip_control");
        B.clipControlEXT(B.LOWER_LEFT_EXT, B.ZERO_TO_ONE_EXT)
    }
    const h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , m = n.getParameter(n.MAX_TEXTURE_SIZE)
      , g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , p = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , v = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , w = n.getParameter(n.MAX_VARYING_VECTORS)
      , _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , x = d > 0
      , b = n.getParameter(n.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: u,
        reverseDepthBuffer: f,
        maxTextures: h,
        maxVertexTextures: d,
        maxTextureSize: m,
        maxCubemapSize: g,
        maxAttributes: p,
        maxVertexUniforms: v,
        maxVaryings: w,
        maxFragmentUniforms: _,
        vertexTextures: x,
        maxSamples: b
    }
}
function hre(n) {
    const e = this;
    let t = null
      , r = 0
      , i = !1
      , s = !1;
    const o = new Ra
      , a = new dt
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(u, f) {
        const h = u.length !== 0 || f || r !== 0 || i;
        return i = f,
        r = u.length,
        h
    }
    ,
    this.beginShadows = function() {
        s = !0,
        A(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(u, f) {
        t = A(u, f, 0)
    }
    ,
    this.setState = function(u, f, h) {
        const d = u.clippingPlanes
          , m = u.clipIntersection
          , g = u.clipShadows
          , p = n.get(u);
        if (!i || d === null || d.length === 0 || s && !g)
            s ? A(null) : c();
        else {
            const v = s ? 0 : r
              , w = v * 4;
            let _ = p.clippingState || null;
            l.value = _,
            _ = A(d, f, w, h);
            for (let x = 0; x !== w; ++x)
                _[x] = t[x];
            p.clippingState = _,
            this.numIntersection = m ? this.numPlanes : 0,
            this.numPlanes += v
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = r > 0),
        e.numPlanes = r,
        e.numIntersection = 0
    }
    function A(u, f, h, d) {
        const m = u !== null ? u.length : 0;
        let g = null;
        if (m !== 0) {
            if (g = l.value,
            d !== !0 || g === null) {
                const p = h + m * 4
                  , v = f.matrixWorldInverse;
                a.getNormalMatrix(v),
                (g === null || g.length < p) && (g = new Float32Array(p));
                for (let w = 0, _ = h; w !== m; ++w,
                _ += 4)
                    o.copy(u[w]).applyMatrix4(v, a),
                    o.normal.toArray(g, _),
                    g[_ + 3] = o.constant
            }
            l.value = g,
            l.needsUpdate = !0
        }
        return e.numPlanes = m,
        e.numIntersection = 0,
        g
    }
}
function dre(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === kg ? o.mapping = Id : a === iC && (o.mapping = Rd),
        o
    }
    function r(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === kg || a === iC)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new Bee(l.height);
                        return c.fromEquirectangularTexture(n, o),
                        e.set(o, c),
                        o.addEventListener("dispose", i),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: s
    }
}
class v0 extends Sz {
    constructor(e=-1, t=1, r=1, i=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = r,
        this.bottom = i,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, r, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = i,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , r = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let s = r - e
          , o = r + e
          , a = i + t
          , l = i - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , A = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= A * this.view.offsetY,
            l = a - A * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const kh = 4
  , BL = [.125, .215, .35, .446, .526, .582]
  , lu = 20
  , OE = new v0
  , ML = new Qe;
let kE = null
  , QE = 0
  , HE = 0
  , zE = !1;
const ru = (1 + Math.sqrt(5)) / 2
  , xf = 1 / ru
  , SL = [new $(-ru,xf,0), new $(ru,xf,0), new $(-xf,0,ru), new $(xf,0,ru), new $(0,ru,-xf), new $(0,ru,xf), new $(-1,1,-1), new $(1,1,-1), new $(-1,1,1), new $(1,1,1)];
class CL {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, r=.1, i=100) {
        kE = this._renderer.getRenderTarget(),
        QE = this._renderer.getActiveCubeFace(),
        HE = this._renderer.getActiveMipmapLevel(),
        zE = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, r, i, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = RL(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = IL(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(kE, QE, HE),
        this._renderer.xr.enabled = zE,
        e.scissorTest = !1,
        Rv(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Id || e.mapping === Rd ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        kE = this._renderer.getRenderTarget(),
        QE = this._renderer.getActiveCubeFace(),
        HE = this._renderer.getActiveMipmapLevel(),
        zE = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const r = t || this._allocateTargets();
        return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , r = {
            magFilter: Lr,
            minFilter: Lr,
            generateMipmaps: !1,
            type: Ha,
            format: Nr,
            colorSpace: Sr,
            depthBuffer: !1
        }
          , i = TL(e, t, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = TL(e, t, r);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = pre(s)),
            this._blurMaterial = mre(s, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new dn(this._lodPlanes[0],e);
        this._renderer.compile(t, OE)
    }
    _sceneToCubeUV(e, t, r, i) {
        const a = new Fr(90,1,t,r)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , A = this._renderer
          , u = A.autoClear
          , f = A.toneMapping;
        A.getClearColor(ML),
        A.toneMapping = fA,
        A.autoClear = !1;
        const h = new qi({
            name: "PMREM.Background",
            side: oi,
            depthWrite: !1,
            depthTest: !1
        })
          , d = new dn(new g0,h);
        let m = !1;
        const g = e.background;
        g ? g.isColor && (h.color.copy(g),
        e.background = null,
        m = !0) : (h.color.copy(ML),
        m = !0);
        for (let p = 0; p < 6; p++) {
            const v = p % 3;
            v === 0 ? (a.up.set(0, l[p], 0),
            a.lookAt(c[p], 0, 0)) : v === 1 ? (a.up.set(0, 0, l[p]),
            a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0),
            a.lookAt(0, 0, c[p]));
            const w = this._cubeSize;
            Rv(i, v * w, p > 2 ? w : 0, w, w),
            A.setRenderTarget(i),
            m && A.render(d, a),
            A.render(e, a)
        }
        d.geometry.dispose(),
        d.material.dispose(),
        A.toneMapping = f,
        A.autoClear = u,
        e.background = g
    }
    _textureToCubeUV(e, t) {
        const r = this._renderer
          , i = e.mapping === Id || e.mapping === Rd;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = RL()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = IL());
        const s = i ? this._cubemapMaterial : this._equirectMaterial
          , o = new dn(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Rv(t, 0, 0, 3 * l, 2 * l),
        r.setRenderTarget(t),
        r.render(o, OE)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , r = t.autoClear;
        t.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let s = 1; s < i; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , a = SL[(i - s - 1) % SL.length];
            this._blur(e, s - 1, s, o, a)
        }
        t.autoClear = r
    }
    _blur(e, t, r, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, r, i, "latitudinal", s),
        this._halfBlur(o, e, r, r, i, "longitudinal", s)
    }
    _halfBlur(e, t, r, i, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const A = 3
          , u = new dn(this._lodPlanes[i],c)
          , f = c.uniforms
          , h = this._sizeLods[r] - 1
          , d = isFinite(s) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * lu - 1)
          , m = s / d
          , g = isFinite(s) ? 1 + Math.floor(A * m) : lu;
        g > lu && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${lu}`);
        const p = [];
        let v = 0;
        for (let B = 0; B < lu; ++B) {
            const S = B / m
              , I = Math.exp(-S * S / 2);
            p.push(I),
            B === 0 ? v += I : B < g && (v += 2 * I)
        }
        for (let B = 0; B < p.length; B++)
            p[B] = p[B] / v;
        f.envMap.value = e.texture,
        f.samples.value = g,
        f.weights.value = p,
        f.latitudinal.value = o === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: w} = this;
        f.dTheta.value = d,
        f.mipInt.value = w - r;
        const _ = this._sizeLods[i]
          , x = 3 * _ * (i > w - kh ? i - w + kh : 0)
          , b = 4 * (this._cubeSize - _);
        Rv(t, x, b, 3 * _, 2 * _),
        l.setRenderTarget(t),
        l.render(u, OE)
    }
}
function pre(n) {
    const e = []
      , t = []
      , r = [];
    let i = n;
    const s = n - kh + 1 + BL.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let l = 1 / a;
        o > n - kh ? l = BL[o - n + kh - 1] : o === 0 && (l = 0),
        r.push(l);
        const c = 1 / (a - 2)
          , A = -c
          , u = 1 + c
          , f = [A, A, u, A, u, u, A, A, u, u, A, u]
          , h = 6
          , d = 6
          , m = 3
          , g = 2
          , p = 1
          , v = new Float32Array(m * d * h)
          , w = new Float32Array(g * d * h)
          , _ = new Float32Array(p * d * h);
        for (let b = 0; b < h; b++) {
            const B = b % 3 * 2 / 3 - 1
              , S = b > 2 ? 0 : -1
              , I = [B, S, 0, B + 2 / 3, S, 0, B + 2 / 3, S + 1, 0, B, S, 0, B + 2 / 3, S + 1, 0, B, S + 1, 0];
            v.set(I, m * d * b),
            w.set(f, g * d * b);
            const M = [b, b, b, b, b, b];
            _.set(M, p * d * b)
        }
        const x = new Jt;
        x.setAttribute("position", new ct(v,m)),
        x.setAttribute("uv", new ct(w,g)),
        x.setAttribute("faceIndex", new ct(_,p)),
        e.push(x),
        i > kh && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: r
    }
}
function TL(n, e, t) {
    const r = new tl(n,e,t);
    return r.texture.mapping = c1,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r
}
function Rv(n, e, t, r, i) {
    n.viewport.set(e, t, r, i),
    n.scissor.set(e, t, r, i)
}
function mre(n, e, t) {
    const r = new Float32Array(lu)
      , i = new $(0,1,0);
    return new mr({
        name: "SphericalGaussianBlur",
        defines: {
            n: lu,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: QR(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: jl,
        depthTest: !1,
        depthWrite: !1
    })
}
function IL() {
    return new mr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: QR(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: jl,
        depthTest: !1,
        depthWrite: !1
    })
}
function RL() {
    return new mr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: QR(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: jl,
        depthTest: !1,
        depthWrite: !1
    })
}
function QR() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function gre(n) {
    let e = new WeakMap
      , t = null;
    function r(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === kg || l === iC
              , A = l === Id || l === Rd;
            if (c || A) {
                let u = e.get(a);
                const f = u !== void 0 ? u.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== f)
                    return t === null && (t = new CL(n)),
                    u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u),
                    u.texture.pmremVersion = a.pmremVersion,
                    e.set(a, u),
                    u.texture;
                if (u !== void 0)
                    return u.texture;
                {
                    const h = a.image;
                    return c && h && h.height > 0 || A && h && i(h) ? (t === null && (t = new CL(n)),
                    u = c ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    u.texture.pmremVersion = a.pmremVersion,
                    e.set(a, u),
                    a.addEventListener("dispose", s),
                    u.texture) : null
                }
            }
        }
        return a
    }
    function i(a) {
        let l = 0;
        const c = 6;
        for (let A = 0; A < c; A++)
            a[A] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: r,
        dispose: o
    }
}
function vre(n) {
    const e = {};
    function t(r) {
        if (e[r] !== void 0)
            return e[r];
        let i;
        switch (r) {
        case "WEBGL_depth_texture":
            i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = n.getExtension(r)
        }
        return e[r] = i,
        i
    }
    return {
        has: function(r) {
            return t(r) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(r) {
            const i = t(r);
            return i === null && Sw("THREE.WebGLRenderer: " + r + " extension not supported."),
            i
        }
    }
}
function yre(n, e, t, r) {
    const i = {}
      , s = new WeakMap;
    function o(u) {
        const f = u.target;
        f.index !== null && e.remove(f.index);
        for (const d in f.attributes)
            e.remove(f.attributes[d]);
        for (const d in f.morphAttributes) {
            const m = f.morphAttributes[d];
            for (let g = 0, p = m.length; g < p; g++)
                e.remove(m[g])
        }
        f.removeEventListener("dispose", o),
        delete i[f.id];
        const h = s.get(f);
        h && (e.remove(h),
        s.delete(f)),
        r.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(u, f) {
        return i[f.id] === !0 || (f.addEventListener("dispose", o),
        i[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function l(u) {
        const f = u.attributes;
        for (const d in f)
            e.update(f[d], n.ARRAY_BUFFER);
        const h = u.morphAttributes;
        for (const d in h) {
            const m = h[d];
            for (let g = 0, p = m.length; g < p; g++)
                e.update(m[g], n.ARRAY_BUFFER)
        }
    }
    function c(u) {
        const f = []
          , h = u.index
          , d = u.attributes.position;
        let m = 0;
        if (h !== null) {
            const v = h.array;
            m = h.version;
            for (let w = 0, _ = v.length; w < _; w += 3) {
                const x = v[w + 0]
                  , b = v[w + 1]
                  , B = v[w + 2];
                f.push(x, b, b, B, B, x)
            }
        } else if (d !== void 0) {
            const v = d.array;
            m = d.version;
            for (let w = 0, _ = v.length / 3 - 1; w < _; w += 3) {
                const x = w + 0
                  , b = w + 1
                  , B = w + 2;
                f.push(x, b, b, B, B, x)
            }
        } else
            return;
        const g = new (xz(f) ? Bz : f1)(f,1);
        g.version = m;
        const p = s.get(u);
        p && e.remove(p),
        s.set(u, g)
    }
    function A(u) {
        const f = s.get(u);
        if (f) {
            const h = u.index;
            h !== null && f.version < h.version && c(u)
        } else
            c(u);
        return s.get(u)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: A
    }
}
function wre(n, e, t) {
    let r;
    function i(f) {
        r = f
    }
    let s, o;
    function a(f) {
        s = f.type,
        o = f.bytesPerElement
    }
    function l(f, h) {
        n.drawElements(r, h, s, f * o),
        t.update(h, r, 1)
    }
    function c(f, h, d) {
        d !== 0 && (n.drawElementsInstanced(r, h, s, f * o, d),
        t.update(h, r, d))
    }
    function A(f, h, d) {
        if (d === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, h, 0, s, f, 0, d);
        let g = 0;
        for (let p = 0; p < d; p++)
            g += h[p];
        t.update(g, r, 1)
    }
    function u(f, h, d, m) {
        if (d === 0)
            return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null)
            for (let p = 0; p < f.length; p++)
                c(f[p] / o, h[p], m[p]);
        else {
            g.multiDrawElementsInstancedWEBGL(r, h, 0, s, f, 0, m, 0, d);
            let p = 0;
            for (let v = 0; v < d; v++)
                p += h[v];
            for (let v = 0; v < m.length; v++)
                t.update(p, r, m[v])
        }
    }
    this.setMode = i,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = A,
    this.renderMultiDrawInstances = u
}
function _re(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: r
    }
}
function xre(n, e, t) {
    const r = new WeakMap
      , i = new Pt;
    function s(o, a, l) {
        const c = o.morphTargetInfluences
          , A = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , u = A !== void 0 ? A.length : 0;
        let f = r.get(a);
        if (f === void 0 || f.count !== u) {
            let I = function() {
                B.dispose(),
                r.delete(a),
                a.removeEventListener("dispose", I)
            };
            f !== void 0 && f.texture.dispose();
            const h = a.morphAttributes.position !== void 0
              , d = a.morphAttributes.normal !== void 0
              , m = a.morphAttributes.color !== void 0
              , g = a.morphAttributes.position || []
              , p = a.morphAttributes.normal || []
              , v = a.morphAttributes.color || [];
            let w = 0;
            h === !0 && (w = 1),
            d === !0 && (w = 2),
            m === !0 && (w = 3);
            let _ = a.attributes.position.count * w
              , x = 1;
            _ > e.maxTextureSize && (x = Math.ceil(_ / e.maxTextureSize),
            _ = e.maxTextureSize);
            const b = new Float32Array(_ * x * 4 * u)
              , B = new bz(b,_,x,u);
            B.type = xi,
            B.needsUpdate = !0;
            const S = w * 4;
            for (let M = 0; M < u; M++) {
                const L = g[M]
                  , D = p[M]
                  , T = v[M]
                  , y = _ * x * 4 * M;
                for (let E = 0; E < L.count; E++) {
                    const R = E * S;
                    h === !0 && (i.fromBufferAttribute(L, E),
                    b[y + R + 0] = i.x,
                    b[y + R + 1] = i.y,
                    b[y + R + 2] = i.z,
                    b[y + R + 3] = 0),
                    d === !0 && (i.fromBufferAttribute(D, E),
                    b[y + R + 4] = i.x,
                    b[y + R + 5] = i.y,
                    b[y + R + 6] = i.z,
                    b[y + R + 7] = 0),
                    m === !0 && (i.fromBufferAttribute(T, E),
                    b[y + R + 8] = i.x,
                    b[y + R + 9] = i.y,
                    b[y + R + 10] = i.z,
                    b[y + R + 11] = T.itemSize === 4 ? i.w : 1)
                }
            }
            f = {
                count: u,
                texture: B,
                size: new We(_,x)
            },
            r.set(a, f),
            a.addEventListener("dispose", I)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
        else {
            let h = 0;
            for (let m = 0; m < c.length; m++)
                h += c[m];
            const d = a.morphTargetsRelative ? 1 : 1 - h;
            l.getUniforms().setValue(n, "morphTargetBaseInfluence", d),
            l.getUniforms().setValue(n, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(n, "morphTargetsTexture", f.texture, t),
        l.getUniforms().setValue(n, "morphTargetsTextureSize", f.size)
    }
    return {
        update: s
    }
}
function bre(n, e, t, r) {
    let i = new WeakMap;
    function s(l) {
        const c = r.render.frame
          , A = l.geometry
          , u = e.get(l, A);
        if (i.get(u) !== c && (e.update(u),
        i.set(u, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        i.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
        i.set(l, c))),
        l.isSkinnedMesh) {
            const f = l.skeleton;
            i.get(f) !== c && (f.update(),
            i.set(f, c))
        }
        return u
    }
    function o() {
        i = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class HR extends Un {
    constructor(e, t, r, i, s, o, a, l, c, A=sd) {
        if (A !== sd && A !== Fd)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        r === void 0 && A === sd && (r = wA),
        r === void 0 && A === Fd && (r = Ud),
        super(null, i, s, o, a, l, A, r, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Xr,
        this.minFilter = l !== void 0 ? l : Xr,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const Iz = new Un
  , UL = new HR(1,1)
  , Rz = new bz
  , Uz = new aee
  , Fz = new Cz
  , FL = []
  , PL = []
  , LL = new Float32Array(16)
  , DL = new Float32Array(9)
  , NL = new Float32Array(4);
function Xd(n, e, t) {
    const r = n[0];
    if (r <= 0 || r > 0)
        return n;
    const i = e * t;
    let s = FL[i];
    if (s === void 0 && (s = new Float32Array(i),
    FL[i] = s),
    e !== 0) {
        r.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Or(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, r = n.length; t < r; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function kr(n, e) {
    for (let t = 0, r = e.length; t < r; t++)
        n[t] = e[t]
}
function d1(n, e) {
    let t = PL[e];
    t === void 0 && (t = new Int32Array(e),
    PL[e] = t);
    for (let r = 0; r !== e; ++r)
        t[r] = n.allocateTextureUnit();
    return t
}
function Ere(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function Bre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Or(t, e))
            return;
        n.uniform2fv(this.addr, e),
        kr(t, e)
    }
}
function Mre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Or(t, e))
            return;
        n.uniform3fv(this.addr, e),
        kr(t, e)
    }
}
function Sre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Or(t, e))
            return;
        n.uniform4fv(this.addr, e),
        kr(t, e)
    }
}
function Cre(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Or(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        kr(t, e)
    } else {
        if (Or(t, r))
            return;
        NL.set(r),
        n.uniformMatrix2fv(this.addr, !1, NL),
        kr(t, r)
    }
}
function Tre(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Or(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        kr(t, e)
    } else {
        if (Or(t, r))
            return;
        DL.set(r),
        n.uniformMatrix3fv(this.addr, !1, DL),
        kr(t, r)
    }
}
function Ire(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Or(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        kr(t, e)
    } else {
        if (Or(t, r))
            return;
        LL.set(r),
        n.uniformMatrix4fv(this.addr, !1, LL),
        kr(t, r)
    }
}
function Rre(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function Ure(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Or(t, e))
            return;
        n.uniform2iv(this.addr, e),
        kr(t, e)
    }
}
function Fre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Or(t, e))
            return;
        n.uniform3iv(this.addr, e),
        kr(t, e)
    }
}
function Pre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Or(t, e))
            return;
        n.uniform4iv(this.addr, e),
        kr(t, e)
    }
}
function Lre(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function Dre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Or(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        kr(t, e)
    }
}
function Nre(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Or(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        kr(t, e)
    }
}
function Ore(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Or(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        kr(t, e)
    }
}
function kre(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i);
    let s;
    this.type === n.SAMPLER_2D_SHADOW ? (UL.compareFunction = _z,
    s = UL) : s = Iz,
    t.setTexture2D(e || s, i)
}
function Qre(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTexture3D(e || Uz, i)
}
function Hre(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTextureCube(e || Fz, i)
}
function zre(n, e, t) {
    const r = this.cache
      , i = t.allocateTextureUnit();
    r[0] !== i && (n.uniform1i(this.addr, i),
    r[0] = i),
    t.setTexture2DArray(e || Rz, i)
}
function Gre(n) {
    switch (n) {
    case 5126:
        return Ere;
    case 35664:
        return Bre;
    case 35665:
        return Mre;
    case 35666:
        return Sre;
    case 35674:
        return Cre;
    case 35675:
        return Tre;
    case 35676:
        return Ire;
    case 5124:
    case 35670:
        return Rre;
    case 35667:
    case 35671:
        return Ure;
    case 35668:
    case 35672:
        return Fre;
    case 35669:
    case 35673:
        return Pre;
    case 5125:
        return Lre;
    case 36294:
        return Dre;
    case 36295:
        return Nre;
    case 36296:
        return Ore;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return kre;
    case 35679:
    case 36299:
    case 36307:
        return Qre;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Hre;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return zre
    }
}
function Vre(n, e) {
    n.uniform1fv(this.addr, e)
}
function jre(n, e) {
    const t = Xd(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function Wre(n, e) {
    const t = Xd(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function Kre(n, e) {
    const t = Xd(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function Xre(n, e) {
    const t = Xd(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function Yre(n, e) {
    const t = Xd(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function $re(n, e) {
    const t = Xd(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function Zre(n, e) {
    n.uniform1iv(this.addr, e)
}
function Jre(n, e) {
    n.uniform2iv(this.addr, e)
}
function qre(n, e) {
    n.uniform3iv(this.addr, e)
}
function eie(n, e) {
    n.uniform4iv(this.addr, e)
}
function tie(n, e) {
    n.uniform1uiv(this.addr, e)
}
function nie(n, e) {
    n.uniform2uiv(this.addr, e)
}
function rie(n, e) {
    n.uniform3uiv(this.addr, e)
}
function iie(n, e) {
    n.uniform4uiv(this.addr, e)
}
function sie(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = d1(t, i);
    Or(r, s) || (n.uniform1iv(this.addr, s),
    kr(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2D(e[o] || Iz, s[o])
}
function oie(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = d1(t, i);
    Or(r, s) || (n.uniform1iv(this.addr, s),
    kr(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture3D(e[o] || Uz, s[o])
}
function aie(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = d1(t, i);
    Or(r, s) || (n.uniform1iv(this.addr, s),
    kr(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTextureCube(e[o] || Fz, s[o])
}
function lie(n, e, t) {
    const r = this.cache
      , i = e.length
      , s = d1(t, i);
    Or(r, s) || (n.uniform1iv(this.addr, s),
    kr(r, s));
    for (let o = 0; o !== i; ++o)
        t.setTexture2DArray(e[o] || Rz, s[o])
}
function cie(n) {
    switch (n) {
    case 5126:
        return Vre;
    case 35664:
        return jre;
    case 35665:
        return Wre;
    case 35666:
        return Kre;
    case 35674:
        return Xre;
    case 35675:
        return Yre;
    case 35676:
        return $re;
    case 5124:
    case 35670:
        return Zre;
    case 35667:
    case 35671:
        return Jre;
    case 35668:
    case 35672:
        return qre;
    case 35669:
    case 35673:
        return eie;
    case 5125:
        return tie;
    case 36294:
        return nie;
    case 36295:
        return rie;
    case 36296:
        return iie;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return sie;
    case 35679:
    case 36299:
    case 36307:
        return oie;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return aie;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return lie
    }
}
class Aie {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = t.type,
        this.setValue = Gre(t.type)
    }
}
class uie {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = cie(t.type)
    }
}
class fie {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, r) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, t[a.id], r)
        }
    }
}
const GE = /(\w+)(\])?(\[|\.)?/g;
function OL(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function hie(n, e, t) {
    const r = n.name
      , i = r.length;
    for (GE.lastIndex = 0; ; ) {
        const s = GE.exec(r)
          , o = GE.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === i) {
            OL(t, c === void 0 ? new Aie(a,n,e) : new uie(a,n,e));
            break
        } else {
            let u = t.map[a];
            u === void 0 && (u = new fie(a),
            OL(t, u)),
            t = u
        }
    }
}
class Cw {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < r; ++i) {
            const s = e.getActiveUniform(t, i)
              , o = e.getUniformLocation(t, s.name);
            hie(s, o, this)
        }
    }
    setValue(e, t, r, i) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, r, i)
    }
    setOptional(e, t, r) {
        const i = t[r];
        i !== void 0 && this.setValue(e, r, i)
    }
    static upload(e, t, r, i) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = r[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, t) {
        const r = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in t && r.push(o)
        }
        return r
    }
}
function kL(n, e, t) {
    const r = n.createShader(e);
    return n.shaderSource(r, t),
    n.compileShader(r),
    r
}
const die = 37297;
let pie = 0;
function mie(n, e) {
    const t = n.split(`
`)
      , r = []
      , i = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return r.join(`
`)
}
function gie(n) {
    const e = Et.getPrimaries(Et.workingColorSpace)
      , t = Et.getPrimaries(n);
    let r;
    switch (e === t ? r = "" : e === N_ && t === D_ ? r = "LinearDisplayP3ToLinearSRGB" : e === D_ && t === N_ && (r = "LinearSRGBToLinearDisplayP3"),
    n) {
    case Sr:
    case u1:
        return [r, "LinearTransferOETF"];
    case Ut:
    case LR:
        return [r, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [r, "LinearTransferOETF"]
    }
}
function QL(n, e, t) {
    const r = n.getShaderParameter(e, n.COMPILE_STATUS)
      , i = n.getShaderInfoLog(e).trim();
    if (r && i === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + i + `

` + mie(n.getShaderSource(e), o)
    } else
        return i
}
function vie(n, e) {
    const t = gie(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function yie(n, e) {
    let t;
    switch (e) {
    case fq:
        t = "Linear";
        break;
    case hq:
        t = "Reinhard";
        break;
    case dq:
        t = "Cineon";
        break;
    case pq:
        t = "ACESFilmic";
        break;
    case gq:
        t = "AgX";
        break;
    case vq:
        t = "Neutral";
        break;
    case mq:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const Uv = new $;
function wie() {
    Et.getLuminanceCoefficients(Uv);
    const n = Uv.x.toFixed(4)
      , e = Uv.y.toFixed(4)
      , t = Uv.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function _ie(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(xm).join(`
`)
}
function xie(n) {
    const e = [];
    for (const t in n) {
        const r = n[t];
        r !== !1 && e.push("#define " + t + " " + r)
    }
    return e.join(`
`)
}
function bie(n, e) {
    const t = {}
      , r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < r; i++) {
        const s = n.getActiveAttrib(e, i)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function xm(n) {
    return n !== ""
}
function HL(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function zL(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const Eie = /^[ \t]*#include +<([\w\d./]+)>/gm;
function FC(n) {
    return n.replace(Eie, Mie)
}
const Bie = new Map;
function Mie(n, e) {
    let t = Mt[e];
    if (t === void 0) {
        const r = Bie.get(e);
        if (r !== void 0)
            t = Mt[r],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return FC(t)
}
const Sie = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function GL(n) {
    return n.replace(Sie, Cie)
}
function Cie(n, e, t, r) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}
function VL(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function Tie(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === cz ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === jJ ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Bl && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function Iie(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Id:
        case Rd:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case c1:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function Rie(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Rd:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function Uie(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case l1:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case Aq:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case uq:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function Fie(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: r,
        maxMip: t
    }
}
function Pie(n, e, t, r) {
    const i = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = Tie(t)
      , c = Iie(t)
      , A = Rie(t)
      , u = Uie(t)
      , f = Fie(t)
      , h = _ie(t)
      , d = xie(s)
      , m = i.createProgram();
    let g, p, v = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, d].filter(xm).join(`
`),
    g.length > 0 && (g += `
`),
    p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, d].filter(xm).join(`
`),
    p.length > 0 && (p += `
`)) : (g = [VL(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, d, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + A : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(xm).join(`
`),
    p = [VL(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, d, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + A : "", t.envMap ? "#define " + u : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== fA ? "#define TONE_MAPPING" : "", t.toneMapping !== fA ? Mt.tonemapping_pars_fragment : "", t.toneMapping !== fA ? yie("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Mt.colorspace_pars_fragment, vie("linearToOutputTexel", t.outputColorSpace), wie(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(xm).join(`
`)),
    o = FC(o),
    o = HL(o, t),
    o = zL(o, t),
    a = FC(a),
    a = HL(a, t),
    a = zL(a, t),
    o = GL(o),
    a = GL(a),
    t.isRawShaderMaterial !== !0 && (v = `#version 300 es
`,
    g = [h, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g,
    p = ["#define varying in", t.glslVersion === oL ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === oL ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
    const w = v + g + o
      , _ = v + p + a
      , x = kL(i, i.VERTEX_SHADER, w)
      , b = kL(i, i.FRAGMENT_SHADER, _);
    i.attachShader(m, x),
    i.attachShader(m, b),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
    i.linkProgram(m);
    function B(L) {
        if (n.debug.checkShaderErrors) {
            const D = i.getProgramInfoLog(m).trim()
              , T = i.getShaderInfoLog(x).trim()
              , y = i.getShaderInfoLog(b).trim();
            let E = !0
              , R = !0;
            if (i.getProgramParameter(m, i.LINK_STATUS) === !1)
                if (E = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(i, m, x, b);
                else {
                    const F = QL(i, x, "vertex")
                      , O = QL(i, b, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + D + `
` + F + `
` + O)
                }
            else
                D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (T === "" || y === "") && (R = !1);
            R && (L.diagnostics = {
                runnable: E,
                programLog: D,
                vertexShader: {
                    log: T,
                    prefix: g
                },
                fragmentShader: {
                    log: y,
                    prefix: p
                }
            })
        }
        i.deleteShader(x),
        i.deleteShader(b),
        S = new Cw(i,m),
        I = bie(i, m)
    }
    let S;
    this.getUniforms = function() {
        return S === void 0 && B(this),
        S
    }
    ;
    let I;
    this.getAttributes = function() {
        return I === void 0 && B(this),
        I
    }
    ;
    let M = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return M === !1 && (M = i.getProgramParameter(m, die)),
        M
    }
    ,
    this.destroy = function() {
        r.releaseStatesOfProgram(this),
        i.deleteProgram(m),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = pie++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = m,
    this.vertexShader = x,
    this.fragmentShader = b,
    this
}
let Lie = 0;
class Die {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , r = e.fragmentShader
          , i = this._getShaderStage(t)
          , s = this._getShaderStage(r)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i),
        i.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const r of t)
            r.usedTimes--,
            r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let r = t.get(e);
        return r === void 0 && (r = new Set,
        t.set(e, r)),
        r
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let r = t.get(e);
        return r === void 0 && (r = new Nie(e),
        t.set(e, r)),
        r
    }
}
class Nie {
    constructor(e) {
        this.id = Lie++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Oie(n, e, t, r, i, s, o) {
    const a = new OR
      , l = new Die
      , c = new Set
      , A = []
      , u = i.logarithmicDepthBuffer
      , f = i.reverseDepthBuffer
      , h = i.vertexTextures;
    let d = i.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function g(M) {
        return c.add(M),
        M === 0 ? "uv" : `uv${M}`
    }
    function p(M, L, D, T, y) {
        const E = T.fog
          , R = y.geometry
          , F = M.isMeshStandardMaterial ? T.environment : null
          , O = (M.isMeshStandardMaterial ? t : e).get(M.envMap || F)
          , z = O && O.mapping === c1 ? O.image.height : null
          , j = m[M.type];
        M.precision !== null && (d = i.getMaxPrecision(M.precision),
        d !== M.precision && console.warn("THREE.WebGLProgram.getParameters:", M.precision, "not supported, using", d, "instead."));
        const Q = R.morphAttributes.position || R.morphAttributes.normal || R.morphAttributes.color
          , C = Q !== void 0 ? Q.length : 0;
        let W = 0;
        R.morphAttributes.position !== void 0 && (W = 1),
        R.morphAttributes.normal !== void 0 && (W = 2),
        R.morphAttributes.color !== void 0 && (W = 3);
        let ee, P, re, ue;
        if (j) {
            const xt = Ua[j];
            ee = xt.vertexShader,
            P = xt.fragmentShader
        } else
            ee = M.vertexShader,
            P = M.fragmentShader,
            l.update(M),
            re = l.getVertexShaderID(M),
            ue = l.getFragmentShaderID(M);
        const le = n.getRenderTarget()
          , me = y.isInstancedMesh === !0
          , ie = y.isBatchedMesh === !0
          , ge = !!M.map
          , _e = !!M.matcap
          , se = !!O
          , H = !!M.aoMap
          , fe = !!M.lightMap
          , Ae = !!M.bumpMap
          , J = !!M.normalMap
          , q = !!M.displacementMap
          , he = !!M.emissiveMap
          , X = !!M.metalnessMap
          , G = !!M.roughnessMap
          , ne = M.anisotropy > 0
          , Y = M.clearcoat > 0
          , de = M.dispersion > 0
          , ae = M.iridescence > 0
          , Ee = M.sheen > 0
          , V = M.transmission > 0
          , U = ne && !!M.anisotropyMap
          , N = Y && !!M.clearcoatMap
          , K = Y && !!M.clearcoatNormalMap
          , oe = Y && !!M.clearcoatRoughnessMap
          , pe = ae && !!M.iridescenceMap
          , ve = ae && !!M.iridescenceThicknessMap
          , Ce = Ee && !!M.sheenColorMap
          , Le = Ee && !!M.sheenRoughnessMap
          , Re = !!M.specularMap
          , $e = !!M.specularColorMap
          , ce = !!M.specularIntensityMap
          , Pe = V && !!M.transmissionMap
          , Se = V && !!M.thicknessMap
          , Te = !!M.gradientMap
          , Fe = !!M.alphaMap
          , De = M.alphaTest > 0
          , Ze = !!M.alphaHash
          , At = !!M.extensions;
        let Pn = fA;
        M.toneMapped && (le === null || le.isXRRenderTarget === !0) && (Pn = n.toneMapping);
        const rt = {
            shaderID: j,
            shaderType: M.type,
            shaderName: M.name,
            vertexShader: ee,
            fragmentShader: P,
            defines: M.defines,
            customVertexShaderID: re,
            customFragmentShaderID: ue,
            isRawShaderMaterial: M.isRawShaderMaterial === !0,
            glslVersion: M.glslVersion,
            precision: d,
            batching: ie,
            batchingColor: ie && y._colorsTexture !== null,
            instancing: me,
            instancingColor: me && y.instanceColor !== null,
            instancingMorph: me && y.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: le === null ? n.outputColorSpace : le.isXRRenderTarget === !0 ? le.texture.colorSpace : Sr,
            alphaToCoverage: !!M.alphaToCoverage,
            map: ge,
            matcap: _e,
            envMap: se,
            envMapMode: se && O.mapping,
            envMapCubeUVHeight: z,
            aoMap: H,
            lightMap: fe,
            bumpMap: Ae,
            normalMap: J,
            displacementMap: h && q,
            emissiveMap: he,
            normalMapObjectSpace: J && M.normalMapType === Sq,
            normalMapTangentSpace: J && M.normalMapType === Kd,
            metalnessMap: X,
            roughnessMap: G,
            anisotropy: ne,
            anisotropyMap: U,
            clearcoat: Y,
            clearcoatMap: N,
            clearcoatNormalMap: K,
            clearcoatRoughnessMap: oe,
            dispersion: de,
            iridescence: ae,
            iridescenceMap: pe,
            iridescenceThicknessMap: ve,
            sheen: Ee,
            sheenColorMap: Ce,
            sheenRoughnessMap: Le,
            specularMap: Re,
            specularColorMap: $e,
            specularIntensityMap: ce,
            transmission: V,
            transmissionMap: Pe,
            thicknessMap: Se,
            gradientMap: Te,
            opaque: M.transparent === !1 && M.blending === id && M.alphaToCoverage === !1,
            alphaMap: Fe,
            alphaTest: De,
            alphaHash: Ze,
            combine: M.combine,
            mapUv: ge && g(M.map.channel),
            aoMapUv: H && g(M.aoMap.channel),
            lightMapUv: fe && g(M.lightMap.channel),
            bumpMapUv: Ae && g(M.bumpMap.channel),
            normalMapUv: J && g(M.normalMap.channel),
            displacementMapUv: q && g(M.displacementMap.channel),
            emissiveMapUv: he && g(M.emissiveMap.channel),
            metalnessMapUv: X && g(M.metalnessMap.channel),
            roughnessMapUv: G && g(M.roughnessMap.channel),
            anisotropyMapUv: U && g(M.anisotropyMap.channel),
            clearcoatMapUv: N && g(M.clearcoatMap.channel),
            clearcoatNormalMapUv: K && g(M.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: oe && g(M.clearcoatRoughnessMap.channel),
            iridescenceMapUv: pe && g(M.iridescenceMap.channel),
            iridescenceThicknessMapUv: ve && g(M.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ce && g(M.sheenColorMap.channel),
            sheenRoughnessMapUv: Le && g(M.sheenRoughnessMap.channel),
            specularMapUv: Re && g(M.specularMap.channel),
            specularColorMapUv: $e && g(M.specularColorMap.channel),
            specularIntensityMapUv: ce && g(M.specularIntensityMap.channel),
            transmissionMapUv: Pe && g(M.transmissionMap.channel),
            thicknessMapUv: Se && g(M.thicknessMap.channel),
            alphaMapUv: Fe && g(M.alphaMap.channel),
            vertexTangents: !!R.attributes.tangent && (J || ne),
            vertexColors: M.vertexColors,
            vertexAlphas: M.vertexColors === !0 && !!R.attributes.color && R.attributes.color.itemSize === 4,
            pointsUvs: y.isPoints === !0 && !!R.attributes.uv && (ge || Fe),
            fog: !!E,
            useFog: M.fog === !0,
            fogExp2: !!E && E.isFogExp2,
            flatShading: M.flatShading === !0,
            sizeAttenuation: M.sizeAttenuation === !0,
            logarithmicDepthBuffer: u,
            reverseDepthBuffer: f,
            skinning: y.isSkinnedMesh === !0,
            morphTargets: R.morphAttributes.position !== void 0,
            morphNormals: R.morphAttributes.normal !== void 0,
            morphColors: R.morphAttributes.color !== void 0,
            morphTargetsCount: C,
            morphTextureStride: W,
            numDirLights: L.directional.length,
            numPointLights: L.point.length,
            numSpotLights: L.spot.length,
            numSpotLightMaps: L.spotLightMap.length,
            numRectAreaLights: L.rectArea.length,
            numHemiLights: L.hemi.length,
            numDirLightShadows: L.directionalShadowMap.length,
            numPointLightShadows: L.pointShadowMap.length,
            numSpotLightShadows: L.spotShadowMap.length,
            numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
            numLightProbes: L.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: M.dithering,
            shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Pn,
            decodeVideoTexture: ge && M.map.isVideoTexture === !0 && Et.getTransfer(M.map.colorSpace) === Sn,
            premultipliedAlpha: M.premultipliedAlpha,
            doubleSided: M.side === _i,
            flipSided: M.side === oi,
            useDepthPacking: M.depthPacking >= 0,
            depthPacking: M.depthPacking || 0,
            index0AttributeName: M.index0AttributeName,
            extensionClipCullDistance: At && M.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (At && M.extensions.multiDraw === !0 || ie) && r.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: M.customProgramCacheKey()
        };
        return rt.vertexUv1s = c.has(1),
        rt.vertexUv2s = c.has(2),
        rt.vertexUv3s = c.has(3),
        c.clear(),
        rt
    }
    function v(M) {
        const L = [];
        if (M.shaderID ? L.push(M.shaderID) : (L.push(M.customVertexShaderID),
        L.push(M.customFragmentShaderID)),
        M.defines !== void 0)
            for (const D in M.defines)
                L.push(D),
                L.push(M.defines[D]);
        return M.isRawShaderMaterial === !1 && (w(L, M),
        _(L, M),
        L.push(n.outputColorSpace)),
        L.push(M.customProgramCacheKey),
        L.join()
    }
    function w(M, L) {
        M.push(L.precision),
        M.push(L.outputColorSpace),
        M.push(L.envMapMode),
        M.push(L.envMapCubeUVHeight),
        M.push(L.mapUv),
        M.push(L.alphaMapUv),
        M.push(L.lightMapUv),
        M.push(L.aoMapUv),
        M.push(L.bumpMapUv),
        M.push(L.normalMapUv),
        M.push(L.displacementMapUv),
        M.push(L.emissiveMapUv),
        M.push(L.metalnessMapUv),
        M.push(L.roughnessMapUv),
        M.push(L.anisotropyMapUv),
        M.push(L.clearcoatMapUv),
        M.push(L.clearcoatNormalMapUv),
        M.push(L.clearcoatRoughnessMapUv),
        M.push(L.iridescenceMapUv),
        M.push(L.iridescenceThicknessMapUv),
        M.push(L.sheenColorMapUv),
        M.push(L.sheenRoughnessMapUv),
        M.push(L.specularMapUv),
        M.push(L.specularColorMapUv),
        M.push(L.specularIntensityMapUv),
        M.push(L.transmissionMapUv),
        M.push(L.thicknessMapUv),
        M.push(L.combine),
        M.push(L.fogExp2),
        M.push(L.sizeAttenuation),
        M.push(L.morphTargetsCount),
        M.push(L.morphAttributeCount),
        M.push(L.numDirLights),
        M.push(L.numPointLights),
        M.push(L.numSpotLights),
        M.push(L.numSpotLightMaps),
        M.push(L.numHemiLights),
        M.push(L.numRectAreaLights),
        M.push(L.numDirLightShadows),
        M.push(L.numPointLightShadows),
        M.push(L.numSpotLightShadows),
        M.push(L.numSpotLightShadowsWithMaps),
        M.push(L.numLightProbes),
        M.push(L.shadowMapType),
        M.push(L.toneMapping),
        M.push(L.numClippingPlanes),
        M.push(L.numClipIntersection),
        M.push(L.depthPacking)
    }
    function _(M, L) {
        a.disableAll(),
        L.supportsVertexTextures && a.enable(0),
        L.instancing && a.enable(1),
        L.instancingColor && a.enable(2),
        L.instancingMorph && a.enable(3),
        L.matcap && a.enable(4),
        L.envMap && a.enable(5),
        L.normalMapObjectSpace && a.enable(6),
        L.normalMapTangentSpace && a.enable(7),
        L.clearcoat && a.enable(8),
        L.iridescence && a.enable(9),
        L.alphaTest && a.enable(10),
        L.vertexColors && a.enable(11),
        L.vertexAlphas && a.enable(12),
        L.vertexUv1s && a.enable(13),
        L.vertexUv2s && a.enable(14),
        L.vertexUv3s && a.enable(15),
        L.vertexTangents && a.enable(16),
        L.anisotropy && a.enable(17),
        L.alphaHash && a.enable(18),
        L.batching && a.enable(19),
        L.dispersion && a.enable(20),
        L.batchingColor && a.enable(21),
        M.push(a.mask),
        a.disableAll(),
        L.fog && a.enable(0),
        L.useFog && a.enable(1),
        L.flatShading && a.enable(2),
        L.logarithmicDepthBuffer && a.enable(3),
        L.reverseDepthBuffer && a.enable(4),
        L.skinning && a.enable(5),
        L.morphTargets && a.enable(6),
        L.morphNormals && a.enable(7),
        L.morphColors && a.enable(8),
        L.premultipliedAlpha && a.enable(9),
        L.shadowMapEnabled && a.enable(10),
        L.doubleSided && a.enable(11),
        L.flipSided && a.enable(12),
        L.useDepthPacking && a.enable(13),
        L.dithering && a.enable(14),
        L.transmission && a.enable(15),
        L.sheen && a.enable(16),
        L.opaque && a.enable(17),
        L.pointsUvs && a.enable(18),
        L.decodeVideoTexture && a.enable(19),
        L.alphaToCoverage && a.enable(20),
        M.push(a.mask)
    }
    function x(M) {
        const L = m[M.type];
        let D;
        if (L) {
            const T = Ua[L];
            D = kR.clone(T.uniforms)
        } else
            D = M.uniforms;
        return D
    }
    function b(M, L) {
        let D;
        for (let T = 0, y = A.length; T < y; T++) {
            const E = A[T];
            if (E.cacheKey === L) {
                D = E,
                ++D.usedTimes;
                break
            }
        }
        return D === void 0 && (D = new Pie(n,L,M,s),
        A.push(D)),
        D
    }
    function B(M) {
        if (--M.usedTimes === 0) {
            const L = A.indexOf(M);
            A[L] = A[A.length - 1],
            A.pop(),
            M.destroy()
        }
    }
    function S(M) {
        l.remove(M)
    }
    function I() {
        l.dispose()
    }
    return {
        getParameters: p,
        getProgramCacheKey: v,
        getUniforms: x,
        acquireProgram: b,
        releaseProgram: B,
        releaseShaderCache: S,
        programs: A,
        dispose: I
    }
}
function kie() {
    let n = new WeakMap;
    function e(o) {
        return n.has(o)
    }
    function t(o) {
        let a = n.get(o);
        return a === void 0 && (a = {},
        n.set(o, a)),
        a
    }
    function r(o) {
        n.delete(o)
    }
    function i(o, a, l) {
        n.get(o)[a] = l
    }
    function s() {
        n = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: r,
        update: i,
        dispose: s
    }
}
function Qie(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function jL(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function WL() {
    const n = [];
    let e = 0;
    const t = []
      , r = []
      , i = [];
    function s() {
        e = 0,
        t.length = 0,
        r.length = 0,
        i.length = 0
    }
    function o(u, f, h, d, m, g) {
        let p = n[e];
        return p === void 0 ? (p = {
            id: u.id,
            object: u,
            geometry: f,
            material: h,
            groupOrder: d,
            renderOrder: u.renderOrder,
            z: m,
            group: g
        },
        n[e] = p) : (p.id = u.id,
        p.object = u,
        p.geometry = f,
        p.material = h,
        p.groupOrder = d,
        p.renderOrder = u.renderOrder,
        p.z = m,
        p.group = g),
        e++,
        p
    }
    function a(u, f, h, d, m, g) {
        const p = o(u, f, h, d, m, g);
        h.transmission > 0 ? r.push(p) : h.transparent === !0 ? i.push(p) : t.push(p)
    }
    function l(u, f, h, d, m, g) {
        const p = o(u, f, h, d, m, g);
        h.transmission > 0 ? r.unshift(p) : h.transparent === !0 ? i.unshift(p) : t.unshift(p)
    }
    function c(u, f) {
        t.length > 1 && t.sort(u || Qie),
        r.length > 1 && r.sort(f || jL),
        i.length > 1 && i.sort(f || jL)
    }
    function A() {
        for (let u = e, f = n.length; u < f; u++) {
            const h = n[u];
            if (h.id === null)
                break;
            h.id = null,
            h.object = null,
            h.geometry = null,
            h.material = null,
            h.group = null
        }
    }
    return {
        opaque: t,
        transmissive: r,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: A,
        sort: c
    }
}
function Hie() {
    let n = new WeakMap;
    function e(r, i) {
        const s = n.get(r);
        let o;
        return s === void 0 ? (o = new WL,
        n.set(r, [o])) : i >= s.length ? (o = new WL,
        s.push(o)) : o = s[i],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function zie() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new $,
                    color: new Qe
                };
                break;
            case "SpotLight":
                t = {
                    position: new $,
                    direction: new $,
                    color: new Qe,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new $,
                    color: new Qe,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new $,
                    skyColor: new Qe,
                    groundColor: new Qe
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Qe,
                    position: new $,
                    halfWidth: new $,
                    halfHeight: new $
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function Gie() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new We
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new We
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new We,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let Vie = 0;
function jie(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function Wie(n) {
    const e = new zie
      , t = Gie()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        r.probe.push(new $);
    const i = new $
      , s = new He
      , o = new He;
    function a(c) {
        let A = 0
          , u = 0
          , f = 0;
        for (let I = 0; I < 9; I++)
            r.probe[I].set(0, 0, 0);
        let h = 0
          , d = 0
          , m = 0
          , g = 0
          , p = 0
          , v = 0
          , w = 0
          , _ = 0
          , x = 0
          , b = 0
          , B = 0;
        c.sort(jie);
        for (let I = 0, M = c.length; I < M; I++) {
            const L = c[I]
              , D = L.color
              , T = L.intensity
              , y = L.distance
              , E = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
            if (L.isAmbientLight)
                A += D.r * T,
                u += D.g * T,
                f += D.b * T;
            else if (L.isLightProbe) {
                for (let R = 0; R < 9; R++)
                    r.probe[R].addScaledVector(L.sh.coefficients[R], T);
                B++
            } else if (L.isDirectionalLight) {
                const R = e.get(L);
                if (R.color.copy(L.color).multiplyScalar(L.intensity),
                L.castShadow) {
                    const F = L.shadow
                      , O = t.get(L);
                    O.shadowIntensity = F.intensity,
                    O.shadowBias = F.bias,
                    O.shadowNormalBias = F.normalBias,
                    O.shadowRadius = F.radius,
                    O.shadowMapSize = F.mapSize,
                    r.directionalShadow[h] = O,
                    r.directionalShadowMap[h] = E,
                    r.directionalShadowMatrix[h] = L.shadow.matrix,
                    v++
                }
                r.directional[h] = R,
                h++
            } else if (L.isSpotLight) {
                const R = e.get(L);
                R.position.setFromMatrixPosition(L.matrixWorld),
                R.color.copy(D).multiplyScalar(T),
                R.distance = y,
                R.coneCos = Math.cos(L.angle),
                R.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)),
                R.decay = L.decay,
                r.spot[m] = R;
                const F = L.shadow;
                if (L.map && (r.spotLightMap[x] = L.map,
                x++,
                F.updateMatrices(L),
                L.castShadow && b++),
                r.spotLightMatrix[m] = F.matrix,
                L.castShadow) {
                    const O = t.get(L);
                    O.shadowIntensity = F.intensity,
                    O.shadowBias = F.bias,
                    O.shadowNormalBias = F.normalBias,
                    O.shadowRadius = F.radius,
                    O.shadowMapSize = F.mapSize,
                    r.spotShadow[m] = O,
                    r.spotShadowMap[m] = E,
                    _++
                }
                m++
            } else if (L.isRectAreaLight) {
                const R = e.get(L);
                R.color.copy(D).multiplyScalar(T),
                R.halfWidth.set(L.width * .5, 0, 0),
                R.halfHeight.set(0, L.height * .5, 0),
                r.rectArea[g] = R,
                g++
            } else if (L.isPointLight) {
                const R = e.get(L);
                if (R.color.copy(L.color).multiplyScalar(L.intensity),
                R.distance = L.distance,
                R.decay = L.decay,
                L.castShadow) {
                    const F = L.shadow
                      , O = t.get(L);
                    O.shadowIntensity = F.intensity,
                    O.shadowBias = F.bias,
                    O.shadowNormalBias = F.normalBias,
                    O.shadowRadius = F.radius,
                    O.shadowMapSize = F.mapSize,
                    O.shadowCameraNear = F.camera.near,
                    O.shadowCameraFar = F.camera.far,
                    r.pointShadow[d] = O,
                    r.pointShadowMap[d] = E,
                    r.pointShadowMatrix[d] = L.shadow.matrix,
                    w++
                }
                r.point[d] = R,
                d++
            } else if (L.isHemisphereLight) {
                const R = e.get(L);
                R.skyColor.copy(L.color).multiplyScalar(T),
                R.groundColor.copy(L.groundColor).multiplyScalar(T),
                r.hemi[p] = R,
                p++
            }
        }
        g > 0 && (n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Ge.LTC_FLOAT_1,
        r.rectAreaLTC2 = Ge.LTC_FLOAT_2) : (r.rectAreaLTC1 = Ge.LTC_HALF_1,
        r.rectAreaLTC2 = Ge.LTC_HALF_2)),
        r.ambient[0] = A,
        r.ambient[1] = u,
        r.ambient[2] = f;
        const S = r.hash;
        (S.directionalLength !== h || S.pointLength !== d || S.spotLength !== m || S.rectAreaLength !== g || S.hemiLength !== p || S.numDirectionalShadows !== v || S.numPointShadows !== w || S.numSpotShadows !== _ || S.numSpotMaps !== x || S.numLightProbes !== B) && (r.directional.length = h,
        r.spot.length = m,
        r.rectArea.length = g,
        r.point.length = d,
        r.hemi.length = p,
        r.directionalShadow.length = v,
        r.directionalShadowMap.length = v,
        r.pointShadow.length = w,
        r.pointShadowMap.length = w,
        r.spotShadow.length = _,
        r.spotShadowMap.length = _,
        r.directionalShadowMatrix.length = v,
        r.pointShadowMatrix.length = w,
        r.spotLightMatrix.length = _ + x - b,
        r.spotLightMap.length = x,
        r.numSpotLightShadowsWithMaps = b,
        r.numLightProbes = B,
        S.directionalLength = h,
        S.pointLength = d,
        S.spotLength = m,
        S.rectAreaLength = g,
        S.hemiLength = p,
        S.numDirectionalShadows = v,
        S.numPointShadows = w,
        S.numSpotShadows = _,
        S.numSpotMaps = x,
        S.numLightProbes = B,
        r.version = Vie++)
    }
    function l(c, A) {
        let u = 0
          , f = 0
          , h = 0
          , d = 0
          , m = 0;
        const g = A.matrixWorldInverse;
        for (let p = 0, v = c.length; p < v; p++) {
            const w = c[p];
            if (w.isDirectionalLight) {
                const _ = r.directional[u];
                _.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                _.direction.sub(i),
                _.direction.transformDirection(g),
                u++
            } else if (w.isSpotLight) {
                const _ = r.spot[h];
                _.position.setFromMatrixPosition(w.matrixWorld),
                _.position.applyMatrix4(g),
                _.direction.setFromMatrixPosition(w.matrixWorld),
                i.setFromMatrixPosition(w.target.matrixWorld),
                _.direction.sub(i),
                _.direction.transformDirection(g),
                h++
            } else if (w.isRectAreaLight) {
                const _ = r.rectArea[d];
                _.position.setFromMatrixPosition(w.matrixWorld),
                _.position.applyMatrix4(g),
                o.identity(),
                s.copy(w.matrixWorld),
                s.premultiply(g),
                o.extractRotation(s),
                _.halfWidth.set(w.width * .5, 0, 0),
                _.halfHeight.set(0, w.height * .5, 0),
                _.halfWidth.applyMatrix4(o),
                _.halfHeight.applyMatrix4(o),
                d++
            } else if (w.isPointLight) {
                const _ = r.point[f];
                _.position.setFromMatrixPosition(w.matrixWorld),
                _.position.applyMatrix4(g),
                f++
            } else if (w.isHemisphereLight) {
                const _ = r.hemi[m];
                _.direction.setFromMatrixPosition(w.matrixWorld),
                _.direction.transformDirection(g),
                m++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: r
    }
}
function KL(n) {
    const e = new Wie(n)
      , t = []
      , r = [];
    function i(A) {
        c.camera = A,
        t.length = 0,
        r.length = 0
    }
    function s(A) {
        t.push(A)
    }
    function o(A) {
        r.push(A)
    }
    function a() {
        e.setup(t)
    }
    function l(A) {
        e.setupView(t, A)
    }
    const c = {
        lightsArray: t,
        shadowsArray: r,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}
function Kie(n) {
    let e = new WeakMap;
    function t(i, s=0) {
        const o = e.get(i);
        let a;
        return o === void 0 ? (a = new KL(n),
        e.set(i, [a])) : s >= o.length ? (a = new KL(n),
        o.push(a)) : a = o[s],
        a
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: r
    }
}
class Xie extends as {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Bq,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Yie extends as {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const $ie = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , Zie = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Jie(n, e, t) {
    let r = new h1;
    const i = new We
      , s = new We
      , o = new Pt
      , a = new Xie({
        depthPacking: Mq
    })
      , l = new Yie
      , c = {}
      , A = t.maxTextureSize
      , u = {
        [Hs]: oi,
        [oi]: Hs,
        [_i]: _i
    }
      , f = new mr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new We
            },
            radius: {
                value: 4
            }
        },
        vertexShader: $ie,
        fragmentShader: Zie
    })
      , h = f.clone();
    h.defines.HORIZONTAL_PASS = 1;
    const d = new Jt;
    d.setAttribute("position", new ct(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const m = new dn(d,f)
      , g = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = cz;
    let p = this.type;
    this.render = function(b, B, S) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || b.length === 0)
            return;
        const I = n.getRenderTarget()
          , M = n.getActiveCubeFace()
          , L = n.getActiveMipmapLevel()
          , D = n.state;
        D.setBlending(jl),
        D.buffers.color.setClear(1, 1, 1, 1),
        D.buffers.depth.setTest(!0),
        D.setScissorTest(!1);
        const T = p !== Bl && this.type === Bl
          , y = p === Bl && this.type !== Bl;
        for (let E = 0, R = b.length; E < R; E++) {
            const F = b[E]
              , O = F.shadow;
            if (O === void 0) {
                console.warn("THREE.WebGLShadowMap:", F, "has no shadow.");
                continue
            }
            if (O.autoUpdate === !1 && O.needsUpdate === !1)
                continue;
            i.copy(O.mapSize);
            const z = O.getFrameExtents();
            if (i.multiply(z),
            s.copy(O.mapSize),
            (i.x > A || i.y > A) && (i.x > A && (s.x = Math.floor(A / z.x),
            i.x = s.x * z.x,
            O.mapSize.x = s.x),
            i.y > A && (s.y = Math.floor(A / z.y),
            i.y = s.y * z.y,
            O.mapSize.y = s.y)),
            O.map === null || T === !0 || y === !0) {
                const Q = this.type !== Bl ? {
                    minFilter: Xr,
                    magFilter: Xr
                } : {};
                O.map !== null && O.map.dispose(),
                O.map = new tl(i.x,i.y,Q),
                O.map.texture.name = F.name + ".shadowMap",
                O.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(O.map),
            n.clear();
            const j = O.getViewportCount();
            for (let Q = 0; Q < j; Q++) {
                const C = O.getViewport(Q);
                o.set(s.x * C.x, s.y * C.y, s.x * C.z, s.y * C.w),
                D.viewport(o),
                O.updateMatrices(F, Q),
                r = O.getFrustum(),
                _(B, S, O.camera, F, this.type)
            }
            O.isPointLightShadow !== !0 && this.type === Bl && v(O, S),
            O.needsUpdate = !1
        }
        p = this.type,
        g.needsUpdate = !1,
        n.setRenderTarget(I, M, L)
    }
    ;
    function v(b, B) {
        const S = e.update(m);
        f.defines.VSM_SAMPLES !== b.blurSamples && (f.defines.VSM_SAMPLES = b.blurSamples,
        h.defines.VSM_SAMPLES = b.blurSamples,
        f.needsUpdate = !0,
        h.needsUpdate = !0),
        b.mapPass === null && (b.mapPass = new tl(i.x,i.y)),
        f.uniforms.shadow_pass.value = b.map.texture,
        f.uniforms.resolution.value = b.mapSize,
        f.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.mapPass),
        n.clear(),
        n.renderBufferDirect(B, null, S, f, m, null),
        h.uniforms.shadow_pass.value = b.mapPass.texture,
        h.uniforms.resolution.value = b.mapSize,
        h.uniforms.radius.value = b.radius,
        n.setRenderTarget(b.map),
        n.clear(),
        n.renderBufferDirect(B, null, S, h, m, null)
    }
    function w(b, B, S, I) {
        let M = null;
        const L = S.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
        if (L !== void 0)
            M = L;
        else if (M = S.isPointLight === !0 ? l : a,
        n.localClippingEnabled && B.clipShadows === !0 && Array.isArray(B.clippingPlanes) && B.clippingPlanes.length !== 0 || B.displacementMap && B.displacementScale !== 0 || B.alphaMap && B.alphaTest > 0 || B.map && B.alphaTest > 0) {
            const D = M.uuid
              , T = B.uuid;
            let y = c[D];
            y === void 0 && (y = {},
            c[D] = y);
            let E = y[T];
            E === void 0 && (E = M.clone(),
            y[T] = E,
            B.addEventListener("dispose", x)),
            M = E
        }
        if (M.visible = B.visible,
        M.wireframe = B.wireframe,
        I === Bl ? M.side = B.shadowSide !== null ? B.shadowSide : B.side : M.side = B.shadowSide !== null ? B.shadowSide : u[B.side],
        M.alphaMap = B.alphaMap,
        M.alphaTest = B.alphaTest,
        M.map = B.map,
        M.clipShadows = B.clipShadows,
        M.clippingPlanes = B.clippingPlanes,
        M.clipIntersection = B.clipIntersection,
        M.displacementMap = B.displacementMap,
        M.displacementScale = B.displacementScale,
        M.displacementBias = B.displacementBias,
        M.wireframeLinewidth = B.wireframeLinewidth,
        M.linewidth = B.linewidth,
        S.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
            const D = n.properties.get(M);
            D.light = S
        }
        return M
    }
    function _(b, B, S, I, M) {
        if (b.visible === !1)
            return;
        if (b.layers.test(B.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && M === Bl) && (!b.frustumCulled || r.intersectsObject(b))) {
            b.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, b.matrixWorld);
            const T = e.update(b)
              , y = b.material;
            if (Array.isArray(y)) {
                const E = T.groups;
                for (let R = 0, F = E.length; R < F; R++) {
                    const O = E[R]
                      , z = y[O.materialIndex];
                    if (z && z.visible) {
                        const j = w(b, z, I, M);
                        b.onBeforeShadow(n, b, B, S, T, j, O),
                        n.renderBufferDirect(S, null, T, j, b, O),
                        b.onAfterShadow(n, b, B, S, T, j, O)
                    }
                }
            } else if (y.visible) {
                const E = w(b, y, I, M);
                b.onBeforeShadow(n, b, B, S, T, E, null),
                n.renderBufferDirect(S, null, T, E, b, null),
                b.onAfterShadow(n, b, B, S, T, E, null)
            }
        }
        const D = b.children;
        for (let T = 0, y = D.length; T < y; T++)
            _(D[T], B, S, I, M)
    }
    function x(b) {
        b.target.removeEventListener("dispose", x);
        for (const S in c) {
            const I = c[S]
              , M = b.target.uuid;
            M in I && (I[M].dispose(),
            delete I[M])
        }
    }
}
const qie = {
    [ZS]: JS,
    [qS]: nC,
    [eC]: rC,
    [Td]: tC,
    [JS]: ZS,
    [nC]: qS,
    [rC]: eC,
    [tC]: Td
};
function ese(n) {
    function e() {
        let ce = !1;
        const Pe = new Pt;
        let Se = null;
        const Te = new Pt(0,0,0,0);
        return {
            setMask: function(Fe) {
                Se !== Fe && !ce && (n.colorMask(Fe, Fe, Fe, Fe),
                Se = Fe)
            },
            setLocked: function(Fe) {
                ce = Fe
            },
            setClear: function(Fe, De, Ze, At, Pn) {
                Pn === !0 && (Fe *= At,
                De *= At,
                Ze *= At),
                Pe.set(Fe, De, Ze, At),
                Te.equals(Pe) === !1 && (n.clearColor(Fe, De, Ze, At),
                Te.copy(Pe))
            },
            reset: function() {
                ce = !1,
                Se = null,
                Te.set(-1, 0, 0, 0)
            }
        }
    }
    function t() {
        let ce = !1
          , Pe = !1
          , Se = null
          , Te = null
          , Fe = null;
        return {
            setReversed: function(De) {
                Pe = De
            },
            setTest: function(De) {
                De ? re(n.DEPTH_TEST) : ue(n.DEPTH_TEST)
            },
            setMask: function(De) {
                Se !== De && !ce && (n.depthMask(De),
                Se = De)
            },
            setFunc: function(De) {
                if (Pe && (De = qie[De]),
                Te !== De) {
                    switch (De) {
                    case ZS:
                        n.depthFunc(n.NEVER);
                        break;
                    case JS:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case qS:
                        n.depthFunc(n.LESS);
                        break;
                    case Td:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case eC:
                        n.depthFunc(n.EQUAL);
                        break;
                    case tC:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case nC:
                        n.depthFunc(n.GREATER);
                        break;
                    case rC:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    Te = De
                }
            },
            setLocked: function(De) {
                ce = De
            },
            setClear: function(De) {
                Fe !== De && (n.clearDepth(De),
                Fe = De)
            },
            reset: function() {
                ce = !1,
                Se = null,
                Te = null,
                Fe = null
            }
        }
    }
    function r() {
        let ce = !1
          , Pe = null
          , Se = null
          , Te = null
          , Fe = null
          , De = null
          , Ze = null
          , At = null
          , Pn = null;
        return {
            setTest: function(rt) {
                ce || (rt ? re(n.STENCIL_TEST) : ue(n.STENCIL_TEST))
            },
            setMask: function(rt) {
                Pe !== rt && !ce && (n.stencilMask(rt),
                Pe = rt)
            },
            setFunc: function(rt, xt, Tr) {
                (Se !== rt || Te !== xt || Fe !== Tr) && (n.stencilFunc(rt, xt, Tr),
                Se = rt,
                Te = xt,
                Fe = Tr)
            },
            setOp: function(rt, xt, Tr) {
                (De !== rt || Ze !== xt || At !== Tr) && (n.stencilOp(rt, xt, Tr),
                De = rt,
                Ze = xt,
                At = Tr)
            },
            setLocked: function(rt) {
                ce = rt
            },
            setClear: function(rt) {
                Pn !== rt && (n.clearStencil(rt),
                Pn = rt)
            },
            reset: function() {
                ce = !1,
                Pe = null,
                Se = null,
                Te = null,
                Fe = null,
                De = null,
                Ze = null,
                At = null,
                Pn = null
            }
        }
    }
    const i = new e
      , s = new t
      , o = new r
      , a = new WeakMap
      , l = new WeakMap;
    let c = {}
      , A = {}
      , u = new WeakMap
      , f = []
      , h = null
      , d = !1
      , m = null
      , g = null
      , p = null
      , v = null
      , w = null
      , _ = null
      , x = null
      , b = new Qe(0,0,0)
      , B = 0
      , S = !1
      , I = null
      , M = null
      , L = null
      , D = null
      , T = null;
    const y = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let E = !1
      , R = 0;
    const F = n.getParameter(n.VERSION);
    F.indexOf("WebGL") !== -1 ? (R = parseFloat(/^WebGL (\d)/.exec(F)[1]),
    E = R >= 1) : F.indexOf("OpenGL ES") !== -1 && (R = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),
    E = R >= 2);
    let O = null
      , z = {};
    const j = n.getParameter(n.SCISSOR_BOX)
      , Q = n.getParameter(n.VIEWPORT)
      , C = new Pt().fromArray(j)
      , W = new Pt().fromArray(Q);
    function ee(ce, Pe, Se, Te) {
        const Fe = new Uint8Array(4)
          , De = n.createTexture();
        n.bindTexture(ce, De),
        n.texParameteri(ce, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(ce, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let Ze = 0; Ze < Se; Ze++)
            ce === n.TEXTURE_3D || ce === n.TEXTURE_2D_ARRAY ? n.texImage3D(Pe, 0, n.RGBA, 1, 1, Te, 0, n.RGBA, n.UNSIGNED_BYTE, Fe) : n.texImage2D(Pe + Ze, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Fe);
        return De
    }
    const P = {};
    P[n.TEXTURE_2D] = ee(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    P[n.TEXTURE_CUBE_MAP] = ee(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    P[n.TEXTURE_2D_ARRAY] = ee(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    P[n.TEXTURE_3D] = ee(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1),
    i.setClear(0, 0, 0, 1),
    s.setClear(1),
    o.setClear(0),
    re(n.DEPTH_TEST),
    s.setFunc(Td),
    fe(!1),
    Ae(tL),
    re(n.CULL_FACE),
    se(jl);
    function re(ce) {
        c[ce] !== !0 && (n.enable(ce),
        c[ce] = !0)
    }
    function ue(ce) {
        c[ce] !== !1 && (n.disable(ce),
        c[ce] = !1)
    }
    function le(ce, Pe) {
        return A[ce] !== Pe ? (n.bindFramebuffer(ce, Pe),
        A[ce] = Pe,
        ce === n.DRAW_FRAMEBUFFER && (A[n.FRAMEBUFFER] = Pe),
        ce === n.FRAMEBUFFER && (A[n.DRAW_FRAMEBUFFER] = Pe),
        !0) : !1
    }
    function me(ce, Pe) {
        let Se = f
          , Te = !1;
        if (ce) {
            Se = u.get(Pe),
            Se === void 0 && (Se = [],
            u.set(Pe, Se));
            const Fe = ce.textures;
            if (Se.length !== Fe.length || Se[0] !== n.COLOR_ATTACHMENT0) {
                for (let De = 0, Ze = Fe.length; De < Ze; De++)
                    Se[De] = n.COLOR_ATTACHMENT0 + De;
                Se.length = Fe.length,
                Te = !0
            }
        } else
            Se[0] !== n.BACK && (Se[0] = n.BACK,
            Te = !0);
        Te && n.drawBuffers(Se)
    }
    function ie(ce) {
        return h !== ce ? (n.useProgram(ce),
        h = ce,
        !0) : !1
    }
    const ge = {
        [au]: n.FUNC_ADD,
        [KJ]: n.FUNC_SUBTRACT,
        [XJ]: n.FUNC_REVERSE_SUBTRACT
    };
    ge[YJ] = n.MIN,
    ge[$J] = n.MAX;
    const _e = {
        [ZJ]: n.ZERO,
        [JJ]: n.ONE,
        [qJ]: n.SRC_COLOR,
        [YS]: n.SRC_ALPHA,
        [sq]: n.SRC_ALPHA_SATURATE,
        [rq]: n.DST_COLOR,
        [tq]: n.DST_ALPHA,
        [eq]: n.ONE_MINUS_SRC_COLOR,
        [$S]: n.ONE_MINUS_SRC_ALPHA,
        [iq]: n.ONE_MINUS_DST_COLOR,
        [nq]: n.ONE_MINUS_DST_ALPHA,
        [oq]: n.CONSTANT_COLOR,
        [aq]: n.ONE_MINUS_CONSTANT_COLOR,
        [lq]: n.CONSTANT_ALPHA,
        [cq]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function se(ce, Pe, Se, Te, Fe, De, Ze, At, Pn, rt) {
        if (ce === jl) {
            d === !0 && (ue(n.BLEND),
            d = !1);
            return
        }
        if (d === !1 && (re(n.BLEND),
        d = !0),
        ce !== WJ) {
            if (ce !== m || rt !== S) {
                if ((g !== au || w !== au) && (n.blendEquation(n.FUNC_ADD),
                g = au,
                w = au),
                rt)
                    switch (ce) {
                    case id:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Du:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case nL:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case rL:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ce);
                        break
                    }
                else
                    switch (ce) {
                    case id:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Du:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case nL:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case rL:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ce);
                        break
                    }
                p = null,
                v = null,
                _ = null,
                x = null,
                b.set(0, 0, 0),
                B = 0,
                m = ce,
                S = rt
            }
            return
        }
        Fe = Fe || Pe,
        De = De || Se,
        Ze = Ze || Te,
        (Pe !== g || Fe !== w) && (n.blendEquationSeparate(ge[Pe], ge[Fe]),
        g = Pe,
        w = Fe),
        (Se !== p || Te !== v || De !== _ || Ze !== x) && (n.blendFuncSeparate(_e[Se], _e[Te], _e[De], _e[Ze]),
        p = Se,
        v = Te,
        _ = De,
        x = Ze),
        (At.equals(b) === !1 || Pn !== B) && (n.blendColor(At.r, At.g, At.b, Pn),
        b.copy(At),
        B = Pn),
        m = ce,
        S = !1
    }
    function H(ce, Pe) {
        ce.side === _i ? ue(n.CULL_FACE) : re(n.CULL_FACE);
        let Se = ce.side === oi;
        Pe && (Se = !Se),
        fe(Se),
        ce.blending === id && ce.transparent === !1 ? se(jl) : se(ce.blending, ce.blendEquation, ce.blendSrc, ce.blendDst, ce.blendEquationAlpha, ce.blendSrcAlpha, ce.blendDstAlpha, ce.blendColor, ce.blendAlpha, ce.premultipliedAlpha),
        s.setFunc(ce.depthFunc),
        s.setTest(ce.depthTest),
        s.setMask(ce.depthWrite),
        i.setMask(ce.colorWrite);
        const Te = ce.stencilWrite;
        o.setTest(Te),
        Te && (o.setMask(ce.stencilWriteMask),
        o.setFunc(ce.stencilFunc, ce.stencilRef, ce.stencilFuncMask),
        o.setOp(ce.stencilFail, ce.stencilZFail, ce.stencilZPass)),
        q(ce.polygonOffset, ce.polygonOffsetFactor, ce.polygonOffsetUnits),
        ce.alphaToCoverage === !0 ? re(n.SAMPLE_ALPHA_TO_COVERAGE) : ue(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function fe(ce) {
        I !== ce && (ce ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        I = ce)
    }
    function Ae(ce) {
        ce !== GJ ? (re(n.CULL_FACE),
        ce !== M && (ce === tL ? n.cullFace(n.BACK) : ce === VJ ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ue(n.CULL_FACE),
        M = ce
    }
    function J(ce) {
        ce !== L && (E && n.lineWidth(ce),
        L = ce)
    }
    function q(ce, Pe, Se) {
        ce ? (re(n.POLYGON_OFFSET_FILL),
        (D !== Pe || T !== Se) && (n.polygonOffset(Pe, Se),
        D = Pe,
        T = Se)) : ue(n.POLYGON_OFFSET_FILL)
    }
    function he(ce) {
        ce ? re(n.SCISSOR_TEST) : ue(n.SCISSOR_TEST)
    }
    function X(ce) {
        ce === void 0 && (ce = n.TEXTURE0 + y - 1),
        O !== ce && (n.activeTexture(ce),
        O = ce)
    }
    function G(ce, Pe, Se) {
        Se === void 0 && (O === null ? Se = n.TEXTURE0 + y - 1 : Se = O);
        let Te = z[Se];
        Te === void 0 && (Te = {
            type: void 0,
            texture: void 0
        },
        z[Se] = Te),
        (Te.type !== ce || Te.texture !== Pe) && (O !== Se && (n.activeTexture(Se),
        O = Se),
        n.bindTexture(ce, Pe || P[ce]),
        Te.type = ce,
        Te.texture = Pe)
    }
    function ne() {
        const ce = z[O];
        ce !== void 0 && ce.type !== void 0 && (n.bindTexture(ce.type, null),
        ce.type = void 0,
        ce.texture = void 0)
    }
    function Y() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function de() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function ae() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function Ee() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function V() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function U() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function N() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function K() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function oe() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function pe() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (ce) {
            console.error("THREE.WebGLState:", ce)
        }
    }
    function ve(ce) {
        C.equals(ce) === !1 && (n.scissor(ce.x, ce.y, ce.z, ce.w),
        C.copy(ce))
    }
    function Ce(ce) {
        W.equals(ce) === !1 && (n.viewport(ce.x, ce.y, ce.z, ce.w),
        W.copy(ce))
    }
    function Le(ce, Pe) {
        let Se = l.get(Pe);
        Se === void 0 && (Se = new WeakMap,
        l.set(Pe, Se));
        let Te = Se.get(ce);
        Te === void 0 && (Te = n.getUniformBlockIndex(Pe, ce.name),
        Se.set(ce, Te))
    }
    function Re(ce, Pe) {
        const Te = l.get(Pe).get(ce);
        a.get(Pe) !== Te && (n.uniformBlockBinding(Pe, Te, ce.__bindingPointIndex),
        a.set(Pe, Te))
    }
    function $e() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        c = {},
        O = null,
        z = {},
        A = {},
        u = new WeakMap,
        f = [],
        h = null,
        d = !1,
        m = null,
        g = null,
        p = null,
        v = null,
        w = null,
        _ = null,
        x = null,
        b = new Qe(0,0,0),
        B = 0,
        S = !1,
        I = null,
        M = null,
        L = null,
        D = null,
        T = null,
        C.set(0, 0, n.canvas.width, n.canvas.height),
        W.set(0, 0, n.canvas.width, n.canvas.height),
        i.reset(),
        s.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: i,
            depth: s,
            stencil: o
        },
        enable: re,
        disable: ue,
        bindFramebuffer: le,
        drawBuffers: me,
        useProgram: ie,
        setBlending: se,
        setMaterial: H,
        setFlipSided: fe,
        setCullFace: Ae,
        setLineWidth: J,
        setPolygonOffset: q,
        setScissorTest: he,
        activeTexture: X,
        bindTexture: G,
        unbindTexture: ne,
        compressedTexImage2D: Y,
        compressedTexImage3D: de,
        texImage2D: oe,
        texImage3D: pe,
        updateUBOMapping: Le,
        uniformBlockBinding: Re,
        texStorage2D: N,
        texStorage3D: K,
        texSubImage2D: ae,
        texSubImage3D: Ee,
        compressedTexSubImage2D: V,
        compressedTexSubImage3D: U,
        scissor: ve,
        viewport: Ce,
        reset: $e
    }
}
function XL(n, e, t, r) {
    const i = tse(r);
    switch (t) {
    case dz:
        return n * e;
    case mz:
        return n * e;
    case gz:
        return n * e * 2;
    case RR:
        return n * e / i.components * i.byteLength;
    case A1:
        return n * e / i.components * i.byteLength;
    case vz:
        return n * e * 2 / i.components * i.byteLength;
    case UR:
        return n * e * 2 / i.components * i.byteLength;
    case pz:
        return n * e * 3 / i.components * i.byteLength;
    case Nr:
        return n * e * 4 / i.components * i.byteLength;
    case FR:
        return n * e * 4 / i.components * i.byteLength;
    case xw:
    case bw:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Ew:
    case Bw:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case oC:
    case lC:
        return Math.max(n, 16) * Math.max(e, 8) / 4;
    case sC:
    case aC:
        return Math.max(n, 8) * Math.max(e, 8) / 2;
    case cC:
    case AC:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case uC:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fC:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case hC:
        return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case dC:
        return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case pC:
        return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case mC:
        return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case gC:
        return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case vC:
        return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case yC:
        return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case wC:
        return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case _C:
        return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case xC:
        return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case bC:
        return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case EC:
        return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case BC:
        return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Mw:
    case MC:
    case SC:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case yz:
    case CC:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case TC:
    case IC:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function tse(n) {
    switch (n) {
    case rc:
    case uz:
        return {
            byteLength: 1,
            components: 1
        };
    case Hg:
    case fz:
    case Ha:
        return {
            byteLength: 2,
            components: 1
        };
    case TR:
    case IR:
        return {
            byteLength: 2,
            components: 4
        };
    case wA:
    case CR:
    case xi:
        return {
            byteLength: 4,
            components: 1
        };
    case hz:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${n}.`)
}
function nse(n, e, t, r, i, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new We
      , A = new WeakMap;
    let u;
    const f = new WeakMap;
    let h = !1;
    try {
        h = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function d(X, G) {
        return h ? new OffscreenCanvas(X,G) : zg("canvas")
    }
    function m(X, G, ne) {
        let Y = 1;
        const de = he(X);
        if ((de.width > ne || de.height > ne) && (Y = ne / Math.max(de.width, de.height)),
        Y < 1)
            if (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && X instanceof ImageBitmap || typeof VideoFrame < "u" && X instanceof VideoFrame) {
                const ae = Math.floor(Y * de.width)
                  , Ee = Math.floor(Y * de.height);
                u === void 0 && (u = d(ae, Ee));
                const V = G ? d(ae, Ee) : u;
                return V.width = ae,
                V.height = Ee,
                V.getContext("2d").drawImage(X, 0, 0, ae, Ee),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + de.width + "x" + de.height + ") to (" + ae + "x" + Ee + ")."),
                V
            } else
                return "data"in X && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + de.width + "x" + de.height + ")."),
                X;
        return X
    }
    function g(X) {
        return X.generateMipmaps && X.minFilter !== Xr && X.minFilter !== Lr
    }
    function p(X) {
        n.generateMipmap(X)
    }
    function v(X, G, ne, Y, de=!1) {
        if (X !== null) {
            if (n[X] !== void 0)
                return n[X];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + X + "'")
        }
        let ae = G;
        if (G === n.RED && (ne === n.FLOAT && (ae = n.R32F),
        ne === n.HALF_FLOAT && (ae = n.R16F),
        ne === n.UNSIGNED_BYTE && (ae = n.R8)),
        G === n.RED_INTEGER && (ne === n.UNSIGNED_BYTE && (ae = n.R8UI),
        ne === n.UNSIGNED_SHORT && (ae = n.R16UI),
        ne === n.UNSIGNED_INT && (ae = n.R32UI),
        ne === n.BYTE && (ae = n.R8I),
        ne === n.SHORT && (ae = n.R16I),
        ne === n.INT && (ae = n.R32I)),
        G === n.RG && (ne === n.FLOAT && (ae = n.RG32F),
        ne === n.HALF_FLOAT && (ae = n.RG16F),
        ne === n.UNSIGNED_BYTE && (ae = n.RG8)),
        G === n.RG_INTEGER && (ne === n.UNSIGNED_BYTE && (ae = n.RG8UI),
        ne === n.UNSIGNED_SHORT && (ae = n.RG16UI),
        ne === n.UNSIGNED_INT && (ae = n.RG32UI),
        ne === n.BYTE && (ae = n.RG8I),
        ne === n.SHORT && (ae = n.RG16I),
        ne === n.INT && (ae = n.RG32I)),
        G === n.RGB_INTEGER && (ne === n.UNSIGNED_BYTE && (ae = n.RGB8UI),
        ne === n.UNSIGNED_SHORT && (ae = n.RGB16UI),
        ne === n.UNSIGNED_INT && (ae = n.RGB32UI),
        ne === n.BYTE && (ae = n.RGB8I),
        ne === n.SHORT && (ae = n.RGB16I),
        ne === n.INT && (ae = n.RGB32I)),
        G === n.RGBA_INTEGER && (ne === n.UNSIGNED_BYTE && (ae = n.RGBA8UI),
        ne === n.UNSIGNED_SHORT && (ae = n.RGBA16UI),
        ne === n.UNSIGNED_INT && (ae = n.RGBA32UI),
        ne === n.BYTE && (ae = n.RGBA8I),
        ne === n.SHORT && (ae = n.RGBA16I),
        ne === n.INT && (ae = n.RGBA32I)),
        G === n.RGB && ne === n.UNSIGNED_INT_5_9_9_9_REV && (ae = n.RGB9_E5),
        G === n.RGBA) {
            const Ee = de ? L_ : Et.getTransfer(Y);
            ne === n.FLOAT && (ae = n.RGBA32F),
            ne === n.HALF_FLOAT && (ae = n.RGBA16F),
            ne === n.UNSIGNED_BYTE && (ae = Ee === Sn ? n.SRGB8_ALPHA8 : n.RGBA8),
            ne === n.UNSIGNED_SHORT_4_4_4_4 && (ae = n.RGBA4),
            ne === n.UNSIGNED_SHORT_5_5_5_1 && (ae = n.RGB5_A1)
        }
        return (ae === n.R16F || ae === n.R32F || ae === n.RG16F || ae === n.RG32F || ae === n.RGBA16F || ae === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        ae
    }
    function w(X, G) {
        let ne;
        return X ? G === null || G === wA || G === Ud ? ne = n.DEPTH24_STENCIL8 : G === xi ? ne = n.DEPTH32F_STENCIL8 : G === Hg && (ne = n.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : G === null || G === wA || G === Ud ? ne = n.DEPTH_COMPONENT24 : G === xi ? ne = n.DEPTH_COMPONENT32F : G === Hg && (ne = n.DEPTH_COMPONENT16),
        ne
    }
    function _(X, G) {
        return g(X) === !0 || X.isFramebufferTexture && X.minFilter !== Xr && X.minFilter !== Lr ? Math.log2(Math.max(G.width, G.height)) + 1 : X.mipmaps !== void 0 && X.mipmaps.length > 0 ? X.mipmaps.length : X.isCompressedTexture && Array.isArray(X.image) ? G.mipmaps.length : 1
    }
    function x(X) {
        const G = X.target;
        G.removeEventListener("dispose", x),
        B(G),
        G.isVideoTexture && A.delete(G)
    }
    function b(X) {
        const G = X.target;
        G.removeEventListener("dispose", b),
        I(G)
    }
    function B(X) {
        const G = r.get(X);
        if (G.__webglInit === void 0)
            return;
        const ne = X.source
          , Y = f.get(ne);
        if (Y) {
            const de = Y[G.__cacheKey];
            de.usedTimes--,
            de.usedTimes === 0 && S(X),
            Object.keys(Y).length === 0 && f.delete(ne)
        }
        r.remove(X)
    }
    function S(X) {
        const G = r.get(X);
        n.deleteTexture(G.__webglTexture);
        const ne = X.source
          , Y = f.get(ne);
        delete Y[G.__cacheKey],
        o.memory.textures--
    }
    function I(X) {
        const G = r.get(X);
        if (X.depthTexture && X.depthTexture.dispose(),
        X.isWebGLCubeRenderTarget)
            for (let Y = 0; Y < 6; Y++) {
                if (Array.isArray(G.__webglFramebuffer[Y]))
                    for (let de = 0; de < G.__webglFramebuffer[Y].length; de++)
                        n.deleteFramebuffer(G.__webglFramebuffer[Y][de]);
                else
                    n.deleteFramebuffer(G.__webglFramebuffer[Y]);
                G.__webglDepthbuffer && n.deleteRenderbuffer(G.__webglDepthbuffer[Y])
            }
        else {
            if (Array.isArray(G.__webglFramebuffer))
                for (let Y = 0; Y < G.__webglFramebuffer.length; Y++)
                    n.deleteFramebuffer(G.__webglFramebuffer[Y]);
            else
                n.deleteFramebuffer(G.__webglFramebuffer);
            if (G.__webglDepthbuffer && n.deleteRenderbuffer(G.__webglDepthbuffer),
            G.__webglMultisampledFramebuffer && n.deleteFramebuffer(G.__webglMultisampledFramebuffer),
            G.__webglColorRenderbuffer)
                for (let Y = 0; Y < G.__webglColorRenderbuffer.length; Y++)
                    G.__webglColorRenderbuffer[Y] && n.deleteRenderbuffer(G.__webglColorRenderbuffer[Y]);
            G.__webglDepthRenderbuffer && n.deleteRenderbuffer(G.__webglDepthRenderbuffer)
        }
        const ne = X.textures;
        for (let Y = 0, de = ne.length; Y < de; Y++) {
            const ae = r.get(ne[Y]);
            ae.__webglTexture && (n.deleteTexture(ae.__webglTexture),
            o.memory.textures--),
            r.remove(ne[Y])
        }
        r.remove(X)
    }
    let M = 0;
    function L() {
        M = 0
    }
    function D() {
        const X = M;
        return X >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + X + " texture units while this GPU supports only " + i.maxTextures),
        M += 1,
        X
    }
    function T(X) {
        const G = [];
        return G.push(X.wrapS),
        G.push(X.wrapT),
        G.push(X.wrapR || 0),
        G.push(X.magFilter),
        G.push(X.minFilter),
        G.push(X.anisotropy),
        G.push(X.internalFormat),
        G.push(X.format),
        G.push(X.type),
        G.push(X.generateMipmaps),
        G.push(X.premultiplyAlpha),
        G.push(X.flipY),
        G.push(X.unpackAlignment),
        G.push(X.colorSpace),
        G.join()
    }
    function y(X, G) {
        const ne = r.get(X);
        if (X.isVideoTexture && J(X),
        X.isRenderTargetTexture === !1 && X.version > 0 && ne.__version !== X.version) {
            const Y = X.image;
            if (Y === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Y.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                W(ne, X, G);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, ne.__webglTexture, n.TEXTURE0 + G)
    }
    function E(X, G) {
        const ne = r.get(X);
        if (X.version > 0 && ne.__version !== X.version) {
            W(ne, X, G);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, ne.__webglTexture, n.TEXTURE0 + G)
    }
    function R(X, G) {
        const ne = r.get(X);
        if (X.version > 0 && ne.__version !== X.version) {
            W(ne, X, G);
            return
        }
        t.bindTexture(n.TEXTURE_3D, ne.__webglTexture, n.TEXTURE0 + G)
    }
    function F(X, G) {
        const ne = r.get(X);
        if (X.version > 0 && ne.__version !== X.version) {
            ee(ne, X, G);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, ne.__webglTexture, n.TEXTURE0 + G)
    }
    const O = {
        [zs]: n.REPEAT,
        [Rs]: n.CLAMP_TO_EDGE,
        [Qg]: n.MIRRORED_REPEAT
    }
      , z = {
        [Xr]: n.NEAREST,
        [SR]: n.NEAREST_MIPMAP_NEAREST,
        [Dh]: n.NEAREST_MIPMAP_LINEAR,
        [Lr]: n.LINEAR,
        [qm]: n.LINEAR_MIPMAP_NEAREST,
        [ea]: n.LINEAR_MIPMAP_LINEAR
    }
      , j = {
        [Cq]: n.NEVER,
        [Pq]: n.ALWAYS,
        [Tq]: n.LESS,
        [_z]: n.LEQUAL,
        [Iq]: n.EQUAL,
        [Fq]: n.GEQUAL,
        [Rq]: n.GREATER,
        [Uq]: n.NOTEQUAL
    };
    function Q(X, G) {
        if (G.type === xi && e.has("OES_texture_float_linear") === !1 && (G.magFilter === Lr || G.magFilter === qm || G.magFilter === Dh || G.magFilter === ea || G.minFilter === Lr || G.minFilter === qm || G.minFilter === Dh || G.minFilter === ea) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        n.texParameteri(X, n.TEXTURE_WRAP_S, O[G.wrapS]),
        n.texParameteri(X, n.TEXTURE_WRAP_T, O[G.wrapT]),
        (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY) && n.texParameteri(X, n.TEXTURE_WRAP_R, O[G.wrapR]),
        n.texParameteri(X, n.TEXTURE_MAG_FILTER, z[G.magFilter]),
        n.texParameteri(X, n.TEXTURE_MIN_FILTER, z[G.minFilter]),
        G.compareFunction && (n.texParameteri(X, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(X, n.TEXTURE_COMPARE_FUNC, j[G.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (G.magFilter === Xr || G.minFilter !== Dh && G.minFilter !== ea || G.type === xi && e.has("OES_texture_float_linear") === !1)
                return;
            if (G.anisotropy > 1 || r.get(G).__currentAnisotropy) {
                const ne = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(X, ne.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, i.getMaxAnisotropy())),
                r.get(G).__currentAnisotropy = G.anisotropy
            }
        }
    }
    function C(X, G) {
        let ne = !1;
        X.__webglInit === void 0 && (X.__webglInit = !0,
        G.addEventListener("dispose", x));
        const Y = G.source;
        let de = f.get(Y);
        de === void 0 && (de = {},
        f.set(Y, de));
        const ae = T(G);
        if (ae !== X.__cacheKey) {
            de[ae] === void 0 && (de[ae] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            ne = !0),
            de[ae].usedTimes++;
            const Ee = de[X.__cacheKey];
            Ee !== void 0 && (de[X.__cacheKey].usedTimes--,
            Ee.usedTimes === 0 && S(G)),
            X.__cacheKey = ae,
            X.__webglTexture = de[ae].texture
        }
        return ne
    }
    function W(X, G, ne) {
        let Y = n.TEXTURE_2D;
        (G.isDataArrayTexture || G.isCompressedArrayTexture) && (Y = n.TEXTURE_2D_ARRAY),
        G.isData3DTexture && (Y = n.TEXTURE_3D);
        const de = C(X, G)
          , ae = G.source;
        t.bindTexture(Y, X.__webglTexture, n.TEXTURE0 + ne);
        const Ee = r.get(ae);
        if (ae.version !== Ee.__version || de === !0) {
            t.activeTexture(n.TEXTURE0 + ne);
            const V = Et.getPrimaries(Et.workingColorSpace)
              , U = G.colorSpace === La ? null : Et.getPrimaries(G.colorSpace)
              , N = G.colorSpace === La || V === U ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, G.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, G.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, N);
            let K = m(G.image, !1, i.maxTextureSize);
            K = q(G, K);
            const oe = s.convert(G.format, G.colorSpace)
              , pe = s.convert(G.type);
            let ve = v(G.internalFormat, oe, pe, G.colorSpace, G.isVideoTexture);
            Q(Y, G);
            let Ce;
            const Le = G.mipmaps
              , Re = G.isVideoTexture !== !0
              , $e = Ee.__version === void 0 || de === !0
              , ce = ae.dataReady
              , Pe = _(G, K);
            if (G.isDepthTexture)
                ve = w(G.format === Fd, G.type),
                $e && (Re ? t.texStorage2D(n.TEXTURE_2D, 1, ve, K.width, K.height) : t.texImage2D(n.TEXTURE_2D, 0, ve, K.width, K.height, 0, oe, pe, null));
            else if (G.isDataTexture)
                if (Le.length > 0) {
                    Re && $e && t.texStorage2D(n.TEXTURE_2D, Pe, ve, Le[0].width, Le[0].height);
                    for (let Se = 0, Te = Le.length; Se < Te; Se++)
                        Ce = Le[Se],
                        Re ? ce && t.texSubImage2D(n.TEXTURE_2D, Se, 0, 0, Ce.width, Ce.height, oe, pe, Ce.data) : t.texImage2D(n.TEXTURE_2D, Se, ve, Ce.width, Ce.height, 0, oe, pe, Ce.data);
                    G.generateMipmaps = !1
                } else
                    Re ? ($e && t.texStorage2D(n.TEXTURE_2D, Pe, ve, K.width, K.height),
                    ce && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, K.width, K.height, oe, pe, K.data)) : t.texImage2D(n.TEXTURE_2D, 0, ve, K.width, K.height, 0, oe, pe, K.data);
            else if (G.isCompressedTexture)
                if (G.isCompressedArrayTexture) {
                    Re && $e && t.texStorage3D(n.TEXTURE_2D_ARRAY, Pe, ve, Le[0].width, Le[0].height, K.depth);
                    for (let Se = 0, Te = Le.length; Se < Te; Se++)
                        if (Ce = Le[Se],
                        G.format !== Nr)
                            if (oe !== null)
                                if (Re) {
                                    if (ce)
                                        if (G.layerUpdates.size > 0) {
                                            const Fe = XL(Ce.width, Ce.height, G.format, G.type);
                                            for (const De of G.layerUpdates) {
                                                const Ze = Ce.data.subarray(De * Fe / Ce.data.BYTES_PER_ELEMENT, (De + 1) * Fe / Ce.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Se, 0, 0, De, Ce.width, Ce.height, 1, oe, Ze, 0, 0)
                                            }
                                            G.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Se, 0, 0, 0, Ce.width, Ce.height, K.depth, oe, Ce.data, 0, 0)
                                } else
                                    t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Se, ve, Ce.width, Ce.height, K.depth, 0, Ce.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Re ? ce && t.texSubImage3D(n.TEXTURE_2D_ARRAY, Se, 0, 0, 0, Ce.width, Ce.height, K.depth, oe, pe, Ce.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Se, ve, Ce.width, Ce.height, K.depth, 0, oe, pe, Ce.data)
                } else {
                    Re && $e && t.texStorage2D(n.TEXTURE_2D, Pe, ve, Le[0].width, Le[0].height);
                    for (let Se = 0, Te = Le.length; Se < Te; Se++)
                        Ce = Le[Se],
                        G.format !== Nr ? oe !== null ? Re ? ce && t.compressedTexSubImage2D(n.TEXTURE_2D, Se, 0, 0, Ce.width, Ce.height, oe, Ce.data) : t.compressedTexImage2D(n.TEXTURE_2D, Se, ve, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Re ? ce && t.texSubImage2D(n.TEXTURE_2D, Se, 0, 0, Ce.width, Ce.height, oe, pe, Ce.data) : t.texImage2D(n.TEXTURE_2D, Se, ve, Ce.width, Ce.height, 0, oe, pe, Ce.data)
                }
            else if (G.isDataArrayTexture)
                if (Re) {
                    if ($e && t.texStorage3D(n.TEXTURE_2D_ARRAY, Pe, ve, K.width, K.height, K.depth),
                    ce)
                        if (G.layerUpdates.size > 0) {
                            const Se = XL(K.width, K.height, G.format, G.type);
                            for (const Te of G.layerUpdates) {
                                const Fe = K.data.subarray(Te * Se / K.data.BYTES_PER_ELEMENT, (Te + 1) * Se / K.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, Te, K.width, K.height, 1, oe, pe, Fe)
                            }
                            G.clearLayerUpdates()
                        } else
                            t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, K.width, K.height, K.depth, oe, pe, K.data)
                } else
                    t.texImage3D(n.TEXTURE_2D_ARRAY, 0, ve, K.width, K.height, K.depth, 0, oe, pe, K.data);
            else if (G.isData3DTexture)
                Re ? ($e && t.texStorage3D(n.TEXTURE_3D, Pe, ve, K.width, K.height, K.depth),
                ce && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, K.width, K.height, K.depth, oe, pe, K.data)) : t.texImage3D(n.TEXTURE_3D, 0, ve, K.width, K.height, K.depth, 0, oe, pe, K.data);
            else if (G.isFramebufferTexture) {
                if ($e)
                    if (Re)
                        t.texStorage2D(n.TEXTURE_2D, Pe, ve, K.width, K.height);
                    else {
                        let Se = K.width
                          , Te = K.height;
                        for (let Fe = 0; Fe < Pe; Fe++)
                            t.texImage2D(n.TEXTURE_2D, Fe, ve, Se, Te, 0, oe, pe, null),
                            Se >>= 1,
                            Te >>= 1
                    }
            } else if (Le.length > 0) {
                if (Re && $e) {
                    const Se = he(Le[0]);
                    t.texStorage2D(n.TEXTURE_2D, Pe, ve, Se.width, Se.height)
                }
                for (let Se = 0, Te = Le.length; Se < Te; Se++)
                    Ce = Le[Se],
                    Re ? ce && t.texSubImage2D(n.TEXTURE_2D, Se, 0, 0, oe, pe, Ce) : t.texImage2D(n.TEXTURE_2D, Se, ve, oe, pe, Ce);
                G.generateMipmaps = !1
            } else if (Re) {
                if ($e) {
                    const Se = he(K);
                    t.texStorage2D(n.TEXTURE_2D, Pe, ve, Se.width, Se.height)
                }
                ce && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, oe, pe, K)
            } else
                t.texImage2D(n.TEXTURE_2D, 0, ve, oe, pe, K);
            g(G) && p(Y),
            Ee.__version = ae.version,
            G.onUpdate && G.onUpdate(G)
        }
        X.__version = G.version
    }
    function ee(X, G, ne) {
        if (G.image.length !== 6)
            return;
        const Y = C(X, G)
          , de = G.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, X.__webglTexture, n.TEXTURE0 + ne);
        const ae = r.get(de);
        if (de.version !== ae.__version || Y === !0) {
            t.activeTexture(n.TEXTURE0 + ne);
            const Ee = Et.getPrimaries(Et.workingColorSpace)
              , V = G.colorSpace === La ? null : Et.getPrimaries(G.colorSpace)
              , U = G.colorSpace === La || Ee === V ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, G.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, G.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, U);
            const N = G.isCompressedTexture || G.image[0].isCompressedTexture
              , K = G.image[0] && G.image[0].isDataTexture
              , oe = [];
            for (let Te = 0; Te < 6; Te++)
                !N && !K ? oe[Te] = m(G.image[Te], !0, i.maxCubemapSize) : oe[Te] = K ? G.image[Te].image : G.image[Te],
                oe[Te] = q(G, oe[Te]);
            const pe = oe[0]
              , ve = s.convert(G.format, G.colorSpace)
              , Ce = s.convert(G.type)
              , Le = v(G.internalFormat, ve, Ce, G.colorSpace)
              , Re = G.isVideoTexture !== !0
              , $e = ae.__version === void 0 || Y === !0
              , ce = de.dataReady;
            let Pe = _(G, pe);
            Q(n.TEXTURE_CUBE_MAP, G);
            let Se;
            if (N) {
                Re && $e && t.texStorage2D(n.TEXTURE_CUBE_MAP, Pe, Le, pe.width, pe.height);
                for (let Te = 0; Te < 6; Te++) {
                    Se = oe[Te].mipmaps;
                    for (let Fe = 0; Fe < Se.length; Fe++) {
                        const De = Se[Fe];
                        G.format !== Nr ? ve !== null ? Re ? ce && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe, 0, 0, De.width, De.height, ve, De.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe, Le, De.width, De.height, 0, De.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Re ? ce && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe, 0, 0, De.width, De.height, ve, Ce, De.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe, Le, De.width, De.height, 0, ve, Ce, De.data)
                    }
                }
            } else {
                if (Se = G.mipmaps,
                Re && $e) {
                    Se.length > 0 && Pe++;
                    const Te = he(oe[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, Pe, Le, Te.width, Te.height)
                }
                for (let Te = 0; Te < 6; Te++)
                    if (K) {
                        Re ? ce && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, 0, 0, oe[Te].width, oe[Te].height, ve, Ce, oe[Te].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, Le, oe[Te].width, oe[Te].height, 0, ve, Ce, oe[Te].data);
                        for (let Fe = 0; Fe < Se.length; Fe++) {
                            const Ze = Se[Fe].image[Te].image;
                            Re ? ce && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe + 1, 0, 0, Ze.width, Ze.height, ve, Ce, Ze.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe + 1, Le, Ze.width, Ze.height, 0, ve, Ce, Ze.data)
                        }
                    } else {
                        Re ? ce && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, 0, 0, ve, Ce, oe[Te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0, Le, ve, Ce, oe[Te]);
                        for (let Fe = 0; Fe < Se.length; Fe++) {
                            const De = Se[Fe];
                            Re ? ce && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe + 1, 0, 0, ve, Ce, De.image[Te]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Fe + 1, Le, ve, Ce, De.image[Te])
                        }
                    }
            }
            g(G) && p(n.TEXTURE_CUBE_MAP),
            ae.__version = de.version,
            G.onUpdate && G.onUpdate(G)
        }
        X.__version = G.version
    }
    function P(X, G, ne, Y, de, ae) {
        const Ee = s.convert(ne.format, ne.colorSpace)
          , V = s.convert(ne.type)
          , U = v(ne.internalFormat, Ee, V, ne.colorSpace);
        if (!r.get(G).__hasExternalTextures) {
            const K = Math.max(1, G.width >> ae)
              , oe = Math.max(1, G.height >> ae);
            de === n.TEXTURE_3D || de === n.TEXTURE_2D_ARRAY ? t.texImage3D(de, ae, U, K, oe, G.depth, 0, Ee, V, null) : t.texImage2D(de, ae, U, K, oe, 0, Ee, V, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, X),
        Ae(G) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Y, de, r.get(ne).__webglTexture, 0, fe(G)) : (de === n.TEXTURE_2D || de >= n.TEXTURE_CUBE_MAP_POSITIVE_X && de <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Y, de, r.get(ne).__webglTexture, ae),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function re(X, G, ne) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, X),
        G.depthBuffer) {
            const Y = G.depthTexture
              , de = Y && Y.isDepthTexture ? Y.type : null
              , ae = w(G.stencilBuffer, de)
              , Ee = G.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , V = fe(G);
            Ae(G) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, V, ae, G.width, G.height) : ne ? n.renderbufferStorageMultisample(n.RENDERBUFFER, V, ae, G.width, G.height) : n.renderbufferStorage(n.RENDERBUFFER, ae, G.width, G.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Ee, n.RENDERBUFFER, X)
        } else {
            const Y = G.textures;
            for (let de = 0; de < Y.length; de++) {
                const ae = Y[de]
                  , Ee = s.convert(ae.format, ae.colorSpace)
                  , V = s.convert(ae.type)
                  , U = v(ae.internalFormat, Ee, V, ae.colorSpace)
                  , N = fe(G);
                ne && Ae(G) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, N, U, G.width, G.height) : Ae(G) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, N, U, G.width, G.height) : n.renderbufferStorage(n.RENDERBUFFER, U, G.width, G.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function ue(X, G) {
        if (G && G.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, X),
        !(G.depthTexture && G.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!r.get(G.depthTexture).__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width,
        G.depthTexture.image.height = G.height,
        G.depthTexture.needsUpdate = !0),
        y(G.depthTexture, 0);
        const Y = r.get(G.depthTexture).__webglTexture
          , de = fe(G);
        if (G.depthTexture.format === sd)
            Ae(G) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Y, 0, de) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Y, 0);
        else if (G.depthTexture.format === Fd)
            Ae(G) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Y, 0, de) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Y, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function le(X) {
        const G = r.get(X)
          , ne = X.isWebGLCubeRenderTarget === !0;
        if (G.__boundDepthTexture !== X.depthTexture) {
            const Y = X.depthTexture;
            if (G.__depthDisposeCallback && G.__depthDisposeCallback(),
            Y) {
                const de = () => {
                    delete G.__boundDepthTexture,
                    delete G.__depthDisposeCallback,
                    Y.removeEventListener("dispose", de)
                }
                ;
                Y.addEventListener("dispose", de),
                G.__depthDisposeCallback = de
            }
            G.__boundDepthTexture = Y
        }
        if (X.depthTexture && !G.__autoAllocateDepthBuffer) {
            if (ne)
                throw new Error("target.depthTexture not supported in Cube render targets");
            ue(G.__webglFramebuffer, X)
        } else if (ne) {
            G.__webglDepthbuffer = [];
            for (let Y = 0; Y < 6; Y++)
                if (t.bindFramebuffer(n.FRAMEBUFFER, G.__webglFramebuffer[Y]),
                G.__webglDepthbuffer[Y] === void 0)
                    G.__webglDepthbuffer[Y] = n.createRenderbuffer(),
                    re(G.__webglDepthbuffer[Y], X, !1);
                else {
                    const de = X.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                      , ae = G.__webglDepthbuffer[Y];
                    n.bindRenderbuffer(n.RENDERBUFFER, ae),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, de, n.RENDERBUFFER, ae)
                }
        } else if (t.bindFramebuffer(n.FRAMEBUFFER, G.__webglFramebuffer),
        G.__webglDepthbuffer === void 0)
            G.__webglDepthbuffer = n.createRenderbuffer(),
            re(G.__webglDepthbuffer, X, !1);
        else {
            const Y = X.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , de = G.__webglDepthbuffer;
            n.bindRenderbuffer(n.RENDERBUFFER, de),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Y, n.RENDERBUFFER, de)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function me(X, G, ne) {
        const Y = r.get(X);
        G !== void 0 && P(Y.__webglFramebuffer, X, X.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        ne !== void 0 && le(X)
    }
    function ie(X) {
        const G = X.texture
          , ne = r.get(X)
          , Y = r.get(G);
        X.addEventListener("dispose", b);
        const de = X.textures
          , ae = X.isWebGLCubeRenderTarget === !0
          , Ee = de.length > 1;
        if (Ee || (Y.__webglTexture === void 0 && (Y.__webglTexture = n.createTexture()),
        Y.__version = G.version,
        o.memory.textures++),
        ae) {
            ne.__webglFramebuffer = [];
            for (let V = 0; V < 6; V++)
                if (G.mipmaps && G.mipmaps.length > 0) {
                    ne.__webglFramebuffer[V] = [];
                    for (let U = 0; U < G.mipmaps.length; U++)
                        ne.__webglFramebuffer[V][U] = n.createFramebuffer()
                } else
                    ne.__webglFramebuffer[V] = n.createFramebuffer()
        } else {
            if (G.mipmaps && G.mipmaps.length > 0) {
                ne.__webglFramebuffer = [];
                for (let V = 0; V < G.mipmaps.length; V++)
                    ne.__webglFramebuffer[V] = n.createFramebuffer()
            } else
                ne.__webglFramebuffer = n.createFramebuffer();
            if (Ee)
                for (let V = 0, U = de.length; V < U; V++) {
                    const N = r.get(de[V]);
                    N.__webglTexture === void 0 && (N.__webglTexture = n.createTexture(),
                    o.memory.textures++)
                }
            if (X.samples > 0 && Ae(X) === !1) {
                ne.__webglMultisampledFramebuffer = n.createFramebuffer(),
                ne.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, ne.__webglMultisampledFramebuffer);
                for (let V = 0; V < de.length; V++) {
                    const U = de[V];
                    ne.__webglColorRenderbuffer[V] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, ne.__webglColorRenderbuffer[V]);
                    const N = s.convert(U.format, U.colorSpace)
                      , K = s.convert(U.type)
                      , oe = v(U.internalFormat, N, K, U.colorSpace, X.isXRRenderTarget === !0)
                      , pe = fe(X);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, pe, oe, X.width, X.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + V, n.RENDERBUFFER, ne.__webglColorRenderbuffer[V])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                X.depthBuffer && (ne.__webglDepthRenderbuffer = n.createRenderbuffer(),
                re(ne.__webglDepthRenderbuffer, X, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (ae) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, Y.__webglTexture),
            Q(n.TEXTURE_CUBE_MAP, G);
            for (let V = 0; V < 6; V++)
                if (G.mipmaps && G.mipmaps.length > 0)
                    for (let U = 0; U < G.mipmaps.length; U++)
                        P(ne.__webglFramebuffer[V][U], X, G, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + V, U);
                else
                    P(ne.__webglFramebuffer[V], X, G, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + V, 0);
            g(G) && p(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (Ee) {
            for (let V = 0, U = de.length; V < U; V++) {
                const N = de[V]
                  , K = r.get(N);
                t.bindTexture(n.TEXTURE_2D, K.__webglTexture),
                Q(n.TEXTURE_2D, N),
                P(ne.__webglFramebuffer, X, N, n.COLOR_ATTACHMENT0 + V, n.TEXTURE_2D, 0),
                g(N) && p(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let V = n.TEXTURE_2D;
            if ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) && (V = X.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
            t.bindTexture(V, Y.__webglTexture),
            Q(V, G),
            G.mipmaps && G.mipmaps.length > 0)
                for (let U = 0; U < G.mipmaps.length; U++)
                    P(ne.__webglFramebuffer[U], X, G, n.COLOR_ATTACHMENT0, V, U);
            else
                P(ne.__webglFramebuffer, X, G, n.COLOR_ATTACHMENT0, V, 0);
            g(G) && p(V),
            t.unbindTexture()
        }
        X.depthBuffer && le(X)
    }
    function ge(X) {
        const G = X.textures;
        for (let ne = 0, Y = G.length; ne < Y; ne++) {
            const de = G[ne];
            if (g(de)) {
                const ae = X.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , Ee = r.get(de).__webglTexture;
                t.bindTexture(ae, Ee),
                p(ae),
                t.unbindTexture()
            }
        }
    }
    const _e = []
      , se = [];
    function H(X) {
        if (X.samples > 0) {
            if (Ae(X) === !1) {
                const G = X.textures
                  , ne = X.width
                  , Y = X.height;
                let de = n.COLOR_BUFFER_BIT;
                const ae = X.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                  , Ee = r.get(X)
                  , V = G.length > 1;
                if (V)
                    for (let U = 0; U < G.length; U++)
                        t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + U, n.RENDERBUFFER, null),
                        t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + U, n.TEXTURE_2D, null, 0);
                t.bindFramebuffer(n.READ_FRAMEBUFFER, Ee.__webglMultisampledFramebuffer),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ee.__webglFramebuffer);
                for (let U = 0; U < G.length; U++) {
                    if (X.resolveDepthBuffer && (X.depthBuffer && (de |= n.DEPTH_BUFFER_BIT),
                    X.stencilBuffer && X.resolveStencilBuffer && (de |= n.STENCIL_BUFFER_BIT)),
                    V) {
                        n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ee.__webglColorRenderbuffer[U]);
                        const N = r.get(G[U]).__webglTexture;
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, N, 0)
                    }
                    n.blitFramebuffer(0, 0, ne, Y, 0, 0, ne, Y, de, n.NEAREST),
                    l === !0 && (_e.length = 0,
                    se.length = 0,
                    _e.push(n.COLOR_ATTACHMENT0 + U),
                    X.depthBuffer && X.resolveDepthBuffer === !1 && (_e.push(ae),
                    se.push(ae),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, se)),
                    n.invalidateFramebuffer(n.READ_FRAMEBUFFER, _e))
                }
                if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                V)
                    for (let U = 0; U < G.length; U++) {
                        t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + U, n.RENDERBUFFER, Ee.__webglColorRenderbuffer[U]);
                        const N = r.get(G[U]).__webglTexture;
                        t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + U, n.TEXTURE_2D, N, 0)
                    }
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ee.__webglMultisampledFramebuffer)
            } else if (X.depthBuffer && X.resolveDepthBuffer === !1 && l) {
                const G = X.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [G])
            }
        }
    }
    function fe(X) {
        return Math.min(i.maxSamples, X.samples)
    }
    function Ae(X) {
        const G = r.get(X);
        return X.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1
    }
    function J(X) {
        const G = o.render.frame;
        A.get(X) !== G && (A.set(X, G),
        X.update())
    }
    function q(X, G) {
        const ne = X.colorSpace
          , Y = X.format
          , de = X.type;
        return X.isCompressedTexture === !0 || X.isVideoTexture === !0 || ne !== Sr && ne !== La && (Et.getTransfer(ne) === Sn ? (Y !== Nr || de !== rc) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ne)),
        G
    }
    function he(X) {
        return typeof HTMLImageElement < "u" && X instanceof HTMLImageElement ? (c.width = X.naturalWidth || X.width,
        c.height = X.naturalHeight || X.height) : typeof VideoFrame < "u" && X instanceof VideoFrame ? (c.width = X.displayWidth,
        c.height = X.displayHeight) : (c.width = X.width,
        c.height = X.height),
        c
    }
    this.allocateTextureUnit = D,
    this.resetTextureUnits = L,
    this.setTexture2D = y,
    this.setTexture2DArray = E,
    this.setTexture3D = R,
    this.setTextureCube = F,
    this.rebindTextures = me,
    this.setupRenderTarget = ie,
    this.updateRenderTargetMipmap = ge,
    this.updateMultisampleRenderTarget = H,
    this.setupDepthRenderbuffer = le,
    this.setupFrameBufferTexture = P,
    this.useMultisampledRTT = Ae
}
function rse(n, e) {
    function t(r, i=La) {
        let s;
        const o = Et.getTransfer(i);
        if (r === rc)
            return n.UNSIGNED_BYTE;
        if (r === TR)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (r === IR)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (r === hz)
            return n.UNSIGNED_INT_5_9_9_9_REV;
        if (r === uz)
            return n.BYTE;
        if (r === fz)
            return n.SHORT;
        if (r === Hg)
            return n.UNSIGNED_SHORT;
        if (r === CR)
            return n.INT;
        if (r === wA)
            return n.UNSIGNED_INT;
        if (r === xi)
            return n.FLOAT;
        if (r === Ha)
            return n.HALF_FLOAT;
        if (r === dz)
            return n.ALPHA;
        if (r === pz)
            return n.RGB;
        if (r === Nr)
            return n.RGBA;
        if (r === mz)
            return n.LUMINANCE;
        if (r === gz)
            return n.LUMINANCE_ALPHA;
        if (r === sd)
            return n.DEPTH_COMPONENT;
        if (r === Fd)
            return n.DEPTH_STENCIL;
        if (r === RR)
            return n.RED;
        if (r === A1)
            return n.RED_INTEGER;
        if (r === vz)
            return n.RG;
        if (r === UR)
            return n.RG_INTEGER;
        if (r === FR)
            return n.RGBA_INTEGER;
        if (r === xw || r === bw || r === Ew || r === Bw)
            if (o === Sn)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (r === xw)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (r === bw)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (r === Ew)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (r === Bw)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (r === xw)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (r === bw)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (r === Ew)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (r === Bw)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (r === sC || r === oC || r === aC || r === lC)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (r === sC)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (r === oC)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (r === aC)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (r === lC)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (r === cC || r === AC || r === uC)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (r === cC || r === AC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (r === uC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (r === fC || r === hC || r === dC || r === pC || r === mC || r === gC || r === vC || r === yC || r === wC || r === _C || r === xC || r === bC || r === EC || r === BC)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (r === fC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (r === hC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (r === dC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (r === pC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (r === mC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (r === gC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (r === vC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (r === yC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (r === wC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (r === _C)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (r === xC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (r === bC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (r === EC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (r === BC)
                    return o === Sn ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (r === Mw || r === MC || r === SC)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (r === Mw)
                    return o === Sn ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (r === MC)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (r === SC)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (r === yz || r === CC || r === TC || r === IC)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (r === Mw)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (r === CC)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (r === TC)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (r === IC)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return r === Ud ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null
    }
    return {
        convert: t
    }
}
class ise extends Fr {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class ri extends Lt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const sse = {
    type: "move"
};
class VE {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new ri,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new ri,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new $,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new $),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new ri,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new $,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new $),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const r of e.hand.values())
                    this._getHandJoint(t, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, r) {
        let i = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const m of e.hand.values()) {
                    const g = t.getJointPose(m, r)
                      , p = this._getHandJoint(c, m);
                    g !== null && (p.matrix.fromArray(g.transform.matrix),
                    p.matrix.decompose(p.position, p.rotation, p.scale),
                    p.matrixWorldNeedsUpdate = !0,
                    p.jointRadius = g.radius),
                    p.visible = g !== null
                }
                const A = c.joints["index-finger-tip"]
                  , u = c.joints["thumb-tip"]
                  , f = A.position.distanceTo(u.position)
                  , h = .02
                  , d = .005;
                c.inputState.pinching && f > h + d ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= h - d && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, r),
            i === null && s !== null && (i = s),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(sse)))
        }
        return a !== null && (a.visible = i !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const r = new ri;
            r.matrixAutoUpdate = !1,
            r.visible = !1,
            e.joints[t.jointName] = r,
            e.add(r)
        }
        return e.joints[t.jointName]
    }
}
const ose = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , ase = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class lse {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, r) {
        if (this.texture === null) {
            const i = new Un
              , s = e.properties.get(i);
            s.__webglTexture = t.texture,
            (t.depthNear != r.depthNear || t.depthFar != r.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = i
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , r = new mr({
                vertexShader: ose,
                fragmentShader: ase,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new dn(new cc(20,20),r)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class cse extends UA {
    constructor(e, t) {
        super();
        const r = this;
        let i = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , A = null
          , u = null
          , f = null
          , h = null
          , d = null;
        const m = new lse
          , g = t.getContextAttributes();
        let p = null
          , v = null;
        const w = []
          , _ = []
          , x = new We;
        let b = null;
        const B = new Fr;
        B.layers.enable(1),
        B.viewport = new Pt;
        const S = new Fr;
        S.layers.enable(2),
        S.viewport = new Pt;
        const I = [B, S]
          , M = new ise;
        M.layers.enable(1),
        M.layers.enable(2);
        let L = null
          , D = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(ee) {
            let P = w[ee];
            return P === void 0 && (P = new VE,
            w[ee] = P),
            P.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(ee) {
            let P = w[ee];
            return P === void 0 && (P = new VE,
            w[ee] = P),
            P.getGripSpace()
        }
        ,
        this.getHand = function(ee) {
            let P = w[ee];
            return P === void 0 && (P = new VE,
            w[ee] = P),
            P.getHandSpace()
        }
        ;
        function T(ee) {
            const P = _.indexOf(ee.inputSource);
            if (P === -1)
                return;
            const re = w[P];
            re !== void 0 && (re.update(ee.inputSource, ee.frame, c || o),
            re.dispatchEvent({
                type: ee.type,
                data: ee.inputSource
            }))
        }
        function y() {
            i.removeEventListener("select", T),
            i.removeEventListener("selectstart", T),
            i.removeEventListener("selectend", T),
            i.removeEventListener("squeeze", T),
            i.removeEventListener("squeezestart", T),
            i.removeEventListener("squeezeend", T),
            i.removeEventListener("end", y),
            i.removeEventListener("inputsourceschange", E);
            for (let ee = 0; ee < w.length; ee++) {
                const P = _[ee];
                P !== null && (_[ee] = null,
                w[ee].disconnect(P))
            }
            L = null,
            D = null,
            m.reset(),
            e.setRenderTarget(p),
            h = null,
            f = null,
            u = null,
            i = null,
            v = null,
            W.stop(),
            r.isPresenting = !1,
            e.setPixelRatio(b),
            e.setSize(x.width, x.height, !1),
            r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(ee) {
            s = ee,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(ee) {
            a = ee,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(ee) {
            c = ee
        }
        ,
        this.getBaseLayer = function() {
            return f !== null ? f : h
        }
        ,
        this.getBinding = function() {
            return u
        }
        ,
        this.getFrame = function() {
            return d
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(ee) {
            if (i = ee,
            i !== null) {
                if (p = e.getRenderTarget(),
                i.addEventListener("select", T),
                i.addEventListener("selectstart", T),
                i.addEventListener("selectend", T),
                i.addEventListener("squeeze", T),
                i.addEventListener("squeezestart", T),
                i.addEventListener("squeezeend", T),
                i.addEventListener("end", y),
                i.addEventListener("inputsourceschange", E),
                g.xrCompatible !== !0 && await t.makeXRCompatible(),
                b = e.getPixelRatio(),
                e.getSize(x),
                i.renderState.layers === void 0) {
                    const P = {
                        antialias: g.antialias,
                        alpha: !0,
                        depth: g.depth,
                        stencil: g.stencil,
                        framebufferScaleFactor: s
                    };
                    h = new XRWebGLLayer(i,t,P),
                    i.updateRenderState({
                        baseLayer: h
                    }),
                    e.setPixelRatio(1),
                    e.setSize(h.framebufferWidth, h.framebufferHeight, !1),
                    v = new tl(h.framebufferWidth,h.framebufferHeight,{
                        format: Nr,
                        type: rc,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: g.stencil
                    })
                } else {
                    let P = null
                      , re = null
                      , ue = null;
                    g.depth && (ue = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    P = g.stencil ? Fd : sd,
                    re = g.stencil ? Ud : wA);
                    const le = {
                        colorFormat: t.RGBA8,
                        depthFormat: ue,
                        scaleFactor: s
                    };
                    u = new XRWebGLBinding(i,t),
                    f = u.createProjectionLayer(le),
                    i.updateRenderState({
                        layers: [f]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.textureWidth, f.textureHeight, !1),
                    v = new tl(f.textureWidth,f.textureHeight,{
                        format: Nr,
                        type: rc,
                        depthTexture: new HR(f.textureWidth,f.textureHeight,re,void 0,void 0,void 0,void 0,void 0,void 0,P),
                        stencilBuffer: g.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: g.antialias ? 4 : 0,
                        resolveDepthBuffer: f.ignoreDepthValues === !1
                    })
                }
                v.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await i.requestReferenceSpace(a),
                W.setContext(i),
                W.start(),
                r.isPresenting = !0,
                r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return m.getDepthTexture()
        }
        ;
        function E(ee) {
            for (let P = 0; P < ee.removed.length; P++) {
                const re = ee.removed[P]
                  , ue = _.indexOf(re);
                ue >= 0 && (_[ue] = null,
                w[ue].disconnect(re))
            }
            for (let P = 0; P < ee.added.length; P++) {
                const re = ee.added[P];
                let ue = _.indexOf(re);
                if (ue === -1) {
                    for (let me = 0; me < w.length; me++)
                        if (me >= _.length) {
                            _.push(re),
                            ue = me;
                            break
                        } else if (_[me] === null) {
                            _[me] = re,
                            ue = me;
                            break
                        }
                    if (ue === -1)
                        break
                }
                const le = w[ue];
                le && le.connect(re)
            }
        }
        const R = new $
          , F = new $;
        function O(ee, P, re) {
            R.setFromMatrixPosition(P.matrixWorld),
            F.setFromMatrixPosition(re.matrixWorld);
            const ue = R.distanceTo(F)
              , le = P.projectionMatrix.elements
              , me = re.projectionMatrix.elements
              , ie = le[14] / (le[10] - 1)
              , ge = le[14] / (le[10] + 1)
              , _e = (le[9] + 1) / le[5]
              , se = (le[9] - 1) / le[5]
              , H = (le[8] - 1) / le[0]
              , fe = (me[8] + 1) / me[0]
              , Ae = ie * H
              , J = ie * fe
              , q = ue / (-H + fe)
              , he = q * -H;
            if (P.matrixWorld.decompose(ee.position, ee.quaternion, ee.scale),
            ee.translateX(he),
            ee.translateZ(q),
            ee.matrixWorld.compose(ee.position, ee.quaternion, ee.scale),
            ee.matrixWorldInverse.copy(ee.matrixWorld).invert(),
            le[10] === -1)
                ee.projectionMatrix.copy(P.projectionMatrix),
                ee.projectionMatrixInverse.copy(P.projectionMatrixInverse);
            else {
                const X = ie + q
                  , G = ge + q
                  , ne = Ae - he
                  , Y = J + (ue - he)
                  , de = _e * ge / G * X
                  , ae = se * ge / G * X;
                ee.projectionMatrix.makePerspective(ne, Y, de, ae, X, G),
                ee.projectionMatrixInverse.copy(ee.projectionMatrix).invert()
            }
        }
        function z(ee, P) {
            P === null ? ee.matrixWorld.copy(ee.matrix) : ee.matrixWorld.multiplyMatrices(P.matrixWorld, ee.matrix),
            ee.matrixWorldInverse.copy(ee.matrixWorld).invert()
        }
        this.updateCamera = function(ee) {
            if (i === null)
                return;
            let P = ee.near
              , re = ee.far;
            m.texture !== null && (m.depthNear > 0 && (P = m.depthNear),
            m.depthFar > 0 && (re = m.depthFar)),
            M.near = S.near = B.near = P,
            M.far = S.far = B.far = re,
            (L !== M.near || D !== M.far) && (i.updateRenderState({
                depthNear: M.near,
                depthFar: M.far
            }),
            L = M.near,
            D = M.far);
            const ue = ee.parent
              , le = M.cameras;
            z(M, ue);
            for (let me = 0; me < le.length; me++)
                z(le[me], ue);
            le.length === 2 ? O(M, B, S) : M.projectionMatrix.copy(B.projectionMatrix),
            j(ee, M, ue)
        }
        ;
        function j(ee, P, re) {
            re === null ? ee.matrix.copy(P.matrixWorld) : (ee.matrix.copy(re.matrixWorld),
            ee.matrix.invert(),
            ee.matrix.multiply(P.matrixWorld)),
            ee.matrix.decompose(ee.position, ee.quaternion, ee.scale),
            ee.updateMatrixWorld(!0),
            ee.projectionMatrix.copy(P.projectionMatrix),
            ee.projectionMatrixInverse.copy(P.projectionMatrixInverse),
            ee.isPerspectiveCamera && (ee.fov = Dd * 2 * Math.atan(1 / ee.projectionMatrix.elements[5]),
            ee.zoom = 1)
        }
        this.getCamera = function() {
            return M
        }
        ,
        this.getFoveation = function() {
            if (!(f === null && h === null))
                return l
        }
        ,
        this.setFoveation = function(ee) {
            l = ee,
            f !== null && (f.fixedFoveation = ee),
            h !== null && h.fixedFoveation !== void 0 && (h.fixedFoveation = ee)
        }
        ,
        this.hasDepthSensing = function() {
            return m.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return m.getMesh(M)
        }
        ;
        let Q = null;
        function C(ee, P) {
            if (A = P.getViewerPose(c || o),
            d = P,
            A !== null) {
                const re = A.views;
                h !== null && (e.setRenderTargetFramebuffer(v, h.framebuffer),
                e.setRenderTarget(v));
                let ue = !1;
                re.length !== M.cameras.length && (M.cameras.length = 0,
                ue = !0);
                for (let me = 0; me < re.length; me++) {
                    const ie = re[me];
                    let ge = null;
                    if (h !== null)
                        ge = h.getViewport(ie);
                    else {
                        const se = u.getViewSubImage(f, ie);
                        ge = se.viewport,
                        me === 0 && (e.setRenderTargetTextures(v, se.colorTexture, f.ignoreDepthValues ? void 0 : se.depthStencilTexture),
                        e.setRenderTarget(v))
                    }
                    let _e = I[me];
                    _e === void 0 && (_e = new Fr,
                    _e.layers.enable(me),
                    _e.viewport = new Pt,
                    I[me] = _e),
                    _e.matrix.fromArray(ie.transform.matrix),
                    _e.matrix.decompose(_e.position, _e.quaternion, _e.scale),
                    _e.projectionMatrix.fromArray(ie.projectionMatrix),
                    _e.projectionMatrixInverse.copy(_e.projectionMatrix).invert(),
                    _e.viewport.set(ge.x, ge.y, ge.width, ge.height),
                    me === 0 && (M.matrix.copy(_e.matrix),
                    M.matrix.decompose(M.position, M.quaternion, M.scale)),
                    ue === !0 && M.cameras.push(_e)
                }
                const le = i.enabledFeatures;
                if (le && le.includes("depth-sensing")) {
                    const me = u.getDepthInformation(re[0]);
                    me && me.isValid && me.texture && m.init(e, me, i.renderState)
                }
            }
            for (let re = 0; re < w.length; re++) {
                const ue = _[re]
                  , le = w[re];
                ue !== null && le !== void 0 && le.update(ue, P, c || o)
            }
            Q && Q(ee, P),
            P.detectedPlanes && r.dispatchEvent({
                type: "planesdetected",
                data: P
            }),
            d = null
        }
        const W = new Tz;
        W.setAnimationLoop(C),
        this.setAnimationLoop = function(ee) {
            Q = ee
        }
        ,
        this.dispose = function() {}
    }
}
const GA = new nr
  , Ase = new He;
function use(n, e) {
    function t(g, p) {
        g.matrixAutoUpdate === !0 && g.updateMatrix(),
        p.value.copy(g.matrix)
    }
    function r(g, p) {
        p.color.getRGB(g.fogColor.value, Mz(n)),
        p.isFog ? (g.fogNear.value = p.near,
        g.fogFar.value = p.far) : p.isFogExp2 && (g.fogDensity.value = p.density)
    }
    function i(g, p, v, w, _) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? s(g, p) : p.isMeshToonMaterial ? (s(g, p),
        u(g, p)) : p.isMeshPhongMaterial ? (s(g, p),
        A(g, p)) : p.isMeshStandardMaterial ? (s(g, p),
        f(g, p),
        p.isMeshPhysicalMaterial && h(g, p, _)) : p.isMeshMatcapMaterial ? (s(g, p),
        d(g, p)) : p.isMeshDepthMaterial ? s(g, p) : p.isMeshDistanceMaterial ? (s(g, p),
        m(g, p)) : p.isMeshNormalMaterial ? s(g, p) : p.isLineBasicMaterial ? (o(g, p),
        p.isLineDashedMaterial && a(g, p)) : p.isPointsMaterial ? l(g, p, v, w) : p.isSpriteMaterial ? c(g, p) : p.isShadowMaterial ? (g.color.value.copy(p.color),
        g.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function s(g, p) {
        g.opacity.value = p.opacity,
        p.color && g.diffuse.value.copy(p.color),
        p.emissive && g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (g.map.value = p.map,
        t(p.map, g.mapTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap,
        t(p.alphaMap, g.alphaMapTransform)),
        p.bumpMap && (g.bumpMap.value = p.bumpMap,
        t(p.bumpMap, g.bumpMapTransform),
        g.bumpScale.value = p.bumpScale,
        p.side === oi && (g.bumpScale.value *= -1)),
        p.normalMap && (g.normalMap.value = p.normalMap,
        t(p.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(p.normalScale),
        p.side === oi && g.normalScale.value.negate()),
        p.displacementMap && (g.displacementMap.value = p.displacementMap,
        t(p.displacementMap, g.displacementMapTransform),
        g.displacementScale.value = p.displacementScale,
        g.displacementBias.value = p.displacementBias),
        p.emissiveMap && (g.emissiveMap.value = p.emissiveMap,
        t(p.emissiveMap, g.emissiveMapTransform)),
        p.specularMap && (g.specularMap.value = p.specularMap,
        t(p.specularMap, g.specularMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
        const v = e.get(p)
          , w = v.envMap
          , _ = v.envMapRotation;
        w && (g.envMap.value = w,
        GA.copy(_),
        GA.x *= -1,
        GA.y *= -1,
        GA.z *= -1,
        w.isCubeTexture && w.isRenderTargetTexture === !1 && (GA.y *= -1,
        GA.z *= -1),
        g.envMapRotation.value.setFromMatrix4(Ase.makeRotationFromEuler(GA)),
        g.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1,
        g.reflectivity.value = p.reflectivity,
        g.ior.value = p.ior,
        g.refractionRatio.value = p.refractionRatio),
        p.lightMap && (g.lightMap.value = p.lightMap,
        g.lightMapIntensity.value = p.lightMapIntensity,
        t(p.lightMap, g.lightMapTransform)),
        p.aoMap && (g.aoMap.value = p.aoMap,
        g.aoMapIntensity.value = p.aoMapIntensity,
        t(p.aoMap, g.aoMapTransform))
    }
    function o(g, p) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        p.map && (g.map.value = p.map,
        t(p.map, g.mapTransform))
    }
    function a(g, p) {
        g.dashSize.value = p.dashSize,
        g.totalSize.value = p.dashSize + p.gapSize,
        g.scale.value = p.scale
    }
    function l(g, p, v, w) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        g.size.value = p.size * v,
        g.scale.value = w * .5,
        p.map && (g.map.value = p.map,
        t(p.map, g.uvTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap,
        t(p.alphaMap, g.alphaMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
    }
    function c(g, p) {
        g.diffuse.value.copy(p.color),
        g.opacity.value = p.opacity,
        g.rotation.value = p.rotation,
        p.map && (g.map.value = p.map,
        t(p.map, g.mapTransform)),
        p.alphaMap && (g.alphaMap.value = p.alphaMap,
        t(p.alphaMap, g.alphaMapTransform)),
        p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest)
    }
    function A(g, p) {
        g.specular.value.copy(p.specular),
        g.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function u(g, p) {
        p.gradientMap && (g.gradientMap.value = p.gradientMap)
    }
    function f(g, p) {
        g.metalness.value = p.metalness,
        p.metalnessMap && (g.metalnessMap.value = p.metalnessMap,
        t(p.metalnessMap, g.metalnessMapTransform)),
        g.roughness.value = p.roughness,
        p.roughnessMap && (g.roughnessMap.value = p.roughnessMap,
        t(p.roughnessMap, g.roughnessMapTransform)),
        p.envMap && (g.envMapIntensity.value = p.envMapIntensity)
    }
    function h(g, p, v) {
        g.ior.value = p.ior,
        p.sheen > 0 && (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        g.sheenRoughness.value = p.sheenRoughness,
        p.sheenColorMap && (g.sheenColorMap.value = p.sheenColorMap,
        t(p.sheenColorMap, g.sheenColorMapTransform)),
        p.sheenRoughnessMap && (g.sheenRoughnessMap.value = p.sheenRoughnessMap,
        t(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
        p.clearcoat > 0 && (g.clearcoat.value = p.clearcoat,
        g.clearcoatRoughness.value = p.clearcoatRoughness,
        p.clearcoatMap && (g.clearcoatMap.value = p.clearcoatMap,
        t(p.clearcoatMap, g.clearcoatMapTransform)),
        p.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap,
        t(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap && (g.clearcoatNormalMap.value = p.clearcoatNormalMap,
        t(p.clearcoatNormalMap, g.clearcoatNormalMapTransform),
        g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
        p.side === oi && g.clearcoatNormalScale.value.negate())),
        p.dispersion > 0 && (g.dispersion.value = p.dispersion),
        p.iridescence > 0 && (g.iridescence.value = p.iridescence,
        g.iridescenceIOR.value = p.iridescenceIOR,
        g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0],
        g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1],
        p.iridescenceMap && (g.iridescenceMap.value = p.iridescenceMap,
        t(p.iridescenceMap, g.iridescenceMapTransform)),
        p.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = p.iridescenceThicknessMap,
        t(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
        p.transmission > 0 && (g.transmission.value = p.transmission,
        g.transmissionSamplerMap.value = v.texture,
        g.transmissionSamplerSize.value.set(v.width, v.height),
        p.transmissionMap && (g.transmissionMap.value = p.transmissionMap,
        t(p.transmissionMap, g.transmissionMapTransform)),
        g.thickness.value = p.thickness,
        p.thicknessMap && (g.thicknessMap.value = p.thicknessMap,
        t(p.thicknessMap, g.thicknessMapTransform)),
        g.attenuationDistance.value = p.attenuationDistance,
        g.attenuationColor.value.copy(p.attenuationColor)),
        p.anisotropy > 0 && (g.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)),
        p.anisotropyMap && (g.anisotropyMap.value = p.anisotropyMap,
        t(p.anisotropyMap, g.anisotropyMapTransform))),
        g.specularIntensity.value = p.specularIntensity,
        g.specularColor.value.copy(p.specularColor),
        p.specularColorMap && (g.specularColorMap.value = p.specularColorMap,
        t(p.specularColorMap, g.specularColorMapTransform)),
        p.specularIntensityMap && (g.specularIntensityMap.value = p.specularIntensityMap,
        t(p.specularIntensityMap, g.specularIntensityMapTransform))
    }
    function d(g, p) {
        p.matcap && (g.matcap.value = p.matcap)
    }
    function m(g, p) {
        const v = e.get(p).light;
        g.referencePosition.value.setFromMatrixPosition(v.matrixWorld),
        g.nearDistance.value = v.shadow.camera.near,
        g.farDistance.value = v.shadow.camera.far
    }
    return {
        refreshFogUniforms: r,
        refreshMaterialUniforms: i
    }
}
function fse(n, e, t, r) {
    let i = {}
      , s = {}
      , o = [];
    const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(v, w) {
        const _ = w.program;
        r.uniformBlockBinding(v, _)
    }
    function c(v, w) {
        let _ = i[v.id];
        _ === void 0 && (d(v),
        _ = A(v),
        i[v.id] = _,
        v.addEventListener("dispose", g));
        const x = w.program;
        r.updateUBOMapping(v, x);
        const b = e.render.frame;
        s[v.id] !== b && (f(v),
        s[v.id] = b)
    }
    function A(v) {
        const w = u();
        v.__bindingPointIndex = w;
        const _ = n.createBuffer()
          , x = v.__size
          , b = v.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, _),
        n.bufferData(n.UNIFORM_BUFFER, x, b),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, w, _),
        _
    }
    function u() {
        for (let v = 0; v < a; v++)
            if (o.indexOf(v) === -1)
                return o.push(v),
                v;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(v) {
        const w = i[v.id]
          , _ = v.uniforms
          , x = v.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, w);
        for (let b = 0, B = _.length; b < B; b++) {
            const S = Array.isArray(_[b]) ? _[b] : [_[b]];
            for (let I = 0, M = S.length; I < M; I++) {
                const L = S[I];
                if (h(L, b, I, x) === !0) {
                    const D = L.__offset
                      , T = Array.isArray(L.value) ? L.value : [L.value];
                    let y = 0;
                    for (let E = 0; E < T.length; E++) {
                        const R = T[E]
                          , F = m(R);
                        typeof R == "number" || typeof R == "boolean" ? (L.__data[0] = R,
                        n.bufferSubData(n.UNIFORM_BUFFER, D + y, L.__data)) : R.isMatrix3 ? (L.__data[0] = R.elements[0],
                        L.__data[1] = R.elements[1],
                        L.__data[2] = R.elements[2],
                        L.__data[3] = 0,
                        L.__data[4] = R.elements[3],
                        L.__data[5] = R.elements[4],
                        L.__data[6] = R.elements[5],
                        L.__data[7] = 0,
                        L.__data[8] = R.elements[6],
                        L.__data[9] = R.elements[7],
                        L.__data[10] = R.elements[8],
                        L.__data[11] = 0) : (R.toArray(L.__data, y),
                        y += F.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, D, L.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function h(v, w, _, x) {
        const b = v.value
          , B = w + "_" + _;
        if (x[B] === void 0)
            return typeof b == "number" || typeof b == "boolean" ? x[B] = b : x[B] = b.clone(),
            !0;
        {
            const S = x[B];
            if (typeof b == "number" || typeof b == "boolean") {
                if (S !== b)
                    return x[B] = b,
                    !0
            } else if (S.equals(b) === !1)
                return S.copy(b),
                !0
        }
        return !1
    }
    function d(v) {
        const w = v.uniforms;
        let _ = 0;
        const x = 16;
        for (let B = 0, S = w.length; B < S; B++) {
            const I = Array.isArray(w[B]) ? w[B] : [w[B]];
            for (let M = 0, L = I.length; M < L; M++) {
                const D = I[M]
                  , T = Array.isArray(D.value) ? D.value : [D.value];
                for (let y = 0, E = T.length; y < E; y++) {
                    const R = T[y]
                      , F = m(R)
                      , O = _ % x
                      , z = O % F.boundary
                      , j = O + z;
                    _ += z,
                    j !== 0 && x - j < F.storage && (_ += x - j),
                    D.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT),
                    D.__offset = _,
                    _ += F.storage
                }
            }
        }
        const b = _ % x;
        return b > 0 && (_ += x - b),
        v.__size = _,
        v.__cache = {},
        this
    }
    function m(v) {
        const w = {
            boundary: 0,
            storage: 0
        };
        return typeof v == "number" || typeof v == "boolean" ? (w.boundary = 4,
        w.storage = 4) : v.isVector2 ? (w.boundary = 8,
        w.storage = 8) : v.isVector3 || v.isColor ? (w.boundary = 16,
        w.storage = 12) : v.isVector4 ? (w.boundary = 16,
        w.storage = 16) : v.isMatrix3 ? (w.boundary = 48,
        w.storage = 48) : v.isMatrix4 ? (w.boundary = 64,
        w.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v),
        w
    }
    function g(v) {
        const w = v.target;
        w.removeEventListener("dispose", g);
        const _ = o.indexOf(w.__bindingPointIndex);
        o.splice(_, 1),
        n.deleteBuffer(i[w.id]),
        delete i[w.id],
        delete s[w.id]
    }
    function p() {
        for (const v in i)
            n.deleteBuffer(i[v]);
        o = [],
        i = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: p
    }
}
class y0 {
    constructor(e={}) {
        const {canvas: t=Jq(), context: r=null, depth: i=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: A="default", failIfMajorPerformanceCaveat: u=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        if (r !== null) {
            if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = r.getContextAttributes().alpha
        } else
            f = o;
        const h = new Uint32Array(4)
          , d = new Int32Array(4);
        let m = null
          , g = null;
        const p = []
          , v = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Ut,
        this.toneMapping = fA,
        this.toneMappingExposure = 1;
        const w = this;
        let _ = !1
          , x = 0
          , b = 0
          , B = null
          , S = -1
          , I = null;
        const M = new Pt
          , L = new Pt;
        let D = null;
        const T = new Qe(0);
        let y = 0
          , E = t.width
          , R = t.height
          , F = 1
          , O = null
          , z = null;
        const j = new Pt(0,0,E,R)
          , Q = new Pt(0,0,E,R);
        let C = !1;
        const W = new h1;
        let ee = !1
          , P = !1;
        const re = new He
          , ue = new He
          , le = new $
          , me = new Pt
          , ie = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let ge = !1;
        function _e() {
            return B === null ? F : 1
        }
        let se = r;
        function H(te, ye) {
            return t.getContext(te, ye)
        }
        try {
            const te = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: A,
                failIfMajorPerformanceCaveat: u
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${nc}`),
            t.addEventListener("webglcontextlost", Te, !1),
            t.addEventListener("webglcontextrestored", Fe, !1),
            t.addEventListener("webglcontextcreationerror", De, !1),
            se === null) {
                const ye = "webgl2";
                if (se = H(ye, te),
                se === null)
                    throw H(ye) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (te) {
            throw console.error("THREE.WebGLRenderer: " + te.message),
            te
        }
        let fe, Ae, J, q, he, X, G, ne, Y, de, ae, Ee, V, U, N, K, oe, pe, ve, Ce, Le, Re, $e, ce;
        function Pe() {
            fe = new vre(se),
            fe.init(),
            Re = new rse(se,fe),
            Ae = new fre(se,fe,e,Re),
            J = new ese(se),
            Ae.reverseDepthBuffer && J.buffers.depth.setReversed(!0),
            q = new _re(se),
            he = new kie,
            X = new nse(se,fe,J,he,Ae,Re,q),
            G = new dre(w),
            ne = new gre(w),
            Y = new Cee(se),
            $e = new Are(se,Y),
            de = new yre(se,Y,q,$e),
            ae = new bre(se,de,Y,q),
            ve = new xre(se,Ae,X),
            K = new hre(he),
            Ee = new Oie(w,G,ne,fe,Ae,$e,K),
            V = new use(w,he),
            U = new Hie,
            N = new Kie(fe),
            pe = new cre(w,G,ne,J,ae,f,l),
            oe = new Jie(w,ae,Ae),
            ce = new fse(se,q,Ae,J),
            Ce = new ure(se,fe,q),
            Le = new wre(se,fe,q),
            q.programs = Ee.programs,
            w.capabilities = Ae,
            w.extensions = fe,
            w.properties = he,
            w.renderLists = U,
            w.shadowMap = oe,
            w.state = J,
            w.info = q
        }
        Pe();
        const Se = new cse(w,se);
        this.xr = Se,
        this.getContext = function() {
            return se
        }
        ,
        this.getContextAttributes = function() {
            return se.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const te = fe.get("WEBGL_lose_context");
            te && te.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const te = fe.get("WEBGL_lose_context");
            te && te.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return F
        }
        ,
        this.setPixelRatio = function(te) {
            te !== void 0 && (F = te,
            this.setSize(E, R, !1))
        }
        ,
        this.getSize = function(te) {
            return te.set(E, R)
        }
        ,
        this.setSize = function(te, ye, Be=!0) {
            if (Se.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            E = te,
            R = ye,
            t.width = Math.floor(te * F),
            t.height = Math.floor(ye * F),
            Be === !0 && (t.style.width = te + "px",
            t.style.height = ye + "px"),
            this.setViewport(0, 0, te, ye)
        }
        ,
        this.getDrawingBufferSize = function(te) {
            return te.set(E * F, R * F).floor()
        }
        ,
        this.setDrawingBufferSize = function(te, ye, Be) {
            E = te,
            R = ye,
            F = Be,
            t.width = Math.floor(te * Be),
            t.height = Math.floor(ye * Be),
            this.setViewport(0, 0, te, ye)
        }
        ,
        this.getCurrentViewport = function(te) {
            return te.copy(M)
        }
        ,
        this.getViewport = function(te) {
            return te.copy(j)
        }
        ,
        this.setViewport = function(te, ye, Be, Me) {
            te.isVector4 ? j.set(te.x, te.y, te.z, te.w) : j.set(te, ye, Be, Me),
            J.viewport(M.copy(j).multiplyScalar(F).round())
        }
        ,
        this.getScissor = function(te) {
            return te.copy(Q)
        }
        ,
        this.setScissor = function(te, ye, Be, Me) {
            te.isVector4 ? Q.set(te.x, te.y, te.z, te.w) : Q.set(te, ye, Be, Me),
            J.scissor(L.copy(Q).multiplyScalar(F).round())
        }
        ,
        this.getScissorTest = function() {
            return C
        }
        ,
        this.setScissorTest = function(te) {
            J.setScissorTest(C = te)
        }
        ,
        this.setOpaqueSort = function(te) {
            O = te
        }
        ,
        this.setTransparentSort = function(te) {
            z = te
        }
        ,
        this.getClearColor = function(te) {
            return te.copy(pe.getClearColor())
        }
        ,
        this.setClearColor = function() {
            pe.setClearColor.apply(pe, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return pe.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            pe.setClearAlpha.apply(pe, arguments)
        }
        ,
        this.clear = function(te=!0, ye=!0, Be=!0) {
            let Me = 0;
            if (te) {
                let we = !1;
                if (B !== null) {
                    const ke = B.texture.format;
                    we = ke === FR || ke === UR || ke === A1
                }
                if (we) {
                    const ke = B.texture.type
                      , Xe = ke === rc || ke === wA || ke === Hg || ke === Ud || ke === TR || ke === IR
                      , qe = pe.getClearColor()
                      , tt = pe.getClearAlpha()
                      , ft = qe.r
                      , mt = qe.g
                      , st = qe.b;
                    Xe ? (h[0] = ft,
                    h[1] = mt,
                    h[2] = st,
                    h[3] = tt,
                    se.clearBufferuiv(se.COLOR, 0, h)) : (d[0] = ft,
                    d[1] = mt,
                    d[2] = st,
                    d[3] = tt,
                    se.clearBufferiv(se.COLOR, 0, d))
                } else
                    Me |= se.COLOR_BUFFER_BIT
            }
            ye && (Me |= se.DEPTH_BUFFER_BIT,
            se.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1)),
            Be && (Me |= se.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            se.clear(Me)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", Te, !1),
            t.removeEventListener("webglcontextrestored", Fe, !1),
            t.removeEventListener("webglcontextcreationerror", De, !1),
            U.dispose(),
            N.dispose(),
            he.dispose(),
            G.dispose(),
            ne.dispose(),
            ae.dispose(),
            $e.dispose(),
            ce.dispose(),
            Ee.dispose(),
            Se.dispose(),
            Se.removeEventListener("sessionstart", tn),
            Se.removeEventListener("sessionend", qt),
            Jr.stop()
        }
        ;
        function Te(te) {
            te.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            _ = !0
        }
        function Fe() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            _ = !1;
            const te = q.autoReset
              , ye = oe.enabled
              , Be = oe.autoUpdate
              , Me = oe.needsUpdate
              , we = oe.type;
            Pe(),
            q.autoReset = te,
            oe.enabled = ye,
            oe.autoUpdate = Be,
            oe.needsUpdate = Me,
            oe.type = we
        }
        function De(te) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", te.statusMessage)
        }
        function Ze(te) {
            const ye = te.target;
            ye.removeEventListener("dispose", Ze),
            At(ye)
        }
        function At(te) {
            Pn(te),
            he.remove(te)
        }
        function Pn(te) {
            const ye = he.get(te).programs;
            ye !== void 0 && (ye.forEach(function(Be) {
                Ee.releaseProgram(Be)
            }),
            te.isShaderMaterial && Ee.releaseShaderCache(te))
        }
        this.renderBufferDirect = function(te, ye, Be, Me, we, ke) {
            ye === null && (ye = ie);
            const Xe = we.isMesh && we.matrixWorld.determinant() < 0
              , qe = ma(te, ye, Be, Me, we);
            J.setMaterial(Me, Xe);
            let tt = Be.index
              , ft = 1;
            if (Me.wireframe === !0) {
                if (tt = de.getWireframeAttribute(Be),
                tt === void 0)
                    return;
                ft = 2
            }
            const mt = Be.drawRange
              , st = Be.attributes.position;
            let Wt = mt.start * ft
              , fn = (mt.start + mt.count) * ft;
            ke !== null && (Wt = Math.max(Wt, ke.start * ft),
            fn = Math.min(fn, (ke.start + ke.count) * ft)),
            tt !== null ? (Wt = Math.max(Wt, 0),
            fn = Math.min(fn, tt.count)) : st != null && (Wt = Math.max(Wt, 0),
            fn = Math.min(fn, st.count));
            const yn = fn - Wt;
            if (yn < 0 || yn === 1 / 0)
                return;
            $e.setup(we, Me, qe, Be, tt);
            let qr, Vt = Ce;
            if (tt !== null && (qr = Y.get(tt),
            Vt = Le,
            Vt.setIndex(qr)),
            we.isMesh)
                Me.wireframe === !0 ? (J.setLineWidth(Me.wireframeLinewidth * _e()),
                Vt.setMode(se.LINES)) : Vt.setMode(se.TRIANGLES);
            else if (we.isLine) {
                let at = Me.linewidth;
                at === void 0 && (at = 1),
                J.setLineWidth(at * _e()),
                we.isLineSegments ? Vt.setMode(se.LINES) : we.isLineLoop ? Vt.setMode(se.LINE_LOOP) : Vt.setMode(se.LINE_STRIP)
            } else
                we.isPoints ? Vt.setMode(se.POINTS) : we.isSprite && Vt.setMode(se.TRIANGLES);
            if (we.isBatchedMesh)
                if (we._multiDrawInstances !== null)
                    Vt.renderMultiDrawInstances(we._multiDrawStarts, we._multiDrawCounts, we._multiDrawCount, we._multiDrawInstances);
                else if (fe.get("WEBGL_multi_draw"))
                    Vt.renderMultiDraw(we._multiDrawStarts, we._multiDrawCounts, we._multiDrawCount);
                else {
                    const at = we._multiDrawStarts
                      , or = we._multiDrawCounts
                      , an = we._multiDrawCount
                      , Ro = tt ? Y.get(tt).bytesPerElement : 1
                      , sf = he.get(Me).currentProgram.getUniforms();
                    for (let ds = 0; ds < an; ds++)
                        sf.setValue(se, "_gl_DrawID", ds),
                        Vt.render(at[ds] / Ro, or[ds])
                }
            else if (we.isInstancedMesh)
                Vt.renderInstances(Wt, yn, we.count);
            else if (Be.isInstancedBufferGeometry) {
                const at = Be._maxInstanceCount !== void 0 ? Be._maxInstanceCount : 1 / 0
                  , or = Math.min(Be.instanceCount, at);
                Vt.renderInstances(Wt, yn, or)
            } else
                Vt.render(Wt, yn)
        }
        ;
        function rt(te, ye, Be) {
            te.transparent === !0 && te.side === _i && te.forceSinglePass === !1 ? (te.side = oi,
            te.needsUpdate = !0,
            Ii(te, ye, Be),
            te.side = Hs,
            te.needsUpdate = !0,
            Ii(te, ye, Be),
            te.side = _i) : Ii(te, ye, Be)
        }
        this.compile = function(te, ye, Be=null) {
            Be === null && (Be = te),
            g = N.get(Be),
            g.init(ye),
            v.push(g),
            Be.traverseVisible(function(we) {
                we.isLight && we.layers.test(ye.layers) && (g.pushLight(we),
                we.castShadow && g.pushShadow(we))
            }),
            te !== Be && te.traverseVisible(function(we) {
                we.isLight && we.layers.test(ye.layers) && (g.pushLight(we),
                we.castShadow && g.pushShadow(we))
            }),
            g.setupLights();
            const Me = new Set;
            return te.traverse(function(we) {
                if (!(we.isMesh || we.isPoints || we.isLine || we.isSprite))
                    return;
                const ke = we.material;
                if (ke)
                    if (Array.isArray(ke))
                        for (let Xe = 0; Xe < ke.length; Xe++) {
                            const qe = ke[Xe];
                            rt(qe, Be, we),
                            Me.add(qe)
                        }
                    else
                        rt(ke, Be, we),
                        Me.add(ke)
            }),
            v.pop(),
            g = null,
            Me
        }
        ,
        this.compileAsync = function(te, ye, Be=null) {
            const Me = this.compile(te, ye, Be);
            return new Promise(we => {
                function ke() {
                    if (Me.forEach(function(Xe) {
                        he.get(Xe).currentProgram.isReady() && Me.delete(Xe)
                    }),
                    Me.size === 0) {
                        we(te);
                        return
                    }
                    setTimeout(ke, 10)
                }
                fe.get("KHR_parallel_shader_compile") !== null ? ke() : setTimeout(ke, 10)
            }
            )
        }
        ;
        let xt = null;
        function Tr(te) {
            xt && xt(te)
        }
        function tn() {
            Jr.stop()
        }
        function qt() {
            Jr.start()
        }
        const Jr = new Tz;
        Jr.setAnimationLoop(Tr),
        typeof self < "u" && Jr.setContext(self),
        this.setAnimationLoop = function(te) {
            xt = te,
            Se.setAnimationLoop(te),
            te === null ? Jr.stop() : Jr.start()
        }
        ,
        Se.addEventListener("sessionstart", tn),
        Se.addEventListener("sessionend", qt),
        this.render = function(te, ye) {
            if (ye !== void 0 && ye.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (_ === !0)
                return;
            if (te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(),
            ye.parent === null && ye.matrixWorldAutoUpdate === !0 && ye.updateMatrixWorld(),
            Se.enabled === !0 && Se.isPresenting === !0 && (Se.cameraAutoUpdate === !0 && Se.updateCamera(ye),
            ye = Se.getCamera()),
            te.isScene === !0 && te.onBeforeRender(w, te, ye, B),
            g = N.get(te, v.length),
            g.init(ye),
            v.push(g),
            ue.multiplyMatrices(ye.projectionMatrix, ye.matrixWorldInverse),
            W.setFromProjectionMatrix(ue),
            P = this.localClippingEnabled,
            ee = K.init(this.clippingPlanes, P),
            m = U.get(te, p.length),
            m.init(),
            p.push(m),
            Se.enabled === !0 && Se.isPresenting === !0) {
                const ke = w.xr.getDepthSensingMesh();
                ke !== null && en(ke, ye, -1 / 0, w.sortObjects)
            }
            en(te, ye, 0, w.sortObjects),
            m.finish(),
            w.sortObjects === !0 && m.sort(O, z),
            ge = Se.enabled === !1 || Se.isPresenting === !1 || Se.hasDepthSensing() === !1,
            ge && pe.addToRenderList(m, te),
            this.info.render.frame++,
            ee === !0 && K.beginShadows();
            const Be = g.state.shadowsArray;
            oe.render(Be, te, ye),
            ee === !0 && K.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const Me = m.opaque
              , we = m.transmissive;
            if (g.setupLights(),
            ye.isArrayCamera) {
                const ke = ye.cameras;
                if (we.length > 0)
                    for (let Xe = 0, qe = ke.length; Xe < qe; Xe++) {
                        const tt = ke[Xe];
                        Ks(Me, we, te, tt)
                    }
                ge && pe.render(te);
                for (let Xe = 0, qe = ke.length; Xe < qe; Xe++) {
                    const tt = ke[Xe];
                    nn(m, te, tt, tt.viewport)
                }
            } else
                we.length > 0 && Ks(Me, we, te, ye),
                ge && pe.render(te),
                nn(m, te, ye);
            B !== null && (X.updateMultisampleRenderTarget(B),
            X.updateRenderTargetMipmap(B)),
            te.isScene === !0 && te.onAfterRender(w, te, ye),
            $e.resetDefaultState(),
            S = -1,
            I = null,
            v.pop(),
            v.length > 0 ? (g = v[v.length - 1],
            ee === !0 && K.setGlobalState(w.clippingPlanes, g.state.camera)) : g = null,
            p.pop(),
            p.length > 0 ? m = p[p.length - 1] : m = null
        }
        ;
        function en(te, ye, Be, Me) {
            if (te.visible === !1)
                return;
            if (te.layers.test(ye.layers)) {
                if (te.isGroup)
                    Be = te.renderOrder;
                else if (te.isLOD)
                    te.autoUpdate === !0 && te.update(ye);
                else if (te.isLight)
                    g.pushLight(te),
                    te.castShadow && g.pushShadow(te);
                else if (te.isSprite) {
                    if (!te.frustumCulled || W.intersectsSprite(te)) {
                        Me && me.setFromMatrixPosition(te.matrixWorld).applyMatrix4(ue);
                        const Xe = ae.update(te)
                          , qe = te.material;
                        qe.visible && m.push(te, Xe, qe, Be, me.z, null)
                    }
                } else if ((te.isMesh || te.isLine || te.isPoints) && (!te.frustumCulled || W.intersectsObject(te))) {
                    const Xe = ae.update(te)
                      , qe = te.material;
                    if (Me && (te.boundingSphere !== void 0 ? (te.boundingSphere === null && te.computeBoundingSphere(),
                    me.copy(te.boundingSphere.center)) : (Xe.boundingSphere === null && Xe.computeBoundingSphere(),
                    me.copy(Xe.boundingSphere.center)),
                    me.applyMatrix4(te.matrixWorld).applyMatrix4(ue)),
                    Array.isArray(qe)) {
                        const tt = Xe.groups;
                        for (let ft = 0, mt = tt.length; ft < mt; ft++) {
                            const st = tt[ft]
                              , Wt = qe[st.materialIndex];
                            Wt && Wt.visible && m.push(te, Xe, Wt, Be, me.z, st)
                        }
                    } else
                        qe.visible && m.push(te, Xe, qe, Be, me.z, null)
                }
            }
            const ke = te.children;
            for (let Xe = 0, qe = ke.length; Xe < qe; Xe++)
                en(ke[Xe], ye, Be, Me)
        }
        function nn(te, ye, Be, Me) {
            const we = te.opaque
              , ke = te.transmissive
              , Xe = te.transparent;
            g.setupLightsView(Be),
            ee === !0 && K.setGlobalState(w.clippingPlanes, Be),
            Me && J.viewport(M.copy(Me)),
            we.length > 0 && Xt(we, ye, Be),
            ke.length > 0 && Xt(ke, ye, Be),
            Xe.length > 0 && Xt(Xe, ye, Be),
            J.buffers.depth.setTest(!0),
            J.buffers.depth.setMask(!0),
            J.buffers.color.setMask(!0),
            J.setPolygonOffset(!1)
        }
        function Ks(te, ye, Be, Me) {
            if ((Be.isScene === !0 ? Be.overrideMaterial : null) !== null)
                return;
            g.state.transmissionRenderTarget[Me.id] === void 0 && (g.state.transmissionRenderTarget[Me.id] = new tl(1,1,{
                generateMipmaps: !0,
                type: fe.has("EXT_color_buffer_half_float") || fe.has("EXT_color_buffer_float") ? Ha : rc,
                minFilter: ea,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Et.workingColorSpace
            }));
            const ke = g.state.transmissionRenderTarget[Me.id]
              , Xe = Me.viewport || M;
            ke.setSize(Xe.z, Xe.w);
            const qe = w.getRenderTarget();
            w.setRenderTarget(ke),
            w.getClearColor(T),
            y = w.getClearAlpha(),
            y < 1 && w.setClearColor(16777215, .5),
            w.clear(),
            ge && pe.render(Be);
            const tt = w.toneMapping;
            w.toneMapping = fA;
            const ft = Me.viewport;
            if (Me.viewport !== void 0 && (Me.viewport = void 0),
            g.setupLightsView(Me),
            ee === !0 && K.setGlobalState(w.clippingPlanes, Me),
            Xt(te, Be, Me),
            X.updateMultisampleRenderTarget(ke),
            X.updateRenderTargetMipmap(ke),
            fe.has("WEBGL_multisampled_render_to_texture") === !1) {
                let mt = !1;
                for (let st = 0, Wt = ye.length; st < Wt; st++) {
                    const fn = ye[st]
                      , yn = fn.object
                      , qr = fn.geometry
                      , Vt = fn.material
                      , at = fn.group;
                    if (Vt.side === _i && yn.layers.test(Me.layers)) {
                        const or = Vt.side;
                        Vt.side = oi,
                        Vt.needsUpdate = !0,
                        Yt(yn, Be, Me, qr, Vt, at),
                        Vt.side = or,
                        Vt.needsUpdate = !0,
                        mt = !0
                    }
                }
                mt === !0 && (X.updateMultisampleRenderTarget(ke),
                X.updateRenderTargetMipmap(ke))
            }
            w.setRenderTarget(qe),
            w.setClearColor(T, y),
            ft !== void 0 && (Me.viewport = ft),
            w.toneMapping = tt
        }
        function Xt(te, ye, Be) {
            const Me = ye.isScene === !0 ? ye.overrideMaterial : null;
            for (let we = 0, ke = te.length; we < ke; we++) {
                const Xe = te[we]
                  , qe = Xe.object
                  , tt = Xe.geometry
                  , ft = Me === null ? Xe.material : Me
                  , mt = Xe.group;
                qe.layers.test(Be.layers) && Yt(qe, ye, Be, tt, ft, mt)
            }
        }
        function Yt(te, ye, Be, Me, we, ke) {
            te.onBeforeRender(w, ye, Be, Me, we, ke),
            te.modelViewMatrix.multiplyMatrices(Be.matrixWorldInverse, te.matrixWorld),
            te.normalMatrix.getNormalMatrix(te.modelViewMatrix),
            we.onBeforeRender(w, ye, Be, Me, te, ke),
            we.transparent === !0 && we.side === _i && we.forceSinglePass === !1 ? (we.side = oi,
            we.needsUpdate = !0,
            w.renderBufferDirect(Be, ye, Me, we, te, ke),
            we.side = Hs,
            we.needsUpdate = !0,
            w.renderBufferDirect(Be, ye, Me, we, te, ke),
            we.side = _i) : w.renderBufferDirect(Be, ye, Me, we, te, ke),
            te.onAfterRender(w, ye, Be, Me, we, ke)
        }
        function Ii(te, ye, Be) {
            ye.isScene !== !0 && (ye = ie);
            const Me = he.get(te)
              , we = g.state.lights
              , ke = g.state.shadowsArray
              , Xe = we.state.version
              , qe = Ee.getParameters(te, we.state, ke, ye, Be)
              , tt = Ee.getProgramCacheKey(qe);
            let ft = Me.programs;
            Me.environment = te.isMeshStandardMaterial ? ye.environment : null,
            Me.fog = ye.fog,
            Me.envMap = (te.isMeshStandardMaterial ? ne : G).get(te.envMap || Me.environment),
            Me.envMapRotation = Me.environment !== null && te.envMap === null ? ye.environmentRotation : te.envMapRotation,
            ft === void 0 && (te.addEventListener("dispose", Ze),
            ft = new Map,
            Me.programs = ft);
            let mt = ft.get(tt);
            if (mt !== void 0) {
                if (Me.currentProgram === mt && Me.lightsStateVersion === Xe)
                    return sn(te, qe),
                    mt
            } else
                qe.uniforms = Ee.getUniforms(te),
                te.onBeforeCompile(qe, w),
                mt = Ee.acquireProgram(qe, tt),
                ft.set(tt, mt),
                Me.uniforms = qe.uniforms;
            const st = Me.uniforms;
            return (!te.isShaderMaterial && !te.isRawShaderMaterial || te.clipping === !0) && (st.clippingPlanes = K.uniform),
            sn(te, qe),
            Me.needsLights = on(te),
            Me.lightsStateVersion = Xe,
            Me.needsLights && (st.ambientLightColor.value = we.state.ambient,
            st.lightProbe.value = we.state.probe,
            st.directionalLights.value = we.state.directional,
            st.directionalLightShadows.value = we.state.directionalShadow,
            st.spotLights.value = we.state.spot,
            st.spotLightShadows.value = we.state.spotShadow,
            st.rectAreaLights.value = we.state.rectArea,
            st.ltc_1.value = we.state.rectAreaLTC1,
            st.ltc_2.value = we.state.rectAreaLTC2,
            st.pointLights.value = we.state.point,
            st.pointLightShadows.value = we.state.pointShadow,
            st.hemisphereLights.value = we.state.hemi,
            st.directionalShadowMap.value = we.state.directionalShadowMap,
            st.directionalShadowMatrix.value = we.state.directionalShadowMatrix,
            st.spotShadowMap.value = we.state.spotShadowMap,
            st.spotLightMatrix.value = we.state.spotLightMatrix,
            st.spotLightMap.value = we.state.spotLightMap,
            st.pointShadowMap.value = we.state.pointShadowMap,
            st.pointShadowMatrix.value = we.state.pointShadowMatrix),
            Me.currentProgram = mt,
            Me.uniformsList = null,
            mt
        }
        function rn(te) {
            if (te.uniformsList === null) {
                const ye = te.currentProgram.getUniforms();
                te.uniformsList = Cw.seqWithValue(ye.seq, te.uniforms)
            }
            return te.uniformsList
        }
        function sn(te, ye) {
            const Be = he.get(te);
            Be.outputColorSpace = ye.outputColorSpace,
            Be.batching = ye.batching,
            Be.batchingColor = ye.batchingColor,
            Be.instancing = ye.instancing,
            Be.instancingColor = ye.instancingColor,
            Be.instancingMorph = ye.instancingMorph,
            Be.skinning = ye.skinning,
            Be.morphTargets = ye.morphTargets,
            Be.morphNormals = ye.morphNormals,
            Be.morphColors = ye.morphColors,
            Be.morphTargetsCount = ye.morphTargetsCount,
            Be.numClippingPlanes = ye.numClippingPlanes,
            Be.numIntersection = ye.numClipIntersection,
            Be.vertexAlphas = ye.vertexAlphas,
            Be.vertexTangents = ye.vertexTangents,
            Be.toneMapping = ye.toneMapping
        }
        function ma(te, ye, Be, Me, we) {
            ye.isScene !== !0 && (ye = ie),
            X.resetTextureUnits();
            const ke = ye.fog
              , Xe = Me.isMeshStandardMaterial ? ye.environment : null
              , qe = B === null ? w.outputColorSpace : B.isXRRenderTarget === !0 ? B.texture.colorSpace : Sr
              , tt = (Me.isMeshStandardMaterial ? ne : G).get(Me.envMap || Xe)
              , ft = Me.vertexColors === !0 && !!Be.attributes.color && Be.attributes.color.itemSize === 4
              , mt = !!Be.attributes.tangent && (!!Me.normalMap || Me.anisotropy > 0)
              , st = !!Be.morphAttributes.position
              , Wt = !!Be.morphAttributes.normal
              , fn = !!Be.morphAttributes.color;
            let yn = fA;
            Me.toneMapped && (B === null || B.isXRRenderTarget === !0) && (yn = w.toneMapping);
            const qr = Be.morphAttributes.position || Be.morphAttributes.normal || Be.morphAttributes.color
              , Vt = qr !== void 0 ? qr.length : 0
              , at = he.get(Me)
              , or = g.state.lights;
            if (ee === !0 && (P === !0 || te !== I)) {
                const Xs = te === I && Me.id === S;
                K.setState(Me, te, Xs)
            }
            let an = !1;
            Me.version === at.__version ? (at.needsLights && at.lightsStateVersion !== or.state.version || at.outputColorSpace !== qe || we.isBatchedMesh && at.batching === !1 || !we.isBatchedMesh && at.batching === !0 || we.isBatchedMesh && at.batchingColor === !0 && we.colorTexture === null || we.isBatchedMesh && at.batchingColor === !1 && we.colorTexture !== null || we.isInstancedMesh && at.instancing === !1 || !we.isInstancedMesh && at.instancing === !0 || we.isSkinnedMesh && at.skinning === !1 || !we.isSkinnedMesh && at.skinning === !0 || we.isInstancedMesh && at.instancingColor === !0 && we.instanceColor === null || we.isInstancedMesh && at.instancingColor === !1 && we.instanceColor !== null || we.isInstancedMesh && at.instancingMorph === !0 && we.morphTexture === null || we.isInstancedMesh && at.instancingMorph === !1 && we.morphTexture !== null || at.envMap !== tt || Me.fog === !0 && at.fog !== ke || at.numClippingPlanes !== void 0 && (at.numClippingPlanes !== K.numPlanes || at.numIntersection !== K.numIntersection) || at.vertexAlphas !== ft || at.vertexTangents !== mt || at.morphTargets !== st || at.morphNormals !== Wt || at.morphColors !== fn || at.toneMapping !== yn || at.morphTargetsCount !== Vt) && (an = !0) : (an = !0,
            at.__version = Me.version);
            let Ro = at.currentProgram;
            an === !0 && (Ro = Ii(Me, ye, we));
            let sf = !1
              , ds = !1
              , fb = !1;
            const ar = Ro.getUniforms()
              , pc = at.uniforms;
            if (J.useProgram(Ro.program) && (sf = !0,
            ds = !0,
            fb = !0),
            Me.id !== S && (S = Me.id,
            ds = !0),
            sf || I !== te) {
                Ae.reverseDepthBuffer ? (re.copy(te.projectionMatrix),
                eee(re),
                tee(re),
                ar.setValue(se, "projectionMatrix", re)) : ar.setValue(se, "projectionMatrix", te.projectionMatrix),
                ar.setValue(se, "viewMatrix", te.matrixWorldInverse);
                const Xs = ar.map.cameraPosition;
                Xs !== void 0 && Xs.setValue(se, le.setFromMatrixPosition(te.matrixWorld)),
                Ae.logarithmicDepthBuffer && ar.setValue(se, "logDepthBufFC", 2 / (Math.log(te.far + 1) / Math.LN2)),
                (Me.isMeshPhongMaterial || Me.isMeshToonMaterial || Me.isMeshLambertMaterial || Me.isMeshBasicMaterial || Me.isMeshStandardMaterial || Me.isShaderMaterial) && ar.setValue(se, "isOrthographic", te.isOrthographicCamera === !0),
                I !== te && (I = te,
                ds = !0,
                fb = !0)
            }
            if (we.isSkinnedMesh) {
                ar.setOptional(se, we, "bindMatrix"),
                ar.setOptional(se, we, "bindMatrixInverse");
                const Xs = we.skeleton;
                Xs && (Xs.boneTexture === null && Xs.computeBoneTexture(),
                ar.setValue(se, "boneTexture", Xs.boneTexture, X))
            }
            we.isBatchedMesh && (ar.setOptional(se, we, "batchingTexture"),
            ar.setValue(se, "batchingTexture", we._matricesTexture, X),
            ar.setOptional(se, we, "batchingIdTexture"),
            ar.setValue(se, "batchingIdTexture", we._indirectTexture, X),
            ar.setOptional(se, we, "batchingColorTexture"),
            we._colorsTexture !== null && ar.setValue(se, "batchingColorTexture", we._colorsTexture, X));
            const hb = Be.morphAttributes;
            if ((hb.position !== void 0 || hb.normal !== void 0 || hb.color !== void 0) && ve.update(we, Be, Ro),
            (ds || at.receiveShadow !== we.receiveShadow) && (at.receiveShadow = we.receiveShadow,
            ar.setValue(se, "receiveShadow", we.receiveShadow)),
            Me.isMeshGouraudMaterial && Me.envMap !== null && (pc.envMap.value = tt,
            pc.flipEnvMap.value = tt.isCubeTexture && tt.isRenderTargetTexture === !1 ? -1 : 1),
            Me.isMeshStandardMaterial && Me.envMap === null && ye.environment !== null && (pc.envMapIntensity.value = ye.environmentIntensity),
            ds && (ar.setValue(se, "toneMappingExposure", w.toneMappingExposure),
            at.needsLights && un(pc, fb),
            ke && Me.fog === !0 && V.refreshFogUniforms(pc, ke),
            V.refreshMaterialUniforms(pc, Me, F, R, g.state.transmissionRenderTarget[te.id]),
            Cw.upload(se, rn(at), pc, X)),
            Me.isShaderMaterial && Me.uniformsNeedUpdate === !0 && (Cw.upload(se, rn(at), pc, X),
            Me.uniformsNeedUpdate = !1),
            Me.isSpriteMaterial && ar.setValue(se, "center", we.center),
            ar.setValue(se, "modelViewMatrix", we.modelViewMatrix),
            ar.setValue(se, "normalMatrix", we.normalMatrix),
            ar.setValue(se, "modelMatrix", we.matrixWorld),
            Me.isShaderMaterial || Me.isRawShaderMaterial) {
                const Xs = Me.uniformsGroups;
                for (let db = 0, CW = Xs.length; db < CW; db++) {
                    const EU = Xs[db];
                    ce.update(EU, Ro),
                    ce.bind(EU, Ro)
                }
            }
            return Ro
        }
        function un(te, ye) {
            te.ambientLightColor.needsUpdate = ye,
            te.lightProbe.needsUpdate = ye,
            te.directionalLights.needsUpdate = ye,
            te.directionalLightShadows.needsUpdate = ye,
            te.pointLights.needsUpdate = ye,
            te.pointLightShadows.needsUpdate = ye,
            te.spotLights.needsUpdate = ye,
            te.spotLightShadows.needsUpdate = ye,
            te.rectAreaLights.needsUpdate = ye,
            te.hemisphereLights.needsUpdate = ye
        }
        function on(te) {
            return te.isMeshLambertMaterial || te.isMeshToonMaterial || te.isMeshPhongMaterial || te.isMeshStandardMaterial || te.isShadowMaterial || te.isShaderMaterial && te.lights === !0
        }
        this.getActiveCubeFace = function() {
            return x
        }
        ,
        this.getActiveMipmapLevel = function() {
            return b
        }
        ,
        this.getRenderTarget = function() {
            return B
        }
        ,
        this.setRenderTargetTextures = function(te, ye, Be) {
            he.get(te.texture).__webglTexture = ye,
            he.get(te.depthTexture).__webglTexture = Be;
            const Me = he.get(te);
            Me.__hasExternalTextures = !0,
            Me.__autoAllocateDepthBuffer = Be === void 0,
            Me.__autoAllocateDepthBuffer || fe.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            Me.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(te, ye) {
            const Be = he.get(te);
            Be.__webglFramebuffer = ye,
            Be.__useDefaultFramebuffer = ye === void 0
        }
        ,
        this.setRenderTarget = function(te, ye=0, Be=0) {
            B = te,
            x = ye,
            b = Be;
            let Me = !0
              , we = null
              , ke = !1
              , Xe = !1;
            if (te) {
                const tt = he.get(te);
                if (tt.__useDefaultFramebuffer !== void 0)
                    J.bindFramebuffer(se.FRAMEBUFFER, null),
                    Me = !1;
                else if (tt.__webglFramebuffer === void 0)
                    X.setupRenderTarget(te);
                else if (tt.__hasExternalTextures)
                    X.rebindTextures(te, he.get(te.texture).__webglTexture, he.get(te.depthTexture).__webglTexture);
                else if (te.depthBuffer) {
                    const st = te.depthTexture;
                    if (tt.__boundDepthTexture !== st) {
                        if (st !== null && he.has(st) && (te.width !== st.image.width || te.height !== st.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        X.setupDepthRenderbuffer(te)
                    }
                }
                const ft = te.texture;
                (ft.isData3DTexture || ft.isDataArrayTexture || ft.isCompressedArrayTexture) && (Xe = !0);
                const mt = he.get(te).__webglFramebuffer;
                te.isWebGLCubeRenderTarget ? (Array.isArray(mt[ye]) ? we = mt[ye][Be] : we = mt[ye],
                ke = !0) : te.samples > 0 && X.useMultisampledRTT(te) === !1 ? we = he.get(te).__webglMultisampledFramebuffer : Array.isArray(mt) ? we = mt[Be] : we = mt,
                M.copy(te.viewport),
                L.copy(te.scissor),
                D = te.scissorTest
            } else
                M.copy(j).multiplyScalar(F).floor(),
                L.copy(Q).multiplyScalar(F).floor(),
                D = C;
            if (J.bindFramebuffer(se.FRAMEBUFFER, we) && Me && J.drawBuffers(te, we),
            J.viewport(M),
            J.scissor(L),
            J.setScissorTest(D),
            ke) {
                const tt = he.get(te.texture);
                se.framebufferTexture2D(se.FRAMEBUFFER, se.COLOR_ATTACHMENT0, se.TEXTURE_CUBE_MAP_POSITIVE_X + ye, tt.__webglTexture, Be)
            } else if (Xe) {
                const tt = he.get(te.texture)
                  , ft = ye || 0;
                se.framebufferTextureLayer(se.FRAMEBUFFER, se.COLOR_ATTACHMENT0, tt.__webglTexture, Be || 0, ft)
            }
            S = -1
        }
        ,
        this.readRenderTargetPixels = function(te, ye, Be, Me, we, ke, Xe) {
            if (!(te && te.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let qe = he.get(te).__webglFramebuffer;
            if (te.isWebGLCubeRenderTarget && Xe !== void 0 && (qe = qe[Xe]),
            qe) {
                J.bindFramebuffer(se.FRAMEBUFFER, qe);
                try {
                    const tt = te.texture
                      , ft = tt.format
                      , mt = tt.type;
                    if (!Ae.textureFormatReadable(ft)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!Ae.textureTypeReadable(mt)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    ye >= 0 && ye <= te.width - Me && Be >= 0 && Be <= te.height - we && se.readPixels(ye, Be, Me, we, Re.convert(ft), Re.convert(mt), ke)
                } finally {
                    const tt = B !== null ? he.get(B).__webglFramebuffer : null;
                    J.bindFramebuffer(se.FRAMEBUFFER, tt)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(te, ye, Be, Me, we, ke, Xe) {
            if (!(te && te.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let qe = he.get(te).__webglFramebuffer;
            if (te.isWebGLCubeRenderTarget && Xe !== void 0 && (qe = qe[Xe]),
            qe) {
                const tt = te.texture
                  , ft = tt.format
                  , mt = tt.type;
                if (!Ae.textureFormatReadable(ft))
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                if (!Ae.textureTypeReadable(mt))
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                if (ye >= 0 && ye <= te.width - Me && Be >= 0 && Be <= te.height - we) {
                    J.bindFramebuffer(se.FRAMEBUFFER, qe);
                    const st = se.createBuffer();
                    se.bindBuffer(se.PIXEL_PACK_BUFFER, st),
                    se.bufferData(se.PIXEL_PACK_BUFFER, ke.byteLength, se.STREAM_READ),
                    se.readPixels(ye, Be, Me, we, Re.convert(ft), Re.convert(mt), 0);
                    const Wt = B !== null ? he.get(B).__webglFramebuffer : null;
                    J.bindFramebuffer(se.FRAMEBUFFER, Wt);
                    const fn = se.fenceSync(se.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return se.flush(),
                    await qq(se, fn, 4),
                    se.bindBuffer(se.PIXEL_PACK_BUFFER, st),
                    se.getBufferSubData(se.PIXEL_PACK_BUFFER, 0, ke),
                    se.deleteBuffer(st),
                    se.deleteSync(fn),
                    ke
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
            }
        }
        ,
        this.copyFramebufferToTexture = function(te, ye=null, Be=0) {
            te.isTexture !== !0 && (Sw("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            ye = arguments[0] || null,
            te = arguments[1]);
            const Me = Math.pow(2, -Be)
              , we = Math.floor(te.image.width * Me)
              , ke = Math.floor(te.image.height * Me)
              , Xe = ye !== null ? ye.x : 0
              , qe = ye !== null ? ye.y : 0;
            X.setTexture2D(te, 0),
            se.copyTexSubImage2D(se.TEXTURE_2D, Be, 0, 0, Xe, qe, we, ke),
            J.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(te, ye, Be=null, Me=null, we=0) {
            te.isTexture !== !0 && (Sw("WebGLRenderer: copyTextureToTexture function signature has changed."),
            Me = arguments[0] || null,
            te = arguments[1],
            ye = arguments[2],
            we = arguments[3] || 0,
            Be = null);
            let ke, Xe, qe, tt, ft, mt;
            Be !== null ? (ke = Be.max.x - Be.min.x,
            Xe = Be.max.y - Be.min.y,
            qe = Be.min.x,
            tt = Be.min.y) : (ke = te.image.width,
            Xe = te.image.height,
            qe = 0,
            tt = 0),
            Me !== null ? (ft = Me.x,
            mt = Me.y) : (ft = 0,
            mt = 0);
            const st = Re.convert(ye.format)
              , Wt = Re.convert(ye.type);
            X.setTexture2D(ye, 0),
            se.pixelStorei(se.UNPACK_FLIP_Y_WEBGL, ye.flipY),
            se.pixelStorei(se.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ye.premultiplyAlpha),
            se.pixelStorei(se.UNPACK_ALIGNMENT, ye.unpackAlignment);
            const fn = se.getParameter(se.UNPACK_ROW_LENGTH)
              , yn = se.getParameter(se.UNPACK_IMAGE_HEIGHT)
              , qr = se.getParameter(se.UNPACK_SKIP_PIXELS)
              , Vt = se.getParameter(se.UNPACK_SKIP_ROWS)
              , at = se.getParameter(se.UNPACK_SKIP_IMAGES)
              , or = te.isCompressedTexture ? te.mipmaps[we] : te.image;
            se.pixelStorei(se.UNPACK_ROW_LENGTH, or.width),
            se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, or.height),
            se.pixelStorei(se.UNPACK_SKIP_PIXELS, qe),
            se.pixelStorei(se.UNPACK_SKIP_ROWS, tt),
            te.isDataTexture ? se.texSubImage2D(se.TEXTURE_2D, we, ft, mt, ke, Xe, st, Wt, or.data) : te.isCompressedTexture ? se.compressedTexSubImage2D(se.TEXTURE_2D, we, ft, mt, or.width, or.height, st, or.data) : se.texSubImage2D(se.TEXTURE_2D, we, ft, mt, ke, Xe, st, Wt, or),
            se.pixelStorei(se.UNPACK_ROW_LENGTH, fn),
            se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, yn),
            se.pixelStorei(se.UNPACK_SKIP_PIXELS, qr),
            se.pixelStorei(se.UNPACK_SKIP_ROWS, Vt),
            se.pixelStorei(se.UNPACK_SKIP_IMAGES, at),
            we === 0 && ye.generateMipmaps && se.generateMipmap(se.TEXTURE_2D),
            J.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(te, ye, Be=null, Me=null, we=0) {
            te.isTexture !== !0 && (Sw("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            Be = arguments[0] || null,
            Me = arguments[1] || null,
            te = arguments[2],
            ye = arguments[3],
            we = arguments[4] || 0);
            let ke, Xe, qe, tt, ft, mt, st, Wt, fn;
            const yn = te.isCompressedTexture ? te.mipmaps[we] : te.image;
            Be !== null ? (ke = Be.max.x - Be.min.x,
            Xe = Be.max.y - Be.min.y,
            qe = Be.max.z - Be.min.z,
            tt = Be.min.x,
            ft = Be.min.y,
            mt = Be.min.z) : (ke = yn.width,
            Xe = yn.height,
            qe = yn.depth,
            tt = 0,
            ft = 0,
            mt = 0),
            Me !== null ? (st = Me.x,
            Wt = Me.y,
            fn = Me.z) : (st = 0,
            Wt = 0,
            fn = 0);
            const qr = Re.convert(ye.format)
              , Vt = Re.convert(ye.type);
            let at;
            if (ye.isData3DTexture)
                X.setTexture3D(ye, 0),
                at = se.TEXTURE_3D;
            else if (ye.isDataArrayTexture || ye.isCompressedArrayTexture)
                X.setTexture2DArray(ye, 0),
                at = se.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            se.pixelStorei(se.UNPACK_FLIP_Y_WEBGL, ye.flipY),
            se.pixelStorei(se.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ye.premultiplyAlpha),
            se.pixelStorei(se.UNPACK_ALIGNMENT, ye.unpackAlignment);
            const or = se.getParameter(se.UNPACK_ROW_LENGTH)
              , an = se.getParameter(se.UNPACK_IMAGE_HEIGHT)
              , Ro = se.getParameter(se.UNPACK_SKIP_PIXELS)
              , sf = se.getParameter(se.UNPACK_SKIP_ROWS)
              , ds = se.getParameter(se.UNPACK_SKIP_IMAGES);
            se.pixelStorei(se.UNPACK_ROW_LENGTH, yn.width),
            se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, yn.height),
            se.pixelStorei(se.UNPACK_SKIP_PIXELS, tt),
            se.pixelStorei(se.UNPACK_SKIP_ROWS, ft),
            se.pixelStorei(se.UNPACK_SKIP_IMAGES, mt),
            te.isDataTexture || te.isData3DTexture ? se.texSubImage3D(at, we, st, Wt, fn, ke, Xe, qe, qr, Vt, yn.data) : ye.isCompressedArrayTexture ? se.compressedTexSubImage3D(at, we, st, Wt, fn, ke, Xe, qe, qr, yn.data) : se.texSubImage3D(at, we, st, Wt, fn, ke, Xe, qe, qr, Vt, yn),
            se.pixelStorei(se.UNPACK_ROW_LENGTH, or),
            se.pixelStorei(se.UNPACK_IMAGE_HEIGHT, an),
            se.pixelStorei(se.UNPACK_SKIP_PIXELS, Ro),
            se.pixelStorei(se.UNPACK_SKIP_ROWS, sf),
            se.pixelStorei(se.UNPACK_SKIP_IMAGES, ds),
            we === 0 && ye.generateMipmaps && se.generateMipmap(at),
            J.unbindTexture()
        }
        ,
        this.initRenderTarget = function(te) {
            he.get(te).__webglFramebuffer === void 0 && X.setupRenderTarget(te)
        }
        ,
        this.initTexture = function(te) {
            te.isCubeTexture ? X.setTextureCube(te, 0) : te.isData3DTexture ? X.setTexture3D(te, 0) : te.isDataArrayTexture || te.isCompressedArrayTexture ? X.setTexture2DArray(te, 0) : X.setTexture2D(te, 0),
            J.unbindTexture()
        }
        ,
        this.resetState = function() {
            x = 0,
            b = 0,
            B = null,
            J.reset(),
            $e.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return zl
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === LR ? "display-p3" : "srgb",
        t.unpackColorSpace = Et.workingColorSpace === u1 ? "display-p3" : "srgb"
    }
}
class Gg extends Lt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new nr,
        this.environmentIntensity = 1,
        this.environmentRotation = new nr,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class hse {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = UC,
        this.updateRanges = [],
        this.version = 0,
        this.uuid = ia()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, r) {
        e *= this.stride,
        r *= t.stride;
        for (let i = 0, s = this.stride; i < s; i++)
            this.array[e + i] = t.array[r + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ia()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , r = new this.constructor(t,this.stride);
        return r.setUsage(this.usage),
        r
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ia()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Ri = new $;
class zR {
    constructor(e, t, r, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = r,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.data.count; t < r; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.applyMatrix4(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.applyNormalMatrix(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.transformDirection(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    getComponent(e, t) {
        let r = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (r = Zo(r, this.array)),
        r
    }
    setComponent(e, t, r) {
        return this.normalized && (r = hn(r, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = r,
        this
    }
    setX(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = hn(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Zo(t, this.array)),
        t
    }
    setXY(e, t, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array),
        i = hn(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, r, i, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = hn(t, this.array),
        r = hn(r, this.array),
        i = hn(i, this.array),
        s = hn(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = r,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return new ct(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new zR(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let r = 0; r < this.count; r++) {
                const i = r * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const YL = new $
  , $L = new Pt
  , ZL = new Pt
  , dse = new $
  , JL = new He
  , Fv = new $
  , jE = new Mi
  , qL = new He
  , WE = new $u;
class sa extends dn {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = iL,
        this.bindMatrix = new He,
        this.bindMatrixInverse = new He,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Hn),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let r = 0; r < t.count; r++)
            this.getVertexPosition(r, Fv),
            this.boundingBox.expandByPoint(Fv)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Mi),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let r = 0; r < t.count; r++)
            this.getVertexPosition(r, Fv),
            this.boundingSphere.expandByPoint(Fv)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const r = this.material
          , i = this.matrixWorld;
        r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        jE.copy(this.boundingSphere),
        jE.applyMatrix4(i),
        e.ray.intersectsSphere(jE) !== !1 && (qL.copy(i).invert(),
        WE.copy(e.ray).applyMatrix4(qL),
        !(this.boundingBox !== null && WE.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, WE)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Pt
          , t = this.geometry.attributes.skinWeight;
        for (let r = 0, i = t.count; r < i; r++) {
            e.fromBufferAttribute(t, r);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(r, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === iL ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === yq ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const r = this.skeleton
          , i = this.geometry;
        $L.fromBufferAttribute(i.attributes.skinIndex, e),
        ZL.fromBufferAttribute(i.attributes.skinWeight, e),
        YL.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = ZL.getComponent(s);
            if (o !== 0) {
                const a = $L.getComponent(s);
                JL.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
                t.addScaledVector(dse.copy(YL).applyMatrix4(JL), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class k_ extends Lt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Eu extends Un {
    constructor(e=null, t=1, r=1, i, s, o, a, l, c=Xr, A=Xr, u, f) {
        super(null, o, a, l, c, A, i, s, u, f),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const eD = new He
  , pse = new He;
class FA {
    constructor(e=[], t=[]) {
        this.uuid = ia(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let r = 0, i = this.bones.length; r < i; r++)
                this.boneInverses.push(new He)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = new He;
            this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(r)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = this.bones[e];
            r && r.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const r = this.bones[e];
            r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld),
            r.matrix.decompose(r.position, r.quaternion, r.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , r = this.boneMatrices
          , i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : pse;
            eD.multiplyMatrices(a, t[s]),
            eD.toArray(r, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new FA(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const r = new Eu(t,e,e,Nr,xi);
        return r.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = r,
        this
    }
    getBoneByName(e) {
        for (let t = 0, r = this.bones.length; t < r; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let r = 0, i = e.bones.length; r < i; r++) {
            const s = e.bones[r];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new k_),
            this.bones.push(o),
            this.boneInverses.push(new He().fromArray(e.boneInverses[r]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , r = this.boneInverses;
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = r[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Vg extends ct {
    constructor(e, t, r, i=1) {
        super(e, t, r),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const bf = new He
  , tD = new He
  , Pv = []
  , nD = new Hn
  , mse = new He
  , Pp = new dn
  , Lp = new Mi;
class p1 extends dn {
    constructor(e, t, r) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Vg(new Float32Array(r * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = r,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < r; i++)
            this.setMatrixAt(i, mse)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new Hn),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let r = 0; r < t; r++)
            this.getMatrixAt(r, bf),
            nD.copy(e.boundingBox).applyMatrix4(bf),
            this.boundingBox.union(nD)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Mi),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let r = 0; r < t; r++)
            this.getMatrixAt(r, bf),
            Lp.copy(e.boundingSphere).applyMatrix4(bf),
            this.boundingSphere.union(Lp)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const r = t.morphTargetInfluences
          , i = this.morphTexture.source.data.data
          , s = r.length + 1
          , o = e * s + 1;
        for (let a = 0; a < r.length; a++)
            r[a] = i[o + a]
    }
    raycast(e, t) {
        const r = this.matrixWorld
          , i = this.count;
        if (Pp.geometry = this.geometry,
        Pp.material = this.material,
        Pp.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Lp.copy(this.boundingSphere),
        Lp.applyMatrix4(r),
        e.ray.intersectsSphere(Lp) !== !1))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, bf),
                tD.multiplyMatrices(r, bf),
                Pp.matrixWorld = tD,
                Pp.raycast(e, Pv);
                for (let o = 0, a = Pv.length; o < a; o++) {
                    const l = Pv[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                Pv.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Vg(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const r = t.morphTargetInfluences
          , i = r.length + 1;
        this.morphTexture === null && (this.morphTexture = new Eu(new Float32Array(i * this.count),i,this.count,RR,xi));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < r.length; c++)
            o += r[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , l = i * e;
        s[l] = a,
        s.set(r, l + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null),
        this
    }
}
function gse(n, e) {
    return n.z - e.z
}
function vse(n, e) {
    return e.z - n.z
}
class yse {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, t, r) {
        const i = this.pool
          , s = this.list;
        this.index >= i.length && i.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const o = i[this.index];
        s.push(o),
        this.index++,
        o.start = e.start,
        o.count = e.count,
        o.z = t,
        o.index = r
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const Bc = new He
  , KE = new He
  , wse = new He
  , _se = new Qe(1,1,1)
  , rD = new He
  , XE = new h1
  , Lv = new Hn
  , VA = new Mi
  , Dp = new $
  , iD = new $
  , xse = new $
  , YE = new yse
  , di = new dn
  , Dv = [];
function bse(n, e, t=0) {
    const r = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const i = n.count;
        for (let s = 0; s < i; s++)
            for (let o = 0; o < r; o++)
                e.setComponent(s + t, o, n.getComponent(s, o))
    } else
        e.array.set(n.array, t * r);
    e.needsUpdate = !0
}
class Ese extends dn {
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    constructor(e, t, r=t * 2, i) {
        super(new Jt, i),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._drawInfo = [],
        this._availableInstanceIds = [],
        this._drawRanges = [],
        this._reservedRanges = [],
        this._bounds = [],
        this._maxInstanceCount = e,
        this._maxVertexCount = t,
        this._maxIndexCount = r,
        this._geometryInitialized = !1,
        this._geometryCount = 0,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._multiDrawInstances = null,
        this._visibilityChanged = !0,
        this._matricesTexture = null,
        this._indirectTexture = null,
        this._colorsTexture = null,
        this._initMatricesTexture(),
        this._initIndirectTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4)
          , r = new Eu(t,e,e,Nr,xi);
        this._matricesTexture = r
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e)
          , r = new Eu(t,e,e,A1,wA);
        this._indirectTexture = r
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1)
          , r = new Eu(t,e,e,Nr,xi);
        r.colorSpace = Et.workingColorSpace,
        this._colorsTexture = r
    }
    _initializeGeometry(e) {
        const t = this.geometry
          , r = this._maxVertexCount
          , i = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const s in e.attributes) {
                const o = e.getAttribute(s)
                  , {array: a, itemSize: l, normalized: c} = o
                  , A = new a.constructor(r * l)
                  , u = new ct(A,l,c);
                t.setAttribute(s, u)
            }
            if (e.getIndex() !== null) {
                const s = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                t.setIndex(new ct(s,1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const r in t.attributes) {
            if (!e.hasAttribute(r))
                throw new Error(`BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);
            const i = e.getAttribute(r)
              , s = t.getAttribute(r);
            if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Hn);
        const e = this.boundingBox
          , t = this._drawInfo;
        e.makeEmpty();
        for (let r = 0, i = t.length; r < i; r++) {
            if (t[r].active === !1)
                continue;
            const s = t[r].geometryIndex;
            this.getMatrixAt(r, Bc),
            this.getBoundingBoxAt(s, Lv).applyMatrix4(Bc),
            e.union(Lv)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Mi);
        const e = this.boundingSphere
          , t = this._drawInfo;
        e.makeEmpty();
        for (let r = 0, i = t.length; r < i; r++) {
            if (t[r].active === !1)
                continue;
            const s = t[r].geometryIndex;
            this.getMatrixAt(r, Bc),
            this.getBoundingSphereAt(s, VA).applyMatrix4(Bc),
            e.union(VA)
        }
    }
    addInstance(e) {
        if (this._drawInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
            throw new Error("BatchedMesh: Maximum item count reached.");
        const r = {
            visible: !0,
            active: !0,
            geometryIndex: e
        };
        let i = null;
        this._availableInstanceIds.length > 0 ? (i = this._availableInstanceIds.pop(),
        this._drawInfo[i] = r) : (i = this._drawInfo.length,
        this._drawInfo.push(r));
        const s = this._matricesTexture
          , o = s.image.data;
        wse.toArray(o, i * 16),
        s.needsUpdate = !0;
        const a = this._colorsTexture;
        return a && (_se.toArray(a.image.data, i * 4),
        a.needsUpdate = !0),
        i
    }
    addGeometry(e, t=-1, r=-1) {
        if (this._initializeGeometry(e),
        this._validateGeometry(e),
        this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        const i = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let s = null;
        const o = this._reservedRanges
          , a = this._drawRanges
          , l = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]),
        t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t,
        s === null ? i.vertexStart = 0 : i.vertexStart = s.vertexStart + s.vertexCount;
        const c = e.getIndex()
          , A = c !== null;
        if (A && (r === -1 ? i.indexCount = c.count : i.indexCount = r,
        s === null ? i.indexStart = 0 : i.indexStart = s.indexStart + s.indexCount),
        i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const u = this._geometryCount;
        return this._geometryCount++,
        o.push(i),
        a.push({
            start: A ? i.indexStart : i.vertexStart,
            count: -1
        }),
        l.push({
            boxInitialized: !1,
            box: new Hn,
            sphereInitialized: !1,
            sphere: new Mi
        }),
        this.setGeometryAt(u, e),
        u
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const r = this.geometry
          , i = r.getIndex() !== null
          , s = r.getIndex()
          , o = t.getIndex()
          , a = this._reservedRanges[e];
        if (i && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const l = a.vertexStart
          , c = a.vertexCount;
        for (const h in r.attributes) {
            const d = t.getAttribute(h)
              , m = r.getAttribute(h);
            bse(d, m, l);
            const g = d.itemSize;
            for (let p = d.count, v = c; p < v; p++) {
                const w = l + p;
                for (let _ = 0; _ < g; _++)
                    m.setComponent(w, _, 0)
            }
            m.needsUpdate = !0,
            m.addUpdateRange(l * g, c * g)
        }
        if (i) {
            const h = a.indexStart;
            for (let d = 0; d < o.count; d++)
                s.setX(h + d, l + o.getX(d));
            for (let d = o.count, m = a.indexCount; d < m; d++)
                s.setX(h + d, l);
            s.needsUpdate = !0,
            s.addUpdateRange(h, a.indexCount)
        }
        const A = this._bounds[e];
        t.boundingBox !== null ? (A.box.copy(t.boundingBox),
        A.boxInitialized = !0) : A.boxInitialized = !1,
        t.boundingSphere !== null ? (A.sphere.copy(t.boundingSphere),
        A.sphereInitialized = !0) : A.sphereInitialized = !1;
        const u = this._drawRanges[e]
          , f = t.getAttribute("position");
        return u.count = i ? o.count : f.count,
        this._visibilityChanged = !0,
        e
    }
    deleteInstance(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? this : (t[e].active = !1,
        this._availableInstanceIds.push(e),
        this._visibilityChanged = !0,
        this)
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const r = this._bounds[e]
          , i = r.box
          , s = this.geometry;
        if (r.boxInitialized === !1) {
            i.makeEmpty();
            const o = s.index
              , a = s.attributes.position
              , l = this._drawRanges[e];
            for (let c = l.start, A = l.start + l.count; c < A; c++) {
                let u = c;
                o && (u = o.getX(u)),
                i.expandByPoint(Dp.fromBufferAttribute(a, u))
            }
            r.boxInitialized = !0
        }
        return t.copy(i),
        t
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const r = this._bounds[e]
          , i = r.sphere
          , s = this.geometry;
        if (r.sphereInitialized === !1) {
            i.makeEmpty(),
            this.getBoundingBoxAt(e, Lv),
            Lv.getCenter(i.center);
            const o = s.index
              , a = s.attributes.position
              , l = this._drawRanges[e];
            let c = 0;
            for (let A = l.start, u = l.start + l.count; A < u; A++) {
                let f = A;
                o && (f = o.getX(f)),
                Dp.fromBufferAttribute(a, f),
                c = Math.max(c, i.center.distanceToSquared(Dp))
            }
            i.radius = Math.sqrt(c),
            r.sphereInitialized = !0
        }
        return t.copy(i),
        t
    }
    setMatrixAt(e, t) {
        const r = this._drawInfo
          , i = this._matricesTexture
          , s = this._matricesTexture.image.data;
        return e >= r.length || r[e].active === !1 ? this : (t.toArray(s, e * 16),
        i.needsUpdate = !0,
        this)
    }
    getMatrixAt(e, t) {
        const r = this._drawInfo
          , i = this._matricesTexture.image.data;
        return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 16)
    }
    setColorAt(e, t) {
        this._colorsTexture === null && this._initColorsTexture();
        const r = this._colorsTexture
          , i = this._colorsTexture.image.data
          , s = this._drawInfo;
        return e >= s.length || s[e].active === !1 ? this : (t.toArray(i, e * 4),
        r.needsUpdate = !0,
        this)
    }
    getColorAt(e, t) {
        const r = this._colorsTexture.image.data
          , i = this._drawInfo;
        return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 4)
    }
    setVisibleAt(e, t) {
        const r = this._drawInfo;
        return e >= r.length || r[e].active === !1 || r[e].visible === t ? this : (r[e].visible = t,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? !1 : t[e].visible
    }
    setGeometryIdAt(e, t) {
        const r = this._drawInfo;
        return e >= r.length || r[e].active === !1 || t < 0 || t >= this._geometryCount ? null : (r[e].geometryIndex = t,
        this)
    }
    getGeometryIdAt(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? -1 : t[e].geometryIndex
    }
    getGeometryRangeAt(e, t={}) {
        if (e < 0 || e >= this._geometryCount)
            return null;
        const r = this._drawRanges[e];
        return t.start = r.start,
        t.count = r.count,
        t
    }
    raycast(e, t) {
        const r = this._drawInfo
          , i = this._drawRanges
          , s = this.matrixWorld
          , o = this.geometry;
        di.material = this.material,
        di.geometry.index = o.index,
        di.geometry.attributes = o.attributes,
        di.geometry.boundingBox === null && (di.geometry.boundingBox = new Hn),
        di.geometry.boundingSphere === null && (di.geometry.boundingSphere = new Mi);
        for (let a = 0, l = r.length; a < l; a++) {
            if (!r[a].visible || !r[a].active)
                continue;
            const c = r[a].geometryIndex
              , A = i[c];
            di.geometry.setDrawRange(A.start, A.count),
            this.getMatrixAt(a, di.matrixWorld).premultiply(s),
            this.getBoundingBoxAt(c, di.geometry.boundingBox),
            this.getBoundingSphereAt(c, di.geometry.boundingSphere),
            di.raycast(e, Dv);
            for (let u = 0, f = Dv.length; u < f; u++) {
                const h = Dv[u];
                h.object = this,
                h.batchId = a,
                t.push(h)
            }
            Dv.length = 0
        }
        di.material = null,
        di.geometry.index = null,
        di.geometry.attributes = {},
        di.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._drawRanges = e._drawRanges.map(t => ({
            ...t
        })),
        this._reservedRanges = e._reservedRanges.map(t => ({
            ...t
        })),
        this._drawInfo = e._drawInfo.map(t => ({
            ...t
        })),
        this._bounds = e._bounds.map(t => ({
            boxInitialized: t.boxInitialized,
            box: t.box.clone(),
            sphereInitialized: t.sphereInitialized,
            sphere: t.sphere.clone()
        })),
        this._maxInstanceCount = e._maxInstanceCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._geometryCount = e._geometryCount,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
        this
    }
    dispose() {
        return this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this._indirectTexture.dispose(),
        this._indirectTexture = null,
        this._colorsTexture !== null && (this._colorsTexture.dispose(),
        this._colorsTexture = null),
        this
    }
    onBeforeRender(e, t, r, i, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const o = i.getIndex()
          , a = o === null ? 1 : o.array.BYTES_PER_ELEMENT
          , l = this._drawInfo
          , c = this._multiDrawStarts
          , A = this._multiDrawCounts
          , u = this._drawRanges
          , f = this.perObjectFrustumCulled
          , h = this._indirectTexture
          , d = h.image.data;
        f && (rD.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(this.matrixWorld),
        XE.setFromProjectionMatrix(rD, e.coordinateSystem));
        let m = 0;
        if (this.sortObjects) {
            KE.copy(this.matrixWorld).invert(),
            Dp.setFromMatrixPosition(r.matrixWorld).applyMatrix4(KE),
            iD.set(0, 0, -1).transformDirection(r.matrixWorld).transformDirection(KE);
            for (let v = 0, w = l.length; v < w; v++)
                if (l[v].visible && l[v].active) {
                    const _ = l[v].geometryIndex;
                    this.getMatrixAt(v, Bc),
                    this.getBoundingSphereAt(_, VA).applyMatrix4(Bc);
                    let x = !1;
                    if (f && (x = !XE.intersectsSphere(VA)),
                    !x) {
                        const b = xse.subVectors(VA.center, Dp).dot(iD);
                        YE.push(u[_], b, v)
                    }
                }
            const g = YE.list
              , p = this.customSort;
            p === null ? g.sort(s.transparent ? vse : gse) : p.call(this, g, r);
            for (let v = 0, w = g.length; v < w; v++) {
                const _ = g[v];
                c[m] = _.start * a,
                A[m] = _.count,
                d[m] = _.index,
                m++
            }
            YE.reset()
        } else
            for (let g = 0, p = l.length; g < p; g++)
                if (l[g].visible && l[g].active) {
                    const v = l[g].geometryIndex;
                    let w = !1;
                    if (f && (this.getMatrixAt(g, Bc),
                    this.getBoundingSphereAt(v, VA).applyMatrix4(Bc),
                    w = !XE.intersectsSphere(VA)),
                    !w) {
                        const _ = u[v];
                        c[m] = _.start * a,
                        A[m] = _.count,
                        d[m] = g,
                        m++
                    }
                }
        h.needsUpdate = !0,
        this._multiDrawCount = m,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, r, i, s, o) {
        this.onBeforeRender(e, null, i, s, o)
    }
}
class Ac extends as {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Qe(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Q_ = new $
  , H_ = new $
  , sD = new He
  , Np = new $u
  , Nv = new Mi
  , $E = new $
  , oD = new $;
class Yd extends Lt {
    constructor(e=new Jt, t=new Ac) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [0];
            for (let i = 1, s = t.count; i < s; i++)
                Q_.fromBufferAttribute(t, i - 1),
                H_.fromBufferAttribute(t, i),
                r[i] = r[i - 1],
                r[i] += Q_.distanceTo(H_);
            e.setAttribute("lineDistance", new xn(r,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.matrixWorld
          , s = e.params.Line.threshold
          , o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        Nv.copy(r.boundingSphere),
        Nv.applyMatrix4(i),
        Nv.radius += s,
        e.ray.intersectsSphere(Nv) === !1)
            return;
        sD.copy(i).invert(),
        Np.copy(e.ray).applyMatrix4(sD);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = this.isLineSegments ? 2 : 1
          , A = r.index
          , f = r.attributes.position;
        if (A !== null) {
            const h = Math.max(0, o.start)
              , d = Math.min(A.count, o.start + o.count);
            for (let m = h, g = d - 1; m < g; m += c) {
                const p = A.getX(m)
                  , v = A.getX(m + 1)
                  , w = Ov(this, e, Np, l, p, v);
                w && t.push(w)
            }
            if (this.isLineLoop) {
                const m = A.getX(d - 1)
                  , g = A.getX(h)
                  , p = Ov(this, e, Np, l, m, g);
                p && t.push(p)
            }
        } else {
            const h = Math.max(0, o.start)
              , d = Math.min(f.count, o.start + o.count);
            for (let m = h, g = d - 1; m < g; m += c) {
                const p = Ov(this, e, Np, l, m, m + 1);
                p && t.push(p)
            }
            if (this.isLineLoop) {
                const m = Ov(this, e, Np, l, d - 1, h);
                m && t.push(m)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function Ov(n, e, t, r, i, s) {
    const o = n.geometry.attributes.position;
    if (Q_.fromBufferAttribute(o, i),
    H_.fromBufferAttribute(o, s),
    t.distanceSqToSegment(Q_, H_, $E, oD) > r)
        return;
    $E.applyMatrix4(n.matrixWorld);
    const l = e.ray.origin.distanceTo($E);
    if (!(l < e.near || l > e.far))
        return {
            distance: l,
            point: oD.clone().applyMatrix4(n.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: n
        }
}
const aD = new $
  , lD = new $;
class w0 extends Yd {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , r = [];
            for (let i = 0, s = t.count; i < s; i += 2)
                aD.fromBufferAttribute(t, i),
                lD.fromBufferAttribute(t, i + 1),
                r[i] = i === 0 ? 0 : r[i - 1],
                r[i + 1] = r[i] + aD.distanceTo(lD);
            e.setAttribute("lineDistance", new xn(r,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class Bse extends Yd {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Pz extends as {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Qe(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const cD = new He
  , PC = new $u
  , kv = new Mi
  , Qv = new $;
class Mse extends Lt {
    constructor(e=new Jt, t=new Pz) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const r = this.geometry
          , i = this.matrixWorld
          , s = e.params.Points.threshold
          , o = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        kv.copy(r.boundingSphere),
        kv.applyMatrix4(i),
        kv.radius += s,
        e.ray.intersectsSphere(kv) === !1)
            return;
        cD.copy(i).invert(),
        PC.copy(e.ray).applyMatrix4(cD);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = r.index
          , u = r.attributes.position;
        if (c !== null) {
            const f = Math.max(0, o.start)
              , h = Math.min(c.count, o.start + o.count);
            for (let d = f, m = h; d < m; d++) {
                const g = c.getX(d);
                Qv.fromBufferAttribute(u, g),
                AD(Qv, g, l, i, e, t, this)
            }
        } else {
            const f = Math.max(0, o.start)
              , h = Math.min(u.count, o.start + o.count);
            for (let d = f, m = h; d < m; d++)
                Qv.fromBufferAttribute(u, d),
                AD(Qv, d, l, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const i = t[r[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function AD(n, e, t, r, i, s, o) {
    const a = PC.distanceSqToPoint(n);
    if (a < t) {
        const l = new $;
        PC.closestPointToPoint(n, l),
        l.applyMatrix4(r);
        const c = i.ray.origin.distanceTo(l);
        if (c < i.near || c > i.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: o
        })
    }
}
class ZE extends Un {
    constructor(e, t, r, i, s, o, a, l, c, A, u, f) {
        super(null, o, a, l, c, A, i, s, u, f),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: r
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class Sse extends Un {
    constructor(e, t, r, i, s, o, a, l, c) {
        super(e, t, r, i, s, o, a, l, c),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class Cse {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getPoint(r, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPoint(r / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let r = 0; r <= e; r++)
            t.push(this.getPointAt(r / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let r, i = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            r = this.getPoint(o / e),
            s += r.distanceTo(i),
            t.push(s),
            i = r;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const r = this.getLengths();
        let i = 0;
        const s = r.length;
        let o;
        t ? o = t : o = e * r[s - 1];
        let a = 0, l = s - 1, c;
        for (; a <= l; )
            if (i = Math.floor(a + (l - a) / 2),
            c = r[i] - o,
            c < 0)
                a = i + 1;
            else if (c > 0)
                l = i - 1;
            else {
                l = i;
                break
            }
        if (i = l,
        r[i] === o)
            return i / (s - 1);
        const A = r[i]
          , f = r[i + 1] - A
          , h = (o - A) / f;
        return (i + h) / (s - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4
          , s = e + 1e-4;
        i < 0 && (i = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(i)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new We : new $);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const r = this.getUtoTmapping(e);
        return this.getTangent(r, t)
    }
    computeFrenetFrames(e, t) {
        const r = new $
          , i = []
          , s = []
          , o = []
          , a = new $
          , l = new He;
        for (let h = 0; h <= e; h++) {
            const d = h / e;
            i[h] = this.getTangentAt(d, new $)
        }
        s[0] = new $,
        o[0] = new $;
        let c = Number.MAX_VALUE;
        const A = Math.abs(i[0].x)
          , u = Math.abs(i[0].y)
          , f = Math.abs(i[0].z);
        A <= c && (c = A,
        r.set(1, 0, 0)),
        u <= c && (c = u,
        r.set(0, 1, 0)),
        f <= c && r.set(0, 0, 1),
        a.crossVectors(i[0], r).normalize(),
        s[0].crossVectors(i[0], a),
        o[0].crossVectors(i[0], s[0]);
        for (let h = 1; h <= e; h++) {
            if (s[h] = s[h - 1].clone(),
            o[h] = o[h - 1].clone(),
            a.crossVectors(i[h - 1], i[h]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const d = Math.acos(pr(i[h - 1].dot(i[h]), -1, 1));
                s[h].applyMatrix4(l.makeRotationAxis(a, d))
            }
            o[h].crossVectors(i[h], s[h])
        }
        if (t === !0) {
            let h = Math.acos(pr(s[0].dot(s[e]), -1, 1));
            h /= e,
            i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (h = -h);
            for (let d = 1; d <= e; d++)
                s[d].applyMatrix4(l.makeRotationAxis(i[d], h * d)),
                o[d].crossVectors(i[d], s[d])
        }
        return {
            tangents: i,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class m1 extends Jt {
    constructor(e=1, t=1, r=1, i=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: r,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        i = Math.floor(i),
        s = Math.floor(s);
        const A = []
          , u = []
          , f = []
          , h = [];
        let d = 0;
        const m = []
          , g = r / 2;
        let p = 0;
        v(),
        o === !1 && (e > 0 && w(!0),
        t > 0 && w(!1)),
        this.setIndex(A),
        this.setAttribute("position", new xn(u,3)),
        this.setAttribute("normal", new xn(f,3)),
        this.setAttribute("uv", new xn(h,2));
        function v() {
            const _ = new $
              , x = new $;
            let b = 0;
            const B = (t - e) / r;
            for (let S = 0; S <= s; S++) {
                const I = []
                  , M = S / s
                  , L = M * (t - e) + e;
                for (let D = 0; D <= i; D++) {
                    const T = D / i
                      , y = T * l + a
                      , E = Math.sin(y)
                      , R = Math.cos(y);
                    x.x = L * E,
                    x.y = -M * r + g,
                    x.z = L * R,
                    u.push(x.x, x.y, x.z),
                    _.set(E, B, R).normalize(),
                    f.push(_.x, _.y, _.z),
                    h.push(T, 1 - M),
                    I.push(d++)
                }
                m.push(I)
            }
            for (let S = 0; S < i; S++)
                for (let I = 0; I < s; I++) {
                    const M = m[I][S]
                      , L = m[I + 1][S]
                      , D = m[I + 1][S + 1]
                      , T = m[I][S + 1];
                    e > 0 && (A.push(M, L, T),
                    b += 3),
                    t > 0 && (A.push(L, D, T),
                    b += 3)
                }
            c.addGroup(p, b, 0),
            p += b
        }
        function w(_) {
            const x = d
              , b = new We
              , B = new $;
            let S = 0;
            const I = _ === !0 ? e : t
              , M = _ === !0 ? 1 : -1;
            for (let D = 1; D <= i; D++)
                u.push(0, g * M, 0),
                f.push(0, M, 0),
                h.push(.5, .5),
                d++;
            const L = d;
            for (let D = 0; D <= i; D++) {
                const y = D / i * l + a
                  , E = Math.cos(y)
                  , R = Math.sin(y);
                B.x = I * R,
                B.y = g * M,
                B.z = I * E,
                u.push(B.x, B.y, B.z),
                f.push(0, M, 0),
                b.x = E * .5 + .5,
                b.y = R * .5 * M + .5,
                h.push(b.x, b.y),
                d++
            }
            for (let D = 0; D < i; D++) {
                const T = x + D
                  , y = L + D;
                _ === !0 ? A.push(y, y + 1, T) : A.push(y + 1, y, T),
                S += 3
            }
            c.addGroup(p, S, _ === !0 ? 1 : 2),
            p += S
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new m1(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
const Tse = {
    triangulate: function(n, e, t=2) {
        const r = e && e.length
          , i = r ? e[0] * t : n.length;
        let s = Lz(n, 0, i, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, c, A, u, f, h;
        if (r && (s = Pse(n, e, s, t)),
        n.length > 80 * t) {
            a = c = n[0],
            l = A = n[1];
            for (let d = t; d < i; d += t)
                u = n[d],
                f = n[d + 1],
                u < a && (a = u),
                f < l && (l = f),
                u > c && (c = u),
                f > A && (A = f);
            h = Math.max(c - a, A - l),
            h = h !== 0 ? 32767 / h : 0
        }
        return jg(s, o, t, a, l, h, 0),
        o
    }
};
function Lz(n, e, t, r, i) {
    let s, o;
    if (i === jse(n, e, t, r) > 0)
        for (s = e; s < t; s += r)
            o = uD(s, n[s], n[s + 1], o);
    else
        for (s = t - r; s >= e; s -= r)
            o = uD(s, n[s], n[s + 1], o);
    return o && g1(o, o.next) && (Kg(o),
    o = o.next),
    o
}
function Nu(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, r;
    do
        if (r = !1,
        !t.steiner && (g1(t, t.next) || Kn(t.prev, t, t.next) === 0)) {
            if (Kg(t),
            t = e = t.prev,
            t === t.next)
                break;
            r = !0
        } else
            t = t.next;
    while (r || t !== e);
    return e
}
function jg(n, e, t, r, i, s, o) {
    if (!n)
        return;
    !o && s && kse(n, r, i, s);
    let a = n, l, c;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        c = n.next,
        s ? Rse(n, r, i, s) : Ise(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(c.i / t | 0),
            Kg(n),
            n = c.next,
            a = c.next;
            continue
        }
        if (n = c,
        n === a) {
            o ? o === 1 ? (n = Use(Nu(n), e, t),
            jg(n, e, t, r, i, s, 2)) : o === 2 && Fse(n, e, t, r, i, s) : jg(Nu(n), e, t, r, i, s, 1);
            break
        }
    }
}
function Ise(n) {
    const e = n.prev
      , t = n
      , r = n.next;
    if (Kn(e, t, r) >= 0)
        return !1;
    const i = e.x
      , s = t.x
      , o = r.x
      , a = e.y
      , l = t.y
      , c = r.y
      , A = i < s ? i < o ? i : o : s < o ? s : o
      , u = a < l ? a < c ? a : c : l < c ? l : c
      , f = i > s ? i > o ? i : o : s > o ? s : o
      , h = a > l ? a > c ? a : c : l > c ? l : c;
    let d = r.next;
    for (; d !== e; ) {
        if (d.x >= A && d.x <= f && d.y >= u && d.y <= h && Qh(i, a, s, l, o, c, d.x, d.y) && Kn(d.prev, d, d.next) >= 0)
            return !1;
        d = d.next
    }
    return !0
}
function Rse(n, e, t, r) {
    const i = n.prev
      , s = n
      , o = n.next;
    if (Kn(i, s, o) >= 0)
        return !1;
    const a = i.x
      , l = s.x
      , c = o.x
      , A = i.y
      , u = s.y
      , f = o.y
      , h = a < l ? a < c ? a : c : l < c ? l : c
      , d = A < u ? A < f ? A : f : u < f ? u : f
      , m = a > l ? a > c ? a : c : l > c ? l : c
      , g = A > u ? A > f ? A : f : u > f ? u : f
      , p = LC(h, d, e, t, r)
      , v = LC(m, g, e, t, r);
    let w = n.prevZ
      , _ = n.nextZ;
    for (; w && w.z >= p && _ && _.z <= v; ) {
        if (w.x >= h && w.x <= m && w.y >= d && w.y <= g && w !== i && w !== o && Qh(a, A, l, u, c, f, w.x, w.y) && Kn(w.prev, w, w.next) >= 0 || (w = w.prevZ,
        _.x >= h && _.x <= m && _.y >= d && _.y <= g && _ !== i && _ !== o && Qh(a, A, l, u, c, f, _.x, _.y) && Kn(_.prev, _, _.next) >= 0))
            return !1;
        _ = _.nextZ
    }
    for (; w && w.z >= p; ) {
        if (w.x >= h && w.x <= m && w.y >= d && w.y <= g && w !== i && w !== o && Qh(a, A, l, u, c, f, w.x, w.y) && Kn(w.prev, w, w.next) >= 0)
            return !1;
        w = w.prevZ
    }
    for (; _ && _.z <= v; ) {
        if (_.x >= h && _.x <= m && _.y >= d && _.y <= g && _ !== i && _ !== o && Qh(a, A, l, u, c, f, _.x, _.y) && Kn(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.nextZ
    }
    return !0
}
function Use(n, e, t) {
    let r = n;
    do {
        const i = r.prev
          , s = r.next.next;
        !g1(i, s) && Dz(i, r, r.next, s) && Wg(i, s) && Wg(s, i) && (e.push(i.i / t | 0),
        e.push(r.i / t | 0),
        e.push(s.i / t | 0),
        Kg(r),
        Kg(r.next),
        r = n = s),
        r = r.next
    } while (r !== n);
    return Nu(r)
}
function Fse(n, e, t, r, i, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && zse(o, a)) {
                let l = Nz(o, a);
                o = Nu(o, o.next),
                l = Nu(l, l.next),
                jg(o, e, t, r, i, s, 0),
                jg(l, e, t, r, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function Pse(n, e, t, r) {
    const i = [];
    let s, o, a, l, c;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * r,
        l = s < o - 1 ? e[s + 1] * r : n.length,
        c = Lz(n, a, l, r, !1),
        c === c.next && (c.steiner = !0),
        i.push(Hse(c));
    for (i.sort(Lse),
    s = 0; s < i.length; s++)
        t = Dse(i[s], t);
    return t
}
function Lse(n, e) {
    return n.x - e.x
}
function Dse(n, e) {
    const t = Nse(n, e);
    if (!t)
        return e;
    const r = Nz(t, n);
    return Nu(r, r.next),
    Nu(t, t.next)
}
function Nse(n, e) {
    let t = e, r = -1 / 0, i;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (f <= s && f > r && (r = f,
            i = t.x < t.next.x ? t : t.next,
            f === s))
                return i
        }
        t = t.next
    } while (t !== e);
    if (!i)
        return null;
    const a = i
      , l = i.x
      , c = i.y;
    let A = 1 / 0, u;
    t = i;
    do
        s >= t.x && t.x >= l && s !== t.x && Qh(o < c ? s : r, o, l, c, o < c ? r : s, o, t.x, t.y) && (u = Math.abs(o - t.y) / (s - t.x),
        Wg(t, n) && (u < A || u === A && (t.x > i.x || t.x === i.x && Ose(i, t))) && (i = t,
        A = u)),
        t = t.next;
    while (t !== a);
    return i
}
function Ose(n, e) {
    return Kn(n.prev, n, e.prev) < 0 && Kn(e.next, n, n.next) < 0
}
function kse(n, e, t, r) {
    let i = n;
    do
        i.z === 0 && (i.z = LC(i.x, i.y, e, t, r)),
        i.prevZ = i.prev,
        i.nextZ = i.next,
        i = i.next;
    while (i !== n);
    i.prevZ.nextZ = null,
    i.prevZ = null,
    Qse(i)
}
function Qse(n) {
    let e, t, r, i, s, o, a, l, c = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            r = t,
            a = 0,
            e = 0; e < c && (a++,
            r = r.nextZ,
            !!r); e++)
                ;
            for (l = c; a > 0 || l > 0 && r; )
                a !== 0 && (l === 0 || !r || t.z <= r.z) ? (i = t,
                t = t.nextZ,
                a--) : (i = r,
                r = r.nextZ,
                l--),
                s ? s.nextZ = i : n = i,
                i.prevZ = s,
                s = i;
            t = r
        }
        s.nextZ = null,
        c *= 2
    } while (o > 1);
    return n
}
function LC(n, e, t, r, i) {
    return n = (n - t) * i | 0,
    e = (e - r) * i | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function Hse(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function Qh(n, e, t, r, i, s, o, a) {
    return (i - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (r - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (r - a)
}
function zse(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !Gse(n, e) && (Wg(n, e) && Wg(e, n) && Vse(n, e) && (Kn(n.prev, n, e.prev) || Kn(n, e.prev, e)) || g1(n, e) && Kn(n.prev, n, n.next) > 0 && Kn(e.prev, e, e.next) > 0)
}
function Kn(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function g1(n, e) {
    return n.x === e.x && n.y === e.y
}
function Dz(n, e, t, r) {
    const i = zv(Kn(n, e, t))
      , s = zv(Kn(n, e, r))
      , o = zv(Kn(t, r, n))
      , a = zv(Kn(t, r, e));
    return !!(i !== s && o !== a || i === 0 && Hv(n, t, e) || s === 0 && Hv(n, r, e) || o === 0 && Hv(t, n, r) || a === 0 && Hv(t, e, r))
}
function Hv(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function zv(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function Gse(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && Dz(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function Wg(n, e) {
    return Kn(n.prev, n, n.next) < 0 ? Kn(n, e, n.next) >= 0 && Kn(n, n.prev, e) >= 0 : Kn(n, e, n.prev) < 0 || Kn(n, n.next, e) < 0
}
function Vse(n, e) {
    let t = n
      , r = !1;
    const i = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r),
        t = t.next;
    while (t !== n);
    return r
}
function Nz(n, e) {
    const t = new DC(n.i,n.x,n.y)
      , r = new DC(e.i,e.x,e.y)
      , i = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = i,
    i.prev = t,
    r.next = t,
    t.prev = r,
    s.next = r,
    r.prev = s,
    r
}
function uD(n, e, t, r) {
    const i = new DC(n,e,t);
    return r ? (i.next = r.next,
    i.prev = r,
    r.next.prev = i,
    r.next = i) : (i.prev = i,
    i.next = i),
    i
}
function Kg(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function DC(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function jse(n, e, t, r) {
    let i = 0;
    for (let s = e, o = t - r; s < t; s += r)
        i += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return i
}
class GR {
    static area(e) {
        const t = e.length;
        let r = 0;
        for (let i = t - 1, s = 0; s < t; i = s++)
            r += e[i].x * e[s].y - e[s].x * e[i].y;
        return r * .5
    }
    static isClockWise(e) {
        return GR.area(e) < 0
    }
    static triangulateShape(e, t) {
        const r = []
          , i = []
          , s = [];
        fD(e),
        hD(r, e);
        let o = e.length;
        t.forEach(fD);
        for (let l = 0; l < t.length; l++)
            i.push(o),
            o += t[l].length,
            hD(r, t[l]);
        const a = Tse.triangulate(r, i);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function fD(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function hD(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class VR extends Jt {
    constructor(e=1, t=32, r=16, i=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: r,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        r = Math.max(2, Math.floor(r));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const A = []
          , u = new $
          , f = new $
          , h = []
          , d = []
          , m = []
          , g = [];
        for (let p = 0; p <= r; p++) {
            const v = []
              , w = p / r;
            let _ = 0;
            p === 0 && o === 0 ? _ = .5 / t : p === r && l === Math.PI && (_ = -.5 / t);
            for (let x = 0; x <= t; x++) {
                const b = x / t;
                u.x = -e * Math.cos(i + b * s) * Math.sin(o + w * a),
                u.y = e * Math.cos(o + w * a),
                u.z = e * Math.sin(i + b * s) * Math.sin(o + w * a),
                d.push(u.x, u.y, u.z),
                f.copy(u).normalize(),
                m.push(f.x, f.y, f.z),
                g.push(b + _, 1 - w),
                v.push(c++)
            }
            A.push(v)
        }
        for (let p = 0; p < r; p++)
            for (let v = 0; v < t; v++) {
                const w = A[p][v + 1]
                  , _ = A[p][v]
                  , x = A[p + 1][v]
                  , b = A[p + 1][v + 1];
                (p !== 0 || o > 0) && h.push(w, _, b),
                (p !== r - 1 || l < Math.PI) && h.push(_, x, b)
            }
        this.setIndex(h),
        this.setAttribute("position", new xn(d,3)),
        this.setAttribute("normal", new xn(m,3)),
        this.setAttribute("uv", new xn(g,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new VR(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Od extends as {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Qe(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Qe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Kd,
        this.normalScale = new We(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new nr,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class ol extends Od {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new We(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return pr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Qe(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Qe(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Qe(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class JE extends as {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Qe(16777215),
        this.specular = new Qe(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Qe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Kd,
        this.normalScale = new We(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new nr,
        this.combine = l1,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Wse extends as {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Kd,
        this.normalScale = new We(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class Kse extends as {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Qe(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Qe(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Kd,
        this.normalScale = new We(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new nr,
        this.combine = l1,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
function Gv(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function Xse(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function Yse(n) {
    function e(i, s) {
        return n[i] - n[s]
    }
    const t = n.length
      , r = new Array(t);
    for (let i = 0; i !== t; ++i)
        r[i] = i;
    return r.sort(e),
    r
}
function dD(n, e, t) {
    const r = n.length
      , i = new n.constructor(r);
    for (let s = 0, o = 0; o !== r; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            i[o++] = n[a + l]
    }
    return i
}
function Oz(n, e, t, r) {
    let i = 1
      , s = n[0];
    for (; s !== void 0 && s[r] === void 0; )
        s = n[i++];
    if (s === void 0)
        return;
    let o = s[r];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[i++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[i++];
            while (s !== void 0);
        else
            do
                o = s[r],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[i++];
            while (s !== void 0)
}
class _0 {
    constructor(e, t, r, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(r),
        this.sampleValues = t,
        this.valueSize = r,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let r = this._cachedIndex
          , i = t[r]
          , s = t[r - 1];
        e: {
            t: {
                let o;
                n: {
                    r: if (!(e < i)) {
                        for (let a = r + 2; ; ) {
                            if (i === void 0) {
                                if (e < s)
                                    break r;
                                return r = t.length,
                                this._cachedIndex = r,
                                this.copySampleValue_(r - 1)
                            }
                            if (r === a)
                                break;
                            if (s = i,
                            i = t[++r],
                            e < i)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (r = 2,
                        s = a);
                        for (let l = r - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (r === l)
                                break;
                            if (i = s,
                            s = t[--r - 1],
                            e >= s)
                                break t
                        }
                        o = r,
                        r = 0;
                        break n
                    }
                    break e
                }
                for (; r < o; ) {
                    const a = r + o >>> 1;
                    e < t[a] ? o = a : r = a + 1
                }
                if (i = t[r],
                s = t[r - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return r = t.length,
                    this._cachedIndex = r,
                    this.copySampleValue_(r - 1)
            }
            this._cachedIndex = r,
            this.intervalChanged_(r, s, i)
        }
        return this.interpolate_(r, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , r = this.sampleValues
          , i = this.valueSize
          , s = e * i;
        for (let o = 0; o !== i; ++o)
            t[o] = r[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class $se extends _0 {
    constructor(e, t, r, i) {
        super(e, t, r, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Nh,
            endingEnd: Nh
        }
    }
    intervalChanged_(e, t, r) {
        const i = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = i[s]
          , l = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Oh:
                s = e,
                a = 2 * t - r;
                break;
            case P_:
                s = i.length - 2,
                a = t + i[s] - i[s + 1];
                break;
            default:
                s = e,
                a = r
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case Oh:
                o = e,
                l = 2 * r - t;
                break;
            case P_:
                o = 1,
                l = r + i[1] - i[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (r - t) * .5
          , A = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - r),
        this._offsetPrev = s * A,
        this._offsetNext = o * A
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , A = this._offsetPrev
          , u = this._offsetNext
          , f = this._weightPrev
          , h = this._weightNext
          , d = (r - t) / (i - t)
          , m = d * d
          , g = m * d
          , p = -f * g + 2 * f * m - f * d
          , v = (1 + f) * g + (-1.5 - 2 * f) * m + (-.5 + f) * d + 1
          , w = (-1 - h) * g + (1.5 + h) * m + .5 * d
          , _ = h * g - h * m;
        for (let x = 0; x !== a; ++x)
            s[x] = p * o[A + x] + v * o[c + x] + w * o[l + x] + _ * o[u + x];
        return s
    }
}
class kz extends _0 {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , A = (r - t) / (i - t)
          , u = 1 - A;
        for (let f = 0; f !== a; ++f)
            s[f] = o[c + f] * u + o[l + f] * A;
        return s
    }
}
class Zse extends _0 {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class al {
    constructor(e, t, r, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Gv(t, this.TimeBufferType),
        this.values = Gv(r, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let r;
        if (t.toJSON !== this.toJSON)
            r = t.toJSON(e);
        else {
            r = {
                name: e.name,
                times: Gv(e.times, Array),
                values: Gv(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (r.interpolation = i)
        }
        return r.type = e.ValueTypeName,
        r
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Zse(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new kz(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new $se(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Pd:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Ld:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case mE:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(r);
            return console.warn("THREE.KeyframeTrack:", r),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Pd;
        case this.InterpolantFactoryMethodLinear:
            return Ld;
        case this.InterpolantFactoryMethodSmooth:
            return mE
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let r = 0, i = t.length; r !== i; ++r)
                t[r] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let r = 0, i = t.length; r !== i; ++r)
                t[r] *= e
        }
        return this
    }
    trim(e, t) {
        const r = this.times
          , i = r.length;
        let s = 0
          , o = i - 1;
        for (; s !== i && r[s] < e; )
            ++s;
        for (; o !== -1 && r[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = r.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const r = this.times
          , i = this.values
          , s = r.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = r[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && Xse(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const c = i[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , r = this.getValueSize()
          , i = this.getInterpolation() === mE
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a]
              , A = e[a + 1];
            if (c !== A && (a !== 1 || c !== e[0]))
                if (i)
                    l = !0;
                else {
                    const u = a * r
                      , f = u - r
                      , h = u + r;
                    for (let d = 0; d !== r; ++d) {
                        const m = t[u + d];
                        if (m !== t[f + d] || m !== t[h + d]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const u = a * r
                      , f = o * r;
                    for (let h = 0; h !== r; ++h)
                        t[f + h] = t[u + h]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * r, l = o * r, c = 0; c !== r; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * r)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , r = this.constructor
          , i = new r(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
al.prototype.TimeBufferType = Float32Array;
al.prototype.ValueBufferType = Float32Array;
al.prototype.DefaultInterpolation = Ld;
class $d extends al {
    constructor(e, t, r) {
        super(e, t, r)
    }
}
$d.prototype.ValueTypeName = "bool";
$d.prototype.ValueBufferType = Array;
$d.prototype.DefaultInterpolation = Pd;
$d.prototype.InterpolantFactoryMethodLinear = void 0;
$d.prototype.InterpolantFactoryMethodSmooth = void 0;
class Qz extends al {
}
Qz.prototype.ValueTypeName = "color";
class Ou extends al {
}
Ou.prototype.ValueTypeName = "number";
class Jse extends _0 {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (r - t) / (i - t);
        let c = e * a;
        for (let A = c + a; c !== A; c += 4)
            nt.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class nl extends al {
    InterpolantFactoryMethodLinear(e) {
        return new Jse(this.times,this.values,this.getValueSize(),e)
    }
}
nl.prototype.ValueTypeName = "quaternion";
nl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Zd extends al {
    constructor(e, t, r) {
        super(e, t, r)
    }
}
Zd.prototype.ValueTypeName = "string";
Zd.prototype.ValueBufferType = Array;
Zd.prototype.DefaultInterpolation = Pd;
Zd.prototype.InterpolantFactoryMethodLinear = void 0;
Zd.prototype.InterpolantFactoryMethodSmooth = void 0;
class ic extends al {
}
ic.prototype.ValueTypeName = "vector";
class ku {
    constructor(e="", t=-1, r=[], i=PR) {
        this.name = e,
        this.tracks = r,
        this.duration = t,
        this.blendMode = i,
        this.uuid = ia(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , r = e.tracks
          , i = 1 / (e.fps || 1);
        for (let o = 0, a = r.length; o !== a; ++o)
            t.push(eoe(r[o]).scale(i));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , r = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = r.length; s !== o; ++s)
            t.push(al.toJSON(r[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, r, i) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            c.push(0, 1, 0);
            const A = Yse(l);
            l = dD(l, 1, A),
            c = dD(c, 1, A),
            !i && l[0] === 0 && (l.push(s),
            c.push(c[0])),
            o.push(new Ou(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / r))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let r = e;
        if (!Array.isArray(e)) {
            const i = e;
            r = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < r.length; i++)
            if (r[i].name === t)
                return r[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, r) {
        const i = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , A = c.name.match(s);
            if (A && A.length > 1) {
                const u = A[1];
                let f = i[u];
                f || (i[u] = f = []),
                f.push(c)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const r = function(u, f, h, d, m) {
            if (h.length !== 0) {
                const g = []
                  , p = [];
                Oz(h, g, p, d),
                g.length !== 0 && m.push(new u(f,g,p))
            }
        }
          , i = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
            const f = c[u].keys;
            if (!(!f || f.length === 0))
                if (f[0].morphTargets) {
                    const h = {};
                    let d;
                    for (d = 0; d < f.length; d++)
                        if (f[d].morphTargets)
                            for (let m = 0; m < f[d].morphTargets.length; m++)
                                h[f[d].morphTargets[m]] = -1;
                    for (const m in h) {
                        const g = []
                          , p = [];
                        for (let v = 0; v !== f[d].morphTargets.length; ++v) {
                            const w = f[d];
                            g.push(w.time),
                            p.push(w.morphTarget === m ? 1 : 0)
                        }
                        i.push(new Ou(".morphTargetInfluence[" + m + "]",g,p))
                    }
                    l = h.length * o
                } else {
                    const h = ".bones[" + t[u].name + "]";
                    r(ic, h + ".position", f, "pos", i),
                    r(nl, h + ".quaternion", f, "rot", i),
                    r(ic, h + ".scale", f, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s,l,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let r = 0, i = e.length; r !== i; ++r) {
            const s = this.tracks[r];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function qse(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Ou;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return ic;
    case "color":
        return Qz;
    case "quaternion":
        return nl;
    case "bool":
    case "boolean":
        return $d;
    case "string":
        return Zd
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function eoe(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = qse(n.type);
    if (n.times === void 0) {
        const t = []
          , r = [];
        Oz(n.keys, t, r, "value"),
        n.times = t,
        n.values = r
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const $c = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class Hz {
    constructor(e, t, r) {
        const i = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(A) {
            a++,
            s === !1 && i.onStart !== void 0 && i.onStart(A, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(A) {
            o++,
            i.onProgress !== void 0 && i.onProgress(A, o, a),
            o === a && (s = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(A) {
            i.onError !== void 0 && i.onError(A)
        }
        ,
        this.resolveURL = function(A) {
            return l ? l(A) : A
        }
        ,
        this.setURLModifier = function(A) {
            return l = A,
            this
        }
        ,
        this.addHandler = function(A, u) {
            return c.push(A, u),
            this
        }
        ,
        this.removeHandler = function(A) {
            const u = c.indexOf(A);
            return u !== -1 && c.splice(u, 2),
            this
        }
        ,
        this.getHandler = function(A) {
            for (let u = 0, f = c.length; u < f; u += 2) {
                const h = c[u]
                  , d = c[u + 1];
                if (h.global && (h.lastIndex = 0),
                h.test(A))
                    return d
            }
            return null
        }
    }
}
const toe = new Hz;
class rl {
    constructor(e) {
        this.manager = e !== void 0 ? e : toe,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const r = this;
        return new Promise(function(i, s) {
            r.load(e, i, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
rl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const gl = {};
class noe extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class v1 extends rl {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = $c.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (gl[e] !== void 0) {
            gl[e].push({
                onLoad: t,
                onProgress: r,
                onError: i
            });
            return
        }
        gl[e] = [],
        gl[e].push({
            onLoad: t,
            onProgress: r,
            onError: i
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const A = gl[e]
                  , u = c.body.getReader()
                  , f = c.headers.get("X-File-Size") || c.headers.get("Content-Length")
                  , h = f ? parseInt(f) : 0
                  , d = h !== 0;
                let m = 0;
                const g = new ReadableStream({
                    start(p) {
                        v();
                        function v() {
                            u.read().then( ({done: w, value: _}) => {
                                if (w)
                                    p.close();
                                else {
                                    m += _.byteLength;
                                    const x = new ProgressEvent("progress",{
                                        lengthComputable: d,
                                        loaded: m,
                                        total: h
                                    });
                                    for (let b = 0, B = A.length; b < B; b++) {
                                        const S = A[b];
                                        S.onProgress && S.onProgress(x)
                                    }
                                    p.enqueue(_),
                                    v()
                                }
                            }
                            , w => {
                                p.error(w)
                            }
                            )
                        }
                    }
                });
                return new Response(g)
            } else
                throw new noe(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(A => new DOMParser().parseFromString(A, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const u = /charset="?([^;"\s]*)"?/i.exec(a)
                      , f = u && u[1] ? u[1].toLowerCase() : void 0
                      , h = new TextDecoder(f);
                    return c.arrayBuffer().then(d => h.decode(d))
                }
            }
        }
        ).then(c => {
            $c.add(e, c);
            const A = gl[e];
            delete gl[e];
            for (let u = 0, f = A.length; u < f; u++) {
                const h = A[u];
                h.onLoad && h.onLoad(c)
            }
        }
        ).catch(c => {
            const A = gl[e];
            if (A === void 0)
                throw this.manager.itemError(e),
                c;
            delete gl[e];
            for (let u = 0, f = A.length; u < f; u++) {
                const h = A[u];
                h.onError && h.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class zz extends rl {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = $c.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = zg("img");
        function l() {
            A(),
            $c.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(u) {
            A(),
            i && i(u),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function A() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class roe extends rl {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = new Eu
          , a = new v1(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            let c;
            try {
                c = s.parse(l)
            } catch (A) {
                if (i !== void 0)
                    i(A);
                else {
                    console.error(A);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : Rs,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : Rs,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : Lr,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : Lr,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = ea),
            c.mipmapCount === 1 && (o.minFilter = Lr),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c)
        }, r, i),
        o
    }
}
class PA extends rl {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = new Un
          , o = new zz(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, r, i),
        s
    }
}
class y1 extends Lt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Qe(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
const qE = new He
  , pD = new $
  , mD = new $;
class jR {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new We(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new He,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new h1,
        this._frameExtents = new We(1,1),
        this._viewportCount = 1,
        this._viewports = [new Pt(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , r = this.matrix;
        pD.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(pD),
        mD.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(mD),
        t.updateMatrixWorld(),
        qE.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(qE),
        r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        r.multiply(qE)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class ioe extends jR {
    constructor() {
        super(new Fr(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , r = Dd * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (r !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = r,
        t.aspect = i,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class Gz extends y1 {
    constructor(e, t, r=0, i=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(Lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Lt,
        this.distance = r,
        this.angle = i,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new ioe
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const gD = new He
  , Op = new $
  , eB = new $;
class soe extends jR {
    constructor() {
        super(new Fr(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new We(4,2),
        this._viewportCount = 6,
        this._viewports = [new Pt(2,1,1,1), new Pt(0,1,1,1), new Pt(3,1,1,1), new Pt(1,1,1,1), new Pt(3,0,1,1), new Pt(1,0,1,1)],
        this._cubeDirections = [new $(1,0,0), new $(-1,0,0), new $(0,0,1), new $(0,0,-1), new $(0,1,0), new $(0,-1,0)],
        this._cubeUps = [new $(0,1,0), new $(0,1,0), new $(0,1,0), new $(0,1,0), new $(0,0,1), new $(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const r = this.camera
          , i = this.matrix
          , s = e.distance || r.far;
        s !== r.far && (r.far = s,
        r.updateProjectionMatrix()),
        Op.setFromMatrixPosition(e.matrixWorld),
        r.position.copy(Op),
        eB.copy(r.position),
        eB.add(this._cubeDirections[t]),
        r.up.copy(this._cubeUps[t]),
        r.lookAt(eB),
        r.updateMatrixWorld(),
        i.makeTranslation(-Op.x, -Op.y, -Op.z),
        gD.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(gD)
    }
}
class NC extends y1 {
    constructor(e, t, r=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = r,
        this.decay = i,
        this.shadow = new soe
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class ooe extends jR {
    constructor() {
        super(new v0(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class WR extends y1 {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(Lt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Lt,
        this.shadow = new ooe
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class Vz extends y1 {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class ad {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
        typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let r = 0, i = e.length; r < i; r++)
            t += String.fromCharCode(e[r]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class aoe extends rl {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, r, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = $c.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e),
            o.then) {
                o.then(c => {
                    t && t(c),
                    s.manager.itemEnd(e)
                }
                ).catch(c => {
                    i && i(c)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const l = fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return $c.add(e, c),
            t && t(c),
            s.manager.itemEnd(e),
            c
        }).catch(function(c) {
            i && i(c),
            $c.remove(e),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        });
        $c.add(e, l),
        s.manager.itemStart(e)
    }
}
class w1 {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = vD(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = vD();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function vD() {
    return performance.now()
}
class loe {
    constructor(e, t, r) {
        this.binding = e,
        this.valueSize = r;
        let i, s, o;
        switch (t) {
        case "quaternion":
            i = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(r * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(r * 5);
            break;
        default:
            i = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(r * 5)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const r = this.buffer
          , i = this.valueSize
          , s = e * i + i;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== i; ++a)
                r[s + a] = r[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(r, s, 0, a, i)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , r = this.valueSize
          , i = r * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, r),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , r = this.buffer
          , i = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(r, i, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (r[l] !== r[l + t]) {
                a.setValue(r, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , r = this.valueSize
          , i = r * this._origIndex;
        e.getValue(t, i);
        for (let s = r, o = i; s !== o; ++s)
            t[s] = t[i + s % r];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let r = e; r < t; r++)
            this.buffer[r] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let r = 0; r < this.valueSize; r++)
            this.buffer[t + r] = this.buffer[e + r]
    }
    _select(e, t, r, i, s) {
        if (i >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[r + o]
    }
    _slerp(e, t, r, i) {
        nt.slerpFlat(e, t, e, t, e, r, i)
    }
    _slerpAdditive(e, t, r, i, s) {
        const o = this._workIndex * s;
        nt.multiplyQuaternionsFlat(e, o, e, t, e, r),
        nt.slerpFlat(e, t, e, t, e, o, i)
    }
    _lerp(e, t, r, i, s) {
        const o = 1 - i;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[r + a] * i
        }
    }
    _lerpAdditive(e, t, r, i, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[r + o] * i
        }
    }
}
const KR = "\\[\\]\\.:\\/"
  , coe = new RegExp("[" + KR + "]","g")
  , XR = "[^" + KR + "]"
  , Aoe = "[^" + KR.replace("\\.", "") + "]"
  , uoe = /((?:WC+[\/:])*)/.source.replace("WC", XR)
  , foe = /(WCOD+)?/.source.replace("WCOD", Aoe)
  , hoe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", XR)
  , doe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", XR)
  , poe = new RegExp("^" + uoe + foe + hoe + doe + "$")
  , moe = ["material", "materials", "bones", "map"];
class goe {
    constructor(e, t, r) {
        const i = r || Ct.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const r = this._targetGroup.nCachedObjects_
          , i = this._bindings[r];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const r = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
            r[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
            e[t].unbind()
    }
}
class Ct {
    constructor(e, t, r) {
        this.path = t,
        this.parsedPath = r || Ct.parseTrackName(t),
        this.node = Ct.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, r) {
        return e && e.isAnimationObjectGroup ? new Ct.Composite(e,t,r) : new Ct(e,t,r)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(coe, "")
    }
    static parseTrackName(e) {
        const t = poe.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const r = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = r.nodeName && r.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = r.nodeName.substring(i + 1);
            moe.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i),
            r.objectName = s)
        }
        if (r.propertyName === null || r.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return r
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const r = e.skeleton.getBoneByName(t);
            if (r !== void 0)
                return r
        }
        if (e.children) {
            const r = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = r(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , i = r(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            e[t++] = r[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const r = this.resolvedProperty;
        for (let i = 0, s = r.length; i !== s; ++i)
            r[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , r = t.objectName
          , i = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = Ct.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (r) {
            let c = t.objectIndex;
            switch (r) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let A = 0; A < e.length; A++)
                    if (e[A].name === c) {
                        c = A;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[r] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[r]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
Ct.Composite = goe;
Ct.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
Ct.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
Ct.prototype.GetterByBindingType = [Ct.prototype._getValue_direct, Ct.prototype._getValue_array, Ct.prototype._getValue_arrayElement, Ct.prototype._getValue_toArray];
Ct.prototype.SetterByBindingTypeAndVersioning = [[Ct.prototype._setValue_direct, Ct.prototype._setValue_direct_setNeedsUpdate, Ct.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_array, Ct.prototype._setValue_array_setNeedsUpdate, Ct.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_arrayElement, Ct.prototype._setValue_arrayElement_setNeedsUpdate, Ct.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ct.prototype._setValue_fromArray, Ct.prototype._setValue_fromArray_setNeedsUpdate, Ct.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class voe {
    constructor(e, t, r=null, i=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = r,
        this.blendMode = i;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: Nh,
            endingEnd: Nh
        };
        for (let c = 0; c !== o; ++c) {
            const A = s[c].createInterpolant(null);
            a[c] = A,
            A.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = _q,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, r) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        r) {
            const i = this._clip.duration
              , s = e._clip.duration
              , o = s / i
              , a = i / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, r) {
        return e.crossFadeFrom(this, t, r)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, r) {
        const i = this._mixer
          , s = i.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = i._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , c = a.sampleValues;
        return l[0] = s,
        l[1] = s + r,
        c[0] = e / o,
        c[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, r, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * r;
            l < 0 || r === 0 ? t = 0 : (this._startTime = null,
            t = r * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , c = this._propertyBindings;
            switch (this.blendMode) {
            case bq:
                for (let A = 0, u = l.length; A !== u; ++A)
                    l[A].evaluate(o),
                    c[A].accumulateAdditive(a);
                break;
            case PR:
            default:
                for (let A = 0, u = l.length; A !== u; ++A)
                    l[A].evaluate(o),
                    c[A].accumulate(i, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const r = this._weightInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                t *= i,
                e > r.parameterPositions[1] && (this.stopFading(),
                i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const r = this._timeScaleInterpolant;
            if (r !== null) {
                const i = r.evaluate(e)[0];
                t *= i,
                e > r.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , r = this.loop;
        let i = this.time + e
          , s = this._loopCount;
        const o = r === xq;
        if (e === 0)
            return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
        if (r === wq) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (i >= t)
                    i = t;
                else if (i < 0)
                    i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            i >= t || i < 0) {
                const a = Math.floor(i / t);
                i -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    i = e > 0 ? t : 0,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = i;
            if (o && (s & 1) === 1)
                return t - i
        }
        return i
    }
    _setEndings(e, t, r) {
        const i = this._interpolantSettings;
        r ? (i.endingStart = Oh,
        i.endingEnd = Oh) : (e ? i.endingStart = this.zeroSlopeAtStart ? Oh : Nh : i.endingStart = P_,
        t ? i.endingEnd = this.zeroSlopeAtEnd ? Oh : Nh : i.endingEnd = P_)
    }
    _scheduleFading(e, t, r) {
        const i = this._mixer
          , s = i.time;
        let o = this._weightInterpolant;
        o === null && (o = i._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = r,
        this
    }
}
const yoe = new Float32Array(1);
class woe extends UA {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const r = e._localRoot || this._root
          , i = e._clip.tracks
          , s = i.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = r.uuid
          , c = this._bindingsByRootAndName;
        let A = c[l];
        A === void 0 && (A = {},
        c[l] = A);
        for (let u = 0; u !== s; ++u) {
            const f = i[u]
              , h = f.name;
            let d = A[h];
            if (d !== void 0)
                ++d.referenceCount,
                o[u] = d;
            else {
                if (d = o[u],
                d !== void 0) {
                    d._cacheIndex === null && (++d.referenceCount,
                    this._addInactiveBinding(d, l, h));
                    continue
                }
                const m = t && t._propertyBindings[u].binding.parsedPath;
                d = new loe(Ct.create(r, h, m),f.ValueTypeName,f.getValueSize()),
                ++d.referenceCount,
                this._addInactiveBinding(d, l, h),
                o[u] = d
            }
            a[u].resultBuffer = d.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const r = (e._localRoot || this._root).uuid
                  , i = e._clip.uuid
                  , s = this._actionsByClip[i];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, i, r)
            }
            const t = e._propertyBindings;
            for (let r = 0, i = t.length; r !== i; ++r) {
                const s = t[r];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let r = 0, i = t.length; r !== i; ++r) {
                const s = t[r];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, r) {
        const i = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = i.length,
        i.push(e),
        o.actionByRoot[r] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , r = t[t.length - 1]
          , i = e._cacheIndex;
        r._cacheIndex = i,
        t[i] = r,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , c = l[l.length - 1]
          , A = e._byClipCacheIndex;
        c._byClipCacheIndex = A,
        l[A] = c,
        l.pop(),
        e._byClipCacheIndex = null;
        const u = a.actionByRoot
          , f = (e._localRoot || this._root).uuid;
        delete u[f],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let r = 0, i = t.length; r !== i; ++r) {
            const s = t[r];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , r = e._cacheIndex
          , i = this._nActiveActions++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , r = e._cacheIndex
          , i = --this._nActiveActions
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _addInactiveBinding(e, t, r) {
        const i = this._bindingsByRootAndName
          , s = this._bindings;
        let o = i[t];
        o === void 0 && (o = {},
        i[t] = o),
        o[r] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , r = e.binding
          , i = r.rootNode.uuid
          , s = r.path
          , o = this._bindingsByRootAndName
          , a = o[i]
          , l = t[t.length - 1]
          , c = e._cacheIndex;
        l._cacheIndex = c,
        t[c] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[i]
    }
    _lendBinding(e) {
        const t = this._bindings
          , r = e._cacheIndex
          , i = this._nActiveBindings++
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , r = e._cacheIndex
          , i = --this._nActiveBindings
          , s = t[i];
        e._cacheIndex = i,
        t[i] = e,
        s._cacheIndex = r,
        t[r] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let r = e[t];
        return r === void 0 && (r = new kz(new Float32Array(2),new Float32Array(2),1,yoe),
        r.__cacheIndex = t,
        e[t] = r),
        r
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , r = e.__cacheIndex
          , i = --this._nActiveControlInterpolants
          , s = t[i];
        e.__cacheIndex = i,
        t[i] = e,
        s.__cacheIndex = r,
        t[r] = s
    }
    clipAction(e, t, r) {
        const i = t || this._root
          , s = i.uuid;
        let o = typeof e == "string" ? ku.findByName(i, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let c = null;
        if (r === void 0 && (o !== null ? r = o.blendMode : r = PR),
        l !== void 0) {
            const u = l.actionByRoot[s];
            if (u !== void 0 && u.blendMode === r)
                return u;
            c = l.knownActions[0],
            o === null && (o = c._clip)
        }
        if (o === null)
            return null;
        const A = new voe(this,o,t,r);
        return this._bindAction(A, c),
        this._addInactiveAction(A, a, s),
        A
    }
    existingAction(e, t) {
        const r = t || this._root
          , i = r.uuid
          , s = typeof e == "string" ? ku.findByName(r, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let r = t - 1; r >= 0; --r)
            e[r].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , r = this._nActiveActions
          , i = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let c = 0; c !== r; ++c)
            t[c]._update(i, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c)
            a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , r = e.uuid
          , i = this._actionsByClip
          , s = i[r];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const A = c._cacheIndex
                  , u = t[t.length - 1];
                c._cacheIndex = null,
                c._byClipCacheIndex = null,
                u._cacheIndex = A,
                t[A] = u,
                t.pop(),
                this._removeInactiveBindingsForAction(c)
            }
            delete i[r]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , r = this._actionsByClip;
        for (const o in r) {
            const a = r[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const i = this._bindingsByRootAndName
          , s = i[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const r = this.existingAction(e, t);
        r !== null && (this._deactivateAction(r),
        this._removeInactiveAction(r))
    }
}
class YR {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new YR(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
class yD {
    constructor(e, t, r, i, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = r,
        this.elementSize = i,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const wD = new He;
class jz {
    constructor(e, t, r=0, i=1 / 0) {
        this.ray = new $u(e,t),
        this.near = r,
        this.far = i,
        this.camera = null,
        this.layers = new OR,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return wD.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(wD),
        this
    }
    intersectObject(e, t=!0, r=[]) {
        return OC(e, this, r, t),
        r.sort(_D),
        r
    }
    intersectObjects(e, t=!0, r=[]) {
        for (let i = 0, s = e.length; i < s; i++)
            OC(e[i], this, r, t);
        return r.sort(_D),
        r
    }
}
function _D(n, e) {
    return n.distance - e.distance
}
function OC(n, e, t, r) {
    let i = !0;
    if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1),
    i === !0 && r === !0) {
        const s = n.children;
        for (let o = 0, a = s.length; o < a; o++)
            OC(s[o], e, t, !0)
    }
}
class xD {
    constructor(e=1, t=0, r=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    set(e, t, r) {
        return this.radius = e,
        this.phi = t,
        this.theta = r,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, r) {
        return this.radius = Math.sqrt(e * e + t * t + r * r),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, r),
        this.phi = Math.acos(pr(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const bD = new $
  , Vv = new $;
class Wl {
    constructor(e=new $, t=new $) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        bD.subVectors(e, this.start),
        Vv.subVectors(this.end, this.start);
        const r = Vv.dot(Vv);
        let s = Vv.dot(bD) / r;
        return t && (s = pr(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, r) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(r).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class _oe extends w0 {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , i = new Jt;
        i.setAttribute("position", new xn(t,3)),
        i.setAttribute("color", new xn(r,3));
        const s = new Ac({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, r) {
        const i = new Qe
          , s = this.geometry.attributes.color.array;
        return i.set(e),
        i.toArray(s, 0),
        i.toArray(s, 3),
        i.set(t),
        i.toArray(s, 6),
        i.toArray(s, 9),
        i.set(r),
        i.toArray(s, 12),
        i.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class xoe extends UA {
    constructor(e, t=null) {
        super(),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.state = -1,
        this.keys = {},
        this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        },
        this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect() {}
    disconnect() {}
    dispose() {}
    update() {}
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: nc
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = nc);
const ED = {
    type: "change"
}
  , $R = {
    type: "start"
}
  , Wz = {
    type: "end"
}
  , jv = new $u
  , BD = new Ra
  , boe = Math.cos(70 * Bt.DEG2RAD)
  , Ir = new $
  , Vi = 2 * Math.PI
  , mn = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
}
  , tB = 1e-6;
class Eoe extends xoe {
    constructor(e, t=null) {
        super(e, t),
        this.state = mn.NONE,
        this.enabled = !0,
        this.target = new $,
        this.cursor = new $,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minTargetRadius = 0,
        this.maxTargetRadius = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: rd.ROTATE,
            MIDDLE: rd.DOLLY,
            RIGHT: rd.PAN
        },
        this.touches = {
            ONE: Lh.ROTATE,
            TWO: Lh.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this._lastPosition = new $,
        this._lastQuaternion = new nt,
        this._lastTargetPosition = new $,
        this._quat = new nt().setFromUnitVectors(e.up, new $(0,1,0)),
        this._quatInverse = this._quat.clone().invert(),
        this._spherical = new xD,
        this._sphericalDelta = new xD,
        this._scale = 1,
        this._panOffset = new $,
        this._rotateStart = new We,
        this._rotateEnd = new We,
        this._rotateDelta = new We,
        this._panStart = new We,
        this._panEnd = new We,
        this._panDelta = new We,
        this._dollyStart = new We,
        this._dollyEnd = new We,
        this._dollyDelta = new We,
        this._dollyDirection = new $,
        this._mouse = new We,
        this._performCursorZoom = !1,
        this._pointers = [],
        this._pointerPositions = {},
        this._controlActive = !1,
        this._onPointerMove = Moe.bind(this),
        this._onPointerDown = Boe.bind(this),
        this._onPointerUp = Soe.bind(this),
        this._onContextMenu = Poe.bind(this),
        this._onMouseWheel = Ioe.bind(this),
        this._onKeyDown = Roe.bind(this),
        this._onTouchStart = Uoe.bind(this),
        this._onTouchMove = Foe.bind(this),
        this._onMouseDown = Coe.bind(this),
        this._onMouseMove = Toe.bind(this),
        this._interceptControlDown = Loe.bind(this),
        this._interceptControlUp = Doe.bind(this),
        this.domElement !== null && this.connect(),
        this.update()
    }
    connect() {
        this.domElement.addEventListener("pointerdown", this._onPointerDown),
        this.domElement.addEventListener("pointercancel", this._onPointerUp),
        this.domElement.addEventListener("contextmenu", this._onContextMenu),
        this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: !1
        }),
        this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: !0,
            capture: !0
        }),
        this.domElement.style.touchAction = "none"
    }
    disconnect() {
        this.domElement.removeEventListener("pointerdown", this._onPointerDown),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.domElement.removeEventListener("pointercancel", this._onPointerUp),
        this.domElement.removeEventListener("wheel", this._onMouseWheel),
        this.domElement.removeEventListener("contextmenu", this._onContextMenu),
        this.stopListenToKeyEvents(),
        this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: !0
        }),
        this.domElement.style.touchAction = "auto"
    }
    dispose() {
        this.disconnect()
    }
    getPolarAngle() {
        return this._spherical.phi
    }
    getAzimuthalAngle() {
        return this._spherical.theta
    }
    getDistance() {
        return this.object.position.distanceTo(this.target)
    }
    listenToKeyEvents(e) {
        e.addEventListener("keydown", this._onKeyDown),
        this._domElementKeyEvents = e
    }
    stopListenToKeyEvents() {
        this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown),
        this._domElementKeyEvents = null)
    }
    saveState() {
        this.target0.copy(this.target),
        this.position0.copy(this.object.position),
        this.zoom0 = this.object.zoom
    }
    reset() {
        this.target.copy(this.target0),
        this.object.position.copy(this.position0),
        this.object.zoom = this.zoom0,
        this.object.updateProjectionMatrix(),
        this.dispatchEvent(ED),
        this.update(),
        this.state = mn.NONE
    }
    update(e=null) {
        const t = this.object.position;
        Ir.copy(t).sub(this.target),
        Ir.applyQuaternion(this._quat),
        this._spherical.setFromVector3(Ir),
        this.autoRotate && this.state === mn.NONE && this._rotateLeft(this._getAutoRotationAngle(e)),
        this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor,
        this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta,
        this._spherical.phi += this._sphericalDelta.phi);
        let r = this.minAzimuthAngle
          , i = this.maxAzimuthAngle;
        isFinite(r) && isFinite(i) && (r < -Math.PI ? r += Vi : r > Math.PI && (r -= Vi),
        i < -Math.PI ? i += Vi : i > Math.PI && (i -= Vi),
        r <= i ? this._spherical.theta = Math.max(r, Math.min(i, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (r + i) / 2 ? Math.max(r, this._spherical.theta) : Math.min(i, this._spherical.theta)),
        this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)),
        this._spherical.makeSafe(),
        this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset),
        this.target.sub(this.cursor),
        this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
        this.target.add(this.cursor);
        let s = !1;
        if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
            this._spherical.radius = this._clampDistance(this._spherical.radius);
        else {
            const o = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale),
            s = o != this._spherical.radius
        }
        if (Ir.setFromSpherical(this._spherical),
        Ir.applyQuaternion(this._quatInverse),
        t.copy(this.target).add(Ir),
        this.object.lookAt(this.target),
        this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor,
        this._sphericalDelta.phi *= 1 - this.dampingFactor,
        this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0),
        this._panOffset.set(0, 0, 0)),
        this.zoomToCursor && this._performCursorZoom) {
            let o = null;
            if (this.object.isPerspectiveCamera) {
                const a = Ir.length();
                o = this._clampDistance(a * this._scale);
                const l = a - o;
                this.object.position.addScaledVector(this._dollyDirection, l),
                this.object.updateMatrixWorld(),
                s = !!l
            } else if (this.object.isOrthographicCamera) {
                const a = new $(this._mouse.x,this._mouse.y,0);
                a.unproject(this.object);
                const l = this.object.zoom;
                this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
                this.object.updateProjectionMatrix(),
                s = l !== this.object.zoom;
                const c = new $(this._mouse.x,this._mouse.y,0);
                c.unproject(this.object),
                this.object.position.sub(c).add(a),
                this.object.updateMatrixWorld(),
                o = Ir.length()
            } else
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                this.zoomToCursor = !1;
            o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (jv.origin.copy(this.object.position),
            jv.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(jv.direction)) < boe ? this.object.lookAt(this.target) : (BD.setFromNormalAndCoplanarPoint(this.object.up, this.target),
            jv.intersectPlane(BD, this.target))))
        } else if (this.object.isOrthographicCamera) {
            const o = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
            o !== this.object.zoom && (this.object.updateProjectionMatrix(),
            s = !0)
        }
        return this._scale = 1,
        this._performCursorZoom = !1,
        s || this._lastPosition.distanceToSquared(this.object.position) > tB || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > tB || this._lastTargetPosition.distanceToSquared(this.target) > tB ? (this.dispatchEvent(ED),
        this._lastPosition.copy(this.object.position),
        this._lastQuaternion.copy(this.object.quaternion),
        this._lastTargetPosition.copy(this.target),
        !0) : !1
    }
    _getAutoRotationAngle(e) {
        return e !== null ? Vi / 60 * this.autoRotateSpeed * e : Vi / 60 / 60 * this.autoRotateSpeed
    }
    _getZoomScale(e) {
        const t = Math.abs(e * .01);
        return Math.pow(.95, this.zoomSpeed * t)
    }
    _rotateLeft(e) {
        this._sphericalDelta.theta -= e
    }
    _rotateUp(e) {
        this._sphericalDelta.phi -= e
    }
    _panLeft(e, t) {
        Ir.setFromMatrixColumn(t, 0),
        Ir.multiplyScalar(-e),
        this._panOffset.add(Ir)
    }
    _panUp(e, t) {
        this.screenSpacePanning === !0 ? Ir.setFromMatrixColumn(t, 1) : (Ir.setFromMatrixColumn(t, 0),
        Ir.crossVectors(this.object.up, Ir)),
        Ir.multiplyScalar(e),
        this._panOffset.add(Ir)
    }
    _pan(e, t) {
        const r = this.domElement;
        if (this.object.isPerspectiveCamera) {
            const i = this.object.position;
            Ir.copy(i).sub(this.target);
            let s = Ir.length();
            s *= Math.tan(this.object.fov / 2 * Math.PI / 180),
            this._panLeft(2 * e * s / r.clientHeight, this.object.matrix),
            this._panUp(2 * t * s / r.clientHeight, this.object.matrix)
        } else
            this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / r.clientWidth, this.object.matrix),
            this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / r.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
            this.enablePan = !1)
    }
    _dollyOut(e) {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
        this.enableZoom = !1)
    }
    _dollyIn(e) {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
        this.enableZoom = !1)
    }
    _updateZoomParameters(e, t) {
        if (!this.zoomToCursor)
            return;
        this._performCursorZoom = !0;
        const r = this.domElement.getBoundingClientRect()
          , i = e - r.left
          , s = t - r.top
          , o = r.width
          , a = r.height;
        this._mouse.x = i / o * 2 - 1,
        this._mouse.y = -(s / a) * 2 + 1,
        this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize()
    }
    _clampDistance(e) {
        return Math.max(this.minDistance, Math.min(this.maxDistance, e))
    }
    _handleMouseDownRotate(e) {
        this._rotateStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownDolly(e) {
        this._updateZoomParameters(e.clientX, e.clientX),
        this._dollyStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownPan(e) {
        this._panStart.set(e.clientX, e.clientY)
    }
    _handleMouseMoveRotate(e) {
        this._rotateEnd.set(e.clientX, e.clientY),
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(Vi * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(Vi * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd),
        this.update()
    }
    _handleMouseMoveDolly(e) {
        this._dollyEnd.set(e.clientX, e.clientY),
        this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
        this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
        this._dollyStart.copy(this._dollyEnd),
        this.update()
    }
    _handleMouseMovePan(e) {
        this._panEnd.set(e.clientX, e.clientY),
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd),
        this.update()
    }
    _handleMouseWheel(e) {
        this._updateZoomParameters(e.clientX, e.clientY),
        e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
        this.update()
    }
    _handleKeyDown(e) {
        let t = !1;
        switch (e.code) {
        case this.keys.UP:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Vi * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.BOTTOM:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Vi * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.LEFT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Vi * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0),
            t = !0;
            break;
        case this.keys.RIGHT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Vi * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0),
            t = !0;
            break
        }
        t && (e.preventDefault(),
        this.update())
    }
    _handleTouchStartRotate(e) {
        if (this._pointers.length === 1)
            this._rotateStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , r = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._rotateStart.set(r, i)
        }
    }
    _handleTouchStartPan(e) {
        if (this._pointers.length === 1)
            this._panStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , r = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._panStart.set(r, i)
        }
    }
    _handleTouchStartDolly(e) {
        const t = this._getSecondPointerPosition(e)
          , r = e.pageX - t.x
          , i = e.pageY - t.y
          , s = Math.sqrt(r * r + i * i);
        this._dollyStart.set(0, s)
    }
    _handleTouchStartDollyPan(e) {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enablePan && this._handleTouchStartPan(e)
    }
    _handleTouchStartDollyRotate(e) {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enableRotate && this._handleTouchStartRotate(e)
    }
    _handleTouchMoveRotate(e) {
        if (this._pointers.length == 1)
            this._rotateEnd.set(e.pageX, e.pageY);
        else {
            const r = this._getSecondPointerPosition(e)
              , i = .5 * (e.pageX + r.x)
              , s = .5 * (e.pageY + r.y);
            this._rotateEnd.set(i, s)
        }
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(Vi * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(Vi * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd)
    }
    _handleTouchMovePan(e) {
        if (this._pointers.length === 1)
            this._panEnd.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , r = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._panEnd.set(r, i)
        }
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd)
    }
    _handleTouchMoveDolly(e) {
        const t = this._getSecondPointerPosition(e)
          , r = e.pageX - t.x
          , i = e.pageY - t.y
          , s = Math.sqrt(r * r + i * i);
        this._dollyEnd.set(0, s),
        this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)),
        this._dollyOut(this._dollyDelta.y),
        this._dollyStart.copy(this._dollyEnd);
        const o = (e.pageX + t.x) * .5
          , a = (e.pageY + t.y) * .5;
        this._updateZoomParameters(o, a)
    }
    _handleTouchMoveDollyPan(e) {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enablePan && this._handleTouchMovePan(e)
    }
    _handleTouchMoveDollyRotate(e) {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enableRotate && this._handleTouchMoveRotate(e)
    }
    _addPointer(e) {
        this._pointers.push(e.pointerId)
    }
    _removePointer(e) {
        delete this._pointerPositions[e.pointerId];
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId) {
                this._pointers.splice(t, 1);
                return
            }
    }
    _isTrackingPointer(e) {
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId)
                return !0;
        return !1
    }
    _trackPointer(e) {
        let t = this._pointerPositions[e.pointerId];
        t === void 0 && (t = new We,
        this._pointerPositions[e.pointerId] = t),
        t.set(e.pageX, e.pageY)
    }
    _getSecondPointerPosition(e) {
        const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
        return this._pointerPositions[t]
    }
    _customWheelEvent(e) {
        const t = e.deltaMode
          , r = {
            clientX: e.clientX,
            clientY: e.clientY,
            deltaY: e.deltaY
        };
        switch (t) {
        case 1:
            r.deltaY *= 16;
            break;
        case 2:
            r.deltaY *= 100;
            break
        }
        return e.ctrlKey && !this._controlActive && (r.deltaY *= 10),
        r
    }
}
function Boe(n) {
    this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(n.pointerId),
    this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.domElement.addEventListener("pointerup", this._onPointerUp)),
    !this._isTrackingPointer(n) && (this._addPointer(n),
    n.pointerType === "touch" ? this._onTouchStart(n) : this._onMouseDown(n)))
}
function Moe(n) {
    this.enabled !== !1 && (n.pointerType === "touch" ? this._onTouchMove(n) : this._onMouseMove(n))
}
function Soe(n) {
    switch (this._removePointer(n),
    this._pointers.length) {
    case 0:
        this.domElement.releasePointerCapture(n.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(Wz),
        this.state = mn.NONE;
        break;
    case 1:
        const e = this._pointers[0]
          , t = this._pointerPositions[e];
        this._onTouchStart({
            pointerId: e,
            pageX: t.x,
            pageY: t.y
        });
        break
    }
}
function Coe(n) {
    let e;
    switch (n.button) {
    case 0:
        e = this.mouseButtons.LEFT;
        break;
    case 1:
        e = this.mouseButtons.MIDDLE;
        break;
    case 2:
        e = this.mouseButtons.RIGHT;
        break;
    default:
        e = -1
    }
    switch (e) {
    case rd.DOLLY:
        if (this.enableZoom === !1)
            return;
        this._handleMouseDownDolly(n),
        this.state = mn.DOLLY;
        break;
    case rd.ROTATE:
        if (n.ctrlKey || n.metaKey || n.shiftKey) {
            if (this.enablePan === !1)
                return;
            this._handleMouseDownPan(n),
            this.state = mn.PAN
        } else {
            if (this.enableRotate === !1)
                return;
            this._handleMouseDownRotate(n),
            this.state = mn.ROTATE
        }
        break;
    case rd.PAN:
        if (n.ctrlKey || n.metaKey || n.shiftKey) {
            if (this.enableRotate === !1)
                return;
            this._handleMouseDownRotate(n),
            this.state = mn.ROTATE
        } else {
            if (this.enablePan === !1)
                return;
            this._handleMouseDownPan(n),
            this.state = mn.PAN
        }
        break;
    default:
        this.state = mn.NONE
    }
    this.state !== mn.NONE && this.dispatchEvent($R)
}
function Toe(n) {
    switch (this.state) {
    case mn.ROTATE:
        if (this.enableRotate === !1)
            return;
        this._handleMouseMoveRotate(n);
        break;
    case mn.DOLLY:
        if (this.enableZoom === !1)
            return;
        this._handleMouseMoveDolly(n);
        break;
    case mn.PAN:
        if (this.enablePan === !1)
            return;
        this._handleMouseMovePan(n);
        break
    }
}
function Ioe(n) {
    this.enabled === !1 || this.enableZoom === !1 || this.state !== mn.NONE || (n.preventDefault(),
    this.dispatchEvent($R),
    this._handleMouseWheel(this._customWheelEvent(n)),
    this.dispatchEvent(Wz))
}
function Roe(n) {
    this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(n)
}
function Uoe(n) {
    switch (this._trackPointer(n),
    this._pointers.length) {
    case 1:
        switch (this.touches.ONE) {
        case Lh.ROTATE:
            if (this.enableRotate === !1)
                return;
            this._handleTouchStartRotate(n),
            this.state = mn.TOUCH_ROTATE;
            break;
        case Lh.PAN:
            if (this.enablePan === !1)
                return;
            this._handleTouchStartPan(n),
            this.state = mn.TOUCH_PAN;
            break;
        default:
            this.state = mn.NONE
        }
        break;
    case 2:
        switch (this.touches.TWO) {
        case Lh.DOLLY_PAN:
            if (this.enableZoom === !1 && this.enablePan === !1)
                return;
            this._handleTouchStartDollyPan(n),
            this.state = mn.TOUCH_DOLLY_PAN;
            break;
        case Lh.DOLLY_ROTATE:
            if (this.enableZoom === !1 && this.enableRotate === !1)
                return;
            this._handleTouchStartDollyRotate(n),
            this.state = mn.TOUCH_DOLLY_ROTATE;
            break;
        default:
            this.state = mn.NONE
        }
        break;
    default:
        this.state = mn.NONE
    }
    this.state !== mn.NONE && this.dispatchEvent($R)
}
function Foe(n) {
    switch (this._trackPointer(n),
    this.state) {
    case mn.TOUCH_ROTATE:
        if (this.enableRotate === !1)
            return;
        this._handleTouchMoveRotate(n),
        this.update();
        break;
    case mn.TOUCH_PAN:
        if (this.enablePan === !1)
            return;
        this._handleTouchMovePan(n),
        this.update();
        break;
    case mn.TOUCH_DOLLY_PAN:
        if (this.enableZoom === !1 && this.enablePan === !1)
            return;
        this._handleTouchMoveDollyPan(n),
        this.update();
        break;
    case mn.TOUCH_DOLLY_ROTATE:
        if (this.enableZoom === !1 && this.enableRotate === !1)
            return;
        this._handleTouchMoveDollyRotate(n),
        this.update();
        break;
    default:
        this.state = mn.NONE
    }
}
function Poe(n) {
    this.enabled !== !1 && n.preventDefault()
}
function Loe(n) {
    n.key === "Control" && (this._controlActive = !0,
    this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
function Doe(n) {
    n.key === "Control" && (this._controlActive = !1,
    this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
function Kz(n) {
    let e, t, r, i = -1, s = 0;
    for (let c = 0; c < n.length; ++c) {
        const A = n[c];
        if (e === void 0 && (e = A.array.constructor),
        e !== A.array.constructor)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
            null;
        if (t === void 0 && (t = A.itemSize),
        t !== A.itemSize)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
            null;
        if (r === void 0 && (r = A.normalized),
        r !== A.normalized)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
            null;
        if (i === -1 && (i = A.gpuType),
        i !== A.gpuType)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
            null;
        s += A.count * t
    }
    const o = new e(s)
      , a = new ct(o,t,r);
    let l = 0;
    for (let c = 0; c < n.length; ++c) {
        const A = n[c];
        if (A.isInterleavedBufferAttribute) {
            const u = l / t;
            for (let f = 0, h = A.count; f < h; f++)
                for (let d = 0; d < t; d++) {
                    const m = A.getComponent(f, d);
                    a.setComponent(f + u, d, m)
                }
        } else
            o.set(A.array, l);
        l += A.count * t
    }
    return i !== void 0 && (a.gpuType = i),
    a
}
function MD(n, e) {
    if (e === Eq)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        n;
    if (e === RC || e === wz) {
        let t = n.getIndex();
        if (t === null) {
            const o = []
              , a = n.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++)
                    o.push(l);
                n.setIndex(o),
                t = n.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                n
        }
        const r = t.count - 2
          , i = [];
        if (e === RC)
            for (let o = 1; o <= r; o++)
                i.push(t.getX(0)),
                i.push(t.getX(o)),
                i.push(t.getX(o + 1));
        else
            for (let o = 0; o < r; o++)
                o % 2 === 0 ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = n.clone();
        return s.setIndex(i),
        s.clearGroups(),
        s
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        n
}
class Xz extends rl {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new Hoe(t)
        }),
        this.register(function(t) {
            return new zoe(t)
        }),
        this.register(function(t) {
            return new Zoe(t)
        }),
        this.register(function(t) {
            return new Joe(t)
        }),
        this.register(function(t) {
            return new qoe(t)
        }),
        this.register(function(t) {
            return new Voe(t)
        }),
        this.register(function(t) {
            return new joe(t)
        }),
        this.register(function(t) {
            return new Woe(t)
        }),
        this.register(function(t) {
            return new Koe(t)
        }),
        this.register(function(t) {
            return new Qoe(t)
        }),
        this.register(function(t) {
            return new Xoe(t)
        }),
        this.register(function(t) {
            return new Goe(t)
        }),
        this.register(function(t) {
            return new $oe(t)
        }),
        this.register(function(t) {
            return new Yoe(t)
        }),
        this.register(function(t) {
            return new Ooe(t)
        }),
        this.register(function(t) {
            return new eae(t)
        }),
        this.register(function(t) {
            return new tae(t)
        })
    }
    load(e, t, r, i) {
        const s = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const c = ad.extractUrlBase(e);
            o = ad.resolveURL(c, this.path)
        } else
            o = ad.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(c) {
            i ? i(c) : console.error(c),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
          , l = new v1(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(c) {
            try {
                s.parse(c, o, function(A) {
                    t(A),
                    s.manager.itemEnd(e)
                }, a)
            } catch (A) {
                a(A)
            }
        }, r, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, r, i) {
        let s;
        const o = {}
          , a = {}
          , l = new TextDecoder;
        if (typeof e == "string")
            s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e,0,4)) === Yz) {
                try {
                    o[Ft.KHR_BINARY_GLTF] = new nae(e)
                } catch (u) {
                    i && i(u);
                    return
                }
                s = JSON.parse(o[Ft.KHR_BINARY_GLTF].content)
            } else
                s = JSON.parse(l.decode(e));
        else
            s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new pae(s,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let A = 0; A < this.pluginCallbacks.length; A++) {
            const u = this.pluginCallbacks[A](c);
            u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[u.name] = u,
            o[u.name] = !0
        }
        if (s.extensionsUsed)
            for (let A = 0; A < s.extensionsUsed.length; ++A) {
                const u = s.extensionsUsed[A]
                  , f = s.extensionsRequired || [];
                switch (u) {
                case Ft.KHR_MATERIALS_UNLIT:
                    o[u] = new koe;
                    break;
                case Ft.KHR_DRACO_MESH_COMPRESSION:
                    o[u] = new rae(s,this.dracoLoader);
                    break;
                case Ft.KHR_TEXTURE_TRANSFORM:
                    o[u] = new iae;
                    break;
                case Ft.KHR_MESH_QUANTIZATION:
                    o[u] = new sae;
                    break;
                default:
                    f.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(r, i)
    }
    parseAsync(e, t) {
        const r = this;
        return new Promise(function(i, s) {
            r.parse(e, t, i, s)
        }
        )
    }
}
function Noe() {
    let n = {};
    return {
        get: function(e) {
            return n[e]
        },
        add: function(e, t) {
            n[e] = t
        },
        remove: function(e) {
            delete n[e]
        },
        removeAll: function() {
            n = {}
        }
    }
}
const Ft = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Ooe {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let r = 0, i = t.length; r < i; r++) {
            const s = t[r];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , r = "light:" + e;
        let i = t.cache.get(r);
        if (i)
            return i;
        const s = t.json
          , l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let c;
        const A = new Qe(16777215);
        l.color !== void 0 && A.setRGB(l.color[0], l.color[1], l.color[2], Sr);
        const u = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new WR(A),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new NC(A),
            c.distance = u;
            break;
        case "spot":
            c = new Gz(A),
            c.distance = u,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0),
        c.decay = 2,
        Ul(c, l),
        l.intensity !== void 0 && (c.intensity = l.intensity),
        c.name = t.createUniqueName(l.name || "light_" + e),
        i = Promise.resolve(c),
        t.cache.add(r, i),
        i
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , r = this.parser
          , s = r.json.nodes[e]
          , a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return r._getNodeRef(t.cache, a, l)
        })
    }
}
let koe = class {
    constructor() {
        this.name = Ft.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return qi
    }
    extendParams(e, t, r) {
        const i = [];
        e.color = new Qe(1,1,1),
        e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], Sr),
                e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture, Ut))
        }
        return Promise.all(i)
    }
}
  , Qoe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s),
        Promise.resolve()
    }
}
  , Hoe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new We(a,a)
        }
        return Promise.all(s)
    }
}
  , zoe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0,
        Promise.resolve()
    }
}
  , Goe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(s)
    }
}
  , Voe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = [];
        t.sheenColor = new Qe(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], Sr)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Ut)),
        o.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(s)
    }
}
  , joe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(s)
    }
}
  , Woe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Qe().setRGB(a[0], a[1], a[2], Sr),
        Promise.all(s)
    }
}
  , Koe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = i.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5,
        Promise.resolve()
    }
}
  , Xoe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Qe().setRGB(a[0], a[1], a[2], Sr),
        o.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", o.specularColorTexture, Ut)),
        Promise.all(s)
    }
}
  , Yoe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1,
        o.bumpTexture !== void 0 && s.push(r.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(s)
    }
}
  , $oe = class {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const r = this.parser.json.materials[e];
        return !r.extensions || !r.extensions[this.name] ? null : ol
    }
    extendMaterialParams(e, t) {
        const r = this.parser
          , i = r.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const s = []
          , o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
        o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
        o.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(s)
    }
}
;
class Zoe {
    constructor(e) {
        this.parser = e,
        this.name = Ft.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , r = t.json
          , i = r.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const s = i.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class Joe {
    constructor(e) {
        this.parser = e,
        this.name = Ft.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , r = this.parser
          , i = r.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let l = r.textureLoader;
        if (a.uri) {
            const c = r.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return r.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class qoe {
    constructor(e) {
        this.parser = e,
        this.name = Ft.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , r = this.parser
          , i = r.json
          , s = i.textures[e];
        if (!s.extensions || !s.extensions[t])
            return null;
        const o = s.extensions[t]
          , a = i.images[o.source];
        let l = r.textureLoader;
        if (a.uri) {
            const c = r.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return r.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return r.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class eae {
    constructor(e) {
        this.name = Ft.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , r = t.bufferViews[e];
        if (r.extensions && r.extensions[this.name]) {
            const i = r.extensions[this.name]
              , s = this.parser.getDependency("buffer", i.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = i.byteOffset || 0
                  , c = i.byteLength || 0
                  , A = i.count
                  , u = i.byteStride
                  , f = new Uint8Array(a,l,c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(A, u, f, i.mode, i.filter).then(function(h) {
                    return h.buffer
                }) : o.ready.then(function() {
                    const h = new ArrayBuffer(A * u);
                    return o.decodeGltfBuffer(new Uint8Array(h), A, u, f, i.mode, i.filter),
                    h
                })
            })
        } else
            return null
    }
}
let tae = class {
    constructor(e) {
        this.name = Ft.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , r = t.nodes[e];
        if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0)
            return null;
        const i = t.meshes[r.mesh];
        for (const c of i.primitives)
            if (c.mode !== to.TRIANGLES && c.mode !== to.TRIANGLE_STRIP && c.mode !== to.TRIANGLE_FAN && c.mode !== void 0)
                return null;
        const o = r.extensions[this.name].attributes
          , a = []
          , l = {};
        for (const c in o)
            a.push(this.parser.getDependency("accessor", o[c]).then(A => (l[c] = A,
            l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(c => {
            const A = c.pop()
              , u = A.isGroup ? A.children : [A]
              , f = c[0].count
              , h = [];
            for (const d of u) {
                const m = new He
                  , g = new $
                  , p = new nt
                  , v = new $(1,1,1)
                  , w = new p1(d.geometry,d.material,f);
                for (let _ = 0; _ < f; _++)
                    l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, _),
                    l.ROTATION && p.fromBufferAttribute(l.ROTATION, _),
                    l.SCALE && v.fromBufferAttribute(l.SCALE, _),
                    w.setMatrixAt(_, m.compose(g, p, v));
                for (const _ in l)
                    if (_ === "_COLOR_0") {
                        const x = l[_];
                        w.instanceColor = new Vg(x.array,x.itemSize,x.normalized)
                    } else
                        _ !== "TRANSLATION" && _ !== "ROTATION" && _ !== "SCALE" && d.geometry.setAttribute(_, l[_]);
                Lt.prototype.copy.call(w, d),
                this.parser.assignFinalMaterial(w),
                h.push(w)
            }
            return A.isGroup ? (A.clear(),
            A.add(...h),
            A) : h[0]
        }
        ))
    }
}
;
const Yz = "glTF"
  , kp = 12
  , SD = {
    JSON: 1313821514,
    BIN: 5130562
};
class nae {
    constructor(e) {
        this.name = Ft.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,kp)
          , r = new TextDecoder;
        if (this.header = {
            magic: r.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== Yz)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - kp
          , s = new DataView(e,kp);
        let o = 0;
        for (; o < i; ) {
            const a = s.getUint32(o, !0);
            o += 4;
            const l = s.getUint32(o, !0);
            if (o += 4,
            l === SD.JSON) {
                const c = new Uint8Array(e,kp + o,a);
                this.content = r.decode(c)
            } else if (l === SD.BIN) {
                const c = kp + o;
                this.body = e.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class rae {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Ft.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const r = this.json
          , i = this.dracoLoader
          , s = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , c = {};
        for (const A in o) {
            const u = kC[A] || A.toLowerCase();
            a[u] = o[A]
        }
        for (const A in e.attributes) {
            const u = kC[A] || A.toLowerCase();
            if (o[A] !== void 0) {
                const f = r.accessors[e.attributes[A]]
                  , h = ld[f.componentType];
                c[u] = h.name,
                l[u] = f.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(A) {
            return new Promise(function(u, f) {
                i.decodeDracoFile(A, function(h) {
                    for (const d in h.attributes) {
                        const m = h.attributes[d]
                          , g = l[d];
                        g !== void 0 && (m.normalized = g)
                    }
                    u(h)
                }, a, c, Sr, f)
            }
            )
        })
    }
}
class iae {
    constructor() {
        this.name = Ft.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class sae {
    constructor() {
        this.name = Ft.KHR_MESH_QUANTIZATION
    }
}
class $z extends _0 {
    constructor(e, t, r, i) {
        super(e, t, r, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , r = this.sampleValues
          , i = this.valueSize
          , s = e * i * 3 + i;
        for (let o = 0; o !== i; o++)
            t[o] = r[s + o];
        return t
    }
    interpolate_(e, t, r, i) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , c = a * 3
          , A = i - t
          , u = (r - t) / A
          , f = u * u
          , h = f * u
          , d = e * c
          , m = d - c
          , g = -2 * h + 3 * f
          , p = h - f
          , v = 1 - g
          , w = p - f + u;
        for (let _ = 0; _ !== a; _++) {
            const x = o[m + _ + a]
              , b = o[m + _ + l] * A
              , B = o[d + _ + a]
              , S = o[d + _] * A;
            s[_] = v * x + w * b + g * B + p * S
        }
        return s
    }
}
const oae = new nt;
class aae extends $z {
    interpolate_(e, t, r, i) {
        const s = super.interpolate_(e, t, r, i);
        return oae.fromArray(s).normalize().toArray(s),
        s
    }
}
const to = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , ld = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , CD = {
    9728: Xr,
    9729: Lr,
    9984: SR,
    9985: qm,
    9986: Dh,
    9987: ea
}
  , TD = {
    33071: Rs,
    33648: Qg,
    10497: zs
}
  , nB = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , kC = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Mc = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , lae = {
    CUBICSPLINE: void 0,
    LINEAR: Ld,
    STEP: Pd
}
  , rB = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function cae(n) {
    return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Od({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Hs
    })),
    n.DefaultMaterial
}
function jA(n, e, t) {
    for (const r in t.extensions)
        n[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[r] = t.extensions[r])
}
function Ul(n, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function Aae(n, e, t) {
    let r = !1
      , i = !1
      , s = !1;
    for (let c = 0, A = e.length; c < A; c++) {
        const u = e[c];
        if (u.POSITION !== void 0 && (r = !0),
        u.NORMAL !== void 0 && (i = !0),
        u.COLOR_0 !== void 0 && (s = !0),
        r && i && s)
            break
    }
    if (!r && !i && !s)
        return Promise.resolve(n);
    const o = []
      , a = []
      , l = [];
    for (let c = 0, A = e.length; c < A; c++) {
        const u = e[c];
        if (r) {
            const f = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : n.attributes.position;
            o.push(f)
        }
        if (i) {
            const f = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : n.attributes.normal;
            a.push(f)
        }
        if (s) {
            const f = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : n.attributes.color;
            l.push(f)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const A = c[0]
          , u = c[1]
          , f = c[2];
        return r && (n.morphAttributes.position = A),
        i && (n.morphAttributes.normal = u),
        s && (n.morphAttributes.color = f),
        n.morphTargetsRelative = !0,
        n
    })
}
function uae(n, e) {
    if (n.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, r = e.weights.length; t < r; t++)
            n.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let r = 0, i = t.length; r < i; r++)
                n.morphTargetDictionary[t[r]] = r
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function fae(n) {
    let e;
    const t = n.extensions && n.extensions[Ft.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + iB(t.attributes) : e = n.indices + ":" + iB(n.attributes) + ":" + n.mode,
    n.targets !== void 0)
        for (let r = 0, i = n.targets.length; r < i; r++)
            e += ":" + iB(n.targets[r]);
    return e
}
function iB(n) {
    let e = "";
    const t = Object.keys(n).sort();
    for (let r = 0, i = t.length; r < i; r++)
        e += t[r] + ":" + n[t[r]] + ";";
    return e
}
function QC(n) {
    switch (n) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function hae(n) {
    return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const dae = new He;
class pae {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new Noe,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let r = !1
          , i = -1
          , s = !1
          , o = -1;
        if (typeof navigator < "u") {
            const a = navigator.userAgent;
            r = /^((?!chrome|android).)*safari/i.test(a) === !0;
            const l = a.match(/Version\/(\d+)/);
            i = r && l ? parseInt(l[1], 10) : -1,
            s = a.indexOf("Firefox") > -1,
            o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        typeof createImageBitmap > "u" || r && i < 17 || s && o < 98 ? this.textureLoader = new PA(this.options.manager) : this.textureLoader = new aoe(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new v1(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const r = this
          , i = this.json
          , s = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: r,
                userData: {}
            };
            return jA(s, a, i),
            Ul(a, i),
            Promise.all(r._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                for (const l of a.scenes)
                    l.updateMatrixWorld();
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , r = this.json.meshes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (r[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, r) {
        if (e.refs[t] <= 1)
            return r;
        const i = r.clone()
          , s = (o, a) => {
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c,A] of o.children.entries())
                s(A, a.children[c])
        }
        ;
        return s(r, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let r = 0; r < t.length; r++) {
            const i = e(t[r]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const r = [];
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && r.push(s)
        }
        return r
    }
    getDependency(e, t) {
        const r = e + ":" + t;
        let i = this.cache.get(r);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this._invokeOne(function(s) {
                    return s.loadNode && s.loadNode(t)
                });
                break;
            case "mesh":
                i = this._invokeOne(function(s) {
                    return s.loadMesh && s.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(s) {
                    return s.loadBufferView && s.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(s) {
                    return s.loadMaterial && s.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(s) {
                    return s.loadTexture && s.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(s) {
                    return s.loadAnimation && s.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                if (i = this._invokeOne(function(s) {
                    return s != this && s.getDependency && s.getDependency(e, t)
                }),
                !i)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(r, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const r = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(s, o) {
                return r.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , r = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Ft.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            r.load(ad.resolveURL(t.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(r) {
            const i = t.byteLength || 0
              , s = t.byteOffset || 0;
            return r.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , r = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = nB[i.type]
              , a = ld[i.componentType]
              , l = i.normalized === !0
              , c = new a(i.count * o);
            return Promise.resolve(new ct(c,o,l))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null),
        i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(s).then(function(o) {
            const a = o[0]
              , l = nB[i.type]
              , c = ld[i.componentType]
              , A = c.BYTES_PER_ELEMENT
              , u = A * l
              , f = i.byteOffset || 0
              , h = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0
              , d = i.normalized === !0;
            let m, g;
            if (h && h !== u) {
                const p = Math.floor(f / h)
                  , v = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                let w = t.cache.get(v);
                w || (m = new c(a,p * h,i.count * h / A),
                w = new hse(m,h / A),
                t.cache.add(v, w)),
                g = new zR(w,l,f % h / A,d)
            } else
                a === null ? m = new c(i.count * l) : m = new c(a,f,i.count * l),
                g = new ct(m,l,d);
            if (i.sparse !== void 0) {
                const p = nB.SCALAR
                  , v = ld[i.sparse.indices.componentType]
                  , w = i.sparse.indices.byteOffset || 0
                  , _ = i.sparse.values.byteOffset || 0
                  , x = new v(o[1],w,i.sparse.count * p)
                  , b = new c(o[2],_,i.sparse.count * l);
                a !== null && (g = new ct(g.array.slice(),g.itemSize,g.normalized)),
                g.normalized = !1;
                for (let B = 0, S = x.length; B < S; B++) {
                    const I = x[B];
                    if (g.setX(I, b[B * l]),
                    l >= 2 && g.setY(I, b[B * l + 1]),
                    l >= 3 && g.setZ(I, b[B * l + 2]),
                    l >= 4 && g.setW(I, b[B * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
                g.normalized = d
            }
            return g
        })
    }
    loadTexture(e) {
        const t = this.json
          , r = this.options
          , s = t.textures[e].source
          , o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = r.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, r) {
        const i = this
          , s = this.json
          , o = s.textures[e]
          , a = s.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(t, r).then(function(A) {
            A.flipY = !1,
            A.name = o.name || a.name || "",
            A.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (A.name = a.uri);
            const f = (s.samplers || {})[o.sampler] || {};
            return A.magFilter = CD[f.magFilter] || Lr,
            A.minFilter = CD[f.minFilter] || ea,
            A.wrapS = TD[f.wrapS] || zs,
            A.wrapT = TD[f.wrapT] || zs,
            i.associations.set(A, {
                textures: e
            }),
            A
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c,
        c
    }
    loadImageSource(e, t) {
        const r = this
          , i = this.json
          , s = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(u => u.clone());
        const o = i.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , c = !1;
        if (o.bufferView !== void 0)
            l = r.getDependency("bufferView", o.bufferView).then(function(u) {
                c = !0;
                const f = new Blob([u],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(f),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const A = Promise.resolve(l).then(function(u) {
            return new Promise(function(f, h) {
                let d = f;
                t.isImageBitmapLoader === !0 && (d = function(m) {
                    const g = new Un(m);
                    g.needsUpdate = !0,
                    f(g)
                }
                ),
                t.load(ad.resolveURL(u, s.path), d, void 0, h)
            }
            )
        }).then(function(u) {
            return c === !0 && a.revokeObjectURL(l),
            Ul(u, o),
            u.userData.mimeType = o.mimeType || hae(o.uri),
            u
        }).catch(function(u) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            u
        });
        return this.sourceCache[e] = A,
        A
    }
    assignTexture(e, t, r, i) {
        const s = this;
        return this.getDependency("texture", r.index).then(function(o) {
            if (!o)
                return null;
            if (r.texCoord !== void 0 && r.texCoord > 0 && (o = o.clone(),
            o.channel = r.texCoord),
            s.extensions[Ft.KHR_TEXTURE_TRANSFORM]) {
                const a = r.extensions !== void 0 ? r.extensions[Ft.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[Ft.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    s.associations.set(o, l)
                }
            }
            return i !== void 0 && (o.colorSpace = i),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let r = e.material;
        const i = t.attributes.tangent === void 0
          , s = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new Pz,
            as.prototype.copy.call(l, r),
            l.color.copy(r.color),
            l.map = r.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            r = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + r.uuid;
            let l = this.cache.get(a);
            l || (l = new Ac,
            as.prototype.copy.call(l, r),
            l.color.copy(r.color),
            l.map = r.map,
            this.cache.add(a, l)),
            r = l
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + r.uuid + ":";
            i && (a += "derivative-tangents:"),
            s && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = r.clone(),
            s && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            i && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(r))),
            r = l
        }
        e.material = r
    }
    getMaterialType() {
        return Od
    }
    loadMaterial(e) {
        const t = this
          , r = this.json
          , i = this.extensions
          , s = r.materials[e];
        let o;
        const a = {}
          , l = s.extensions || {}
          , c = [];
        if (l[Ft.KHR_MATERIALS_UNLIT]) {
            const u = i[Ft.KHR_MATERIALS_UNLIT];
            o = u.getMaterialType(),
            c.push(u.extendParams(a, s, t))
        } else {
            const u = s.pbrMetallicRoughness || {};
            if (a.color = new Qe(1,1,1),
            a.opacity = 1,
            Array.isArray(u.baseColorFactor)) {
                const f = u.baseColorFactor;
                a.color.setRGB(f[0], f[1], f[2], Sr),
                a.opacity = f[3]
            }
            u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", u.baseColorTexture, Ut)),
            a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1,
            a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1,
            u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)),
            c.push(t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))),
            o = this._invokeOne(function(f) {
                return f.getMaterialType && f.getMaterialType(e)
            }),
            c.push(Promise.all(this._invokeAll(function(f) {
                return f.extendMaterialParams && f.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = _i);
        const A = s.alphaMode || rB.OPAQUE;
        if (A === rB.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        A === rB.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)),
        s.normalTexture !== void 0 && o !== qi && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        a.normalScale = new We(1,1),
        s.normalTexture.scale !== void 0)) {
            const u = s.normalTexture.scale;
            a.normalScale.set(u, u)
        }
        if (s.occlusionTexture !== void 0 && o !== qi && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)),
        s.emissiveFactor !== void 0 && o !== qi) {
            const u = s.emissiveFactor;
            a.emissive = new Qe().setRGB(u[0], u[1], u[2], Sr)
        }
        return s.emissiveTexture !== void 0 && o !== qi && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Ut)),
        Promise.all(c).then(function() {
            const u = new o(a);
            return s.name && (u.name = s.name),
            Ul(u, s),
            t.associations.set(u, {
                materials: e
            }),
            s.extensions && jA(i, u, s),
            u
        })
    }
    createUniqueName(e) {
        const t = Ct.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
        t)
    }
    loadGeometries(e) {
        const t = this
          , r = this.extensions
          , i = this.primitiveCache;
        function s(a) {
            return r[Ft.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return ID(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , A = fae(c)
              , u = i[A];
            if (u)
                o.push(u.promise);
            else {
                let f;
                c.extensions && c.extensions[Ft.KHR_DRACO_MESH_COMPRESSION] ? f = s(c) : f = ID(new Jt, c, t),
                i[A] = {
                    primitive: c,
                    promise: f
                },
                o.push(f)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , r = this.json
          , i = this.extensions
          , s = r.meshes[e]
          , o = s.primitives
          , a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const A = o[l].material === void 0 ? cae(this.cache) : this.getDependency("material", o[l].material);
            a.push(A)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1)
              , A = l[l.length - 1]
              , u = [];
            for (let h = 0, d = A.length; h < d; h++) {
                const m = A[h]
                  , g = o[h];
                let p;
                const v = c[h];
                if (g.mode === to.TRIANGLES || g.mode === to.TRIANGLE_STRIP || g.mode === to.TRIANGLE_FAN || g.mode === void 0)
                    p = s.isSkinnedMesh === !0 ? new sa(m,v) : new dn(m,v),
                    p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
                    g.mode === to.TRIANGLE_STRIP ? p.geometry = MD(p.geometry, wz) : g.mode === to.TRIANGLE_FAN && (p.geometry = MD(p.geometry, RC));
                else if (g.mode === to.LINES)
                    p = new w0(m,v);
                else if (g.mode === to.LINE_STRIP)
                    p = new Yd(m,v);
                else if (g.mode === to.LINE_LOOP)
                    p = new Bse(m,v);
                else if (g.mode === to.POINTS)
                    p = new Mse(m,v);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
                Object.keys(p.geometry.morphAttributes).length > 0 && uae(p, s),
                p.name = t.createUniqueName(s.name || "mesh_" + e),
                Ul(p, s),
                g.extensions && jA(i, p, g),
                t.assignFinalMaterial(p),
                u.push(p)
            }
            for (let h = 0, d = u.length; h < d; h++)
                t.associations.set(u[h], {
                    meshes: e,
                    primitives: h
                });
            if (u.length === 1)
                return s.extensions && jA(i, u[0], s),
                u[0];
            const f = new ri;
            s.extensions && jA(i, f, s),
            t.associations.set(f, {
                meshes: e
            });
            for (let h = 0, d = u.length; h < d; h++)
                f.add(u[h]);
            return f
        })
    }
    loadCamera(e) {
        let t;
        const r = this.json.cameras[e]
          , i = r[r.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return r.type === "perspective" ? t = new Fr(Bt.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : r.type === "orthographic" && (t = new v0(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        r.name && (t.name = this.createUniqueName(r.name)),
        Ul(t, r),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , r = [];
        for (let i = 0, s = t.joints.length; i < s; i++)
            r.push(this._loadNodeShallow(t.joints[i]));
        return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null),
        Promise.all(r).then(function(i) {
            const s = i.pop()
              , o = i
              , a = []
              , l = [];
            for (let c = 0, A = o.length; c < A; c++) {
                const u = o[c];
                if (u) {
                    a.push(u);
                    const f = new He;
                    s !== null && f.fromArray(s.array, c * 16),
                    l.push(f)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
            }
            return new FA(a,l)
        })
    }
    loadAnimation(e) {
        const t = this.json
          , r = this
          , i = t.animations[e]
          , s = i.name ? i.name : "animation_" + e
          , o = []
          , a = []
          , l = []
          , c = []
          , A = [];
        for (let u = 0, f = i.channels.length; u < f; u++) {
            const h = i.channels[u]
              , d = i.samplers[h.sampler]
              , m = h.target
              , g = m.node
              , p = i.parameters !== void 0 ? i.parameters[d.input] : d.input
              , v = i.parameters !== void 0 ? i.parameters[d.output] : d.output;
            m.node !== void 0 && (o.push(this.getDependency("node", g)),
            a.push(this.getDependency("accessor", p)),
            l.push(this.getDependency("accessor", v)),
            c.push(d),
            A.push(m))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(A)]).then(function(u) {
            const f = u[0]
              , h = u[1]
              , d = u[2]
              , m = u[3]
              , g = u[4]
              , p = [];
            for (let v = 0, w = f.length; v < w; v++) {
                const _ = f[v]
                  , x = h[v]
                  , b = d[v]
                  , B = m[v]
                  , S = g[v];
                if (_ === void 0)
                    continue;
                _.updateMatrix && _.updateMatrix();
                const I = r._createAnimationTracks(_, x, b, B, S);
                if (I)
                    for (let M = 0; M < I.length; M++)
                        p.push(I[M])
            }
            return new ku(s,void 0,p)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , r = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function(s) {
            const o = r._getNodeRef(r.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = i.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = i.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , r = this
          , i = t.nodes[e]
          , s = r._loadNodeShallow(e)
          , o = []
          , a = i.children || [];
        for (let c = 0, A = a.length; c < A; c++)
            o.push(r.getDependency("node", a[c]));
        const l = i.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), l]).then(function(c) {
            const A = c[0]
              , u = c[1]
              , f = c[2];
            f !== null && A.traverse(function(h) {
                h.isSkinnedMesh && h.bind(f, dae)
            });
            for (let h = 0, d = u.length; h < d; h++)
                A.add(u[h]);
            return A
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , r = this.extensions
          , i = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const s = t.nodes[e]
          , o = s.name ? i.createUniqueName(s.name) : ""
          , a = []
          , l = i._invokeOne(function(c) {
            return c.createNodeMesh && c.createNodeMesh(e)
        });
        return l && a.push(l),
        s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(c) {
            return i._getNodeRef(i.cameraCache, s.camera, c)
        })),
        i._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(e)
        }).forEach(function(c) {
            a.push(c)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(c) {
            let A;
            if (s.isBone === !0 ? A = new k_ : c.length > 1 ? A = new ri : c.length === 1 ? A = c[0] : A = new Lt,
            A !== c[0])
                for (let u = 0, f = c.length; u < f; u++)
                    A.add(c[u]);
            if (s.name && (A.userData.name = s.name,
            A.name = o),
            Ul(A, s),
            s.extensions && jA(r, A, s),
            s.matrix !== void 0) {
                const u = new He;
                u.fromArray(s.matrix),
                A.applyMatrix4(u)
            } else
                s.translation !== void 0 && A.position.fromArray(s.translation),
                s.rotation !== void 0 && A.quaternion.fromArray(s.rotation),
                s.scale !== void 0 && A.scale.fromArray(s.scale);
            return i.associations.has(A) || i.associations.set(A, {}),
            i.associations.get(A).nodes = e,
            A
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , r = this.json.scenes[e]
          , i = this
          , s = new ri;
        r.name && (s.name = i.createUniqueName(r.name)),
        Ul(s, r),
        r.extensions && jA(t, s, r);
        const o = r.nodes || []
          , a = [];
        for (let l = 0, c = o.length; l < c; l++)
            a.push(i.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let A = 0, u = l.length; A < u; A++)
                s.add(l[A]);
            const c = A => {
                const u = new Map;
                for (const [f,h] of i.associations)
                    (f instanceof as || f instanceof Un) && u.set(f, h);
                return A.traverse(f => {
                    const h = i.associations.get(f);
                    h != null && u.set(f, h)
                }
                ),
                u
            }
            ;
            return i.associations = c(s),
            s
        })
    }
    _createAnimationTracks(e, t, r, i, s) {
        const o = []
          , a = e.name ? e.name : e.uuid
          , l = [];
        Mc[s.path] === Mc.weights ? e.traverse(function(f) {
            f.morphTargetInfluences && l.push(f.name ? f.name : f.uuid)
        }) : l.push(a);
        let c;
        switch (Mc[s.path]) {
        case Mc.weights:
            c = Ou;
            break;
        case Mc.rotation:
            c = nl;
            break;
        case Mc.position:
        case Mc.scale:
            c = ic;
            break;
        default:
            switch (r.itemSize) {
            case 1:
                c = Ou;
                break;
            case 2:
            case 3:
            default:
                c = ic;
                break
            }
            break
        }
        const A = i.interpolation !== void 0 ? lae[i.interpolation] : Ld
          , u = this._getArrayFromAccessor(r);
        for (let f = 0, h = l.length; f < h; f++) {
            const d = new c(l[f] + "." + Mc[s.path],t.array,u,A);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(d),
            o.push(d)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const r = QC(t.constructor)
              , i = new Float32Array(t.length);
            for (let s = 0, o = t.length; s < o; s++)
                i[s] = t[s] * r;
            t = i
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(r) {
            const i = this instanceof nl ? aae : $z;
            return new i(this.times,this.values,this.getValueSize() / 3,r)
        }
        ,
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function mae(n, e, t) {
    const r = e.attributes
      , i = new Hn;
    if (r.POSITION !== void 0) {
        const a = t.json.accessors[r.POSITION]
          , l = a.min
          , c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (i.set(new $(l[0],l[1],l[2]), new $(c[0],c[1],c[2])),
            a.normalized) {
                const A = QC(ld[a.componentType]);
                i.min.multiplyScalar(A),
                i.max.multiplyScalar(A)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new $
          , l = new $;
        for (let c = 0, A = s.length; c < A; c++) {
            const u = s[c];
            if (u.POSITION !== void 0) {
                const f = t.json.accessors[u.POSITION]
                  , h = f.min
                  , d = f.max;
                if (h !== void 0 && d !== void 0) {
                    if (l.setX(Math.max(Math.abs(h[0]), Math.abs(d[0]))),
                    l.setY(Math.max(Math.abs(h[1]), Math.abs(d[1]))),
                    l.setZ(Math.max(Math.abs(h[2]), Math.abs(d[2]))),
                    f.normalized) {
                        const m = QC(ld[f.componentType]);
                        l.multiplyScalar(m)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    n.boundingBox = i;
    const o = new Mi;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    n.boundingSphere = o
}
function ID(n, e, t) {
    const r = e.attributes
      , i = [];
    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            n.setAttribute(a, l)
        })
    }
    for (const o in r) {
        const a = kC[o] || o.toLowerCase();
        a in n.attributes || i.push(s(r[o], a))
    }
    if (e.indices !== void 0 && !n.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            n.setIndex(a)
        });
        i.push(o)
    }
    return Et.workingColorSpace !== Sr && "COLOR_0"in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Et.workingColorSpace}" not supported.`),
    Ul(n, e),
    mae(n, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? Aae(n, e.targets, t) : n
    })
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var ao = Uint8Array
  , Hh = Uint16Array
  , gae = Int32Array
  , Zz = new ao([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , Jz = new ao([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , vae = new ao([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , qz = function(n, e) {
    for (var t = new Hh(31), r = 0; r < 31; ++r)
        t[r] = e += 1 << n[r - 1];
    for (var i = new gae(t[30]), r = 1; r < 30; ++r)
        for (var s = t[r]; s < t[r + 1]; ++s)
            i[s] = s - t[r] << 5 | r;
    return {
        b: t,
        r: i
    }
}
  , e8 = qz(Zz, 2)
  , t8 = e8.b
  , yae = e8.r;
t8[28] = 258,
yae[258] = 28;
var wae = qz(Jz, 0)
  , _ae = wae.b
  , HC = new Hh(32768);
for (var In = 0; In < 32768; ++In) {
    var Sc = (In & 43690) >> 1 | (In & 21845) << 1;
    Sc = (Sc & 52428) >> 2 | (Sc & 13107) << 2,
    Sc = (Sc & 61680) >> 4 | (Sc & 3855) << 4,
    HC[In] = ((Sc & 65280) >> 8 | (Sc & 255) << 8) >> 1
}
var ng = function(n, e, t) {
    for (var r = n.length, i = 0, s = new Hh(e); i < r; ++i)
        n[i] && ++s[n[i] - 1];
    var o = new Hh(e);
    for (i = 1; i < e; ++i)
        o[i] = o[i - 1] + s[i - 1] << 1;
    var a;
    if (t) {
        a = new Hh(1 << e);
        var l = 15 - e;
        for (i = 0; i < r; ++i)
            if (n[i])
                for (var c = i << 4 | n[i], A = e - n[i], u = o[n[i] - 1]++ << A, f = u | (1 << A) - 1; u <= f; ++u)
                    a[HC[u] >> l] = c
    } else
        for (a = new Hh(r),
        i = 0; i < r; ++i)
            n[i] && (a[i] = HC[o[n[i] - 1]++] >> 15 - n[i]);
    return a
}
  , x0 = new ao(288);
for (var In = 0; In < 144; ++In)
    x0[In] = 8;
for (var In = 144; In < 256; ++In)
    x0[In] = 9;
for (var In = 256; In < 280; ++In)
    x0[In] = 7;
for (var In = 280; In < 288; ++In)
    x0[In] = 8;
var n8 = new ao(32);
for (var In = 0; In < 32; ++In)
    n8[In] = 5;
var xae = ng(x0, 9, 1)
  , bae = ng(n8, 5, 1)
  , sB = function(n) {
    for (var e = n[0], t = 1; t < n.length; ++t)
        n[t] > e && (e = n[t]);
    return e
}
  , Oo = function(n, e, t) {
    var r = e / 8 | 0;
    return (n[r] | n[r + 1] << 8) >> (e & 7) & t
}
  , oB = function(n, e) {
    var t = e / 8 | 0;
    return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >> (e & 7)
}
  , Eae = function(n) {
    return (n + 7) / 8 | 0
}
  , Bae = function(n, e, t) {
    return (e == null || e < 0) && (e = 0),
    (t == null || t > n.length) && (t = n.length),
    new ao(n.subarray(e, t))
}
  , Mae = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
  , Ko = function(n, e, t) {
    var r = new Error(e || Mae[n]);
    if (r.code = n,
    Error.captureStackTrace && Error.captureStackTrace(r, Ko),
    !t)
        throw r;
    return r
}
  , Sae = function(n, e, t, r) {
    var i = n.length
      , s = r ? r.length : 0;
    if (!i || e.f && !e.l)
        return t || new ao(0);
    var o = !t
      , a = o || e.i != 2
      , l = e.i;
    o && (t = new ao(i * 3));
    var c = function(ge) {
        var _e = t.length;
        if (ge > _e) {
            var se = new ao(Math.max(_e * 2, ge));
            se.set(t),
            t = se
        }
    }
      , A = e.f || 0
      , u = e.p || 0
      , f = e.b || 0
      , h = e.l
      , d = e.d
      , m = e.m
      , g = e.n
      , p = i * 8;
    do {
        if (!h) {
            A = Oo(n, u, 1);
            var v = Oo(n, u + 1, 3);
            if (u += 3,
            v)
                if (v == 1)
                    h = xae,
                    d = bae,
                    m = 9,
                    g = 5;
                else if (v == 2) {
                    var b = Oo(n, u, 31) + 257
                      , B = Oo(n, u + 10, 15) + 4
                      , S = b + Oo(n, u + 5, 31) + 1;
                    u += 14;
                    for (var I = new ao(S), M = new ao(19), L = 0; L < B; ++L)
                        M[vae[L]] = Oo(n, u + L * 3, 7);
                    u += B * 3;
                    for (var D = sB(M), T = (1 << D) - 1, y = ng(M, D, 1), L = 0; L < S; ) {
                        var E = y[Oo(n, u, T)];
                        u += E & 15;
                        var w = E >> 4;
                        if (w < 16)
                            I[L++] = w;
                        else {
                            var R = 0
                              , F = 0;
                            for (w == 16 ? (F = 3 + Oo(n, u, 3),
                            u += 2,
                            R = I[L - 1]) : w == 17 ? (F = 3 + Oo(n, u, 7),
                            u += 3) : w == 18 && (F = 11 + Oo(n, u, 127),
                            u += 7); F--; )
                                I[L++] = R
                        }
                    }
                    var O = I.subarray(0, b)
                      , z = I.subarray(b);
                    m = sB(O),
                    g = sB(z),
                    h = ng(O, m, 1),
                    d = ng(z, g, 1)
                } else
                    Ko(1);
            else {
                var w = Eae(u) + 4
                  , _ = n[w - 4] | n[w - 3] << 8
                  , x = w + _;
                if (x > i) {
                    l && Ko(0);
                    break
                }
                a && c(f + _),
                t.set(n.subarray(w, x), f),
                e.b = f += _,
                e.p = u = x * 8,
                e.f = A;
                continue
            }
            if (u > p) {
                l && Ko(0);
                break
            }
        }
        a && c(f + 131072);
        for (var j = (1 << m) - 1, Q = (1 << g) - 1, C = u; ; C = u) {
            var R = h[oB(n, u) & j]
              , W = R >> 4;
            if (u += R & 15,
            u > p) {
                l && Ko(0);
                break
            }
            if (R || Ko(2),
            W < 256)
                t[f++] = W;
            else if (W == 256) {
                C = u,
                h = null;
                break
            } else {
                var ee = W - 254;
                if (W > 264) {
                    var L = W - 257
                      , P = Zz[L];
                    ee = Oo(n, u, (1 << P) - 1) + t8[L],
                    u += P
                }
                var re = d[oB(n, u) & Q]
                  , ue = re >> 4;
                re || Ko(3),
                u += re & 15;
                var z = _ae[ue];
                if (ue > 3) {
                    var P = Jz[ue];
                    z += oB(n, u) & (1 << P) - 1,
                    u += P
                }
                if (u > p) {
                    l && Ko(0);
                    break
                }
                a && c(f + 131072);
                var le = f + ee;
                if (f < z) {
                    var me = s - z
                      , ie = Math.min(z, le);
                    for (me + f < 0 && Ko(3); f < ie; ++f)
                        t[f] = r[me + f]
                }
                for (; f < le; ++f)
                    t[f] = t[f - z]
            }
        }
        e.l = h,
        e.p = C,
        e.b = f,
        e.f = A,
        h && (A = 1,
        e.m = m,
        e.d = d,
        e.n = g)
    } while (!A);
    return f != t.length && o ? Bae(t, 0, f) : t.subarray(0, f)
}
  , Cae = new ao(0)
  , Tae = function(n, e) {
    return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && Ko(6, "invalid zlib data"),
    (n[1] >> 5 & 1) == +!e && Ko(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"),
    (n[1] >> 3 & 4) + 2
};
function Iae(n, e) {
    return Sae(n.subarray(Tae(n, e && e.dictionary), -4), {
        i: 2
    }, e && e.out, e && e.dictionary)
}
var Rae = typeof TextDecoder < "u" && new TextDecoder
  , Uae = 0;
try {
    Rae.decode(Cae, {
        stream: !0
    }),
    Uae = 1
} catch {}
function r8(n, e, t) {
    const r = t.length - n - 1;
    if (e >= t[r])
        return r - 1;
    if (e <= t[n])
        return n;
    let i = n
      , s = r
      , o = Math.floor((i + s) / 2);
    for (; e < t[o] || e >= t[o + 1]; )
        e < t[o] ? s = o : i = o,
        o = Math.floor((i + s) / 2);
    return o
}
function Fae(n, e, t, r) {
    const i = []
      , s = []
      , o = [];
    i[0] = 1;
    for (let a = 1; a <= t; ++a) {
        s[a] = e - r[n + 1 - a],
        o[a] = r[n + a] - e;
        let l = 0;
        for (let c = 0; c < a; ++c) {
            const A = o[c + 1]
              , u = s[a - c]
              , f = i[c] / (A + u);
            i[c] = l + A * f,
            l = u * f
        }
        i[a] = l
    }
    return i
}
function Pae(n, e, t, r) {
    const i = r8(n, r, e)
      , s = Fae(i, r, n, e)
      , o = new Pt(0,0,0,0);
    for (let a = 0; a <= n; ++a) {
        const l = t[i - n + a]
          , c = s[a]
          , A = l.w * c;
        o.x += l.x * A,
        o.y += l.y * A,
        o.z += l.z * A,
        o.w += l.w * c
    }
    return o
}
function Lae(n, e, t, r, i) {
    const s = [];
    for (let u = 0; u <= t; ++u)
        s[u] = 0;
    const o = [];
    for (let u = 0; u <= r; ++u)
        o[u] = s.slice(0);
    const a = [];
    for (let u = 0; u <= t; ++u)
        a[u] = s.slice(0);
    a[0][0] = 1;
    const l = s.slice(0)
      , c = s.slice(0);
    for (let u = 1; u <= t; ++u) {
        l[u] = e - i[n + 1 - u],
        c[u] = i[n + u] - e;
        let f = 0;
        for (let h = 0; h < u; ++h) {
            const d = c[h + 1]
              , m = l[u - h];
            a[u][h] = d + m;
            const g = a[h][u - 1] / a[u][h];
            a[h][u] = f + d * g,
            f = m * g
        }
        a[u][u] = f
    }
    for (let u = 0; u <= t; ++u)
        o[0][u] = a[u][t];
    for (let u = 0; u <= t; ++u) {
        let f = 0
          , h = 1;
        const d = [];
        for (let m = 0; m <= t; ++m)
            d[m] = s.slice(0);
        d[0][0] = 1;
        for (let m = 1; m <= r; ++m) {
            let g = 0;
            const p = u - m
              , v = t - m;
            u >= m && (d[h][0] = d[f][0] / a[v + 1][p],
            g = d[h][0] * a[p][v]);
            const w = p >= -1 ? 1 : -p
              , _ = u - 1 <= v ? m - 1 : t - u;
            for (let b = w; b <= _; ++b)
                d[h][b] = (d[f][b] - d[f][b - 1]) / a[v + 1][p + b],
                g += d[h][b] * a[p + b][v];
            u <= v && (d[h][m] = -d[f][m - 1] / a[v + 1][u],
            g += d[h][m] * a[u][v]),
            o[m][u] = g;
            const x = f;
            f = h,
            h = x
        }
    }
    let A = t;
    for (let u = 1; u <= r; ++u) {
        for (let f = 0; f <= t; ++f)
            o[u][f] *= A;
        A *= t - u
    }
    return o
}
function Dae(n, e, t, r, i) {
    const s = i < n ? i : n
      , o = []
      , a = r8(n, r, e)
      , l = Lae(a, r, n, s, e)
      , c = [];
    for (let A = 0; A < t.length; ++A) {
        const u = t[A].clone()
          , f = u.w;
        u.x *= f,
        u.y *= f,
        u.z *= f,
        c[A] = u
    }
    for (let A = 0; A <= s; ++A) {
        const u = c[a - n].clone().multiplyScalar(l[A][0]);
        for (let f = 1; f <= n; ++f)
            u.add(c[a - n + f].clone().multiplyScalar(l[A][f]));
        o[A] = u
    }
    for (let A = s + 1; A <= i + 1; ++A)
        o[A] = new Pt(0,0,0);
    return o
}
function Nae(n, e) {
    let t = 1;
    for (let i = 2; i <= n; ++i)
        t *= i;
    let r = 1;
    for (let i = 2; i <= e; ++i)
        r *= i;
    for (let i = 2; i <= n - e; ++i)
        r *= i;
    return t / r
}
function Oae(n) {
    const e = n.length
      , t = []
      , r = [];
    for (let s = 0; s < e; ++s) {
        const o = n[s];
        t[s] = new $(o.x,o.y,o.z),
        r[s] = o.w
    }
    const i = [];
    for (let s = 0; s < e; ++s) {
        const o = t[s].clone();
        for (let a = 1; a <= s; ++a)
            o.sub(i[s - a].clone().multiplyScalar(Nae(s, a) * r[a]));
        i[s] = o.divideScalar(r[0])
    }
    return i
}
function kae(n, e, t, r, i) {
    const s = Dae(n, e, t, r, i);
    return Oae(s)
}
class Qae extends Cse {
    constructor(e, t, r, i, s) {
        super(),
        this.degree = e,
        this.knots = t,
        this.controlPoints = [],
        this.startKnot = i || 0,
        this.endKnot = s || this.knots.length - 1;
        for (let o = 0; o < r.length; ++o) {
            const a = r[o];
            this.controlPoints[o] = new Pt(a.x,a.y,a.z,a.w)
        }
    }
    getPoint(e, t=new $) {
        const r = t
          , i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot])
          , s = Pae(this.degree, this.knots, this.controlPoints, i);
        return s.w !== 1 && s.divideScalar(s.w),
        r.set(s.x, s.y, s.z)
    }
    getTangent(e, t=new $) {
        const r = t
          , i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0])
          , s = kae(this.degree, this.knots, this.controlPoints, i, 1);
        return r.copy(s[1]).normalize(),
        r
    }
}
let St, ur, Fi;
class Hae extends rl {
    constructor(e) {
        super(e)
    }
    load(e, t, r, i) {
        const s = this
          , o = s.path === "" ? ad.extractUrlBase(e) : s.path
          , a = new v1(this.manager);
        a.setPath(s.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(s.requestHeader),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            try {
                t(s.parse(l, o))
            } catch (c) {
                i ? i(c) : console.error(c),
                s.manager.itemError(e)
            }
        }, r, i)
    }
    parse(e, t) {
        if (Kae(e))
            St = new Wae().parse(e);
        else {
            const i = o8(e);
            if (!Xae(i))
                throw new Error("THREE.FBXLoader: Unknown format.");
            if (UD(i) < 7e3)
                throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + UD(i));
            St = new jae().parse(i)
        }
        const r = new PA(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
        return new zae(r,this.manager).parse(St)
    }
}
class zae {
    constructor(e, t) {
        this.textureLoader = e,
        this.manager = t
    }
    parse() {
        ur = this.parseConnections();
        const e = this.parseImages()
          , t = this.parseTextures(e)
          , r = this.parseMaterials(t)
          , i = this.parseDeformers()
          , s = new Gae().parse(i);
        return this.parseScene(i, s, r),
        Fi
    }
    parseConnections() {
        const e = new Map;
        return "Connections"in St && St.Connections.connections.forEach(function(r) {
            const i = r[0]
              , s = r[1]
              , o = r[2];
            e.has(i) || e.set(i, {
                parents: [],
                children: []
            });
            const a = {
                ID: s,
                relationship: o
            };
            e.get(i).parents.push(a),
            e.has(s) || e.set(s, {
                parents: [],
                children: []
            });
            const l = {
                ID: i,
                relationship: o
            };
            e.get(s).children.push(l)
        }),
        e
    }
    parseImages() {
        const e = {}
          , t = {};
        if ("Video"in St.Objects) {
            const r = St.Objects.Video;
            for (const i in r) {
                const s = r[i]
                  , o = parseInt(i);
                if (e[o] = s.RelativeFilename || s.Filename,
                "Content"in s) {
                    const a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0
                      , l = typeof s.Content == "string" && s.Content !== "";
                    if (a || l) {
                        const c = this.parseImage(r[i]);
                        t[s.RelativeFilename || s.Filename] = c
                    }
                }
            }
        }
        for (const r in e) {
            const i = e[r];
            t[i] !== void 0 ? e[r] = t[i] : e[r] = e[r].split("\\").pop()
        }
        return e
    }
    parseImage(e) {
        const t = e.Content
          , r = e.RelativeFilename || e.Filename
          , i = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
        let s;
        switch (i) {
        case "bmp":
            s = "image/bmp";
            break;
        case "jpg":
        case "jpeg":
            s = "image/jpeg";
            break;
        case "png":
            s = "image/png";
            break;
        case "tif":
            s = "image/tiff";
            break;
        case "tga":
            this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", r),
            s = "image/tga";
            break;
        default:
            console.warn('FBXLoader: Image type "' + i + '" is not supported.');
            return
        }
        if (typeof t == "string")
            return "data:" + s + ";base64," + t;
        {
            const o = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([o],{
                type: s
            }))
        }
    }
    parseTextures(e) {
        const t = new Map;
        if ("Texture"in St.Objects) {
            const r = St.Objects.Texture;
            for (const i in r) {
                const s = this.parseTexture(r[i], e);
                t.set(parseInt(i), s)
            }
        }
        return t
    }
    parseTexture(e, t) {
        const r = this.loadTexture(e, t);
        r.ID = e.id,
        r.name = e.attrName;
        const i = e.WrapModeU
          , s = e.WrapModeV
          , o = i !== void 0 ? i.value : 0
          , a = s !== void 0 ? s.value : 0;
        if (r.wrapS = o === 0 ? zs : Rs,
        r.wrapT = a === 0 ? zs : Rs,
        "Scaling"in e) {
            const l = e.Scaling.value;
            r.repeat.x = l[0],
            r.repeat.y = l[1]
        }
        if ("Translation"in e) {
            const l = e.Translation.value;
            r.offset.x = l[0],
            r.offset.y = l[1]
        }
        return r
    }
    loadTexture(e, t) {
        const r = new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"])
          , i = e.FileName.split(".").pop().toLowerCase()
          , s = r.has(i) ? this.manager.getHandler(`.${i}`) : this.textureLoader;
        if (!s)
            return console.warn(`FBXLoader: ${i.toUpperCase()} loader not found, creating placeholder texture for`, e.RelativeFilename),
            new Un;
        const o = s.path;
        o || s.setPath(this.textureLoader.path);
        const a = ur.get(e.id).children;
        let l;
        a !== void 0 && a.length > 0 && t[a[0].ID] !== void 0 && (l = t[a[0].ID],
        (l.indexOf("blob:") === 0 || l.indexOf("data:") === 0) && s.setPath(void 0));
        const c = s.load(l);
        return s.setPath(o),
        c
    }
    parseMaterials(e) {
        const t = new Map;
        if ("Material"in St.Objects) {
            const r = St.Objects.Material;
            for (const i in r) {
                const s = this.parseMaterial(r[i], e);
                s !== null && t.set(parseInt(i), s)
            }
        }
        return t
    }
    parseMaterial(e, t) {
        const r = e.id
          , i = e.attrName;
        let s = e.ShadingModel;
        if (typeof s == "object" && (s = s.value),
        !ur.has(r))
            return null;
        const o = this.parseParameters(e, t, r);
        let a;
        switch (s.toLowerCase()) {
        case "phong":
            a = new JE;
            break;
        case "lambert":
            a = new Kse;
            break;
        default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s),
            a = new JE;
            break
        }
        return a.setValues(o),
        a.name = i,
        a
    }
    parseParameters(e, t, r) {
        const i = {};
        e.BumpFactor && (i.bumpScale = e.BumpFactor.value),
        e.Diffuse ? i.color = Et.toWorkingColorSpace(new Qe().fromArray(e.Diffuse.value), Ut) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (i.color = Et.toWorkingColorSpace(new Qe().fromArray(e.DiffuseColor.value), Ut)),
        e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value),
        e.Emissive ? i.emissive = Et.toWorkingColorSpace(new Qe().fromArray(e.Emissive.value), Ut) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (i.emissive = Et.toWorkingColorSpace(new Qe().fromArray(e.EmissiveColor.value), Ut)),
        e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
        e.Opacity && (i.opacity = parseFloat(e.Opacity.value)),
        i.opacity < 1 && (i.transparent = !0),
        e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value),
        e.Shininess && (i.shininess = e.Shininess.value),
        e.Specular ? i.specular = Et.toWorkingColorSpace(new Qe().fromArray(e.Specular.value), Ut) : e.SpecularColor && e.SpecularColor.type === "Color" && (i.specular = Et.toWorkingColorSpace(new Qe().fromArray(e.SpecularColor.value), Ut));
        const s = this;
        return ur.get(r).children.forEach(function(o) {
            const a = o.relationship;
            switch (a) {
            case "Bump":
                i.bumpMap = s.getTexture(t, o.ID);
                break;
            case "Maya|TEX_ao_map":
                i.aoMap = s.getTexture(t, o.ID);
                break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
                i.map = s.getTexture(t, o.ID),
                i.map !== void 0 && (i.map.colorSpace = Ut);
                break;
            case "DisplacementColor":
                i.displacementMap = s.getTexture(t, o.ID);
                break;
            case "EmissiveColor":
                i.emissiveMap = s.getTexture(t, o.ID),
                i.emissiveMap !== void 0 && (i.emissiveMap.colorSpace = Ut);
                break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
                i.normalMap = s.getTexture(t, o.ID);
                break;
            case "ReflectionColor":
                i.envMap = s.getTexture(t, o.ID),
                i.envMap !== void 0 && (i.envMap.mapping = kg,
                i.envMap.colorSpace = Ut);
                break;
            case "SpecularColor":
                i.specularMap = s.getTexture(t, o.ID),
                i.specularMap !== void 0 && (i.specularMap.colorSpace = Ut);
                break;
            case "TransparentColor":
            case "TransparencyFactor":
                i.alphaMap = s.getTexture(t, o.ID),
                i.transparent = !0;
                break;
            case "AmbientColor":
            case "ShininessExponent":
            case "SpecularFactor":
            case "VectorDisplacementColor":
            default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
                break
            }
        }),
        i
    }
    getTexture(e, t) {
        return "LayeredTexture"in St.Objects && t in St.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
        t = ur.get(t).children[0].ID),
        e.get(t)
    }
    parseDeformers() {
        const e = {}
          , t = {};
        if ("Deformer"in St.Objects) {
            const r = St.Objects.Deformer;
            for (const i in r) {
                const s = r[i]
                  , o = ur.get(parseInt(i));
                if (s.attrType === "Skin") {
                    const a = this.parseSkeleton(o, r);
                    a.ID = i,
                    o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                    a.geometryID = o.parents[0].ID,
                    e[i] = a
                } else if (s.attrType === "BlendShape") {
                    const a = {
                        id: i
                    };
                    a.rawTargets = this.parseMorphTargets(o, r),
                    a.id = i,
                    o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                    t[i] = a
                }
            }
        }
        return {
            skeletons: e,
            morphTargets: t
        }
    }
    parseSkeleton(e, t) {
        const r = [];
        return e.children.forEach(function(i) {
            const s = t[i.ID];
            if (s.attrType !== "Cluster")
                return;
            const o = {
                ID: i.ID,
                indices: [],
                weights: [],
                transformLink: new He().fromArray(s.TransformLink.a)
            };
            "Indexes"in s && (o.indices = s.Indexes.a,
            o.weights = s.Weights.a),
            r.push(o)
        }),
        {
            rawBones: r,
            bones: []
        }
    }
    parseMorphTargets(e, t) {
        const r = [];
        for (let i = 0; i < e.children.length; i++) {
            const s = e.children[i]
              , o = t[s.ID]
              , a = {
                name: o.attrName,
                initialWeight: o.DeformPercent,
                id: o.id,
                fullWeights: o.FullWeights.a
            };
            if (o.attrType !== "BlendShapeChannel")
                return;
            a.geoID = ur.get(parseInt(s.ID)).children.filter(function(l) {
                return l.relationship === void 0
            })[0].ID,
            r.push(a)
        }
        return r
    }
    parseScene(e, t, r) {
        Fi = new ri;
        const i = this.parseModels(e.skeletons, t, r)
          , s = St.Objects.Model
          , o = this;
        i.forEach(function(l) {
            const c = s[l.ID];
            o.setLookAtProperties(l, c),
            ur.get(l.ID).parents.forEach(function(u) {
                const f = i.get(u.ID);
                f !== void 0 && f.add(l)
            }),
            l.parent === null && Fi.add(l)
        }),
        this.bindSkeleton(e.skeletons, t, i),
        this.addGlobalSceneSettings(),
        Fi.traverse(function(l) {
            if (l.userData.transformData) {
                l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix,
                l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
                const c = s8(l.userData.transformData);
                l.applyMatrix4(c),
                l.updateWorldMatrix()
            }
        });
        const a = new Vae().parse();
        Fi.children.length === 1 && Fi.children[0].isGroup && (Fi.children[0].animations = a,
        Fi = Fi.children[0]),
        Fi.animations = a
    }
    parseModels(e, t, r) {
        const i = new Map
          , s = St.Objects.Model;
        for (const o in s) {
            const a = parseInt(o)
              , l = s[o]
              , c = ur.get(a);
            let A = this.buildSkeleton(c, e, a, l.attrName);
            if (!A) {
                switch (l.attrType) {
                case "Camera":
                    A = this.createCamera(c);
                    break;
                case "Light":
                    A = this.createLight(c);
                    break;
                case "Mesh":
                    A = this.createMesh(c, t, r);
                    break;
                case "NurbsCurve":
                    A = this.createCurve(c, t);
                    break;
                case "LimbNode":
                case "Root":
                    A = new k_;
                    break;
                case "Null":
                default:
                    A = new ri;
                    break
                }
                A.name = l.attrName ? Ct.sanitizeNodeName(l.attrName) : "",
                A.userData.originalName = l.attrName,
                A.ID = a
            }
            this.getTransformData(A, l),
            i.set(a, A)
        }
        return i
    }
    buildSkeleton(e, t, r, i) {
        let s = null;
        return e.parents.forEach(function(o) {
            for (const a in t) {
                const l = t[a];
                l.rawBones.forEach(function(c, A) {
                    if (c.ID === o.ID) {
                        const u = s;
                        s = new k_,
                        s.matrixWorld.copy(c.transformLink),
                        s.name = i ? Ct.sanitizeNodeName(i) : "",
                        s.userData.originalName = i,
                        s.ID = r,
                        l.bones[A] = s,
                        u !== null && s.add(u)
                    }
                })
            }
        }),
        s
    }
    createCamera(e) {
        let t, r;
        if (e.children.forEach(function(i) {
            const s = St.Objects.NodeAttribute[i.ID];
            s !== void 0 && (r = s)
        }),
        r === void 0)
            t = new Lt;
        else {
            let i = 0;
            r.CameraProjectionType !== void 0 && r.CameraProjectionType.value === 1 && (i = 1);
            let s = 1;
            r.NearPlane !== void 0 && (s = r.NearPlane.value / 1e3);
            let o = 1e3;
            r.FarPlane !== void 0 && (o = r.FarPlane.value / 1e3);
            let a = window.innerWidth
              , l = window.innerHeight;
            r.AspectWidth !== void 0 && r.AspectHeight !== void 0 && (a = r.AspectWidth.value,
            l = r.AspectHeight.value);
            const c = a / l;
            let A = 45;
            r.FieldOfView !== void 0 && (A = r.FieldOfView.value);
            const u = r.FocalLength ? r.FocalLength.value : null;
            switch (i) {
            case 0:
                t = new Fr(A,c,s,o),
                u !== null && t.setFocalLength(u);
                break;
            case 1:
                console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),
                t = new Lt;
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown camera type " + i + "."),
                t = new Lt;
                break
            }
        }
        return t
    }
    createLight(e) {
        let t, r;
        if (e.children.forEach(function(i) {
            const s = St.Objects.NodeAttribute[i.ID];
            s !== void 0 && (r = s)
        }),
        r === void 0)
            t = new Lt;
        else {
            let i;
            r.LightType === void 0 ? i = 0 : i = r.LightType.value;
            let s = 16777215;
            r.Color !== void 0 && (s = Et.toWorkingColorSpace(new Qe().fromArray(r.Color.value), Ut));
            let o = r.Intensity === void 0 ? 1 : r.Intensity.value / 100;
            r.CastLightOnObject !== void 0 && r.CastLightOnObject.value === 0 && (o = 0);
            let a = 0;
            r.FarAttenuationEnd !== void 0 && (r.EnableFarAttenuation !== void 0 && r.EnableFarAttenuation.value === 0 ? a = 0 : a = r.FarAttenuationEnd.value);
            const l = 1;
            switch (i) {
            case 0:
                t = new NC(s,o,a,l);
                break;
            case 1:
                t = new WR(s,o);
                break;
            case 2:
                let c = Math.PI / 3;
                r.InnerAngle !== void 0 && (c = Bt.degToRad(r.InnerAngle.value));
                let A = 0;
                r.OuterAngle !== void 0 && (A = Bt.degToRad(r.OuterAngle.value),
                A = Math.max(A, 1)),
                t = new Gz(s,o,a,c,A,l);
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."),
                t = new NC(s,o);
                break
            }
            r.CastShadows !== void 0 && r.CastShadows.value === 1 && (t.castShadow = !0)
        }
        return t
    }
    createMesh(e, t, r) {
        let i, s = null, o = null;
        const a = [];
        return e.children.forEach(function(l) {
            t.has(l.ID) && (s = t.get(l.ID)),
            r.has(l.ID) && a.push(r.get(l.ID))
        }),
        a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new JE({
            name: rl.DEFAULT_MATERIAL_NAME,
            color: 13421772
        }),
        a.push(o)),
        "color"in s.attributes && a.forEach(function(l) {
            l.vertexColors = !0
        }),
        s.FBX_Deformer ? (i = new sa(s,o),
        i.normalizeSkinWeights()) : i = new dn(s,o),
        i
    }
    createCurve(e, t) {
        const r = e.children.reduce(function(s, o) {
            return t.has(o.ID) && (s = t.get(o.ID)),
            s
        }, null)
          , i = new Ac({
            name: rl.DEFAULT_MATERIAL_NAME,
            color: 3342591,
            linewidth: 1
        });
        return new Yd(r,i)
    }
    getTransformData(e, t) {
        const r = {};
        "InheritType"in t && (r.inheritType = parseInt(t.InheritType.value)),
        "RotationOrder"in t ? r.eulerOrder = Xg(t.RotationOrder.value) : r.eulerOrder = Xg(0),
        "Lcl_Translation"in t && (r.translation = t.Lcl_Translation.value),
        "PreRotation"in t && (r.preRotation = t.PreRotation.value),
        "Lcl_Rotation"in t && (r.rotation = t.Lcl_Rotation.value),
        "PostRotation"in t && (r.postRotation = t.PostRotation.value),
        "Lcl_Scaling"in t && (r.scale = t.Lcl_Scaling.value),
        "ScalingOffset"in t && (r.scalingOffset = t.ScalingOffset.value),
        "ScalingPivot"in t && (r.scalingPivot = t.ScalingPivot.value),
        "RotationOffset"in t && (r.rotationOffset = t.RotationOffset.value),
        "RotationPivot"in t && (r.rotationPivot = t.RotationPivot.value),
        e.userData.transformData = r
    }
    setLookAtProperties(e, t) {
        "LookAtProperty"in t && ur.get(e.ID).children.forEach(function(i) {
            if (i.relationship === "LookAtProperty") {
                const s = St.Objects.Model[i.ID];
                if ("Lcl_Translation"in s) {
                    const o = s.Lcl_Translation.value;
                    e.target !== void 0 ? (e.target.position.fromArray(o),
                    Fi.add(e.target)) : e.lookAt(new $().fromArray(o))
                }
            }
        })
    }
    bindSkeleton(e, t, r) {
        const i = this.parsePoseNodes();
        for (const s in e) {
            const o = e[s];
            ur.get(parseInt(o.ID)).parents.forEach(function(l) {
                if (t.has(l.ID)) {
                    const c = l.ID;
                    ur.get(c).parents.forEach(function(u) {
                        r.has(u.ID) && r.get(u.ID).bind(new FA(o.bones), i[u.ID])
                    })
                }
            })
        }
    }
    parsePoseNodes() {
        const e = {};
        if ("Pose"in St.Objects) {
            const t = St.Objects.Pose;
            for (const r in t)
                if (t[r].attrType === "BindPose" && t[r].NbPoseNodes > 0) {
                    const i = t[r].PoseNode;
                    Array.isArray(i) ? i.forEach(function(s) {
                        e[s.Node] = new He().fromArray(s.Matrix.a)
                    }) : e[i.Node] = new He().fromArray(i.Matrix.a)
                }
        }
        return e
    }
    addGlobalSceneSettings() {
        if ("GlobalSettings"in St) {
            if ("AmbientColor"in St.GlobalSettings) {
                const e = St.GlobalSettings.AmbientColor.value
                  , t = e[0]
                  , r = e[1]
                  , i = e[2];
                if (t !== 0 || r !== 0 || i !== 0) {
                    const s = new Qe().setRGB(t, r, i, Ut);
                    Fi.add(new Vz(s,1))
                }
            }
            "UnitScaleFactor"in St.GlobalSettings && (Fi.userData.unitScaleFactor = St.GlobalSettings.UnitScaleFactor.value)
        }
    }
}
class Gae {
    constructor() {
        this.negativeMaterialIndices = !1
    }
    parse(e) {
        const t = new Map;
        if ("Geometry"in St.Objects) {
            const r = St.Objects.Geometry;
            for (const i in r) {
                const s = ur.get(parseInt(i))
                  , o = this.parseGeometry(s, r[i], e);
                t.set(parseInt(i), o)
            }
        }
        return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
        t
    }
    parseGeometry(e, t, r) {
        switch (t.attrType) {
        case "Mesh":
            return this.parseMeshGeometry(e, t, r);
        case "NurbsCurve":
            return this.parseNurbsGeometry(t)
        }
    }
    parseMeshGeometry(e, t, r) {
        const i = r.skeletons
          , s = []
          , o = e.parents.map(function(u) {
            return St.Objects.Model[u.ID]
        });
        if (o.length === 0)
            return;
        const a = e.children.reduce(function(u, f) {
            return i[f.ID] !== void 0 && (u = i[f.ID]),
            u
        }, null);
        e.children.forEach(function(u) {
            r.morphTargets[u.ID] !== void 0 && s.push(r.morphTargets[u.ID])
        });
        const l = o[0]
          , c = {};
        "RotationOrder"in l && (c.eulerOrder = Xg(l.RotationOrder.value)),
        "InheritType"in l && (c.inheritType = parseInt(l.InheritType.value)),
        "GeometricTranslation"in l && (c.translation = l.GeometricTranslation.value),
        "GeometricRotation"in l && (c.rotation = l.GeometricRotation.value),
        "GeometricScaling"in l && (c.scale = l.GeometricScaling.value);
        const A = s8(c);
        return this.genGeometry(t, a, s, A)
    }
    genGeometry(e, t, r, i) {
        const s = new Jt;
        e.attrName && (s.name = e.attrName);
        const o = this.parseGeoNode(e, t)
          , a = this.genBuffers(o)
          , l = new xn(a.vertex,3);
        if (l.applyMatrix4(i),
        s.setAttribute("position", l),
        a.colors.length > 0 && s.setAttribute("color", new xn(a.colors,3)),
        t && (s.setAttribute("skinIndex", new f1(a.weightsIndices,4)),
        s.setAttribute("skinWeight", new xn(a.vertexWeights,4)),
        s.FBX_Deformer = t),
        a.normal.length > 0) {
            const c = new dt().getNormalMatrix(i)
              , A = new xn(a.normal,3);
            A.applyNormalMatrix(c),
            s.setAttribute("normal", A)
        }
        if (a.uvs.forEach(function(c, A) {
            const u = A === 0 ? "uv" : `uv${A}`;
            s.setAttribute(u, new xn(a.uvs[A],2))
        }),
        o.material && o.material.mappingType !== "AllSame") {
            let c = a.materialIndex[0]
              , A = 0;
            if (a.materialIndex.forEach(function(u, f) {
                u !== c && (s.addGroup(A, f - A, c),
                c = u,
                A = f)
            }),
            s.groups.length > 0) {
                const u = s.groups[s.groups.length - 1]
                  , f = u.start + u.count;
                f !== a.materialIndex.length && s.addGroup(f, a.materialIndex.length - f, c)
            }
            s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
        }
        return this.addMorphTargets(s, e, r, i),
        s
    }
    parseGeoNode(e, t) {
        const r = {};
        if (r.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [],
        r.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [],
        e.LayerElementColor && (r.color = this.parseVertexColors(e.LayerElementColor[0])),
        e.LayerElementMaterial && (r.material = this.parseMaterialIndices(e.LayerElementMaterial[0])),
        e.LayerElementNormal && (r.normal = this.parseNormals(e.LayerElementNormal[0])),
        e.LayerElementUV) {
            r.uv = [];
            let i = 0;
            for (; e.LayerElementUV[i]; )
                e.LayerElementUV[i].UV && r.uv.push(this.parseUVs(e.LayerElementUV[i])),
                i++
        }
        return r.weightTable = {},
        t !== null && (r.skeleton = t,
        t.rawBones.forEach(function(i, s) {
            i.indices.forEach(function(o, a) {
                r.weightTable[o] === void 0 && (r.weightTable[o] = []),
                r.weightTable[o].push({
                    id: s,
                    weight: i.weights[a]
                })
            })
        })),
        r
    }
    genBuffers(e) {
        const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
        };
        let r = 0
          , i = 0
          , s = !1
          , o = []
          , a = []
          , l = []
          , c = []
          , A = []
          , u = [];
        const f = this;
        return e.vertexIndices.forEach(function(h, d) {
            let m, g = !1;
            h < 0 && (h = h ^ -1,
            g = !0);
            let p = []
              , v = [];
            if (o.push(h * 3, h * 3 + 1, h * 3 + 2),
            e.color) {
                const w = Wv(d, r, h, e.color);
                l.push(w[0], w[1], w[2])
            }
            if (e.skeleton) {
                if (e.weightTable[h] !== void 0 && e.weightTable[h].forEach(function(w) {
                    v.push(w.weight),
                    p.push(w.id)
                }),
                v.length > 4) {
                    s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                    s = !0);
                    const w = [0, 0, 0, 0]
                      , _ = [0, 0, 0, 0];
                    v.forEach(function(x, b) {
                        let B = x
                          , S = p[b];
                        _.forEach(function(I, M, L) {
                            if (B > I) {
                                L[M] = B,
                                B = I;
                                const D = w[M];
                                w[M] = S,
                                S = D
                            }
                        })
                    }),
                    p = w,
                    v = _
                }
                for (; v.length < 4; )
                    v.push(0),
                    p.push(0);
                for (let w = 0; w < 4; ++w)
                    A.push(v[w]),
                    u.push(p[w])
            }
            if (e.normal) {
                const w = Wv(d, r, h, e.normal);
                a.push(w[0], w[1], w[2])
            }
            e.material && e.material.mappingType !== "AllSame" && (m = Wv(d, r, h, e.material)[0],
            m < 0 && (f.negativeMaterialIndices = !0,
            m = 0)),
            e.uv && e.uv.forEach(function(w, _) {
                const x = Wv(d, r, h, w);
                c[_] === void 0 && (c[_] = []),
                c[_].push(x[0]),
                c[_].push(x[1])
            }),
            i++,
            g && (f.genFace(t, e, o, m, a, l, c, A, u, i),
            r++,
            i = 0,
            o = [],
            a = [],
            l = [],
            c = [],
            A = [],
            u = [])
        }),
        t
    }
    getNormalNewell(e) {
        const t = new $(0,0,0);
        for (let r = 0; r < e.length; r++) {
            const i = e[r]
              , s = e[(r + 1) % e.length];
            t.x += (i.y - s.y) * (i.z + s.z),
            t.y += (i.z - s.z) * (i.x + s.x),
            t.z += (i.x - s.x) * (i.y + s.y)
        }
        return t.normalize(),
        t
    }
    getNormalTangentAndBitangent(e) {
        const t = this.getNormalNewell(e)
          , i = (Math.abs(t.z) > .5 ? new $(0,1,0) : new $(0,0,1)).cross(t).normalize()
          , s = t.clone().cross(i).normalize();
        return {
            normal: t,
            tangent: i,
            bitangent: s
        }
    }
    flattenVertex(e, t, r) {
        return new We(e.dot(t),e.dot(r))
    }
    genFace(e, t, r, i, s, o, a, l, c, A) {
        let u;
        if (A > 3) {
            const f = []
              , h = t.baseVertexPositions || t.vertexPositions;
            for (let p = 0; p < r.length; p += 3)
                f.push(new $(h[r[p]],h[r[p + 1]],h[r[p + 2]]));
            const {tangent: d, bitangent: m} = this.getNormalTangentAndBitangent(f)
              , g = [];
            for (const p of f)
                g.push(this.flattenVertex(p, d, m));
            u = GR.triangulateShape(g, [])
        } else
            u = [[0, 1, 2]];
        for (const [f,h,d] of u)
            e.vertex.push(t.vertexPositions[r[f * 3]]),
            e.vertex.push(t.vertexPositions[r[f * 3 + 1]]),
            e.vertex.push(t.vertexPositions[r[f * 3 + 2]]),
            e.vertex.push(t.vertexPositions[r[h * 3]]),
            e.vertex.push(t.vertexPositions[r[h * 3 + 1]]),
            e.vertex.push(t.vertexPositions[r[h * 3 + 2]]),
            e.vertex.push(t.vertexPositions[r[d * 3]]),
            e.vertex.push(t.vertexPositions[r[d * 3 + 1]]),
            e.vertex.push(t.vertexPositions[r[d * 3 + 2]]),
            t.skeleton && (e.vertexWeights.push(l[f * 4]),
            e.vertexWeights.push(l[f * 4 + 1]),
            e.vertexWeights.push(l[f * 4 + 2]),
            e.vertexWeights.push(l[f * 4 + 3]),
            e.vertexWeights.push(l[h * 4]),
            e.vertexWeights.push(l[h * 4 + 1]),
            e.vertexWeights.push(l[h * 4 + 2]),
            e.vertexWeights.push(l[h * 4 + 3]),
            e.vertexWeights.push(l[d * 4]),
            e.vertexWeights.push(l[d * 4 + 1]),
            e.vertexWeights.push(l[d * 4 + 2]),
            e.vertexWeights.push(l[d * 4 + 3]),
            e.weightsIndices.push(c[f * 4]),
            e.weightsIndices.push(c[f * 4 + 1]),
            e.weightsIndices.push(c[f * 4 + 2]),
            e.weightsIndices.push(c[f * 4 + 3]),
            e.weightsIndices.push(c[h * 4]),
            e.weightsIndices.push(c[h * 4 + 1]),
            e.weightsIndices.push(c[h * 4 + 2]),
            e.weightsIndices.push(c[h * 4 + 3]),
            e.weightsIndices.push(c[d * 4]),
            e.weightsIndices.push(c[d * 4 + 1]),
            e.weightsIndices.push(c[d * 4 + 2]),
            e.weightsIndices.push(c[d * 4 + 3])),
            t.color && (e.colors.push(o[f * 3]),
            e.colors.push(o[f * 3 + 1]),
            e.colors.push(o[f * 3 + 2]),
            e.colors.push(o[h * 3]),
            e.colors.push(o[h * 3 + 1]),
            e.colors.push(o[h * 3 + 2]),
            e.colors.push(o[d * 3]),
            e.colors.push(o[d * 3 + 1]),
            e.colors.push(o[d * 3 + 2])),
            t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(i),
            e.materialIndex.push(i),
            e.materialIndex.push(i)),
            t.normal && (e.normal.push(s[f * 3]),
            e.normal.push(s[f * 3 + 1]),
            e.normal.push(s[f * 3 + 2]),
            e.normal.push(s[h * 3]),
            e.normal.push(s[h * 3 + 1]),
            e.normal.push(s[h * 3 + 2]),
            e.normal.push(s[d * 3]),
            e.normal.push(s[d * 3 + 1]),
            e.normal.push(s[d * 3 + 2])),
            t.uv && t.uv.forEach(function(m, g) {
                e.uvs[g] === void 0 && (e.uvs[g] = []),
                e.uvs[g].push(a[g][f * 2]),
                e.uvs[g].push(a[g][f * 2 + 1]),
                e.uvs[g].push(a[g][h * 2]),
                e.uvs[g].push(a[g][h * 2 + 1]),
                e.uvs[g].push(a[g][d * 2]),
                e.uvs[g].push(a[g][d * 2 + 1])
            })
    }
    addMorphTargets(e, t, r, i) {
        if (r.length === 0)
            return;
        e.morphTargetsRelative = !0,
        e.morphAttributes.position = [];
        const s = this;
        r.forEach(function(o) {
            o.rawTargets.forEach(function(a) {
                const l = St.Objects.Geometry[a.geoID];
                l !== void 0 && s.genMorphGeometry(e, t, l, i, a.name)
            })
        })
    }
    genMorphGeometry(e, t, r, i, s) {
        const o = t.Vertices !== void 0 ? t.Vertices.a : []
          , a = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : []
          , l = r.Vertices !== void 0 ? r.Vertices.a : []
          , c = r.Indexes !== void 0 ? r.Indexes.a : []
          , A = e.attributes.position.count * 3
          , u = new Float32Array(A);
        for (let m = 0; m < c.length; m++) {
            const g = c[m] * 3;
            u[g] = l[m * 3],
            u[g + 1] = l[m * 3 + 1],
            u[g + 2] = l[m * 3 + 2]
        }
        const f = {
            vertexIndices: a,
            vertexPositions: u,
            baseVertexPositions: o
        }
          , h = this.genBuffers(f)
          , d = new xn(h.vertex,3);
        d.name = s || r.attrName,
        d.applyMatrix4(i),
        e.morphAttributes.position.push(d)
    }
    parseNormals(e) {
        const t = e.MappingInformationType
          , r = e.ReferenceInformationType
          , i = e.Normals.a;
        let s = [];
        return r === "IndexToDirect" && ("NormalIndex"in e ? s = e.NormalIndex.a : "NormalsIndex"in e && (s = e.NormalsIndex.a)),
        {
            dataSize: 3,
            buffer: i,
            indices: s,
            mappingType: t,
            referenceType: r
        }
    }
    parseUVs(e) {
        const t = e.MappingInformationType
          , r = e.ReferenceInformationType
          , i = e.UV.a;
        let s = [];
        return r === "IndexToDirect" && (s = e.UVIndex.a),
        {
            dataSize: 2,
            buffer: i,
            indices: s,
            mappingType: t,
            referenceType: r
        }
    }
    parseVertexColors(e) {
        const t = e.MappingInformationType
          , r = e.ReferenceInformationType
          , i = e.Colors.a;
        let s = [];
        r === "IndexToDirect" && (s = e.ColorIndex.a);
        for (let o = 0, a = new Qe; o < i.length; o += 4)
            a.fromArray(i, o),
            Et.toWorkingColorSpace(a, Ut),
            a.toArray(i, o);
        return {
            dataSize: 4,
            buffer: i,
            indices: s,
            mappingType: t,
            referenceType: r
        }
    }
    parseMaterialIndices(e) {
        const t = e.MappingInformationType
          , r = e.ReferenceInformationType;
        if (t === "NoMappingInformation")
            return {
                dataSize: 1,
                buffer: [0],
                indices: [0],
                mappingType: "AllSame",
                referenceType: r
            };
        const i = e.Materials.a
          , s = [];
        for (let o = 0; o < i.length; ++o)
            s.push(o);
        return {
            dataSize: 1,
            buffer: i,
            indices: s,
            mappingType: t,
            referenceType: r
        }
    }
    parseNurbsGeometry(e) {
        const t = parseInt(e.Order);
        if (isNaN(t))
            return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id),
            new Jt;
        const r = t - 1
          , i = e.KnotVector.a
          , s = []
          , o = e.Points.a;
        for (let u = 0, f = o.length; u < f; u += 4)
            s.push(new Pt().fromArray(o, u));
        let a, l;
        if (e.Form === "Closed")
            s.push(s[0]);
        else if (e.Form === "Periodic") {
            a = r,
            l = i.length - 1 - a;
            for (let u = 0; u < r; ++u)
                s.push(s[u])
        }
        const A = new Qae(r,i,s,a,l).getPoints(s.length * 12);
        return new Jt().setFromPoints(A)
    }
}
class Vae {
    parse() {
        const e = []
          , t = this.parseClips();
        if (t !== void 0)
            for (const r in t) {
                const i = t[r]
                  , s = this.addClip(i);
                e.push(s)
            }
        return e
    }
    parseClips() {
        if (St.Objects.AnimationCurve === void 0)
            return;
        const e = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(e);
        const t = this.parseAnimationLayers(e);
        return this.parseAnimStacks(t)
    }
    parseAnimationCurveNodes() {
        const e = St.Objects.AnimationCurveNode
          , t = new Map;
        for (const r in e) {
            const i = e[r];
            if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
                const s = {
                    id: i.id,
                    attr: i.attrName,
                    curves: {}
                };
                t.set(s.id, s)
            }
        }
        return t
    }
    parseAnimationCurves(e) {
        const t = St.Objects.AnimationCurve;
        for (const r in t) {
            const i = {
                id: t[r].id,
                times: t[r].KeyTime.a.map(Yae),
                values: t[r].KeyValueFloat.a
            }
              , s = ur.get(i.id);
            if (s !== void 0) {
                const o = s.parents[0].ID
                  , a = s.parents[0].relationship;
                a.match(/X/) ? e.get(o).curves.x = i : a.match(/Y/) ? e.get(o).curves.y = i : a.match(/Z/) ? e.get(o).curves.z = i : a.match(/DeformPercent/) && e.has(o) && (e.get(o).curves.morph = i)
            }
        }
    }
    parseAnimationLayers(e) {
        const t = St.Objects.AnimationLayer
          , r = new Map;
        for (const i in t) {
            const s = []
              , o = ur.get(parseInt(i));
            o !== void 0 && (o.children.forEach(function(l, c) {
                if (e.has(l.ID)) {
                    const A = e.get(l.ID);
                    if (A.curves.x !== void 0 || A.curves.y !== void 0 || A.curves.z !== void 0) {
                        if (s[c] === void 0) {
                            const u = ur.get(l.ID).parents.filter(function(f) {
                                return f.relationship !== void 0
                            })[0].ID;
                            if (u !== void 0) {
                                const f = St.Objects.Model[u.toString()];
                                if (f === void 0) {
                                    console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                                    return
                                }
                                const h = {
                                    modelName: f.attrName ? Ct.sanitizeNodeName(f.attrName) : "",
                                    ID: f.id,
                                    initialPosition: [0, 0, 0],
                                    initialRotation: [0, 0, 0],
                                    initialScale: [1, 1, 1]
                                };
                                Fi.traverse(function(d) {
                                    d.ID === f.id && (h.transform = d.matrix,
                                    d.userData.transformData && (h.eulerOrder = d.userData.transformData.eulerOrder))
                                }),
                                h.transform || (h.transform = new He),
                                "PreRotation"in f && (h.preRotation = f.PreRotation.value),
                                "PostRotation"in f && (h.postRotation = f.PostRotation.value),
                                s[c] = h
                            }
                        }
                        s[c] && (s[c][A.attr] = A)
                    } else if (A.curves.morph !== void 0) {
                        if (s[c] === void 0) {
                            const u = ur.get(l.ID).parents.filter(function(p) {
                                return p.relationship !== void 0
                            })[0].ID
                              , f = ur.get(u).parents[0].ID
                              , h = ur.get(f).parents[0].ID
                              , d = ur.get(h).parents[0].ID
                              , m = St.Objects.Model[d]
                              , g = {
                                modelName: m.attrName ? Ct.sanitizeNodeName(m.attrName) : "",
                                morphName: St.Objects.Deformer[u].attrName
                            };
                            s[c] = g
                        }
                        s[c][A.attr] = A
                    }
                }
            }),
            r.set(parseInt(i), s))
        }
        return r
    }
    parseAnimStacks(e) {
        const t = St.Objects.AnimationStack
          , r = {};
        for (const i in t) {
            const s = ur.get(parseInt(i)).children;
            s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const o = e.get(s[0].ID);
            r[i] = {
                name: t[i].attrName,
                layer: o
            }
        }
        return r
    }
    addClip(e) {
        let t = [];
        const r = this;
        return e.layer.forEach(function(i) {
            t = t.concat(r.generateTracks(i))
        }),
        new ku(e.name,-1,t)
    }
    generateTracks(e) {
        const t = [];
        let r = new $
          , i = new $;
        if (e.transform && e.transform.decompose(r, new nt, i),
        r = r.toArray(),
        i = i.toArray(),
        e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
            const s = this.generateVectorTrack(e.modelName, e.T.curves, r, "position");
            s !== void 0 && t.push(s)
        }
        if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
            const s = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
            s !== void 0 && t.push(s)
        }
        if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
            const s = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
            s !== void 0 && t.push(s)
        }
        if (e.DeformPercent !== void 0) {
            const s = this.generateMorphTrack(e);
            s !== void 0 && t.push(s)
        }
        return t
    }
    generateVectorTrack(e, t, r, i) {
        const s = this.getTimesForAllAxes(t)
          , o = this.getKeyframeTrackValues(s, t, r);
        return new ic(e + "." + i,s,o)
    }
    generateRotationTrack(e, t, r, i, s) {
        let o, a;
        if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
            const f = this.interpolateRotations(t.x, t.y, t.z, s);
            o = f[0],
            a = f[1]
        }
        const l = Xg(0);
        r !== void 0 && (r = r.map(Bt.degToRad),
        r.push(l),
        r = new nr().fromArray(r),
        r = new nt().setFromEuler(r)),
        i !== void 0 && (i = i.map(Bt.degToRad),
        i.push(l),
        i = new nr().fromArray(i),
        i = new nt().setFromEuler(i).invert());
        const c = new nt
          , A = new nr
          , u = [];
        if (!a || !o)
            return new nl(e + ".quaternion",[0],[0]);
        for (let f = 0; f < a.length; f += 3)
            A.set(a[f], a[f + 1], a[f + 2], s),
            c.setFromEuler(A),
            r !== void 0 && c.premultiply(r),
            i !== void 0 && c.multiply(i),
            f > 2 && new nt().fromArray(u, (f - 3) / 3 * 4).dot(c) < 0 && c.set(-c.x, -c.y, -c.z, -c.w),
            c.toArray(u, f / 3 * 4);
        return new nl(e + ".quaternion",o,u)
    }
    generateMorphTrack(e) {
        const t = e.DeformPercent.curves.morph
          , r = t.values.map(function(s) {
            return s / 100
        })
          , i = Fi.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
        return new Ou(e.modelName + ".morphTargetInfluences[" + i + "]",t.times,r)
    }
    getTimesForAllAxes(e) {
        let t = [];
        if (e.x !== void 0 && (t = t.concat(e.x.times)),
        e.y !== void 0 && (t = t.concat(e.y.times)),
        e.z !== void 0 && (t = t.concat(e.z.times)),
        t = t.sort(function(r, i) {
            return r - i
        }),
        t.length > 1) {
            let r = 1
              , i = t[0];
            for (let s = 1; s < t.length; s++) {
                const o = t[s];
                o !== i && (t[r] = o,
                i = o,
                r++)
            }
            t = t.slice(0, r)
        }
        return t
    }
    getKeyframeTrackValues(e, t, r) {
        const i = r
          , s = [];
        let o = -1
          , a = -1
          , l = -1;
        return e.forEach(function(c) {
            if (t.x && (o = t.x.times.indexOf(c)),
            t.y && (a = t.y.times.indexOf(c)),
            t.z && (l = t.z.times.indexOf(c)),
            o !== -1) {
                const A = t.x.values[o];
                s.push(A),
                i[0] = A
            } else
                s.push(i[0]);
            if (a !== -1) {
                const A = t.y.values[a];
                s.push(A),
                i[1] = A
            } else
                s.push(i[1]);
            if (l !== -1) {
                const A = t.z.values[l];
                s.push(A),
                i[2] = A
            } else
                s.push(i[2])
        }),
        s
    }
    interpolateRotations(e, t, r, i) {
        const s = []
          , o = [];
        s.push(e.times[0]),
        o.push(Bt.degToRad(e.values[0])),
        o.push(Bt.degToRad(t.values[0])),
        o.push(Bt.degToRad(r.values[0]));
        for (let a = 1; a < e.values.length; a++) {
            const l = [e.values[a - 1], t.values[a - 1], r.values[a - 1]];
            if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
                continue;
            const c = l.map(Bt.degToRad)
              , A = [e.values[a], t.values[a], r.values[a]];
            if (isNaN(A[0]) || isNaN(A[1]) || isNaN(A[2]))
                continue;
            const u = A.map(Bt.degToRad)
              , f = [A[0] - l[0], A[1] - l[1], A[2] - l[2]]
              , h = [Math.abs(f[0]), Math.abs(f[1]), Math.abs(f[2])];
            if (h[0] >= 180 || h[1] >= 180 || h[2] >= 180) {
                const m = Math.max(...h) / 180
                  , g = new nr(...c,i)
                  , p = new nr(...u,i)
                  , v = new nt().setFromEuler(g)
                  , w = new nt().setFromEuler(p);
                v.dot(w) && w.set(-w.x, -w.y, -w.z, -w.w);
                const _ = e.times[a - 1]
                  , x = e.times[a] - _
                  , b = new nt
                  , B = new nr;
                for (let S = 0; S < 1; S += 1 / m)
                    b.copy(v.clone().slerp(w.clone(), S)),
                    s.push(_ + S * x),
                    B.setFromQuaternion(b, i),
                    o.push(B.x),
                    o.push(B.y),
                    o.push(B.z)
            } else
                s.push(e.times[a]),
                o.push(Bt.degToRad(e.values[a])),
                o.push(Bt.degToRad(t.values[a])),
                o.push(Bt.degToRad(r.values[a]))
        }
        return [s, o]
    }
}
class jae {
    getPrevNode() {
        return this.nodeStack[this.currentIndent - 2]
    }
    getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1]
    }
    getCurrentProp() {
        return this.currentProp
    }
    pushStack(e) {
        this.nodeStack.push(e),
        this.currentIndent += 1
    }
    popStack() {
        this.nodeStack.pop(),
        this.currentIndent -= 1
    }
    setCurrentProp(e, t) {
        this.currentProp = e,
        this.currentPropName = t
    }
    parse(e) {
        this.currentIndent = 0,
        this.allNodes = new i8,
        this.nodeStack = [],
        this.currentProp = [],
        this.currentPropName = "";
        const t = this
          , r = e.split(/[\r\n]+/);
        return r.forEach(function(i, s) {
            const o = i.match(/^[\s\t]*;/)
              , a = i.match(/^[\s\t]*$/);
            if (o || a)
                return;
            const l = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", "")
              , c = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
              , A = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
            l ? t.parseNodeBegin(i, l) : c ? t.parseNodeProperty(i, c, r[++s]) : A ? t.popStack() : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i)
        }),
        this.allNodes
    }
    parseNodeBegin(e, t) {
        const r = t[1].trim().replace(/^"/, "").replace(/"$/, "")
          , i = t[2].split(",").map(function(l) {
            return l.trim().replace(/^"/, "").replace(/"$/, "")
        })
          , s = {
            name: r
        }
          , o = this.parseNodeAttr(i)
          , a = this.getCurrentNode();
        this.currentIndent === 0 ? this.allNodes.add(r, s) : r in a ? (r === "PoseNode" ? a.PoseNode.push(s) : a[r].id !== void 0 && (a[r] = {},
        a[r][a[r].id] = a[r]),
        o.id !== "" && (a[r][o.id] = s)) : typeof o.id == "number" ? (a[r] = {},
        a[r][o.id] = s) : r !== "Properties70" && (r === "PoseNode" ? a[r] = [s] : a[r] = s),
        typeof o.id == "number" && (s.id = o.id),
        o.name !== "" && (s.attrName = o.name),
        o.type !== "" && (s.attrType = o.type),
        this.pushStack(s)
    }
    parseNodeAttr(e) {
        let t = e[0];
        e[0] !== "" && (t = parseInt(e[0]),
        isNaN(t) && (t = e[0]));
        let r = ""
          , i = "";
        return e.length > 1 && (r = e[1].replace(/^(\w+)::/, ""),
        i = e[2]),
        {
            id: t,
            name: r,
            type: i
        }
    }
    parseNodeProperty(e, t, r) {
        let i = t[1].replace(/^"/, "").replace(/"$/, "").trim()
          , s = t[2].replace(/^"/, "").replace(/"$/, "").trim();
        i === "Content" && s === "," && (s = r.replace(/"/g, "").replace(/,$/, "").trim());
        const o = this.getCurrentNode();
        if (o.name === "Properties70") {
            this.parseNodeSpecialProperty(e, i, s);
            return
        }
        if (i === "C") {
            const l = s.split(",").slice(1)
              , c = parseInt(l[0])
              , A = parseInt(l[1]);
            let u = s.split(",").slice(3);
            u = u.map(function(f) {
                return f.trim().replace(/^"/, "")
            }),
            i = "connections",
            s = [c, A],
            Zae(s, u),
            o[i] === void 0 && (o[i] = [])
        }
        i === "Node" && (o.id = s),
        i in o && Array.isArray(o[i]) ? o[i].push(s) : i !== "a" ? o[i] = s : o.a = s,
        this.setCurrentProp(o, i),
        i === "a" && s.slice(-1) !== "," && (o.a = lB(s))
    }
    parseNodePropertyContinued(e) {
        const t = this.getCurrentNode();
        t.a += e,
        e.slice(-1) !== "," && (t.a = lB(t.a))
    }
    parseNodeSpecialProperty(e, t, r) {
        const i = r.split('",').map(function(A) {
            return A.trim().replace(/^\"/, "").replace(/\s/, "_")
        })
          , s = i[0]
          , o = i[1]
          , a = i[2]
          , l = i[3];
        let c = i[4];
        switch (o) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
            c = parseFloat(c);
            break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
            c = lB(c);
            break
        }
        this.getPrevNode()[s] = {
            type: o,
            type2: a,
            flag: l,
            value: c
        },
        this.setCurrentProp(this.getPrevNode(), s)
    }
}
class Wae {
    parse(e) {
        const t = new RD(e);
        t.skip(23);
        const r = t.getUint32();
        if (r < 6400)
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + r);
        const i = new i8;
        for (; !this.endOfContent(t); ) {
            const s = this.parseNode(t, r);
            s !== null && i.add(s.name, s)
        }
        return i
    }
    endOfContent(e) {
        return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
    }
    parseNode(e, t) {
        const r = {}
          , i = t >= 7500 ? e.getUint64() : e.getUint32()
          , s = t >= 7500 ? e.getUint64() : e.getUint32();
        t >= 7500 ? e.getUint64() : e.getUint32();
        const o = e.getUint8()
          , a = e.getString(o);
        if (i === 0)
            return null;
        const l = [];
        for (let f = 0; f < s; f++)
            l.push(this.parseProperty(e));
        const c = l.length > 0 ? l[0] : ""
          , A = l.length > 1 ? l[1] : ""
          , u = l.length > 2 ? l[2] : "";
        for (r.singleProperty = s === 1 && e.getOffset() === i; i > e.getOffset(); ) {
            const f = this.parseNode(e, t);
            f !== null && this.parseSubNode(a, r, f)
        }
        return r.propertyList = l,
        typeof c == "number" && (r.id = c),
        A !== "" && (r.attrName = A),
        u !== "" && (r.attrType = u),
        a !== "" && (r.name = a),
        r
    }
    parseSubNode(e, t, r) {
        if (r.singleProperty === !0) {
            const i = r.propertyList[0];
            Array.isArray(i) ? (t[r.name] = r,
            r.a = i) : t[r.name] = i
        } else if (e === "Connections" && r.name === "C") {
            const i = [];
            r.propertyList.forEach(function(s, o) {
                o !== 0 && i.push(s)
            }),
            t.connections === void 0 && (t.connections = []),
            t.connections.push(i)
        } else if (r.name === "Properties70")
            Object.keys(r).forEach(function(s) {
                t[s] = r[s]
            });
        else if (e === "Properties70" && r.name === "P") {
            let i = r.propertyList[0]
              , s = r.propertyList[1];
            const o = r.propertyList[2]
              , a = r.propertyList[3];
            let l;
            i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")),
            s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")),
            s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? l = [r.propertyList[4], r.propertyList[5], r.propertyList[6]] : l = r.propertyList[4],
            t[i] = {
                type: s,
                type2: o,
                flag: a,
                value: l
            }
        } else
            t[r.name] === void 0 ? typeof r.id == "number" ? (t[r.name] = {},
            t[r.name][r.id] = r) : t[r.name] = r : r.name === "PoseNode" ? (Array.isArray(t[r.name]) || (t[r.name] = [t[r.name]]),
            t[r.name].push(r)) : t[r.name][r.id] === void 0 && (t[r.name][r.id] = r)
    }
    parseProperty(e) {
        const t = e.getString(1);
        let r;
        switch (t) {
        case "C":
            return e.getBoolean();
        case "D":
            return e.getFloat64();
        case "F":
            return e.getFloat32();
        case "I":
            return e.getInt32();
        case "L":
            return e.getInt64();
        case "R":
            return r = e.getUint32(),
            e.getArrayBuffer(r);
        case "S":
            return r = e.getUint32(),
            e.getString(r);
        case "Y":
            return e.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
            const i = e.getUint32()
              , s = e.getUint32()
              , o = e.getUint32();
            if (s === 0)
                switch (t) {
                case "b":
                case "c":
                    return e.getBooleanArray(i);
                case "d":
                    return e.getFloat64Array(i);
                case "f":
                    return e.getFloat32Array(i);
                case "i":
                    return e.getInt32Array(i);
                case "l":
                    return e.getInt64Array(i)
                }
            const a = Iae(new Uint8Array(e.getArrayBuffer(o)))
              , l = new RD(a.buffer);
            switch (t) {
            case "b":
            case "c":
                return l.getBooleanArray(i);
            case "d":
                return l.getFloat64Array(i);
            case "f":
                return l.getFloat32Array(i);
            case "i":
                return l.getInt32Array(i);
            case "l":
                return l.getInt64Array(i)
            }
            break;
        default:
            throw new Error("THREE.FBXLoader: Unknown property type " + t)
        }
    }
}
class RD {
    constructor(e, t) {
        this.dv = new DataView(e),
        this.offset = 0,
        this.littleEndian = t !== void 0 ? t : !0,
        this._textDecoder = new TextDecoder
    }
    getOffset() {
        return this.offset
    }
    size() {
        return this.dv.buffer.byteLength
    }
    skip(e) {
        this.offset += e
    }
    getBoolean() {
        return (this.getUint8() & 1) === 1
    }
    getBooleanArray(e) {
        const t = [];
        for (let r = 0; r < e; r++)
            t.push(this.getBoolean());
        return t
    }
    getUint8() {
        const e = this.dv.getUint8(this.offset);
        return this.offset += 1,
        e
    }
    getInt16() {
        const e = this.dv.getInt16(this.offset, this.littleEndian);
        return this.offset += 2,
        e
    }
    getInt32() {
        const e = this.dv.getInt32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getInt32Array(e) {
        const t = [];
        for (let r = 0; r < e; r++)
            t.push(this.getInt32());
        return t
    }
    getUint32() {
        const e = this.dv.getUint32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getInt64() {
        let e, t;
        return this.littleEndian ? (e = this.getUint32(),
        t = this.getUint32()) : (t = this.getUint32(),
        e = this.getUint32()),
        t & 2147483648 ? (t = ~t & 4294967295,
        e = ~e & 4294967295,
        e === 4294967295 && (t = t + 1 & 4294967295),
        e = e + 1 & 4294967295,
        -(t * 4294967296 + e)) : t * 4294967296 + e
    }
    getInt64Array(e) {
        const t = [];
        for (let r = 0; r < e; r++)
            t.push(this.getInt64());
        return t
    }
    getUint64() {
        let e, t;
        return this.littleEndian ? (e = this.getUint32(),
        t = this.getUint32()) : (t = this.getUint32(),
        e = this.getUint32()),
        t * 4294967296 + e
    }
    getFloat32() {
        const e = this.dv.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4,
        e
    }
    getFloat32Array(e) {
        const t = [];
        for (let r = 0; r < e; r++)
            t.push(this.getFloat32());
        return t
    }
    getFloat64() {
        const e = this.dv.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8,
        e
    }
    getFloat64Array(e) {
        const t = [];
        for (let r = 0; r < e; r++)
            t.push(this.getFloat64());
        return t
    }
    getArrayBuffer(e) {
        const t = this.dv.buffer.slice(this.offset, this.offset + e);
        return this.offset += e,
        t
    }
    getString(e) {
        const t = this.offset;
        let r = new Uint8Array(this.dv.buffer,t,e);
        this.skip(e);
        const i = r.indexOf(0);
        return i >= 0 && (r = new Uint8Array(this.dv.buffer,t,i)),
        this._textDecoder.decode(r)
    }
}
class i8 {
    add(e, t) {
        this[e] = t
    }
}
function Kae(n) {
    const e = "Kaydara FBX Binary  \0";
    return n.byteLength >= e.length && e === o8(n, 0, e.length)
}
function Xae(n) {
    const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
    let t = 0;
    function r(i) {
        const s = n[i - 1];
        return n = n.slice(t + i),
        t++,
        s
    }
    for (let i = 0; i < e.length; ++i)
        if (r(1) === e[i])
            return !1;
    return !0
}
function UD(n) {
    const e = /FBXVersion: (\d+)/
      , t = n.match(e);
    if (t)
        return parseInt(t[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
}
function Yae(n) {
    return n / 46186158e3
}
const $ae = [];
function Wv(n, e, t, r) {
    let i;
    switch (r.mappingType) {
    case "ByPolygonVertex":
        i = n;
        break;
    case "ByPolygon":
        i = e;
        break;
    case "ByVertice":
        i = t;
        break;
    case "AllSame":
        i = r.indices[0];
        break;
    default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType)
    }
    r.referenceType === "IndexToDirect" && (i = r.indices[i]);
    const s = i * r.dataSize
      , o = s + r.dataSize;
    return Jae($ae, r.buffer, s, o)
}
const aB = new nr
  , Ef = new $;
function s8(n) {
    const e = new He
      , t = new He
      , r = new He
      , i = new He
      , s = new He
      , o = new He
      , a = new He
      , l = new He
      , c = new He
      , A = new He
      , u = new He
      , f = new He
      , h = n.inheritType ? n.inheritType : 0;
    n.translation && e.setPosition(Ef.fromArray(n.translation));
    const d = Xg(0);
    if (n.preRotation) {
        const L = n.preRotation.map(Bt.degToRad);
        L.push(d),
        t.makeRotationFromEuler(aB.fromArray(L))
    }
    if (n.rotation) {
        const L = n.rotation.map(Bt.degToRad);
        L.push(n.eulerOrder || d),
        r.makeRotationFromEuler(aB.fromArray(L))
    }
    if (n.postRotation) {
        const L = n.postRotation.map(Bt.degToRad);
        L.push(d),
        i.makeRotationFromEuler(aB.fromArray(L)),
        i.invert()
    }
    n.scale && s.scale(Ef.fromArray(n.scale)),
    n.scalingOffset && a.setPosition(Ef.fromArray(n.scalingOffset)),
    n.scalingPivot && o.setPosition(Ef.fromArray(n.scalingPivot)),
    n.rotationOffset && l.setPosition(Ef.fromArray(n.rotationOffset)),
    n.rotationPivot && c.setPosition(Ef.fromArray(n.rotationPivot)),
    n.parentMatrixWorld && (u.copy(n.parentMatrix),
    A.copy(n.parentMatrixWorld));
    const m = t.clone().multiply(r).multiply(i)
      , g = new He;
    g.extractRotation(A);
    const p = new He;
    p.copyPosition(A);
    const v = p.clone().invert().multiply(A)
      , w = g.clone().invert().multiply(v)
      , _ = s
      , x = new He;
    if (h === 0)
        x.copy(g).multiply(m).multiply(w).multiply(_);
    else if (h === 1)
        x.copy(g).multiply(w).multiply(m).multiply(_);
    else {
        const D = new He().scale(new $().setFromMatrixScale(u)).clone().invert()
          , T = w.clone().multiply(D);
        x.copy(g).multiply(m).multiply(T).multiply(_)
    }
    const b = c.clone().invert()
      , B = o.clone().invert();
    let S = e.clone().multiply(l).multiply(c).multiply(t).multiply(r).multiply(i).multiply(b).multiply(a).multiply(o).multiply(s).multiply(B);
    const I = new He().copyPosition(S)
      , M = A.clone().multiply(I);
    return f.copyPosition(M),
    S = f.clone().multiply(x),
    S.premultiply(A.invert()),
    S
}
function Xg(n) {
    n = n || 0;
    const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return n === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
    e[0]) : e[n]
}
function lB(n) {
    return n.split(",").map(function(t) {
        return parseFloat(t)
    })
}
function o8(n, e, t) {
    return e === void 0 && (e = 0),
    t === void 0 && (t = n.byteLength),
    new TextDecoder().decode(new Uint8Array(n,e,t))
}
function Zae(n, e) {
    for (let t = 0, r = n.length, i = e.length; t < i; t++,
    r++)
        n[r] = e[t]
}
function Jae(n, e, t, r) {
    for (let i = t, s = 0; i < r; i++,
    s++)
        n[s] = e[i];
    return n
}
let Qp, cB, Bf, Kv;
function AB(n, e=1 / 0, t=null) {
    cB || (cB = new cc(2,2,1,1)),
    Bf || (Bf = new mr({
        uniforms: {
            blitTexture: new YR(n)
        },
        vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
        fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = sRGBTransferOETF( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
    })),
    Bf.uniforms.blitTexture.value = n,
    Bf.defines.IS_SRGB = n.colorSpace == Ut,
    Bf.needsUpdate = !0,
    Kv || (Kv = new dn(cB,Bf),
    Kv.frustumCulled = !1);
    const r = new Fr
      , i = new Gg;
    i.add(Kv),
    t === null && (t = Qp = new y0({
        antialias: !1
    }));
    const s = Math.min(n.image.width, e)
      , o = Math.min(n.image.height, e);
    t.setSize(s, o),
    t.clear(),
    t.render(i, r);
    const a = document.createElement("canvas")
      , l = a.getContext("2d");
    a.width = s,
    a.height = o,
    l.drawImage(t.domElement, 0, 0, s, o);
    const c = new Sse(a);
    return c.minFilter = n.minFilter,
    c.magFilter = n.magFilter,
    c.wrapS = n.wrapS,
    c.wrapT = n.wrapT,
    c.colorSpace = n.colorSpace,
    c.name = n.name,
    Qp && (Qp.forceContextLoss(),
    Qp.dispose(),
    Qp = null),
    c
}
const FD = {
    POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
    NORMAL: ["byte normalized", "short normalized"],
    TANGENT: ["byte normalized", "short normalized"],
    TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class ZR {
    constructor() {
        this.pluginCallbacks = [],
        this.register(function(e) {
            return new lle(e)
        }),
        this.register(function(e) {
            return new cle(e)
        }),
        this.register(function(e) {
            return new hle(e)
        }),
        this.register(function(e) {
            return new dle(e)
        }),
        this.register(function(e) {
            return new ple(e)
        }),
        this.register(function(e) {
            return new mle(e)
        }),
        this.register(function(e) {
            return new Ale(e)
        }),
        this.register(function(e) {
            return new ule(e)
        }),
        this.register(function(e) {
            return new fle(e)
        }),
        this.register(function(e) {
            return new gle(e)
        }),
        this.register(function(e) {
            return new vle(e)
        }),
        this.register(function(e) {
            return new yle(e)
        }),
        this.register(function(e) {
            return new wle(e)
        }),
        this.register(function(e) {
            return new _le(e)
        })
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, r, i) {
        const s = new ale
          , o = [];
        for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
            o.push(this.pluginCallbacks[a](s));
        s.setPlugins(o),
        s.write(e, t, i).catch(r)
    }
    parseAsync(e, t) {
        const r = this;
        return new Promise(function(i, s) {
            r.parse(e, i, s, t)
        }
        )
    }
}
const Rt = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
}
  , uB = "KHR_mesh_quantization"
  , Us = {};
Us[Xr] = Rt.NEAREST;
Us[SR] = Rt.NEAREST_MIPMAP_NEAREST;
Us[Dh] = Rt.NEAREST_MIPMAP_LINEAR;
Us[Lr] = Rt.LINEAR;
Us[qm] = Rt.LINEAR_MIPMAP_NEAREST;
Us[ea] = Rt.LINEAR_MIPMAP_LINEAR;
Us[Rs] = Rt.CLAMP_TO_EDGE;
Us[zs] = Rt.REPEAT;
Us[Qg] = Rt.MIRRORED_REPEAT;
const PD = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
}
  , qae = new Qe
  , LD = 12
  , ele = 1179937895
  , tle = 2
  , DD = 8
  , nle = 1313821514
  , rle = 5130562;
function bm(n, e) {
    return n.length === e.length && n.every(function(t, r) {
        return t === e[r]
    })
}
function ile(n) {
    return new TextEncoder().encode(n).buffer
}
function sle(n) {
    return bm(n.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
}
function ole(n, e, t) {
    const r = {
        min: new Array(n.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(n.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let i = e; i < e + t; i++)
        for (let s = 0; s < n.itemSize; s++) {
            let o;
            n.itemSize > 4 ? o = n.array[i * n.itemSize + s] : (s === 0 ? o = n.getX(i) : s === 1 ? o = n.getY(i) : s === 2 ? o = n.getZ(i) : s === 3 && (o = n.getW(i)),
            n.normalized === !0 && (o = Bt.normalize(o, n.array))),
            r.min[s] = Math.min(r.min[s], o),
            r.max[s] = Math.max(r.max[s], o)
        }
    return r
}
function a8(n) {
    return Math.ceil(n / 4) * 4
}
function fB(n, e=0) {
    const t = a8(n.byteLength);
    if (t !== n.byteLength) {
        const r = new Uint8Array(t);
        if (r.set(new Uint8Array(n)),
        e !== 0)
            for (let i = n.byteLength; i < t; i++)
                r[i] = e;
        return r.buffer
    }
    return n
}
function ND() {
    return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1,1) : document.createElement("canvas")
}
function OD(n, e) {
    if (n.toBlob !== void 0)
        return new Promise(r => n.toBlob(r, e));
    let t;
    return e === "image/jpeg" ? t = .92 : e === "image/webp" && (t = .8),
    n.convertToBlob({
        type: e,
        quality: t
    })
}
class ale {
    constructor() {
        this.plugins = [],
        this.options = {},
        this.pending = [],
        this.buffers = [],
        this.byteOffset = 0,
        this.buffers = [],
        this.nodeMap = new Map,
        this.skins = [],
        this.extensionsUsed = {},
        this.extensionsRequired = {},
        this.uids = new Map,
        this.uid = 0,
        this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter r" + nc
            }
        },
        this.cache = {
            meshes: new Map,
            attributes: new Map,
            attributesNormalized: new Map,
            materials: new Map,
            textures: new Map,
            images: new Map
        }
    }
    setPlugins(e) {
        this.plugins = e
    }
    async write(e, t, r={}) {
        this.options = Object.assign({
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1
        }, r),
        this.options.animations.length > 0 && (this.options.trs = !0),
        this.processInput(e),
        await Promise.all(this.pending);
        const i = this
          , s = i.buffers
          , o = i.json;
        r = i.options;
        const a = i.extensionsUsed
          , l = i.extensionsRequired
          , c = new Blob(s,{
            type: "application/octet-stream"
        })
          , A = Object.keys(a)
          , u = Object.keys(l);
        if (A.length > 0 && (o.extensionsUsed = A),
        u.length > 0 && (o.extensionsRequired = u),
        o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size),
        r.binary === !0) {
            const f = new FileReader;
            f.readAsArrayBuffer(c),
            f.onloadend = function() {
                const h = fB(f.result)
                  , d = new DataView(new ArrayBuffer(DD));
                d.setUint32(0, h.byteLength, !0),
                d.setUint32(4, rle, !0);
                const m = fB(ile(JSON.stringify(o)), 32)
                  , g = new DataView(new ArrayBuffer(DD));
                g.setUint32(0, m.byteLength, !0),
                g.setUint32(4, nle, !0);
                const p = new ArrayBuffer(LD)
                  , v = new DataView(p);
                v.setUint32(0, ele, !0),
                v.setUint32(4, tle, !0);
                const w = LD + g.byteLength + m.byteLength + d.byteLength + h.byteLength;
                v.setUint32(8, w, !0);
                const _ = new Blob([p, g, m, d, h],{
                    type: "application/octet-stream"
                })
                  , x = new FileReader;
                x.readAsArrayBuffer(_),
                x.onloadend = function() {
                    t(x.result)
                }
            }
        } else if (o.buffers && o.buffers.length > 0) {
            const f = new FileReader;
            f.readAsDataURL(c),
            f.onloadend = function() {
                const h = f.result;
                o.buffers[0].uri = h,
                t(o)
            }
        } else
            t(o)
    }
    serializeUserData(e, t) {
        if (Object.keys(e.userData).length === 0)
            return;
        const r = this.options
          , i = this.extensionsUsed;
        try {
            const s = JSON.parse(JSON.stringify(e.userData));
            if (r.includeCustomExtensions && s.gltfExtensions) {
                t.extensions === void 0 && (t.extensions = {});
                for (const o in s.gltfExtensions)
                    t.extensions[o] = s.gltfExtensions[o],
                    i[o] = !0;
                delete s.gltfExtensions
            }
            Object.keys(s).length > 0 && (t.extras = s)
        } catch (s) {
            console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + s.message)
        }
    }
    getUID(e, t=!1) {
        if (this.uids.has(e) === !1) {
            const i = new Map;
            i.set(!0, this.uid++),
            i.set(!1, this.uid++),
            this.uids.set(e, i)
        }
        return this.uids.get(e).get(t)
    }
    isNormalizedNormalAttribute(e) {
        if (this.cache.attributesNormalized.has(e))
            return !1;
        const r = new $;
        for (let i = 0, s = e.count; i < s; i++)
            if (Math.abs(r.fromBufferAttribute(e, i).length() - 1) > 5e-4)
                return !1;
        return !0
    }
    createNormalizedNormalAttribute(e) {
        const t = this.cache;
        if (t.attributesNormalized.has(e))
            return t.attributesNormalized.get(e);
        const r = e.clone()
          , i = new $;
        for (let s = 0, o = r.count; s < o; s++)
            i.fromBufferAttribute(r, s),
            i.x === 0 && i.y === 0 && i.z === 0 ? i.setX(1) : i.normalize(),
            r.setXYZ(s, i.x, i.y, i.z);
        return t.attributesNormalized.set(e, r),
        r
    }
    applyTextureTransform(e, t) {
        let r = !1;
        const i = {};
        (t.offset.x !== 0 || t.offset.y !== 0) && (i.offset = t.offset.toArray(),
        r = !0),
        t.rotation !== 0 && (i.rotation = t.rotation,
        r = !0),
        (t.repeat.x !== 1 || t.repeat.y !== 1) && (i.scale = t.repeat.toArray(),
        r = !0),
        r && (e.extensions = e.extensions || {},
        e.extensions.KHR_texture_transform = i,
        this.extensionsUsed.KHR_texture_transform = !0)
    }
    buildMetalRoughTexture(e, t) {
        if (e === t)
            return e;
        function r(h) {
            return h.colorSpace === Ut ? function(m) {
                return m < .04045 ? m * .0773993808 : Math.pow(m * .9478672986 + .0521327014, 2.4)
            }
            : function(m) {
                return m
            }
        }
        console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),
        e instanceof ZE && (e = AB(e)),
        t instanceof ZE && (t = AB(t));
        const i = e ? e.image : null
          , s = t ? t.image : null
          , o = Math.max(i ? i.width : 0, s ? s.width : 0)
          , a = Math.max(i ? i.height : 0, s ? s.height : 0)
          , l = ND();
        l.width = o,
        l.height = a;
        const c = l.getContext("2d", {
            willReadFrequently: !0
        });
        c.fillStyle = "#00ffff",
        c.fillRect(0, 0, o, a);
        const A = c.getImageData(0, 0, o, a);
        if (i) {
            c.drawImage(i, 0, 0, o, a);
            const h = r(e)
              , d = c.getImageData(0, 0, o, a).data;
            for (let m = 2; m < d.length; m += 4)
                A.data[m] = h(d[m] / 256) * 256
        }
        if (s) {
            c.drawImage(s, 0, 0, o, a);
            const h = r(t)
              , d = c.getImageData(0, 0, o, a).data;
            for (let m = 1; m < d.length; m += 4)
                A.data[m] = h(d[m] / 256) * 256
        }
        c.putImageData(A, 0, 0);
        const f = (e || t).clone();
        return f.source = new NR(l),
        f.colorSpace = La,
        f.channel = (e || t).channel,
        e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),
        f
    }
    processBuffer(e) {
        const t = this.json
          , r = this.buffers;
        return t.buffers || (t.buffers = [{
            byteLength: 0
        }]),
        r.push(e),
        0
    }
    processBufferView(e, t, r, i, s) {
        const o = this.json;
        o.bufferViews || (o.bufferViews = []);
        let a;
        switch (t) {
        case Rt.BYTE:
        case Rt.UNSIGNED_BYTE:
            a = 1;
            break;
        case Rt.SHORT:
        case Rt.UNSIGNED_SHORT:
            a = 2;
            break;
        default:
            a = 4
        }
        let l = e.itemSize * a;
        s === Rt.ARRAY_BUFFER && (l = Math.ceil(l / 4) * 4);
        const c = a8(i * l)
          , A = new DataView(new ArrayBuffer(c));
        let u = 0;
        for (let d = r; d < r + i; d++) {
            for (let m = 0; m < e.itemSize; m++) {
                let g;
                e.itemSize > 4 ? g = e.array[d * e.itemSize + m] : (m === 0 ? g = e.getX(d) : m === 1 ? g = e.getY(d) : m === 2 ? g = e.getZ(d) : m === 3 && (g = e.getW(d)),
                e.normalized === !0 && (g = Bt.normalize(g, e.array))),
                t === Rt.FLOAT ? A.setFloat32(u, g, !0) : t === Rt.INT ? A.setInt32(u, g, !0) : t === Rt.UNSIGNED_INT ? A.setUint32(u, g, !0) : t === Rt.SHORT ? A.setInt16(u, g, !0) : t === Rt.UNSIGNED_SHORT ? A.setUint16(u, g, !0) : t === Rt.BYTE ? A.setInt8(u, g) : t === Rt.UNSIGNED_BYTE && A.setUint8(u, g),
                u += a
            }
            u % l !== 0 && (u += l - u % l)
        }
        const f = {
            buffer: this.processBuffer(A.buffer),
            byteOffset: this.byteOffset,
            byteLength: c
        };
        return s !== void 0 && (f.target = s),
        s === Rt.ARRAY_BUFFER && (f.byteStride = l),
        this.byteOffset += c,
        o.bufferViews.push(f),
        {
            id: o.bufferViews.length - 1,
            byteLength: 0
        }
    }
    processBufferViewImage(e) {
        const t = this
          , r = t.json;
        return r.bufferViews || (r.bufferViews = []),
        new Promise(function(i) {
            const s = new FileReader;
            s.readAsArrayBuffer(e),
            s.onloadend = function() {
                const o = fB(s.result)
                  , a = {
                    buffer: t.processBuffer(o),
                    byteOffset: t.byteOffset,
                    byteLength: o.byteLength
                };
                t.byteOffset += o.byteLength,
                i(r.bufferViews.push(a) - 1)
            }
        }
        )
    }
    processAccessor(e, t, r, i) {
        const s = this.json
          , o = {
            1: "SCALAR",
            2: "VEC2",
            3: "VEC3",
            4: "VEC4",
            9: "MAT3",
            16: "MAT4"
        };
        let a;
        if (e.array.constructor === Float32Array)
            a = Rt.FLOAT;
        else if (e.array.constructor === Int32Array)
            a = Rt.INT;
        else if (e.array.constructor === Uint32Array)
            a = Rt.UNSIGNED_INT;
        else if (e.array.constructor === Int16Array)
            a = Rt.SHORT;
        else if (e.array.constructor === Uint16Array)
            a = Rt.UNSIGNED_SHORT;
        else if (e.array.constructor === Int8Array)
            a = Rt.BYTE;
        else if (e.array.constructor === Uint8Array)
            a = Rt.UNSIGNED_BYTE;
        else
            throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name);
        if (r === void 0 && (r = 0),
        (i === void 0 || i === 1 / 0) && (i = e.count),
        i === 0)
            return null;
        const l = ole(e, r, i);
        let c;
        t !== void 0 && (c = e === t.index ? Rt.ELEMENT_ARRAY_BUFFER : Rt.ARRAY_BUFFER);
        const A = this.processBufferView(e, a, r, i, c)
          , u = {
            bufferView: A.id,
            byteOffset: A.byteOffset,
            componentType: a,
            count: i,
            max: l.max,
            min: l.min,
            type: o[e.itemSize]
        };
        return e.normalized === !0 && (u.normalized = !0),
        s.accessors || (s.accessors = []),
        s.accessors.push(u) - 1
    }
    processImage(e, t, r, i="image/png") {
        if (e !== null) {
            const s = this
              , o = s.cache
              , a = s.json
              , l = s.options
              , c = s.pending;
            o.images.has(e) || o.images.set(e, {});
            const A = o.images.get(e)
              , u = i + ":flipY/" + r.toString();
            if (A[u] !== void 0)
                return A[u];
            a.images || (a.images = []);
            const f = {
                mimeType: i
            }
              , h = ND();
            h.width = Math.min(e.width, l.maxTextureSize),
            h.height = Math.min(e.height, l.maxTextureSize);
            const d = h.getContext("2d", {
                willReadFrequently: !0
            });
            if (r === !0 && (d.translate(0, h.height),
            d.scale(1, -1)),
            e.data !== void 0) {
                t !== Nr && console.error("GLTFExporter: Only RGBAFormat is supported.", t),
                (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                const g = new Uint8ClampedArray(e.height * e.width * 4);
                for (let p = 0; p < g.length; p += 4)
                    g[p + 0] = e.data[p + 0],
                    g[p + 1] = e.data[p + 1],
                    g[p + 2] = e.data[p + 2],
                    g[p + 3] = e.data[p + 3];
                d.putImageData(new ImageData(g,e.width,e.height), 0, 0)
            } else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)
                d.drawImage(e, 0, 0, h.width, h.height);
            else
                throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");
            l.binary === !0 ? c.push(OD(h, i).then(g => s.processBufferViewImage(g)).then(g => {
                f.bufferView = g
            }
            )) : h.toDataURL !== void 0 ? f.uri = h.toDataURL(i) : c.push(OD(h, i).then(g => new FileReader().readAsDataURL(g)).then(g => {
                f.uri = g
            }
            ));
            const m = a.images.push(f) - 1;
            return A[u] = m,
            m
        } else
            throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
    }
    processSampler(e) {
        const t = this.json;
        t.samplers || (t.samplers = []);
        const r = {
            magFilter: Us[e.magFilter],
            minFilter: Us[e.minFilter],
            wrapS: Us[e.wrapS],
            wrapT: Us[e.wrapT]
        };
        return t.samplers.push(r) - 1
    }
    processTexture(e) {
        const r = this.options
          , i = this.cache
          , s = this.json;
        if (i.textures.has(e))
            return i.textures.get(e);
        s.textures || (s.textures = []),
        e instanceof ZE && (e = AB(e, r.maxTextureSize));
        let o = e.userData.mimeType;
        o === "image/webp" && (o = "image/png");
        const a = {
            sampler: this.processSampler(e),
            source: this.processImage(e.image, e.format, e.flipY, o)
        };
        e.name && (a.name = e.name),
        this._invokeAll(function(c) {
            c.writeTexture && c.writeTexture(e, a)
        });
        const l = s.textures.push(a) - 1;
        return i.textures.set(e, l),
        l
    }
    processMaterial(e) {
        const t = this.cache
          , r = this.json;
        if (t.materials.has(e))
            return t.materials.get(e);
        if (e.isShaderMaterial)
            return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),
            null;
        r.materials || (r.materials = []);
        const i = {
            pbrMetallicRoughness: {}
        };
        e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
        const s = e.color.toArray().concat([e.opacity]);
        if (bm(s, [1, 1, 1, 1]) || (i.pbrMetallicRoughness.baseColorFactor = s),
        e.isMeshStandardMaterial ? (i.pbrMetallicRoughness.metallicFactor = e.metalness,
        i.pbrMetallicRoughness.roughnessFactor = e.roughness) : (i.pbrMetallicRoughness.metallicFactor = .5,
        i.pbrMetallicRoughness.roughnessFactor = .5),
        e.metalnessMap || e.roughnessMap) {
            const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap)
              , l = {
                index: this.processTexture(a),
                channel: a.channel
            };
            this.applyTextureTransform(l, a),
            i.pbrMetallicRoughness.metallicRoughnessTexture = l
        }
        if (e.map) {
            const a = {
                index: this.processTexture(e.map),
                texCoord: e.map.channel
            };
            this.applyTextureTransform(a, e.map),
            i.pbrMetallicRoughness.baseColorTexture = a
        }
        if (e.emissive) {
            const a = e.emissive;
            if (Math.max(a.r, a.g, a.b) > 0 && (i.emissiveFactor = e.emissive.toArray()),
            e.emissiveMap) {
                const c = {
                    index: this.processTexture(e.emissiveMap),
                    texCoord: e.emissiveMap.channel
                };
                this.applyTextureTransform(c, e.emissiveMap),
                i.emissiveTexture = c
            }
        }
        if (e.normalMap) {
            const a = {
                index: this.processTexture(e.normalMap),
                texCoord: e.normalMap.channel
            };
            e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x),
            this.applyTextureTransform(a, e.normalMap),
            i.normalTexture = a
        }
        if (e.aoMap) {
            const a = {
                index: this.processTexture(e.aoMap),
                texCoord: e.aoMap.channel
            };
            e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity),
            this.applyTextureTransform(a, e.aoMap),
            i.occlusionTexture = a
        }
        e.transparent ? i.alphaMode = "BLEND" : e.alphaTest > 0 && (i.alphaMode = "MASK",
        i.alphaCutoff = e.alphaTest),
        e.side === _i && (i.doubleSided = !0),
        e.name !== "" && (i.name = e.name),
        this.serializeUserData(e, i),
        this._invokeAll(function(a) {
            a.writeMaterial && a.writeMaterial(e, i)
        });
        const o = r.materials.push(i) - 1;
        return t.materials.set(e, o),
        o
    }
    processMesh(e) {
        const t = this.cache
          , r = this.json
          , i = [e.geometry.uuid];
        if (Array.isArray(e.material))
            for (let _ = 0, x = e.material.length; _ < x; _++)
                i.push(e.material[_].uuid);
        else
            i.push(e.material.uuid);
        const s = i.join(":");
        if (t.meshes.has(s))
            return t.meshes.get(s);
        const o = e.geometry;
        let a;
        e.isLineSegments ? a = Rt.LINES : e.isLineLoop ? a = Rt.LINE_LOOP : e.isLine ? a = Rt.LINE_STRIP : e.isPoints ? a = Rt.POINTS : a = e.material.wireframe ? Rt.LINES : Rt.TRIANGLES;
        const l = {}
          , c = {}
          , A = []
          , u = []
          , f = {
            uv: "TEXCOORD_0",
            uv1: "TEXCOORD_1",
            uv2: "TEXCOORD_2",
            uv3: "TEXCOORD_3",
            color: "COLOR_0",
            skinWeight: "WEIGHTS_0",
            skinIndex: "JOINTS_0"
        }
          , h = o.getAttribute("normal");
        h !== void 0 && !this.isNormalizedNormalAttribute(h) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),
        o.setAttribute("normal", this.createNormalizedNormalAttribute(h)));
        let d = null;
        for (let _ in o.attributes) {
            if (_.slice(0, 5) === "morph")
                continue;
            const x = o.attributes[_];
            if (_ = f[_] || _.toUpperCase(),
            /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(_) || (_ = "_" + _),
            t.attributes.has(this.getUID(x))) {
                c[_] = t.attributes.get(this.getUID(x));
                continue
            }
            d = null;
            const B = x.array;
            _ === "JOINTS_0" && !(B instanceof Uint16Array) && !(B instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),
            d = new ct(new Uint16Array(B),x.itemSize,x.normalized));
            const S = this.processAccessor(d || x, o);
            S !== null && (_.startsWith("_") || this.detectMeshQuantization(_, x),
            c[_] = S,
            t.attributes.set(this.getUID(x), S))
        }
        if (h !== void 0 && o.setAttribute("normal", h),
        Object.keys(c).length === 0)
            return null;
        if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
            const _ = []
              , x = []
              , b = {};
            if (e.morphTargetDictionary !== void 0)
                for (const B in e.morphTargetDictionary)
                    b[e.morphTargetDictionary[B]] = B;
            for (let B = 0; B < e.morphTargetInfluences.length; ++B) {
                const S = {};
                let I = !1;
                for (const M in o.morphAttributes) {
                    if (M !== "position" && M !== "normal") {
                        I || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),
                        I = !0);
                        continue
                    }
                    const L = o.morphAttributes[M][B]
                      , D = M.toUpperCase()
                      , T = o.attributes[M];
                    if (t.attributes.has(this.getUID(L, !0))) {
                        S[D] = t.attributes.get(this.getUID(L, !0));
                        continue
                    }
                    const y = L.clone();
                    if (!o.morphTargetsRelative)
                        for (let E = 0, R = L.count; E < R; E++)
                            for (let F = 0; F < L.itemSize; F++)
                                F === 0 && y.setX(E, L.getX(E) - T.getX(E)),
                                F === 1 && y.setY(E, L.getY(E) - T.getY(E)),
                                F === 2 && y.setZ(E, L.getZ(E) - T.getZ(E)),
                                F === 3 && y.setW(E, L.getW(E) - T.getW(E));
                    S[D] = this.processAccessor(y, o),
                    t.attributes.set(this.getUID(T, !0), S[D])
                }
                u.push(S),
                _.push(e.morphTargetInfluences[B]),
                e.morphTargetDictionary !== void 0 && x.push(b[B])
            }
            l.weights = _,
            x.length > 0 && (l.extras = {},
            l.extras.targetNames = x)
        }
        const m = Array.isArray(e.material);
        if (m && o.groups.length === 0)
            return null;
        let g = !1;
        if (m && o.index === null) {
            const _ = [];
            for (let x = 0, b = o.attributes.position.count; x < b; x++)
                _[x] = x;
            o.setIndex(_),
            g = !0
        }
        const p = m ? e.material : [e.material]
          , v = m ? o.groups : [{
            materialIndex: 0,
            start: void 0,
            count: void 0
        }];
        for (let _ = 0, x = v.length; _ < x; _++) {
            const b = {
                mode: a,
                attributes: c
            };
            if (this.serializeUserData(o, b),
            u.length > 0 && (b.targets = u),
            o.index !== null) {
                let S = this.getUID(o.index);
                (v[_].start !== void 0 || v[_].count !== void 0) && (S += ":" + v[_].start + ":" + v[_].count),
                t.attributes.has(S) ? b.indices = t.attributes.get(S) : (b.indices = this.processAccessor(o.index, o, v[_].start, v[_].count),
                t.attributes.set(S, b.indices)),
                b.indices === null && delete b.indices
            }
            const B = this.processMaterial(p[v[_].materialIndex]);
            B !== null && (b.material = B),
            A.push(b)
        }
        g === !0 && o.setIndex(null),
        l.primitives = A,
        r.meshes || (r.meshes = []),
        this._invokeAll(function(_) {
            _.writeMesh && _.writeMesh(e, l)
        });
        const w = r.meshes.push(l) - 1;
        return t.meshes.set(s, w),
        w
    }
    detectMeshQuantization(e, t) {
        if (this.extensionsUsed[uB])
            return;
        let r;
        switch (t.array.constructor) {
        case Int8Array:
            r = "byte";
            break;
        case Uint8Array:
            r = "unsigned byte";
            break;
        case Int16Array:
            r = "short";
            break;
        case Uint16Array:
            r = "unsigned short";
            break;
        default:
            return
        }
        t.normalized && (r += " normalized");
        const i = e.split("_", 1)[0];
        FD[i] && FD[i].includes(r) && (this.extensionsUsed[uB] = !0,
        this.extensionsRequired[uB] = !0)
    }
    processCamera(e) {
        const t = this.json;
        t.cameras || (t.cameras = []);
        const r = e.isOrthographicCamera
          , i = {
            type: r ? "orthographic" : "perspective"
        };
        return r ? i.orthographic = {
            xmag: e.right * 2,
            ymag: e.top * 2,
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        } : i.perspective = {
            aspectRatio: e.aspect,
            yfov: Bt.degToRad(e.fov),
            zfar: e.far <= 0 ? .001 : e.far,
            znear: e.near < 0 ? 0 : e.near
        },
        e.name !== "" && (i.name = e.type),
        t.cameras.push(i) - 1
    }
    processAnimation(e, t) {
        const r = this.json
          , i = this.nodeMap;
        r.animations || (r.animations = []),
        e = ZR.Utils.mergeMorphTargetTracks(e.clone(), t);
        const s = e.tracks
          , o = []
          , a = [];
        for (let l = 0; l < s.length; ++l) {
            const c = s[l]
              , A = Ct.parseTrackName(c.name);
            let u = Ct.findNode(t, A.nodeName);
            const f = PD[A.propertyName];
            if (A.objectName === "bones" && (u.isSkinnedMesh === !0 ? u = u.skeleton.getBoneByName(A.objectIndex) : u = void 0),
            !u || !f) {
                console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name);
                continue
            }
            const h = 1;
            let d = c.values.length / c.times.length;
            f === PD.morphTargetInfluences && (d /= u.morphTargetInfluences.length);
            let m;
            c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (m = "CUBICSPLINE",
            d /= 3) : c.getInterpolation() === Pd ? m = "STEP" : m = "LINEAR",
            a.push({
                input: this.processAccessor(new ct(c.times,h)),
                output: this.processAccessor(new ct(c.values,d)),
                interpolation: m
            }),
            o.push({
                sampler: a.length - 1,
                target: {
                    node: i.get(u),
                    path: f
                }
            })
        }
        return r.animations.push({
            name: e.name || "clip_" + r.animations.length,
            samplers: a,
            channels: o
        }),
        r.animations.length - 1
    }
    processSkin(e) {
        const t = this.json
          , r = this.nodeMap
          , i = t.nodes[r.get(e)]
          , s = e.skeleton;
        if (s === void 0)
            return null;
        const o = e.skeleton.bones[0];
        if (o === void 0)
            return null;
        const a = []
          , l = new Float32Array(s.bones.length * 16)
          , c = new He;
        for (let u = 0; u < s.bones.length; ++u)
            a.push(r.get(s.bones[u])),
            c.copy(s.boneInverses[u]),
            c.multiply(e.bindMatrix).toArray(l, u * 16);
        return t.skins === void 0 && (t.skins = []),
        t.skins.push({
            inverseBindMatrices: this.processAccessor(new ct(l,16)),
            joints: a,
            skeleton: r.get(o)
        }),
        i.skin = t.skins.length - 1
    }
    processNode(e) {
        const t = this.json
          , r = this.options
          , i = this.nodeMap;
        t.nodes || (t.nodes = []);
        const s = {};
        if (r.trs) {
            const a = e.quaternion.toArray()
              , l = e.position.toArray()
              , c = e.scale.toArray();
            bm(a, [0, 0, 0, 1]) || (s.rotation = a),
            bm(l, [0, 0, 0]) || (s.translation = l),
            bm(c, [1, 1, 1]) || (s.scale = c)
        } else
            e.matrixAutoUpdate && e.updateMatrix(),
            sle(e.matrix) === !1 && (s.matrix = e.matrix.elements);
        if (e.name !== "" && (s.name = String(e.name)),
        this.serializeUserData(e, s),
        e.isMesh || e.isLine || e.isPoints) {
            const a = this.processMesh(e);
            a !== null && (s.mesh = a)
        } else
            e.isCamera && (s.camera = this.processCamera(e));
        if (e.isSkinnedMesh && this.skins.push(e),
        e.children.length > 0) {
            const a = [];
            for (let l = 0, c = e.children.length; l < c; l++) {
                const A = e.children[l];
                if (A.visible || r.onlyVisible === !1) {
                    const u = this.processNode(A);
                    u !== null && a.push(u)
                }
            }
            a.length > 0 && (s.children = a)
        }
        this._invokeAll(function(a) {
            a.writeNode && a.writeNode(e, s)
        });
        const o = t.nodes.push(s) - 1;
        return i.set(e, o),
        o
    }
    processScene(e) {
        const t = this.json
          , r = this.options;
        t.scenes || (t.scenes = [],
        t.scene = 0);
        const i = {};
        e.name !== "" && (i.name = e.name),
        t.scenes.push(i);
        const s = [];
        for (let o = 0, a = e.children.length; o < a; o++) {
            const l = e.children[o];
            if (l.visible || r.onlyVisible === !1) {
                const c = this.processNode(l);
                c !== null && s.push(c)
            }
        }
        s.length > 0 && (i.nodes = s),
        this.serializeUserData(e, i)
    }
    processObjects(e) {
        const t = new Gg;
        t.name = "AuxScene";
        for (let r = 0; r < e.length; r++)
            t.children.push(e[r]);
        this.processScene(t)
    }
    processInput(e) {
        const t = this.options;
        e = e instanceof Array ? e : [e],
        this._invokeAll(function(i) {
            i.beforeParse && i.beforeParse(e)
        });
        const r = [];
        for (let i = 0; i < e.length; i++)
            e[i]instanceof Gg ? this.processScene(e[i]) : r.push(e[i]);
        r.length > 0 && this.processObjects(r);
        for (let i = 0; i < this.skins.length; ++i)
            this.processSkin(this.skins[i]);
        for (let i = 0; i < t.animations.length; ++i)
            this.processAnimation(t.animations[i], e[0]);
        this._invokeAll(function(i) {
            i.afterParse && i.afterParse(e)
        })
    }
    _invokeAll(e) {
        for (let t = 0, r = this.plugins.length; t < r; t++)
            e(this.plugins[t])
    }
}
class lle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_lights_punctual"
    }
    writeNode(e, t) {
        if (!e.isLight)
            return;
        if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
            console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
            return
        }
        const r = this.writer
          , i = r.json
          , s = r.extensionsUsed
          , o = {};
        e.name && (o.name = e.name),
        o.color = e.color.toArray(),
        o.intensity = e.intensity,
        e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point",
        e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot",
        e.distance > 0 && (o.range = e.distance),
        o.spot = {},
        o.spot.innerConeAngle = (1 - e.penumbra) * e.angle,
        o.spot.outerConeAngle = e.angle),
        e.decay !== void 0 && e.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),
        e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),
        s[this.name] || (i.extensions = i.extensions || {},
        i.extensions[this.name] = {
            lights: []
        },
        s[this.name] = !0);
        const a = i.extensions[this.name].lights;
        a.push(o),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {
            light: a.length - 1
        }
    }
}
class cle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_unlit"
    }
    writeMaterial(e, t) {
        if (!e.isMeshBasicMaterial)
            return;
        const i = this.writer.extensionsUsed;
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {},
        i[this.name] = !0,
        t.pbrMetallicRoughness.metallicFactor = 0,
        t.pbrMetallicRoughness.roughnessFactor = .9
    }
}
class Ale {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_clearcoat"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (s.clearcoatFactor = e.clearcoat,
        e.clearcoatMap) {
            const o = {
                index: r.processTexture(e.clearcoatMap),
                texCoord: e.clearcoatMap.channel
            };
            r.applyTextureTransform(o, e.clearcoatMap),
            s.clearcoatTexture = o
        }
        if (s.clearcoatRoughnessFactor = e.clearcoatRoughness,
        e.clearcoatRoughnessMap) {
            const o = {
                index: r.processTexture(e.clearcoatRoughnessMap),
                texCoord: e.clearcoatRoughnessMap.channel
            };
            r.applyTextureTransform(o, e.clearcoatRoughnessMap),
            s.clearcoatRoughnessTexture = o
        }
        if (e.clearcoatNormalMap) {
            const o = {
                index: r.processTexture(e.clearcoatNormalMap),
                texCoord: e.clearcoatNormalMap.channel
            };
            e.clearcoatNormalScale.x !== 1 && (o.scale = e.clearcoatNormalScale.x),
            r.applyTextureTransform(o, e.clearcoatNormalMap),
            s.clearcoatNormalTexture = o
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class ule {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_dispersion"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.dispersion === 0)
            return;
        const i = this.writer.extensionsUsed
          , s = {};
        s.dispersion = e.dispersion,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class fle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_iridescence"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (s.iridescenceFactor = e.iridescence,
        e.iridescenceMap) {
            const o = {
                index: r.processTexture(e.iridescenceMap),
                texCoord: e.iridescenceMap.channel
            };
            r.applyTextureTransform(o, e.iridescenceMap),
            s.iridescenceTexture = o
        }
        if (s.iridescenceIor = e.iridescenceIOR,
        s.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0],
        s.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1],
        e.iridescenceThicknessMap) {
            const o = {
                index: r.processTexture(e.iridescenceThicknessMap),
                texCoord: e.iridescenceThicknessMap.channel
            };
            r.applyTextureTransform(o, e.iridescenceThicknessMap),
            s.iridescenceThicknessTexture = o
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class hle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_transmission"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.transmission === 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (s.transmissionFactor = e.transmission,
        e.transmissionMap) {
            const o = {
                index: r.processTexture(e.transmissionMap),
                texCoord: e.transmissionMap.channel
            };
            r.applyTextureTransform(o, e.transmissionMap),
            s.transmissionTexture = o
        }
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class dle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_volume"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.transmission === 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (s.thicknessFactor = e.thickness,
        e.thicknessMap) {
            const o = {
                index: r.processTexture(e.thicknessMap),
                texCoord: e.thicknessMap.channel
            };
            r.applyTextureTransform(o, e.thicknessMap),
            s.thicknessTexture = o
        }
        e.attenuationDistance !== 1 / 0 && (s.attenuationDistance = e.attenuationDistance),
        s.attenuationColor = e.attenuationColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class ple {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_ior"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
            return;
        const i = this.writer.extensionsUsed
          , s = {};
        s.ior = e.ior,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class mle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_specular"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(qae) && !e.specularIntensityMap && !e.specularColorMap)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (e.specularIntensityMap) {
            const o = {
                index: r.processTexture(e.specularIntensityMap),
                texCoord: e.specularIntensityMap.channel
            };
            r.applyTextureTransform(o, e.specularIntensityMap),
            s.specularTexture = o
        }
        if (e.specularColorMap) {
            const o = {
                index: r.processTexture(e.specularColorMap),
                texCoord: e.specularColorMap.channel
            };
            r.applyTextureTransform(o, e.specularColorMap),
            s.specularColorTexture = o
        }
        s.specularFactor = e.specularIntensity,
        s.specularColorFactor = e.specularColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class gle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_sheen"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.sheen == 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (e.sheenRoughnessMap) {
            const o = {
                index: r.processTexture(e.sheenRoughnessMap),
                texCoord: e.sheenRoughnessMap.channel
            };
            r.applyTextureTransform(o, e.sheenRoughnessMap),
            s.sheenRoughnessTexture = o
        }
        if (e.sheenColorMap) {
            const o = {
                index: r.processTexture(e.sheenColorMap),
                texCoord: e.sheenColorMap.channel
            };
            r.applyTextureTransform(o, e.sheenColorMap),
            s.sheenColorTexture = o
        }
        s.sheenRoughnessFactor = e.sheenRoughness,
        s.sheenColorFactor = e.sheenColor.toArray(),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class vle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_anisotropy"
    }
    writeMaterial(e, t) {
        if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (e.anisotropyMap) {
            const o = {
                index: r.processTexture(e.anisotropyMap)
            };
            r.applyTextureTransform(o, e.anisotropyMap),
            s.anisotropyTexture = o
        }
        s.anisotropyStrength = e.anisotropy,
        s.anisotropyRotation = e.anisotropyRotation,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class yle {
    constructor(e) {
        this.writer = e,
        this.name = "KHR_materials_emissive_strength"
    }
    writeMaterial(e, t) {
        if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
            return;
        const i = this.writer.extensionsUsed
          , s = {};
        s.emissiveStrength = e.emissiveIntensity,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class wle {
    constructor(e) {
        this.writer = e,
        this.name = "EXT_materials_bump"
    }
    writeMaterial(e, t) {
        if (!e.isMeshStandardMaterial || e.bumpScale === 1 && !e.bumpMap)
            return;
        const r = this.writer
          , i = r.extensionsUsed
          , s = {};
        if (e.bumpMap) {
            const o = {
                index: r.processTexture(e.bumpMap),
                texCoord: e.bumpMap.channel
            };
            r.applyTextureTransform(o, e.bumpMap),
            s.bumpTexture = o
        }
        s.bumpFactor = e.bumpScale,
        t.extensions = t.extensions || {},
        t.extensions[this.name] = s,
        i[this.name] = !0
    }
}
class _le {
    constructor(e) {
        this.writer = e,
        this.name = "EXT_mesh_gpu_instancing"
    }
    writeNode(e, t) {
        if (!e.isInstancedMesh)
            return;
        const r = this.writer
          , i = e
          , s = new Float32Array(i.count * 3)
          , o = new Float32Array(i.count * 4)
          , a = new Float32Array(i.count * 3)
          , l = new He
          , c = new $
          , A = new nt
          , u = new $;
        for (let h = 0; h < i.count; h++)
            i.getMatrixAt(h, l),
            l.decompose(c, A, u),
            c.toArray(s, h * 3),
            A.toArray(o, h * 4),
            u.toArray(a, h * 3);
        const f = {
            TRANSLATION: r.processAccessor(new ct(s,3)),
            ROTATION: r.processAccessor(new ct(o,4)),
            SCALE: r.processAccessor(new ct(a,3))
        };
        i.instanceColor && (f._COLOR_0 = r.processAccessor(i.instanceColor)),
        t.extensions = t.extensions || {},
        t.extensions[this.name] = {
            attributes: f
        },
        r.extensionsUsed[this.name] = !0,
        r.extensionsRequired[this.name] = !0
    }
}
ZR.Utils = {
    insertKeyframe: function(n, e) {
        const r = n.getValueSize()
          , i = new n.TimeBufferType(n.times.length + 1)
          , s = new n.ValueBufferType(n.values.length + r)
          , o = n.createInterpolant(new n.ValueBufferType(r));
        let a;
        if (n.times.length === 0) {
            i[0] = e;
            for (let l = 0; l < r; l++)
                s[l] = 0;
            a = 0
        } else if (e < n.times[0]) {
            if (Math.abs(n.times[0] - e) < .001)
                return 0;
            i[0] = e,
            i.set(n.times, 1),
            s.set(o.evaluate(e), 0),
            s.set(n.values, r),
            a = 0
        } else if (e > n.times[n.times.length - 1]) {
            if (Math.abs(n.times[n.times.length - 1] - e) < .001)
                return n.times.length - 1;
            i[i.length - 1] = e,
            i.set(n.times, 0),
            s.set(n.values, 0),
            s.set(o.evaluate(e), n.values.length),
            a = i.length - 1
        } else
            for (let l = 0; l < n.times.length; l++) {
                if (Math.abs(n.times[l] - e) < .001)
                    return l;
                if (n.times[l] < e && n.times[l + 1] > e) {
                    i.set(n.times.slice(0, l + 1), 0),
                    i[l + 1] = e,
                    i.set(n.times.slice(l + 1), l + 2),
                    s.set(n.values.slice(0, (l + 1) * r), 0),
                    s.set(o.evaluate(e), (l + 1) * r),
                    s.set(n.values.slice((l + 1) * r), (l + 2) * r),
                    a = l + 1;
                    break
                }
            }
        return n.times = i,
        n.values = s,
        a
    },
    mergeMorphTargetTracks: function(n, e) {
        const t = []
          , r = {}
          , i = n.tracks;
        for (let s = 0; s < i.length; ++s) {
            let o = i[s];
            const a = Ct.parseTrackName(o.name)
              , l = Ct.findNode(e, a.nodeName);
            if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
                t.push(o);
                continue
            }
            if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                    throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),
                o = o.clone(),
                o.setInterpolation(Ld)
            }
            const c = l.morphTargetInfluences.length
              , A = l.morphTargetDictionary[a.propertyIndex];
            if (A === void 0)
                throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
            let u;
            if (r[l.uuid] === void 0) {
                u = o.clone();
                const h = new u.ValueBufferType(c * u.times.length);
                for (let d = 0; d < u.times.length; d++)
                    h[d * c + A] = u.values[d];
                u.name = (a.nodeName || "") + ".morphTargetInfluences",
                u.values = h,
                r[l.uuid] = u,
                t.push(u);
                continue
            }
            const f = o.createInterpolant(new o.ValueBufferType(1));
            u = r[l.uuid];
            for (let h = 0; h < u.times.length; h++)
                u.values[h * c + A] = f.evaluate(u.times[h]);
            for (let h = 0; h < o.times.length; h++) {
                const d = this.insertKeyframe(u, o.times[h]);
                u.values[d * c + A] = o.values[h]
            }
        }
        return n.tracks = t,
        n
    }
};
var l8 = {}
  , _1 = {};
_1.byteLength = Ele;
_1.toByteArray = Mle;
_1.fromByteArray = Tle;
var Da = []
  , no = []
  , xle = typeof Uint8Array < "u" ? Uint8Array : Array
  , hB = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Mf = 0, ble = hB.length; Mf < ble; ++Mf)
    Da[Mf] = hB[Mf],
    no[hB.charCodeAt(Mf)] = Mf;
no["-".charCodeAt(0)] = 62;
no["_".charCodeAt(0)] = 63;
function c8(n) {
    var e = n.length;
    if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var t = n.indexOf("=");
    t === -1 && (t = e);
    var r = t === e ? 0 : 4 - t % 4;
    return [t, r]
}
function Ele(n) {
    var e = c8(n)
      , t = e[0]
      , r = e[1];
    return (t + r) * 3 / 4 - r
}
function Ble(n, e, t) {
    return (e + t) * 3 / 4 - t
}
function Mle(n) {
    var e, t = c8(n), r = t[0], i = t[1], s = new xle(Ble(n, r, i)), o = 0, a = i > 0 ? r - 4 : r, l;
    for (l = 0; l < a; l += 4)
        e = no[n.charCodeAt(l)] << 18 | no[n.charCodeAt(l + 1)] << 12 | no[n.charCodeAt(l + 2)] << 6 | no[n.charCodeAt(l + 3)],
        s[o++] = e >> 16 & 255,
        s[o++] = e >> 8 & 255,
        s[o++] = e & 255;
    return i === 2 && (e = no[n.charCodeAt(l)] << 2 | no[n.charCodeAt(l + 1)] >> 4,
    s[o++] = e & 255),
    i === 1 && (e = no[n.charCodeAt(l)] << 10 | no[n.charCodeAt(l + 1)] << 4 | no[n.charCodeAt(l + 2)] >> 2,
    s[o++] = e >> 8 & 255,
    s[o++] = e & 255),
    s
}
function Sle(n) {
    return Da[n >> 18 & 63] + Da[n >> 12 & 63] + Da[n >> 6 & 63] + Da[n & 63]
}
function Cle(n, e, t) {
    for (var r, i = [], s = e; s < t; s += 3)
        r = (n[s] << 16 & 16711680) + (n[s + 1] << 8 & 65280) + (n[s + 2] & 255),
        i.push(Sle(r));
    return i.join("")
}
function Tle(n) {
    for (var e, t = n.length, r = t % 3, i = [], s = 16383, o = 0, a = t - r; o < a; o += s)
        i.push(Cle(n, o, o + s > a ? a : o + s));
    return r === 1 ? (e = n[t - 1],
    i.push(Da[e >> 2] + Da[e << 4 & 63] + "==")) : r === 2 && (e = (n[t - 2] << 8) + n[t - 1],
    i.push(Da[e >> 10] + Da[e >> 4 & 63] + Da[e << 2 & 63] + "=")),
    i.join("")
}
var JR = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
JR.read = function(n, e, t, r, i) {
    var s, o, a = i * 8 - r - 1, l = (1 << a) - 1, c = l >> 1, A = -7, u = t ? i - 1 : 0, f = t ? -1 : 1, h = n[e + u];
    for (u += f,
    s = h & (1 << -A) - 1,
    h >>= -A,
    A += a; A > 0; s = s * 256 + n[e + u],
    u += f,
    A -= 8)
        ;
    for (o = s & (1 << -A) - 1,
    s >>= -A,
    A += r; A > 0; o = o * 256 + n[e + u],
    u += f,
    A -= 8)
        ;
    if (s === 0)
        s = 1 - c;
    else {
        if (s === l)
            return o ? NaN : (h ? -1 : 1) * (1 / 0);
        o = o + Math.pow(2, r),
        s = s - c
    }
    return (h ? -1 : 1) * o * Math.pow(2, s - r)
}
;
JR.write = function(n, e, t, r, i, s) {
    var o, a, l, c = s * 8 - i - 1, A = (1 << c) - 1, u = A >> 1, f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = r ? 0 : s - 1, d = r ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e),
    isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
    o = A) : (o = Math.floor(Math.log(e) / Math.LN2),
    e * (l = Math.pow(2, -o)) < 1 && (o--,
    l *= 2),
    o + u >= 1 ? e += f / l : e += f * Math.pow(2, 1 - u),
    e * l >= 2 && (o++,
    l /= 2),
    o + u >= A ? (a = 0,
    o = A) : o + u >= 1 ? (a = (e * l - 1) * Math.pow(2, i),
    o = o + u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, i),
    o = 0)); i >= 8; n[t + h] = a & 255,
    h += d,
    a /= 256,
    i -= 8)
        ;
    for (o = o << i | a,
    c += i; c > 0; n[t + h] = o & 255,
    h += d,
    o /= 256,
    c -= 8)
        ;
    n[t + h - d] |= m * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
    const e = _1
      , t = JR
      , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    n.Buffer = a,
    n.SlowBuffer = v,
    n.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    n.kMaxLength = i,
    a.TYPED_ARRAY_SUPPORT = s(),
    !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
        try {
            const V = new Uint8Array(1)
              , U = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(U, Uint8Array.prototype),
            Object.setPrototypeOf(V, U),
            V.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(a.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(a.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (a.isBuffer(this))
                return this.byteOffset
        }
    });
    function o(V) {
        if (V > i)
            throw new RangeError('The value "' + V + '" is invalid for option "size"');
        const U = new Uint8Array(V);
        return Object.setPrototypeOf(U, a.prototype),
        U
    }
    function a(V, U, N) {
        if (typeof V == "number") {
            if (typeof U == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return u(V)
        }
        return l(V, U, N)
    }
    a.poolSize = 8192;
    function l(V, U, N) {
        if (typeof V == "string")
            return f(V, U);
        if (ArrayBuffer.isView(V))
            return d(V);
        if (V == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V);
        if (ne(V, ArrayBuffer) || V && ne(V.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ne(V, SharedArrayBuffer) || V && ne(V.buffer, SharedArrayBuffer)))
            return m(V, U, N);
        if (typeof V == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const K = V.valueOf && V.valueOf();
        if (K != null && K !== V)
            return a.from(K, U, N);
        const oe = g(V);
        if (oe)
            return oe;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof V[Symbol.toPrimitive] == "function")
            return a.from(V[Symbol.toPrimitive]("string"), U, N);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof V)
    }
    a.from = function(V, U, N) {
        return l(V, U, N)
    }
    ,
    Object.setPrototypeOf(a.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(a, Uint8Array);
    function c(V) {
        if (typeof V != "number")
            throw new TypeError('"size" argument must be of type number');
        if (V < 0)
            throw new RangeError('The value "' + V + '" is invalid for option "size"')
    }
    function A(V, U, N) {
        return c(V),
        V <= 0 ? o(V) : U !== void 0 ? typeof N == "string" ? o(V).fill(U, N) : o(V).fill(U) : o(V)
    }
    a.alloc = function(V, U, N) {
        return A(V, U, N)
    }
    ;
    function u(V) {
        return c(V),
        o(V < 0 ? 0 : p(V) | 0)
    }
    a.allocUnsafe = function(V) {
        return u(V)
    }
    ,
    a.allocUnsafeSlow = function(V) {
        return u(V)
    }
    ;
    function f(V, U) {
        if ((typeof U != "string" || U === "") && (U = "utf8"),
        !a.isEncoding(U))
            throw new TypeError("Unknown encoding: " + U);
        const N = w(V, U) | 0;
        let K = o(N);
        const oe = K.write(V, U);
        return oe !== N && (K = K.slice(0, oe)),
        K
    }
    function h(V) {
        const U = V.length < 0 ? 0 : p(V.length) | 0
          , N = o(U);
        for (let K = 0; K < U; K += 1)
            N[K] = V[K] & 255;
        return N
    }
    function d(V) {
        if (ne(V, Uint8Array)) {
            const U = new Uint8Array(V);
            return m(U.buffer, U.byteOffset, U.byteLength)
        }
        return h(V)
    }
    function m(V, U, N) {
        if (U < 0 || V.byteLength < U)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (V.byteLength < U + (N || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let K;
        return U === void 0 && N === void 0 ? K = new Uint8Array(V) : N === void 0 ? K = new Uint8Array(V,U) : K = new Uint8Array(V,U,N),
        Object.setPrototypeOf(K, a.prototype),
        K
    }
    function g(V) {
        if (a.isBuffer(V)) {
            const U = p(V.length) | 0
              , N = o(U);
            return N.length === 0 || V.copy(N, 0, 0, U),
            N
        }
        if (V.length !== void 0)
            return typeof V.length != "number" || Y(V.length) ? o(0) : h(V);
        if (V.type === "Buffer" && Array.isArray(V.data))
            return h(V.data)
    }
    function p(V) {
        if (V >= i)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
        return V | 0
    }
    function v(V) {
        return +V != V && (V = 0),
        a.alloc(+V)
    }
    a.isBuffer = function(U) {
        return U != null && U._isBuffer === !0 && U !== a.prototype
    }
    ,
    a.compare = function(U, N) {
        if (ne(U, Uint8Array) && (U = a.from(U, U.offset, U.byteLength)),
        ne(N, Uint8Array) && (N = a.from(N, N.offset, N.byteLength)),
        !a.isBuffer(U) || !a.isBuffer(N))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (U === N)
            return 0;
        let K = U.length
          , oe = N.length;
        for (let pe = 0, ve = Math.min(K, oe); pe < ve; ++pe)
            if (U[pe] !== N[pe]) {
                K = U[pe],
                oe = N[pe];
                break
            }
        return K < oe ? -1 : oe < K ? 1 : 0
    }
    ,
    a.isEncoding = function(U) {
        switch (String(U).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    a.concat = function(U, N) {
        if (!Array.isArray(U))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (U.length === 0)
            return a.alloc(0);
        let K;
        if (N === void 0)
            for (N = 0,
            K = 0; K < U.length; ++K)
                N += U[K].length;
        const oe = a.allocUnsafe(N);
        let pe = 0;
        for (K = 0; K < U.length; ++K) {
            let ve = U[K];
            if (ne(ve, Uint8Array))
                pe + ve.length > oe.length ? (a.isBuffer(ve) || (ve = a.from(ve)),
                ve.copy(oe, pe)) : Uint8Array.prototype.set.call(oe, ve, pe);
            else if (a.isBuffer(ve))
                ve.copy(oe, pe);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            pe += ve.length
        }
        return oe
    }
    ;
    function w(V, U) {
        if (a.isBuffer(V))
            return V.length;
        if (ArrayBuffer.isView(V) || ne(V, ArrayBuffer))
            return V.byteLength;
        if (typeof V != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof V);
        const N = V.length
          , K = arguments.length > 2 && arguments[2] === !0;
        if (!K && N === 0)
            return 0;
        let oe = !1;
        for (; ; )
            switch (U) {
            case "ascii":
            case "latin1":
            case "binary":
                return N;
            case "utf8":
            case "utf-8":
                return J(V).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return N * 2;
            case "hex":
                return N >>> 1;
            case "base64":
                return X(V).length;
            default:
                if (oe)
                    return K ? -1 : J(V).length;
                U = ("" + U).toLowerCase(),
                oe = !0
            }
    }
    a.byteLength = w;
    function _(V, U, N) {
        let K = !1;
        if ((U === void 0 || U < 0) && (U = 0),
        U > this.length || ((N === void 0 || N > this.length) && (N = this.length),
        N <= 0) || (N >>>= 0,
        U >>>= 0,
        N <= U))
            return "";
        for (V || (V = "utf8"); ; )
            switch (V) {
            case "hex":
                return z(this, U, N);
            case "utf8":
            case "utf-8":
                return y(this, U, N);
            case "ascii":
                return F(this, U, N);
            case "latin1":
            case "binary":
                return O(this, U, N);
            case "base64":
                return T(this, U, N);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return j(this, U, N);
            default:
                if (K)
                    throw new TypeError("Unknown encoding: " + V);
                V = (V + "").toLowerCase(),
                K = !0
            }
    }
    a.prototype._isBuffer = !0;
    function x(V, U, N) {
        const K = V[U];
        V[U] = V[N],
        V[N] = K
    }
    a.prototype.swap16 = function() {
        const U = this.length;
        if (U % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let N = 0; N < U; N += 2)
            x(this, N, N + 1);
        return this
    }
    ,
    a.prototype.swap32 = function() {
        const U = this.length;
        if (U % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let N = 0; N < U; N += 4)
            x(this, N, N + 3),
            x(this, N + 1, N + 2);
        return this
    }
    ,
    a.prototype.swap64 = function() {
        const U = this.length;
        if (U % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let N = 0; N < U; N += 8)
            x(this, N, N + 7),
            x(this, N + 1, N + 6),
            x(this, N + 2, N + 5),
            x(this, N + 3, N + 4);
        return this
    }
    ,
    a.prototype.toString = function() {
        const U = this.length;
        return U === 0 ? "" : arguments.length === 0 ? y(this, 0, U) : _.apply(this, arguments)
    }
    ,
    a.prototype.toLocaleString = a.prototype.toString,
    a.prototype.equals = function(U) {
        if (!a.isBuffer(U))
            throw new TypeError("Argument must be a Buffer");
        return this === U ? !0 : a.compare(this, U) === 0
    }
    ,
    a.prototype.inspect = function() {
        let U = "";
        const N = n.INSPECT_MAX_BYTES;
        return U = this.toString("hex", 0, N).replace(/(.{2})/g, "$1 ").trim(),
        this.length > N && (U += " ... "),
        "<Buffer " + U + ">"
    }
    ,
    r && (a.prototype[r] = a.prototype.inspect),
    a.prototype.compare = function(U, N, K, oe, pe) {
        if (ne(U, Uint8Array) && (U = a.from(U, U.offset, U.byteLength)),
        !a.isBuffer(U))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof U);
        if (N === void 0 && (N = 0),
        K === void 0 && (K = U ? U.length : 0),
        oe === void 0 && (oe = 0),
        pe === void 0 && (pe = this.length),
        N < 0 || K > U.length || oe < 0 || pe > this.length)
            throw new RangeError("out of range index");
        if (oe >= pe && N >= K)
            return 0;
        if (oe >= pe)
            return -1;
        if (N >= K)
            return 1;
        if (N >>>= 0,
        K >>>= 0,
        oe >>>= 0,
        pe >>>= 0,
        this === U)
            return 0;
        let ve = pe - oe
          , Ce = K - N;
        const Le = Math.min(ve, Ce)
          , Re = this.slice(oe, pe)
          , $e = U.slice(N, K);
        for (let ce = 0; ce < Le; ++ce)
            if (Re[ce] !== $e[ce]) {
                ve = Re[ce],
                Ce = $e[ce];
                break
            }
        return ve < Ce ? -1 : Ce < ve ? 1 : 0
    }
    ;
    function b(V, U, N, K, oe) {
        if (V.length === 0)
            return -1;
        if (typeof N == "string" ? (K = N,
        N = 0) : N > 2147483647 ? N = 2147483647 : N < -2147483648 && (N = -2147483648),
        N = +N,
        Y(N) && (N = oe ? 0 : V.length - 1),
        N < 0 && (N = V.length + N),
        N >= V.length) {
            if (oe)
                return -1;
            N = V.length - 1
        } else if (N < 0)
            if (oe)
                N = 0;
            else
                return -1;
        if (typeof U == "string" && (U = a.from(U, K)),
        a.isBuffer(U))
            return U.length === 0 ? -1 : B(V, U, N, K, oe);
        if (typeof U == "number")
            return U = U & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? oe ? Uint8Array.prototype.indexOf.call(V, U, N) : Uint8Array.prototype.lastIndexOf.call(V, U, N) : B(V, [U], N, K, oe);
        throw new TypeError("val must be string, number or Buffer")
    }
    function B(V, U, N, K, oe) {
        let pe = 1
          , ve = V.length
          , Ce = U.length;
        if (K !== void 0 && (K = String(K).toLowerCase(),
        K === "ucs2" || K === "ucs-2" || K === "utf16le" || K === "utf-16le")) {
            if (V.length < 2 || U.length < 2)
                return -1;
            pe = 2,
            ve /= 2,
            Ce /= 2,
            N /= 2
        }
        function Le($e, ce) {
            return pe === 1 ? $e[ce] : $e.readUInt16BE(ce * pe)
        }
        let Re;
        if (oe) {
            let $e = -1;
            for (Re = N; Re < ve; Re++)
                if (Le(V, Re) === Le(U, $e === -1 ? 0 : Re - $e)) {
                    if ($e === -1 && ($e = Re),
                    Re - $e + 1 === Ce)
                        return $e * pe
                } else
                    $e !== -1 && (Re -= Re - $e),
                    $e = -1
        } else
            for (N + Ce > ve && (N = ve - Ce),
            Re = N; Re >= 0; Re--) {
                let $e = !0;
                for (let ce = 0; ce < Ce; ce++)
                    if (Le(V, Re + ce) !== Le(U, ce)) {
                        $e = !1;
                        break
                    }
                if ($e)
                    return Re
            }
        return -1
    }
    a.prototype.includes = function(U, N, K) {
        return this.indexOf(U, N, K) !== -1
    }
    ,
    a.prototype.indexOf = function(U, N, K) {
        return b(this, U, N, K, !0)
    }
    ,
    a.prototype.lastIndexOf = function(U, N, K) {
        return b(this, U, N, K, !1)
    }
    ;
    function S(V, U, N, K) {
        N = Number(N) || 0;
        const oe = V.length - N;
        K ? (K = Number(K),
        K > oe && (K = oe)) : K = oe;
        const pe = U.length;
        K > pe / 2 && (K = pe / 2);
        let ve;
        for (ve = 0; ve < K; ++ve) {
            const Ce = parseInt(U.substr(ve * 2, 2), 16);
            if (Y(Ce))
                return ve;
            V[N + ve] = Ce
        }
        return ve
    }
    function I(V, U, N, K) {
        return G(J(U, V.length - N), V, N, K)
    }
    function M(V, U, N, K) {
        return G(q(U), V, N, K)
    }
    function L(V, U, N, K) {
        return G(X(U), V, N, K)
    }
    function D(V, U, N, K) {
        return G(he(U, V.length - N), V, N, K)
    }
    a.prototype.write = function(U, N, K, oe) {
        if (N === void 0)
            oe = "utf8",
            K = this.length,
            N = 0;
        else if (K === void 0 && typeof N == "string")
            oe = N,
            K = this.length,
            N = 0;
        else if (isFinite(N))
            N = N >>> 0,
            isFinite(K) ? (K = K >>> 0,
            oe === void 0 && (oe = "utf8")) : (oe = K,
            K = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const pe = this.length - N;
        if ((K === void 0 || K > pe) && (K = pe),
        U.length > 0 && (K < 0 || N < 0) || N > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        oe || (oe = "utf8");
        let ve = !1;
        for (; ; )
            switch (oe) {
            case "hex":
                return S(this, U, N, K);
            case "utf8":
            case "utf-8":
                return I(this, U, N, K);
            case "ascii":
            case "latin1":
            case "binary":
                return M(this, U, N, K);
            case "base64":
                return L(this, U, N, K);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return D(this, U, N, K);
            default:
                if (ve)
                    throw new TypeError("Unknown encoding: " + oe);
                oe = ("" + oe).toLowerCase(),
                ve = !0
            }
    }
    ,
    a.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function T(V, U, N) {
        return U === 0 && N === V.length ? e.fromByteArray(V) : e.fromByteArray(V.slice(U, N))
    }
    function y(V, U, N) {
        N = Math.min(V.length, N);
        const K = [];
        let oe = U;
        for (; oe < N; ) {
            const pe = V[oe];
            let ve = null
              , Ce = pe > 239 ? 4 : pe > 223 ? 3 : pe > 191 ? 2 : 1;
            if (oe + Ce <= N) {
                let Le, Re, $e, ce;
                switch (Ce) {
                case 1:
                    pe < 128 && (ve = pe);
                    break;
                case 2:
                    Le = V[oe + 1],
                    (Le & 192) === 128 && (ce = (pe & 31) << 6 | Le & 63,
                    ce > 127 && (ve = ce));
                    break;
                case 3:
                    Le = V[oe + 1],
                    Re = V[oe + 2],
                    (Le & 192) === 128 && (Re & 192) === 128 && (ce = (pe & 15) << 12 | (Le & 63) << 6 | Re & 63,
                    ce > 2047 && (ce < 55296 || ce > 57343) && (ve = ce));
                    break;
                case 4:
                    Le = V[oe + 1],
                    Re = V[oe + 2],
                    $e = V[oe + 3],
                    (Le & 192) === 128 && (Re & 192) === 128 && ($e & 192) === 128 && (ce = (pe & 15) << 18 | (Le & 63) << 12 | (Re & 63) << 6 | $e & 63,
                    ce > 65535 && ce < 1114112 && (ve = ce))
                }
            }
            ve === null ? (ve = 65533,
            Ce = 1) : ve > 65535 && (ve -= 65536,
            K.push(ve >>> 10 & 1023 | 55296),
            ve = 56320 | ve & 1023),
            K.push(ve),
            oe += Ce
        }
        return R(K)
    }
    const E = 4096;
    function R(V) {
        const U = V.length;
        if (U <= E)
            return String.fromCharCode.apply(String, V);
        let N = ""
          , K = 0;
        for (; K < U; )
            N += String.fromCharCode.apply(String, V.slice(K, K += E));
        return N
    }
    function F(V, U, N) {
        let K = "";
        N = Math.min(V.length, N);
        for (let oe = U; oe < N; ++oe)
            K += String.fromCharCode(V[oe] & 127);
        return K
    }
    function O(V, U, N) {
        let K = "";
        N = Math.min(V.length, N);
        for (let oe = U; oe < N; ++oe)
            K += String.fromCharCode(V[oe]);
        return K
    }
    function z(V, U, N) {
        const K = V.length;
        (!U || U < 0) && (U = 0),
        (!N || N < 0 || N > K) && (N = K);
        let oe = "";
        for (let pe = U; pe < N; ++pe)
            oe += de[V[pe]];
        return oe
    }
    function j(V, U, N) {
        const K = V.slice(U, N);
        let oe = "";
        for (let pe = 0; pe < K.length - 1; pe += 2)
            oe += String.fromCharCode(K[pe] + K[pe + 1] * 256);
        return oe
    }
    a.prototype.slice = function(U, N) {
        const K = this.length;
        U = ~~U,
        N = N === void 0 ? K : ~~N,
        U < 0 ? (U += K,
        U < 0 && (U = 0)) : U > K && (U = K),
        N < 0 ? (N += K,
        N < 0 && (N = 0)) : N > K && (N = K),
        N < U && (N = U);
        const oe = this.subarray(U, N);
        return Object.setPrototypeOf(oe, a.prototype),
        oe
    }
    ;
    function Q(V, U, N) {
        if (V % 1 !== 0 || V < 0)
            throw new RangeError("offset is not uint");
        if (V + U > N)
            throw new RangeError("Trying to access beyond buffer length")
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(U, N, K) {
        U = U >>> 0,
        N = N >>> 0,
        K || Q(U, N, this.length);
        let oe = this[U]
          , pe = 1
          , ve = 0;
        for (; ++ve < N && (pe *= 256); )
            oe += this[U + ve] * pe;
        return oe
    }
    ,
    a.prototype.readUintBE = a.prototype.readUIntBE = function(U, N, K) {
        U = U >>> 0,
        N = N >>> 0,
        K || Q(U, N, this.length);
        let oe = this[U + --N]
          , pe = 1;
        for (; N > 0 && (pe *= 256); )
            oe += this[U + --N] * pe;
        return oe
    }
    ,
    a.prototype.readUint8 = a.prototype.readUInt8 = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 1, this.length),
        this[U]
    }
    ,
    a.prototype.readUint16LE = a.prototype.readUInt16LE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 2, this.length),
        this[U] | this[U + 1] << 8
    }
    ,
    a.prototype.readUint16BE = a.prototype.readUInt16BE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 2, this.length),
        this[U] << 8 | this[U + 1]
    }
    ,
    a.prototype.readUint32LE = a.prototype.readUInt32LE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        (this[U] | this[U + 1] << 8 | this[U + 2] << 16) + this[U + 3] * 16777216
    }
    ,
    a.prototype.readUint32BE = a.prototype.readUInt32BE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        this[U] * 16777216 + (this[U + 1] << 16 | this[U + 2] << 8 | this[U + 3])
    }
    ,
    a.prototype.readBigUInt64LE = ae(function(U) {
        U = U >>> 0,
        se(U, "offset");
        const N = this[U]
          , K = this[U + 7];
        (N === void 0 || K === void 0) && H(U, this.length - 8);
        const oe = N + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24
          , pe = this[++U] + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + K * 2 ** 24;
        return BigInt(oe) + (BigInt(pe) << BigInt(32))
    }),
    a.prototype.readBigUInt64BE = ae(function(U) {
        U = U >>> 0,
        se(U, "offset");
        const N = this[U]
          , K = this[U + 7];
        (N === void 0 || K === void 0) && H(U, this.length - 8);
        const oe = N * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U]
          , pe = this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + K;
        return (BigInt(oe) << BigInt(32)) + BigInt(pe)
    }),
    a.prototype.readIntLE = function(U, N, K) {
        U = U >>> 0,
        N = N >>> 0,
        K || Q(U, N, this.length);
        let oe = this[U]
          , pe = 1
          , ve = 0;
        for (; ++ve < N && (pe *= 256); )
            oe += this[U + ve] * pe;
        return pe *= 128,
        oe >= pe && (oe -= Math.pow(2, 8 * N)),
        oe
    }
    ,
    a.prototype.readIntBE = function(U, N, K) {
        U = U >>> 0,
        N = N >>> 0,
        K || Q(U, N, this.length);
        let oe = N
          , pe = 1
          , ve = this[U + --oe];
        for (; oe > 0 && (pe *= 256); )
            ve += this[U + --oe] * pe;
        return pe *= 128,
        ve >= pe && (ve -= Math.pow(2, 8 * N)),
        ve
    }
    ,
    a.prototype.readInt8 = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 1, this.length),
        this[U] & 128 ? (255 - this[U] + 1) * -1 : this[U]
    }
    ,
    a.prototype.readInt16LE = function(U, N) {
        U = U >>> 0,
        N || Q(U, 2, this.length);
        const K = this[U] | this[U + 1] << 8;
        return K & 32768 ? K | 4294901760 : K
    }
    ,
    a.prototype.readInt16BE = function(U, N) {
        U = U >>> 0,
        N || Q(U, 2, this.length);
        const K = this[U + 1] | this[U] << 8;
        return K & 32768 ? K | 4294901760 : K
    }
    ,
    a.prototype.readInt32LE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        this[U] | this[U + 1] << 8 | this[U + 2] << 16 | this[U + 3] << 24
    }
    ,
    a.prototype.readInt32BE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        this[U] << 24 | this[U + 1] << 16 | this[U + 2] << 8 | this[U + 3]
    }
    ,
    a.prototype.readBigInt64LE = ae(function(U) {
        U = U >>> 0,
        se(U, "offset");
        const N = this[U]
          , K = this[U + 7];
        (N === void 0 || K === void 0) && H(U, this.length - 8);
        const oe = this[U + 4] + this[U + 5] * 2 ** 8 + this[U + 6] * 2 ** 16 + (K << 24);
        return (BigInt(oe) << BigInt(32)) + BigInt(N + this[++U] * 2 ** 8 + this[++U] * 2 ** 16 + this[++U] * 2 ** 24)
    }),
    a.prototype.readBigInt64BE = ae(function(U) {
        U = U >>> 0,
        se(U, "offset");
        const N = this[U]
          , K = this[U + 7];
        (N === void 0 || K === void 0) && H(U, this.length - 8);
        const oe = (N << 24) + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + this[++U];
        return (BigInt(oe) << BigInt(32)) + BigInt(this[++U] * 2 ** 24 + this[++U] * 2 ** 16 + this[++U] * 2 ** 8 + K)
    }),
    a.prototype.readFloatLE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        t.read(this, U, !0, 23, 4)
    }
    ,
    a.prototype.readFloatBE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 4, this.length),
        t.read(this, U, !1, 23, 4)
    }
    ,
    a.prototype.readDoubleLE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 8, this.length),
        t.read(this, U, !0, 52, 8)
    }
    ,
    a.prototype.readDoubleBE = function(U, N) {
        return U = U >>> 0,
        N || Q(U, 8, this.length),
        t.read(this, U, !1, 52, 8)
    }
    ;
    function C(V, U, N, K, oe, pe) {
        if (!a.isBuffer(V))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (U > oe || U < pe)
            throw new RangeError('"value" argument is out of bounds');
        if (N + K > V.length)
            throw new RangeError("Index out of range")
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(U, N, K, oe) {
        if (U = +U,
        N = N >>> 0,
        K = K >>> 0,
        !oe) {
            const Ce = Math.pow(2, 8 * K) - 1;
            C(this, U, N, K, Ce, 0)
        }
        let pe = 1
          , ve = 0;
        for (this[N] = U & 255; ++ve < K && (pe *= 256); )
            this[N + ve] = U / pe & 255;
        return N + K
    }
    ,
    a.prototype.writeUintBE = a.prototype.writeUIntBE = function(U, N, K, oe) {
        if (U = +U,
        N = N >>> 0,
        K = K >>> 0,
        !oe) {
            const Ce = Math.pow(2, 8 * K) - 1;
            C(this, U, N, K, Ce, 0)
        }
        let pe = K - 1
          , ve = 1;
        for (this[N + pe] = U & 255; --pe >= 0 && (ve *= 256); )
            this[N + pe] = U / ve & 255;
        return N + K
    }
    ,
    a.prototype.writeUint8 = a.prototype.writeUInt8 = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 1, 255, 0),
        this[N] = U & 255,
        N + 1
    }
    ,
    a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 2, 65535, 0),
        this[N] = U & 255,
        this[N + 1] = U >>> 8,
        N + 2
    }
    ,
    a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 2, 65535, 0),
        this[N] = U >>> 8,
        this[N + 1] = U & 255,
        N + 2
    }
    ,
    a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 4, 4294967295, 0),
        this[N + 3] = U >>> 24,
        this[N + 2] = U >>> 16,
        this[N + 1] = U >>> 8,
        this[N] = U & 255,
        N + 4
    }
    ,
    a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 4, 4294967295, 0),
        this[N] = U >>> 24,
        this[N + 1] = U >>> 16,
        this[N + 2] = U >>> 8,
        this[N + 3] = U & 255,
        N + 4
    }
    ;
    function W(V, U, N, K, oe) {
        _e(U, K, oe, V, N, 7);
        let pe = Number(U & BigInt(4294967295));
        V[N++] = pe,
        pe = pe >> 8,
        V[N++] = pe,
        pe = pe >> 8,
        V[N++] = pe,
        pe = pe >> 8,
        V[N++] = pe;
        let ve = Number(U >> BigInt(32) & BigInt(4294967295));
        return V[N++] = ve,
        ve = ve >> 8,
        V[N++] = ve,
        ve = ve >> 8,
        V[N++] = ve,
        ve = ve >> 8,
        V[N++] = ve,
        N
    }
    function ee(V, U, N, K, oe) {
        _e(U, K, oe, V, N, 7);
        let pe = Number(U & BigInt(4294967295));
        V[N + 7] = pe,
        pe = pe >> 8,
        V[N + 6] = pe,
        pe = pe >> 8,
        V[N + 5] = pe,
        pe = pe >> 8,
        V[N + 4] = pe;
        let ve = Number(U >> BigInt(32) & BigInt(4294967295));
        return V[N + 3] = ve,
        ve = ve >> 8,
        V[N + 2] = ve,
        ve = ve >> 8,
        V[N + 1] = ve,
        ve = ve >> 8,
        V[N] = ve,
        N + 8
    }
    a.prototype.writeBigUInt64LE = ae(function(U, N=0) {
        return W(this, U, N, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeBigUInt64BE = ae(function(U, N=0) {
        return ee(this, U, N, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    a.prototype.writeIntLE = function(U, N, K, oe) {
        if (U = +U,
        N = N >>> 0,
        !oe) {
            const Le = Math.pow(2, 8 * K - 1);
            C(this, U, N, K, Le - 1, -Le)
        }
        let pe = 0
          , ve = 1
          , Ce = 0;
        for (this[N] = U & 255; ++pe < K && (ve *= 256); )
            U < 0 && Ce === 0 && this[N + pe - 1] !== 0 && (Ce = 1),
            this[N + pe] = (U / ve >> 0) - Ce & 255;
        return N + K
    }
    ,
    a.prototype.writeIntBE = function(U, N, K, oe) {
        if (U = +U,
        N = N >>> 0,
        !oe) {
            const Le = Math.pow(2, 8 * K - 1);
            C(this, U, N, K, Le - 1, -Le)
        }
        let pe = K - 1
          , ve = 1
          , Ce = 0;
        for (this[N + pe] = U & 255; --pe >= 0 && (ve *= 256); )
            U < 0 && Ce === 0 && this[N + pe + 1] !== 0 && (Ce = 1),
            this[N + pe] = (U / ve >> 0) - Ce & 255;
        return N + K
    }
    ,
    a.prototype.writeInt8 = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 1, 127, -128),
        U < 0 && (U = 255 + U + 1),
        this[N] = U & 255,
        N + 1
    }
    ,
    a.prototype.writeInt16LE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 2, 32767, -32768),
        this[N] = U & 255,
        this[N + 1] = U >>> 8,
        N + 2
    }
    ,
    a.prototype.writeInt16BE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 2, 32767, -32768),
        this[N] = U >>> 8,
        this[N + 1] = U & 255,
        N + 2
    }
    ,
    a.prototype.writeInt32LE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 4, 2147483647, -2147483648),
        this[N] = U & 255,
        this[N + 1] = U >>> 8,
        this[N + 2] = U >>> 16,
        this[N + 3] = U >>> 24,
        N + 4
    }
    ,
    a.prototype.writeInt32BE = function(U, N, K) {
        return U = +U,
        N = N >>> 0,
        K || C(this, U, N, 4, 2147483647, -2147483648),
        U < 0 && (U = 4294967295 + U + 1),
        this[N] = U >>> 24,
        this[N + 1] = U >>> 16,
        this[N + 2] = U >>> 8,
        this[N + 3] = U & 255,
        N + 4
    }
    ,
    a.prototype.writeBigInt64LE = ae(function(U, N=0) {
        return W(this, U, N, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    a.prototype.writeBigInt64BE = ae(function(U, N=0) {
        return ee(this, U, N, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function P(V, U, N, K, oe, pe) {
        if (N + K > V.length)
            throw new RangeError("Index out of range");
        if (N < 0)
            throw new RangeError("Index out of range")
    }
    function re(V, U, N, K, oe) {
        return U = +U,
        N = N >>> 0,
        oe || P(V, U, N, 4),
        t.write(V, U, N, K, 23, 4),
        N + 4
    }
    a.prototype.writeFloatLE = function(U, N, K) {
        return re(this, U, N, !0, K)
    }
    ,
    a.prototype.writeFloatBE = function(U, N, K) {
        return re(this, U, N, !1, K)
    }
    ;
    function ue(V, U, N, K, oe) {
        return U = +U,
        N = N >>> 0,
        oe || P(V, U, N, 8),
        t.write(V, U, N, K, 52, 8),
        N + 8
    }
    a.prototype.writeDoubleLE = function(U, N, K) {
        return ue(this, U, N, !0, K)
    }
    ,
    a.prototype.writeDoubleBE = function(U, N, K) {
        return ue(this, U, N, !1, K)
    }
    ,
    a.prototype.copy = function(U, N, K, oe) {
        if (!a.isBuffer(U))
            throw new TypeError("argument should be a Buffer");
        if (K || (K = 0),
        !oe && oe !== 0 && (oe = this.length),
        N >= U.length && (N = U.length),
        N || (N = 0),
        oe > 0 && oe < K && (oe = K),
        oe === K || U.length === 0 || this.length === 0)
            return 0;
        if (N < 0)
            throw new RangeError("targetStart out of bounds");
        if (K < 0 || K >= this.length)
            throw new RangeError("Index out of range");
        if (oe < 0)
            throw new RangeError("sourceEnd out of bounds");
        oe > this.length && (oe = this.length),
        U.length - N < oe - K && (oe = U.length - N + K);
        const pe = oe - K;
        return this === U && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(N, K, oe) : Uint8Array.prototype.set.call(U, this.subarray(K, oe), N),
        pe
    }
    ,
    a.prototype.fill = function(U, N, K, oe) {
        if (typeof U == "string") {
            if (typeof N == "string" ? (oe = N,
            N = 0,
            K = this.length) : typeof K == "string" && (oe = K,
            K = this.length),
            oe !== void 0 && typeof oe != "string")
                throw new TypeError("encoding must be a string");
            if (typeof oe == "string" && !a.isEncoding(oe))
                throw new TypeError("Unknown encoding: " + oe);
            if (U.length === 1) {
                const ve = U.charCodeAt(0);
                (oe === "utf8" && ve < 128 || oe === "latin1") && (U = ve)
            }
        } else
            typeof U == "number" ? U = U & 255 : typeof U == "boolean" && (U = Number(U));
        if (N < 0 || this.length < N || this.length < K)
            throw new RangeError("Out of range index");
        if (K <= N)
            return this;
        N = N >>> 0,
        K = K === void 0 ? this.length : K >>> 0,
        U || (U = 0);
        let pe;
        if (typeof U == "number")
            for (pe = N; pe < K; ++pe)
                this[pe] = U;
        else {
            const ve = a.isBuffer(U) ? U : a.from(U, oe)
              , Ce = ve.length;
            if (Ce === 0)
                throw new TypeError('The value "' + U + '" is invalid for argument "value"');
            for (pe = 0; pe < K - N; ++pe)
                this[pe + N] = ve[pe % Ce]
        }
        return this
    }
    ;
    const le = {};
    function me(V, U, N) {
        le[V] = class extends N {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: U.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${V}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return V
            }
            set code(oe) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: oe,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${V}]: ${this.message}`
            }
        }
    }
    me("ERR_BUFFER_OUT_OF_BOUNDS", function(V) {
        return V ? `${V} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    me("ERR_INVALID_ARG_TYPE", function(V, U) {
        return `The "${V}" argument must be of type number. Received type ${typeof U}`
    }, TypeError),
    me("ERR_OUT_OF_RANGE", function(V, U, N) {
        let K = `The value of "${V}" is out of range.`
          , oe = N;
        return Number.isInteger(N) && Math.abs(N) > 2 ** 32 ? oe = ie(String(N)) : typeof N == "bigint" && (oe = String(N),
        (N > BigInt(2) ** BigInt(32) || N < -(BigInt(2) ** BigInt(32))) && (oe = ie(oe)),
        oe += "n"),
        K += ` It must be ${U}. Received ${oe}`,
        K
    }, RangeError);
    function ie(V) {
        let U = ""
          , N = V.length;
        const K = V[0] === "-" ? 1 : 0;
        for (; N >= K + 4; N -= 3)
            U = `_${V.slice(N - 3, N)}${U}`;
        return `${V.slice(0, N)}${U}`
    }
    function ge(V, U, N) {
        se(U, "offset"),
        (V[U] === void 0 || V[U + N] === void 0) && H(U, V.length - (N + 1))
    }
    function _e(V, U, N, K, oe, pe) {
        if (V > N || V < U) {
            const ve = typeof U == "bigint" ? "n" : "";
            let Ce;
            throw pe > 3 ? U === 0 || U === BigInt(0) ? Ce = `>= 0${ve} and < 2${ve} ** ${(pe + 1) * 8}${ve}` : Ce = `>= -(2${ve} ** ${(pe + 1) * 8 - 1}${ve}) and < 2 ** ${(pe + 1) * 8 - 1}${ve}` : Ce = `>= ${U}${ve} and <= ${N}${ve}`,
            new le.ERR_OUT_OF_RANGE("value",Ce,V)
        }
        ge(K, oe, pe)
    }
    function se(V, U) {
        if (typeof V != "number")
            throw new le.ERR_INVALID_ARG_TYPE(U,"number",V)
    }
    function H(V, U, N) {
        throw Math.floor(V) !== V ? (se(V, N),
        new le.ERR_OUT_OF_RANGE(N || "offset","an integer",V)) : U < 0 ? new le.ERR_BUFFER_OUT_OF_BOUNDS : new le.ERR_OUT_OF_RANGE(N || "offset",`>= ${N ? 1 : 0} and <= ${U}`,V)
    }
    const fe = /[^+/0-9A-Za-z-_]/g;
    function Ae(V) {
        if (V = V.split("=")[0],
        V = V.trim().replace(fe, ""),
        V.length < 2)
            return "";
        for (; V.length % 4 !== 0; )
            V = V + "=";
        return V
    }
    function J(V, U) {
        U = U || 1 / 0;
        let N;
        const K = V.length;
        let oe = null;
        const pe = [];
        for (let ve = 0; ve < K; ++ve) {
            if (N = V.charCodeAt(ve),
            N > 55295 && N < 57344) {
                if (!oe) {
                    if (N > 56319) {
                        (U -= 3) > -1 && pe.push(239, 191, 189);
                        continue
                    } else if (ve + 1 === K) {
                        (U -= 3) > -1 && pe.push(239, 191, 189);
                        continue
                    }
                    oe = N;
                    continue
                }
                if (N < 56320) {
                    (U -= 3) > -1 && pe.push(239, 191, 189),
                    oe = N;
                    continue
                }
                N = (oe - 55296 << 10 | N - 56320) + 65536
            } else
                oe && (U -= 3) > -1 && pe.push(239, 191, 189);
            if (oe = null,
            N < 128) {
                if ((U -= 1) < 0)
                    break;
                pe.push(N)
            } else if (N < 2048) {
                if ((U -= 2) < 0)
                    break;
                pe.push(N >> 6 | 192, N & 63 | 128)
            } else if (N < 65536) {
                if ((U -= 3) < 0)
                    break;
                pe.push(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128)
            } else if (N < 1114112) {
                if ((U -= 4) < 0)
                    break;
                pe.push(N >> 18 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return pe
    }
    function q(V) {
        const U = [];
        for (let N = 0; N < V.length; ++N)
            U.push(V.charCodeAt(N) & 255);
        return U
    }
    function he(V, U) {
        let N, K, oe;
        const pe = [];
        for (let ve = 0; ve < V.length && !((U -= 2) < 0); ++ve)
            N = V.charCodeAt(ve),
            K = N >> 8,
            oe = N % 256,
            pe.push(oe),
            pe.push(K);
        return pe
    }
    function X(V) {
        return e.toByteArray(Ae(V))
    }
    function G(V, U, N, K) {
        let oe;
        for (oe = 0; oe < K && !(oe + N >= U.length || oe >= V.length); ++oe)
            U[oe + N] = V[oe];
        return oe
    }
    function ne(V, U) {
        return V instanceof U || V != null && V.constructor != null && V.constructor.name != null && V.constructor.name === U.name
    }
    function Y(V) {
        return V !== V
    }
    const de = function() {
        const V = "0123456789abcdef"
          , U = new Array(256);
        for (let N = 0; N < 16; ++N) {
            const K = N * 16;
            for (let oe = 0; oe < 16; ++oe)
                U[K + oe] = V[N] + V[oe]
        }
        return U
    }();
    function ae(V) {
        return typeof BigInt > "u" ? Ee : V
    }
    function Ee() {
        throw new Error("BigInt not supported")
    }
}
)(l8);
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zC = function(n, e) {
    return zC = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(t, r) {
        t.__proto__ = r
    }
    || function(t, r) {
        for (var i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
    }
    ,
    zC(n, e)
};
function ua(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    zC(n, e);
    function t() {
        this.constructor = n
    }
    n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
    new t)
}
function qs(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
function gs(n, e) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1)
                throw s[1];
            return s[1]
        },
        trys: [],
        ops: []
    }, r, i, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(c) {
        return function(A) {
            return l([c, A])
        }
    }
    function l(c) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; t; )
            try {
                if (r = 1,
                i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i),
                0) : i.next) && !(s = s.call(i, c[1])).done)
                    return s;
                switch (i = 0,
                s && (c = [c[0] & 2, s.value]),
                c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return t.label++,
                    {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    t.label++,
                    i = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = t.ops.pop(),
                    t.trys.pop();
                    continue;
                default:
                    if (s = t.trys,
                    !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        t = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        t.label = c[1];
                        break
                    }
                    if (c[0] === 6 && t.label < s[1]) {
                        t.label = s[1],
                        s = c;
                        break
                    }
                    if (s && t.label < s[2]) {
                        t.label = s[2],
                        t.ops.push(c);
                        break
                    }
                    s[2] && t.ops.pop(),
                    t.trys.pop();
                    continue
                }
                c = e.call(n, t)
            } catch (A) {
                c = [6, A],
                i = 0
            } finally {
                r = s = 0
            }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
var Qu = function() {
    function n(e, t, r, i) {
        this.left = e,
        this.top = t,
        this.width = r,
        this.height = i
    }
    return n.prototype.add = function(e, t, r, i) {
        return new n(this.left + e,this.top + t,this.width + r,this.height + i)
    }
    ,
    n.fromClientRect = function(e, t) {
        return new n(t.left + e.windowBounds.left,t.top + e.windowBounds.top,t.width,t.height)
    }
    ,
    n.fromDOMRectList = function(e, t) {
        var r = Array.from(t).find(function(i) {
            return i.width !== 0
        });
        return r ? new n(r.left + e.windowBounds.left,r.top + e.windowBounds.top,r.width,r.height) : n.EMPTY
    }
    ,
    n.EMPTY = new n(0,0,0,0),
    n
}()
  , qR = function(n, e) {
    return Qu.fromClientRect(n, e.getBoundingClientRect())
}
  , x1 = function(n) {
    for (var e = [], t = 0, r = n.length; t < r; ) {
        var i = n.charCodeAt(t++);
        if (i >= 55296 && i <= 56319 && t < r) {
            var s = n.charCodeAt(t++);
            (s & 64512) === 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i),
            t--)
        } else
            e.push(i)
    }
    return e
}
  , Ar = function() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n[e] = arguments[e];
    if (String.fromCodePoint)
        return String.fromCodePoint.apply(String, n);
    var t = n.length;
    if (!t)
        return "";
    for (var r = [], i = -1, s = ""; ++i < t; ) {
        var o = n[i];
        o <= 65535 ? r.push(o) : (o -= 65536,
        r.push((o >> 10) + 55296, o % 1024 + 56320)),
        (i + 1 === t || r.length > 16384) && (s += String.fromCharCode.apply(String, r),
        r.length = 0)
    }
    return s
}
  , kD = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , Ile = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Xv = 0; Xv < kD.length; Xv++)
    Ile[kD.charCodeAt(Xv)] = Xv;
var QD = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , Em = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Yv = 0; Yv < QD.length; Yv++)
    Em[QD.charCodeAt(Yv)] = Yv;
var Rle = function(n) {
    var e = n.length * .75, t = n.length, r, i = 0, s, o, a, l;
    n[n.length - 1] === "=" && (e--,
    n[n.length - 2] === "=" && e--);
    var c = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e)
      , A = Array.isArray(c) ? c : new Uint8Array(c);
    for (r = 0; r < t; r += 4)
        s = Em[n.charCodeAt(r)],
        o = Em[n.charCodeAt(r + 1)],
        a = Em[n.charCodeAt(r + 2)],
        l = Em[n.charCodeAt(r + 3)],
        A[i++] = s << 2 | o >> 4,
        A[i++] = (o & 15) << 4 | a >> 2,
        A[i++] = (a & 3) << 6 | l & 63;
    return c
}
  , Ule = function(n) {
    for (var e = n.length, t = [], r = 0; r < e; r += 2)
        t.push(n[r + 1] << 8 | n[r]);
    return t
}
  , Fle = function(n) {
    for (var e = n.length, t = [], r = 0; r < e; r += 4)
        t.push(n[r + 3] << 24 | n[r + 2] << 16 | n[r + 1] << 8 | n[r]);
    return t
}
  , Bu = 5
  , e2 = 6 + 5
  , dB = 2
  , Ple = e2 - Bu
  , A8 = 65536 >> Bu
  , Lle = 1 << Bu
  , pB = Lle - 1
  , Dle = 1024 >> Bu
  , Nle = A8 + Dle
  , Ole = Nle
  , kle = 32
  , Qle = Ole + kle
  , Hle = 65536 >> e2
  , zle = 1 << Ple
  , Gle = zle - 1
  , HD = function(n, e, t) {
    return n.slice ? n.slice(e, t) : new Uint16Array(Array.prototype.slice.call(n, e, t))
}
  , Vle = function(n, e, t) {
    return n.slice ? n.slice(e, t) : new Uint32Array(Array.prototype.slice.call(n, e, t))
}
  , jle = function(n, e) {
    var t = Rle(n)
      , r = Array.isArray(t) ? Fle(t) : new Uint32Array(t)
      , i = Array.isArray(t) ? Ule(t) : new Uint16Array(t)
      , s = 24
      , o = HD(i, s / 2, r[4] / 2)
      , a = r[5] === 2 ? HD(i, (s + r[4]) / 2) : Vle(r, Math.ceil((s + r[4]) / 4));
    return new Wle(r[0],r[1],r[2],r[3],o,a)
}
  , Wle = function() {
    function n(e, t, r, i, s, o) {
        this.initialValue = e,
        this.errorValue = t,
        this.highStart = r,
        this.highValueIndex = i,
        this.index = s,
        this.data = o
    }
    return n.prototype.get = function(e) {
        var t;
        if (e >= 0) {
            if (e < 55296 || e > 56319 && e <= 65535)
                return t = this.index[e >> Bu],
                t = (t << dB) + (e & pB),
                this.data[t];
            if (e <= 65535)
                return t = this.index[A8 + (e - 55296 >> Bu)],
                t = (t << dB) + (e & pB),
                this.data[t];
            if (e < this.highStart)
                return t = Qle - Hle + (e >> e2),
                t = this.index[t],
                t += e >> Bu & Gle,
                t = this.index[t],
                t = (t << dB) + (e & pB),
                this.data[t];
            if (e <= 1114111)
                return this.data[this.highValueIndex]
        }
        return this.errorValue
    }
    ,
    n
}()
  , zD = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , Kle = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var $v = 0; $v < zD.length; $v++)
    Kle[zD.charCodeAt($v)] = $v;
var Xle = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA=="
  , GD = 50
  , Yle = 1
  , u8 = 2
  , f8 = 3
  , $le = 4
  , Zle = 5
  , VD = 7
  , h8 = 8
  , jD = 9
  , Zc = 10
  , GC = 11
  , WD = 12
  , VC = 13
  , Jle = 14
  , Bm = 15
  , jC = 16
  , Zv = 17
  , Hp = 18
  , qle = 19
  , KD = 20
  , WC = 21
  , zp = 22
  , mB = 23
  , Sf = 24
  , vs = 25
  , Mm = 26
  , Sm = 27
  , Cf = 28
  , ece = 29
  , cu = 30
  , tce = 31
  , Jv = 32
  , qv = 33
  , KC = 34
  , XC = 35
  , YC = 36
  , Yg = 37
  , $C = 38
  , Tw = 39
  , Iw = 40
  , gB = 41
  , d8 = 42
  , nce = 43
  , rce = [9001, 65288]
  , p8 = "!"
  , Ot = "×"
  , ey = "÷"
  , ZC = jle(Xle)
  , vl = [cu, YC]
  , JC = [Yle, u8, f8, Zle]
  , m8 = [Zc, h8]
  , XD = [Sm, Mm]
  , ice = JC.concat(m8)
  , YD = [$C, Tw, Iw, KC, XC]
  , sce = [Bm, VC]
  , oce = function(n, e) {
    e === void 0 && (e = "strict");
    var t = []
      , r = []
      , i = [];
    return n.forEach(function(s, o) {
        var a = ZC.get(s);
        if (a > GD ? (i.push(!0),
        a -= GD) : i.push(!1),
        ["normal", "auto", "loose"].indexOf(e) !== -1 && [8208, 8211, 12316, 12448].indexOf(s) !== -1)
            return r.push(o),
            t.push(jC);
        if (a === $le || a === GC) {
            if (o === 0)
                return r.push(o),
                t.push(cu);
            var l = t[o - 1];
            return ice.indexOf(l) === -1 ? (r.push(r[o - 1]),
            t.push(l)) : (r.push(o),
            t.push(cu))
        }
        if (r.push(o),
        a === tce)
            return t.push(e === "strict" ? WC : Yg);
        if (a === d8 || a === ece)
            return t.push(cu);
        if (a === nce)
            return s >= 131072 && s <= 196605 || s >= 196608 && s <= 262141 ? t.push(Yg) : t.push(cu);
        t.push(a)
    }),
    [r, t, i]
}
  , vB = function(n, e, t, r) {
    var i = r[t];
    if (Array.isArray(n) ? n.indexOf(i) !== -1 : n === i)
        for (var s = t; s <= r.length; ) {
            s++;
            var o = r[s];
            if (o === e)
                return !0;
            if (o !== Zc)
                break
        }
    if (i === Zc)
        for (var s = t; s > 0; ) {
            s--;
            var a = r[s];
            if (Array.isArray(n) ? n.indexOf(a) !== -1 : n === a)
                for (var l = t; l <= r.length; ) {
                    l++;
                    var o = r[l];
                    if (o === e)
                        return !0;
                    if (o !== Zc)
                        break
                }
            if (a !== Zc)
                break
        }
    return !1
}
  , $D = function(n, e) {
    for (var t = n; t >= 0; ) {
        var r = e[t];
        if (r === Zc)
            t--;
        else
            return r
    }
    return 0
}
  , ace = function(n, e, t, r, i) {
    if (t[r] === 0)
        return Ot;
    var s = r - 1;
    if (Array.isArray(i) && i[s] === !0)
        return Ot;
    var o = s - 1
      , a = s + 1
      , l = e[s]
      , c = o >= 0 ? e[o] : 0
      , A = e[a];
    if (l === u8 && A === f8)
        return Ot;
    if (JC.indexOf(l) !== -1)
        return p8;
    if (JC.indexOf(A) !== -1 || m8.indexOf(A) !== -1)
        return Ot;
    if ($D(s, e) === h8)
        return ey;
    if (ZC.get(n[s]) === GC || (l === Jv || l === qv) && ZC.get(n[a]) === GC || l === VD || A === VD || l === jD || [Zc, VC, Bm].indexOf(l) === -1 && A === jD || [Zv, Hp, qle, Sf, Cf].indexOf(A) !== -1 || $D(s, e) === zp || vB(mB, zp, s, e) || vB([Zv, Hp], WC, s, e) || vB(WD, WD, s, e))
        return Ot;
    if (l === Zc)
        return ey;
    if (l === mB || A === mB)
        return Ot;
    if (A === jC || l === jC)
        return ey;
    if ([VC, Bm, WC].indexOf(A) !== -1 || l === Jle || c === YC && sce.indexOf(l) !== -1 || l === Cf && A === YC || A === KD || vl.indexOf(A) !== -1 && l === vs || vl.indexOf(l) !== -1 && A === vs || l === Sm && [Yg, Jv, qv].indexOf(A) !== -1 || [Yg, Jv, qv].indexOf(l) !== -1 && A === Mm || vl.indexOf(l) !== -1 && XD.indexOf(A) !== -1 || XD.indexOf(l) !== -1 && vl.indexOf(A) !== -1 || [Sm, Mm].indexOf(l) !== -1 && (A === vs || [zp, Bm].indexOf(A) !== -1 && e[a + 1] === vs) || [zp, Bm].indexOf(l) !== -1 && A === vs || l === vs && [vs, Cf, Sf].indexOf(A) !== -1)
        return Ot;
    if ([vs, Cf, Sf, Zv, Hp].indexOf(A) !== -1)
        for (var u = s; u >= 0; ) {
            var f = e[u];
            if (f === vs)
                return Ot;
            if ([Cf, Sf].indexOf(f) !== -1)
                u--;
            else
                break
        }
    if ([Sm, Mm].indexOf(A) !== -1)
        for (var u = [Zv, Hp].indexOf(l) !== -1 ? o : s; u >= 0; ) {
            var f = e[u];
            if (f === vs)
                return Ot;
            if ([Cf, Sf].indexOf(f) !== -1)
                u--;
            else
                break
        }
    if ($C === l && [$C, Tw, KC, XC].indexOf(A) !== -1 || [Tw, KC].indexOf(l) !== -1 && [Tw, Iw].indexOf(A) !== -1 || [Iw, XC].indexOf(l) !== -1 && A === Iw || YD.indexOf(l) !== -1 && [KD, Mm].indexOf(A) !== -1 || YD.indexOf(A) !== -1 && l === Sm || vl.indexOf(l) !== -1 && vl.indexOf(A) !== -1 || l === Sf && vl.indexOf(A) !== -1 || vl.concat(vs).indexOf(l) !== -1 && A === zp && rce.indexOf(n[a]) === -1 || vl.concat(vs).indexOf(A) !== -1 && l === Hp)
        return Ot;
    if (l === gB && A === gB) {
        for (var h = t[s], d = 1; h > 0 && (h--,
        e[h] === gB); )
            d++;
        if (d % 2 !== 0)
            return Ot
    }
    return l === Jv && A === qv ? Ot : ey
}
  , lce = function(n, e) {
    e || (e = {
        lineBreak: "normal",
        wordBreak: "normal"
    });
    var t = oce(n, e.lineBreak)
      , r = t[0]
      , i = t[1]
      , s = t[2];
    (e.wordBreak === "break-all" || e.wordBreak === "break-word") && (i = i.map(function(a) {
        return [vs, cu, d8].indexOf(a) !== -1 ? Yg : a
    }));
    var o = e.wordBreak === "keep-all" ? s.map(function(a, l) {
        return a && n[l] >= 19968 && n[l] <= 40959
    }) : void 0;
    return [r, i, o]
}
  , cce = function() {
    function n(e, t, r, i) {
        this.codePoints = e,
        this.required = t === p8,
        this.start = r,
        this.end = i
    }
    return n.prototype.slice = function() {
        return Ar.apply(void 0, this.codePoints.slice(this.start, this.end))
    }
    ,
    n
}()
  , Ace = function(n, e) {
    var t = x1(n)
      , r = lce(t, e)
      , i = r[0]
      , s = r[1]
      , o = r[2]
      , a = t.length
      , l = 0
      , c = 0;
    return {
        next: function() {
            if (c >= a)
                return {
                    done: !0,
                    value: null
                };
            for (var A = Ot; c < a && (A = ace(t, s, i, ++c, o)) === Ot; )
                ;
            if (A !== Ot || c === a) {
                var u = new cce(t,A,l,c);
                return l = c,
                {
                    value: u,
                    done: !1
                }
            }
            return {
                done: !0,
                value: null
            }
        }
    }
}
  , uce = 1
  , fce = 2
  , b0 = 4
  , ZD = 8
  , z_ = 10
  , JD = 47
  , rg = 92
  , hce = 9
  , dce = 32
  , ty = 34
  , Gp = 61
  , pce = 35
  , mce = 36
  , gce = 37
  , ny = 39
  , ry = 40
  , Vp = 41
  , vce = 95
  , Xi = 45
  , yce = 33
  , wce = 60
  , _ce = 62
  , xce = 64
  , bce = 91
  , Ece = 93
  , Bce = 61
  , Mce = 123
  , iy = 63
  , Sce = 125
  , qD = 124
  , Cce = 126
  , Tce = 128
  , eN = 65533
  , yB = 42
  , du = 43
  , Ice = 44
  , Rce = 58
  , Uce = 59
  , $g = 46
  , Fce = 0
  , Pce = 8
  , Lce = 11
  , Dce = 14
  , Nce = 31
  , Oce = 127
  , va = -1
  , g8 = 48
  , v8 = 97
  , y8 = 101
  , kce = 102
  , Qce = 117
  , Hce = 122
  , w8 = 65
  , _8 = 69
  , x8 = 70
  , zce = 85
  , Gce = 90
  , gi = function(n) {
    return n >= g8 && n <= 57
}
  , Vce = function(n) {
    return n >= 55296 && n <= 57343
}
  , Tf = function(n) {
    return gi(n) || n >= w8 && n <= x8 || n >= v8 && n <= kce
}
  , jce = function(n) {
    return n >= v8 && n <= Hce
}
  , Wce = function(n) {
    return n >= w8 && n <= Gce
}
  , Kce = function(n) {
    return jce(n) || Wce(n)
}
  , Xce = function(n) {
    return n >= Tce
}
  , sy = function(n) {
    return n === z_ || n === hce || n === dce
}
  , G_ = function(n) {
    return Kce(n) || Xce(n) || n === vce
}
  , tN = function(n) {
    return G_(n) || gi(n) || n === Xi
}
  , Yce = function(n) {
    return n >= Fce && n <= Pce || n === Lce || n >= Dce && n <= Nce || n === Oce
}
  , Oc = function(n, e) {
    return n !== rg ? !1 : e !== z_
}
  , oy = function(n, e, t) {
    return n === Xi ? G_(e) || Oc(e, t) : G_(n) ? !0 : !!(n === rg && Oc(n, e))
}
  , wB = function(n, e, t) {
    return n === du || n === Xi ? gi(e) ? !0 : e === $g && gi(t) : gi(n === $g ? e : n)
}
  , $ce = function(n) {
    var e = 0
      , t = 1;
    (n[e] === du || n[e] === Xi) && (n[e] === Xi && (t = -1),
    e++);
    for (var r = []; gi(n[e]); )
        r.push(n[e++]);
    var i = r.length ? parseInt(Ar.apply(void 0, r), 10) : 0;
    n[e] === $g && e++;
    for (var s = []; gi(n[e]); )
        s.push(n[e++]);
    var o = s.length
      , a = o ? parseInt(Ar.apply(void 0, s), 10) : 0;
    (n[e] === _8 || n[e] === y8) && e++;
    var l = 1;
    (n[e] === du || n[e] === Xi) && (n[e] === Xi && (l = -1),
    e++);
    for (var c = []; gi(n[e]); )
        c.push(n[e++]);
    var A = c.length ? parseInt(Ar.apply(void 0, c), 10) : 0;
    return t * (i + a * Math.pow(10, -o)) * Math.pow(10, l * A)
}
  , Zce = {
    type: 2
}
  , Jce = {
    type: 3
}
  , qce = {
    type: 4
}
  , eAe = {
    type: 13
}
  , tAe = {
    type: 8
}
  , nAe = {
    type: 21
}
  , rAe = {
    type: 9
}
  , iAe = {
    type: 10
}
  , sAe = {
    type: 11
}
  , oAe = {
    type: 12
}
  , aAe = {
    type: 14
}
  , ay = {
    type: 23
}
  , lAe = {
    type: 1
}
  , cAe = {
    type: 25
}
  , AAe = {
    type: 24
}
  , uAe = {
    type: 26
}
  , fAe = {
    type: 27
}
  , hAe = {
    type: 28
}
  , dAe = {
    type: 29
}
  , pAe = {
    type: 31
}
  , qC = {
    type: 32
}
  , b8 = function() {
    function n() {
        this._value = []
    }
    return n.prototype.write = function(e) {
        this._value = this._value.concat(x1(e))
    }
    ,
    n.prototype.read = function() {
        for (var e = [], t = this.consumeToken(); t !== qC; )
            e.push(t),
            t = this.consumeToken();
        return e
    }
    ,
    n.prototype.consumeToken = function() {
        var e = this.consumeCodePoint();
        switch (e) {
        case ty:
            return this.consumeStringToken(ty);
        case pce:
            var t = this.peekCodePoint(0)
              , r = this.peekCodePoint(1)
              , i = this.peekCodePoint(2);
            if (tN(t) || Oc(r, i)) {
                var s = oy(t, r, i) ? fce : uce
                  , o = this.consumeName();
                return {
                    type: 5,
                    value: o,
                    flags: s
                }
            }
            break;
        case mce:
            if (this.peekCodePoint(0) === Gp)
                return this.consumeCodePoint(),
                eAe;
            break;
        case ny:
            return this.consumeStringToken(ny);
        case ry:
            return Zce;
        case Vp:
            return Jce;
        case yB:
            if (this.peekCodePoint(0) === Gp)
                return this.consumeCodePoint(),
                aAe;
            break;
        case du:
            if (wB(e, this.peekCodePoint(0), this.peekCodePoint(1)))
                return this.reconsumeCodePoint(e),
                this.consumeNumericToken();
            break;
        case Ice:
            return qce;
        case Xi:
            var a = e
              , l = this.peekCodePoint(0)
              , c = this.peekCodePoint(1);
            if (wB(a, l, c))
                return this.reconsumeCodePoint(e),
                this.consumeNumericToken();
            if (oy(a, l, c))
                return this.reconsumeCodePoint(e),
                this.consumeIdentLikeToken();
            if (l === Xi && c === _ce)
                return this.consumeCodePoint(),
                this.consumeCodePoint(),
                AAe;
            break;
        case $g:
            if (wB(e, this.peekCodePoint(0), this.peekCodePoint(1)))
                return this.reconsumeCodePoint(e),
                this.consumeNumericToken();
            break;
        case JD:
            if (this.peekCodePoint(0) === yB)
                for (this.consumeCodePoint(); ; ) {
                    var A = this.consumeCodePoint();
                    if (A === yB && (A = this.consumeCodePoint(),
                    A === JD))
                        return this.consumeToken();
                    if (A === va)
                        return this.consumeToken()
                }
            break;
        case Rce:
            return uAe;
        case Uce:
            return fAe;
        case wce:
            if (this.peekCodePoint(0) === yce && this.peekCodePoint(1) === Xi && this.peekCodePoint(2) === Xi)
                return this.consumeCodePoint(),
                this.consumeCodePoint(),
                cAe;
            break;
        case xce:
            var u = this.peekCodePoint(0)
              , f = this.peekCodePoint(1)
              , h = this.peekCodePoint(2);
            if (oy(u, f, h)) {
                var o = this.consumeName();
                return {
                    type: 7,
                    value: o
                }
            }
            break;
        case bce:
            return hAe;
        case rg:
            if (Oc(e, this.peekCodePoint(0)))
                return this.reconsumeCodePoint(e),
                this.consumeIdentLikeToken();
            break;
        case Ece:
            return dAe;
        case Bce:
            if (this.peekCodePoint(0) === Gp)
                return this.consumeCodePoint(),
                tAe;
            break;
        case Mce:
            return sAe;
        case Sce:
            return oAe;
        case Qce:
        case zce:
            var d = this.peekCodePoint(0)
              , m = this.peekCodePoint(1);
            return d === du && (Tf(m) || m === iy) && (this.consumeCodePoint(),
            this.consumeUnicodeRangeToken()),
            this.reconsumeCodePoint(e),
            this.consumeIdentLikeToken();
        case qD:
            if (this.peekCodePoint(0) === Gp)
                return this.consumeCodePoint(),
                rAe;
            if (this.peekCodePoint(0) === qD)
                return this.consumeCodePoint(),
                nAe;
            break;
        case Cce:
            if (this.peekCodePoint(0) === Gp)
                return this.consumeCodePoint(),
                iAe;
            break;
        case va:
            return qC
        }
        return sy(e) ? (this.consumeWhiteSpace(),
        pAe) : gi(e) ? (this.reconsumeCodePoint(e),
        this.consumeNumericToken()) : G_(e) ? (this.reconsumeCodePoint(e),
        this.consumeIdentLikeToken()) : {
            type: 6,
            value: Ar(e)
        }
    }
    ,
    n.prototype.consumeCodePoint = function() {
        var e = this._value.shift();
        return typeof e > "u" ? -1 : e
    }
    ,
    n.prototype.reconsumeCodePoint = function(e) {
        this._value.unshift(e)
    }
    ,
    n.prototype.peekCodePoint = function(e) {
        return e >= this._value.length ? -1 : this._value[e]
    }
    ,
    n.prototype.consumeUnicodeRangeToken = function() {
        for (var e = [], t = this.consumeCodePoint(); Tf(t) && e.length < 6; )
            e.push(t),
            t = this.consumeCodePoint();
        for (var r = !1; t === iy && e.length < 6; )
            e.push(t),
            t = this.consumeCodePoint(),
            r = !0;
        if (r) {
            var i = parseInt(Ar.apply(void 0, e.map(function(l) {
                return l === iy ? g8 : l
            })), 16)
              , s = parseInt(Ar.apply(void 0, e.map(function(l) {
                return l === iy ? x8 : l
            })), 16);
            return {
                type: 30,
                start: i,
                end: s
            }
        }
        var o = parseInt(Ar.apply(void 0, e), 16);
        if (this.peekCodePoint(0) === Xi && Tf(this.peekCodePoint(1))) {
            this.consumeCodePoint(),
            t = this.consumeCodePoint();
            for (var a = []; Tf(t) && a.length < 6; )
                a.push(t),
                t = this.consumeCodePoint();
            var s = parseInt(Ar.apply(void 0, a), 16);
            return {
                type: 30,
                start: o,
                end: s
            }
        } else
            return {
                type: 30,
                start: o,
                end: o
            }
    }
    ,
    n.prototype.consumeIdentLikeToken = function() {
        var e = this.consumeName();
        return e.toLowerCase() === "url" && this.peekCodePoint(0) === ry ? (this.consumeCodePoint(),
        this.consumeUrlToken()) : this.peekCodePoint(0) === ry ? (this.consumeCodePoint(),
        {
            type: 19,
            value: e
        }) : {
            type: 20,
            value: e
        }
    }
    ,
    n.prototype.consumeUrlToken = function() {
        var e = [];
        if (this.consumeWhiteSpace(),
        this.peekCodePoint(0) === va)
            return {
                type: 22,
                value: ""
            };
        var t = this.peekCodePoint(0);
        if (t === ny || t === ty) {
            var r = this.consumeStringToken(this.consumeCodePoint());
            return r.type === 0 && (this.consumeWhiteSpace(),
            this.peekCodePoint(0) === va || this.peekCodePoint(0) === Vp) ? (this.consumeCodePoint(),
            {
                type: 22,
                value: r.value
            }) : (this.consumeBadUrlRemnants(),
            ay)
        }
        for (; ; ) {
            var i = this.consumeCodePoint();
            if (i === va || i === Vp)
                return {
                    type: 22,
                    value: Ar.apply(void 0, e)
                };
            if (sy(i))
                return this.consumeWhiteSpace(),
                this.peekCodePoint(0) === va || this.peekCodePoint(0) === Vp ? (this.consumeCodePoint(),
                {
                    type: 22,
                    value: Ar.apply(void 0, e)
                }) : (this.consumeBadUrlRemnants(),
                ay);
            if (i === ty || i === ny || i === ry || Yce(i))
                return this.consumeBadUrlRemnants(),
                ay;
            if (i === rg)
                if (Oc(i, this.peekCodePoint(0)))
                    e.push(this.consumeEscapedCodePoint());
                else
                    return this.consumeBadUrlRemnants(),
                    ay;
            else
                e.push(i)
        }
    }
    ,
    n.prototype.consumeWhiteSpace = function() {
        for (; sy(this.peekCodePoint(0)); )
            this.consumeCodePoint()
    }
    ,
    n.prototype.consumeBadUrlRemnants = function() {
        for (; ; ) {
            var e = this.consumeCodePoint();
            if (e === Vp || e === va)
                return;
            Oc(e, this.peekCodePoint(0)) && this.consumeEscapedCodePoint()
        }
    }
    ,
    n.prototype.consumeStringSlice = function(e) {
        for (var t = 5e4, r = ""; e > 0; ) {
            var i = Math.min(t, e);
            r += Ar.apply(void 0, this._value.splice(0, i)),
            e -= i
        }
        return this._value.shift(),
        r
    }
    ,
    n.prototype.consumeStringToken = function(e) {
        var t = ""
          , r = 0;
        do {
            var i = this._value[r];
            if (i === va || i === void 0 || i === e)
                return t += this.consumeStringSlice(r),
                {
                    type: 0,
                    value: t
                };
            if (i === z_)
                return this._value.splice(0, r),
                lAe;
            if (i === rg) {
                var s = this._value[r + 1];
                s !== va && s !== void 0 && (s === z_ ? (t += this.consumeStringSlice(r),
                r = -1,
                this._value.shift()) : Oc(i, s) && (t += this.consumeStringSlice(r),
                t += Ar(this.consumeEscapedCodePoint()),
                r = -1))
            }
            r++
        } while (!0)
    }
    ,
    n.prototype.consumeNumber = function() {
        var e = []
          , t = b0
          , r = this.peekCodePoint(0);
        for ((r === du || r === Xi) && e.push(this.consumeCodePoint()); gi(this.peekCodePoint(0)); )
            e.push(this.consumeCodePoint());
        r = this.peekCodePoint(0);
        var i = this.peekCodePoint(1);
        if (r === $g && gi(i))
            for (e.push(this.consumeCodePoint(), this.consumeCodePoint()),
            t = ZD; gi(this.peekCodePoint(0)); )
                e.push(this.consumeCodePoint());
        r = this.peekCodePoint(0),
        i = this.peekCodePoint(1);
        var s = this.peekCodePoint(2);
        if ((r === _8 || r === y8) && ((i === du || i === Xi) && gi(s) || gi(i)))
            for (e.push(this.consumeCodePoint(), this.consumeCodePoint()),
            t = ZD; gi(this.peekCodePoint(0)); )
                e.push(this.consumeCodePoint());
        return [$ce(e), t]
    }
    ,
    n.prototype.consumeNumericToken = function() {
        var e = this.consumeNumber()
          , t = e[0]
          , r = e[1]
          , i = this.peekCodePoint(0)
          , s = this.peekCodePoint(1)
          , o = this.peekCodePoint(2);
        if (oy(i, s, o)) {
            var a = this.consumeName();
            return {
                type: 15,
                number: t,
                flags: r,
                unit: a
            }
        }
        return i === gce ? (this.consumeCodePoint(),
        {
            type: 16,
            number: t,
            flags: r
        }) : {
            type: 17,
            number: t,
            flags: r
        }
    }
    ,
    n.prototype.consumeEscapedCodePoint = function() {
        var e = this.consumeCodePoint();
        if (Tf(e)) {
            for (var t = Ar(e); Tf(this.peekCodePoint(0)) && t.length < 6; )
                t += Ar(this.consumeCodePoint());
            sy(this.peekCodePoint(0)) && this.consumeCodePoint();
            var r = parseInt(t, 16);
            return r === 0 || Vce(r) || r > 1114111 ? eN : r
        }
        return e === va ? eN : e
    }
    ,
    n.prototype.consumeName = function() {
        for (var e = ""; ; ) {
            var t = this.consumeCodePoint();
            if (tN(t))
                e += Ar(t);
            else if (Oc(t, this.peekCodePoint(0)))
                e += Ar(this.consumeEscapedCodePoint());
            else
                return this.reconsumeCodePoint(t),
                e
        }
    }
    ,
    n
}()
  , E8 = function() {
    function n(e) {
        this._tokens = e
    }
    return n.create = function(e) {
        var t = new b8;
        return t.write(e),
        new n(t.read())
    }
    ,
    n.parseValue = function(e) {
        return n.create(e).parseComponentValue()
    }
    ,
    n.parseValues = function(e) {
        return n.create(e).parseComponentValues()
    }
    ,
    n.prototype.parseComponentValue = function() {
        for (var e = this.consumeToken(); e.type === 31; )
            e = this.consumeToken();
        if (e.type === 32)
            throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
        this.reconsumeToken(e);
        var t = this.consumeComponentValue();
        do
            e = this.consumeToken();
        while (e.type === 31);
        if (e.type === 32)
            return t;
        throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one")
    }
    ,
    n.prototype.parseComponentValues = function() {
        for (var e = []; ; ) {
            var t = this.consumeComponentValue();
            if (t.type === 32)
                return e;
            e.push(t),
            e.push()
        }
    }
    ,
    n.prototype.consumeComponentValue = function() {
        var e = this.consumeToken();
        switch (e.type) {
        case 11:
        case 28:
        case 2:
            return this.consumeSimpleBlock(e.type);
        case 19:
            return this.consumeFunction(e)
        }
        return e
    }
    ,
    n.prototype.consumeSimpleBlock = function(e) {
        for (var t = {
            type: e,
            values: []
        }, r = this.consumeToken(); ; ) {
            if (r.type === 32 || mAe(r, e))
                return t;
            this.reconsumeToken(r),
            t.values.push(this.consumeComponentValue()),
            r = this.consumeToken()
        }
    }
    ,
    n.prototype.consumeFunction = function(e) {
        for (var t = {
            name: e.value,
            values: [],
            type: 18
        }; ; ) {
            var r = this.consumeToken();
            if (r.type === 32 || r.type === 3)
                return t;
            this.reconsumeToken(r),
            t.values.push(this.consumeComponentValue())
        }
    }
    ,
    n.prototype.consumeToken = function() {
        var e = this._tokens.shift();
        return typeof e > "u" ? qC : e
    }
    ,
    n.prototype.reconsumeToken = function(e) {
        this._tokens.unshift(e)
    }
    ,
    n
}()
  , E0 = function(n) {
    return n.type === 15
}
  , b1 = function(n) {
    return n.type === 17
}
  , sr = function(n) {
    return n.type === 20
}
  , eT = function(n, e) {
    return sr(n) && n.value === e
}
  , E1 = function(n) {
    return n.type !== 31 && n.type !== 4
}
  , ll = function(n) {
    var e = []
      , t = [];
    return n.forEach(function(r) {
        if (r.type === 4) {
            if (t.length === 0)
                throw new Error("Error parsing function args, zero tokens for arg");
            e.push(t),
            t = [];
            return
        }
        r.type !== 31 && t.push(r)
    }),
    t.length && e.push(t),
    e
}
  , mAe = function(n, e) {
    return e === 11 && n.type === 12 || e === 28 && n.type === 29 ? !0 : e === 2 && n.type === 3
}
  , _A = function(n) {
    return n.type === 17 || n.type === 15
}
  , br = function(n) {
    return n.type === 16 || _A(n)
}
  , B8 = function(n) {
    return n.length > 1 ? [n[0], n[1]] : [n[0]]
}
  , ii = {
    type: 17,
    number: 0,
    flags: b0
}
  , t2 = {
    type: 16,
    number: 50,
    flags: b0
}
  , Jc = {
    type: 16,
    number: 100,
    flags: b0
}
  , Cm = function(n, e, t) {
    var r = n[0]
      , i = n[1];
    return [bn(r, e), bn(typeof i < "u" ? i : r, t)]
}
  , bn = function(n, e) {
    if (n.type === 16)
        return n.number / 100 * e;
    if (E0(n))
        switch (n.unit) {
        case "rem":
        case "em":
            return 16 * n.number;
        case "px":
        default:
            return n.number
        }
    return n.number
}
  , M8 = "deg"
  , S8 = "grad"
  , C8 = "rad"
  , T8 = "turn"
  , B1 = {
    name: "angle",
    parse: function(n, e) {
        if (e.type === 15)
            switch (e.unit) {
            case M8:
                return Math.PI * e.number / 180;
            case S8:
                return Math.PI / 200 * e.number;
            case C8:
                return e.number;
            case T8:
                return Math.PI * 2 * e.number
            }
        throw new Error("Unsupported angle type")
    }
}
  , I8 = function(n) {
    return n.type === 15 && (n.unit === M8 || n.unit === S8 || n.unit === C8 || n.unit === T8)
}
  , R8 = function(n) {
    var e = n.filter(sr).map(function(t) {
        return t.value
    }).join(" ");
    switch (e) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
        return [ii, ii];
    case "to top":
    case "bottom":
        return fo(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
        return [ii, Jc];
    case "to right":
    case "left":
        return fo(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
        return [Jc, Jc];
    case "to bottom":
    case "top":
        return fo(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
        return [Jc, ii];
    case "to left":
    case "right":
        return fo(270)
    }
    return 0
}
  , fo = function(n) {
    return Math.PI * n / 180
}
  , hA = {
    name: "color",
    parse: function(n, e) {
        if (e.type === 18) {
            var t = gAe[e.name];
            if (typeof t > "u")
                throw new Error('Attempting to parse an unsupported color function "' + e.name + '"');
            return t(n, e.values)
        }
        if (e.type === 5) {
            if (e.value.length === 3) {
                var r = e.value.substring(0, 1)
                  , i = e.value.substring(1, 2)
                  , s = e.value.substring(2, 3);
                return qc(parseInt(r + r, 16), parseInt(i + i, 16), parseInt(s + s, 16), 1)
            }
            if (e.value.length === 4) {
                var r = e.value.substring(0, 1)
                  , i = e.value.substring(1, 2)
                  , s = e.value.substring(2, 3)
                  , o = e.value.substring(3, 4);
                return qc(parseInt(r + r, 16), parseInt(i + i, 16), parseInt(s + s, 16), parseInt(o + o, 16) / 255)
            }
            if (e.value.length === 6) {
                var r = e.value.substring(0, 2)
                  , i = e.value.substring(2, 4)
                  , s = e.value.substring(4, 6);
                return qc(parseInt(r, 16), parseInt(i, 16), parseInt(s, 16), 1)
            }
            if (e.value.length === 8) {
                var r = e.value.substring(0, 2)
                  , i = e.value.substring(2, 4)
                  , s = e.value.substring(4, 6)
                  , o = e.value.substring(6, 8);
                return qc(parseInt(r, 16), parseInt(i, 16), parseInt(s, 16), parseInt(o, 16) / 255)
            }
        }
        if (e.type === 20) {
            var a = Zg[e.value.toUpperCase()];
            if (typeof a < "u")
                return a
        }
        return Zg.TRANSPARENT
    }
}
  , cd = function(n) {
    return (255 & n) === 0
}
  , Hr = function(n) {
    var e = 255 & n
      , t = 255 & n >> 8
      , r = 255 & n >> 16
      , i = 255 & n >> 24;
    return e < 255 ? "rgba(" + i + "," + r + "," + t + "," + e / 255 + ")" : "rgb(" + i + "," + r + "," + t + ")"
}
  , qc = function(n, e, t, r) {
    return (n << 24 | e << 16 | t << 8 | Math.round(r * 255) << 0) >>> 0
}
  , nN = function(n, e) {
    if (n.type === 17)
        return n.number;
    if (n.type === 16) {
        var t = e === 3 ? 1 : 255;
        return e === 3 ? n.number / 100 * t : Math.round(n.number / 100 * t)
    }
    return 0
}
  , rN = function(n, e) {
    var t = e.filter(E1);
    if (t.length === 3) {
        var r = t.map(nN)
          , i = r[0]
          , s = r[1]
          , o = r[2];
        return qc(i, s, o, 1)
    }
    if (t.length === 4) {
        var a = t.map(nN)
          , i = a[0]
          , s = a[1]
          , o = a[2]
          , l = a[3];
        return qc(i, s, o, l)
    }
    return 0
};
function _B(n, e, t) {
    return t < 0 && (t += 1),
    t >= 1 && (t -= 1),
    t < 1 / 6 ? (e - n) * t * 6 + n : t < 1 / 2 ? e : t < 2 / 3 ? (e - n) * 6 * (2 / 3 - t) + n : n
}
var iN = function(n, e) {
    var t = e.filter(E1)
      , r = t[0]
      , i = t[1]
      , s = t[2]
      , o = t[3]
      , a = (r.type === 17 ? fo(r.number) : B1.parse(n, r)) / (Math.PI * 2)
      , l = br(i) ? i.number / 100 : 0
      , c = br(s) ? s.number / 100 : 0
      , A = typeof o < "u" && br(o) ? bn(o, 1) : 1;
    if (l === 0)
        return qc(c * 255, c * 255, c * 255, 1);
    var u = c <= .5 ? c * (l + 1) : c + l - c * l
      , f = c * 2 - u
      , h = _B(f, u, a + 1 / 3)
      , d = _B(f, u, a)
      , m = _B(f, u, a - 1 / 3);
    return qc(h * 255, d * 255, m * 255, A)
}
  , gAe = {
    hsl: iN,
    hsla: iN,
    rgb: rN,
    rgba: rN
}
  , sN = function(n, e) {
    return hA.parse(n, E8.create(e).parseComponentValue())
}
  , Zg = {
    ALICEBLUE: 4042850303,
    ANTIQUEWHITE: 4209760255,
    AQUA: 16777215,
    AQUAMARINE: 2147472639,
    AZURE: 4043309055,
    BEIGE: 4126530815,
    BISQUE: 4293182719,
    BLACK: 255,
    BLANCHEDALMOND: 4293643775,
    BLUE: 65535,
    BLUEVIOLET: 2318131967,
    BROWN: 2771004159,
    BURLYWOOD: 3736635391,
    CADETBLUE: 1604231423,
    CHARTREUSE: 2147418367,
    CHOCOLATE: 3530104575,
    CORAL: 4286533887,
    CORNFLOWERBLUE: 1687547391,
    CORNSILK: 4294499583,
    CRIMSON: 3692313855,
    CYAN: 16777215,
    DARKBLUE: 35839,
    DARKCYAN: 9145343,
    DARKGOLDENROD: 3095837695,
    DARKGRAY: 2846468607,
    DARKGREEN: 6553855,
    DARKGREY: 2846468607,
    DARKKHAKI: 3182914559,
    DARKMAGENTA: 2332068863,
    DARKOLIVEGREEN: 1433087999,
    DARKORANGE: 4287365375,
    DARKORCHID: 2570243327,
    DARKRED: 2332033279,
    DARKSALMON: 3918953215,
    DARKSEAGREEN: 2411499519,
    DARKSLATEBLUE: 1211993087,
    DARKSLATEGRAY: 793726975,
    DARKSLATEGREY: 793726975,
    DARKTURQUOISE: 13554175,
    DARKVIOLET: 2483082239,
    DEEPPINK: 4279538687,
    DEEPSKYBLUE: 12582911,
    DIMGRAY: 1768516095,
    DIMGREY: 1768516095,
    DODGERBLUE: 512819199,
    FIREBRICK: 2988581631,
    FLORALWHITE: 4294635775,
    FORESTGREEN: 579543807,
    FUCHSIA: 4278255615,
    GAINSBORO: 3705462015,
    GHOSTWHITE: 4177068031,
    GOLD: 4292280575,
    GOLDENROD: 3668254975,
    GRAY: 2155905279,
    GREEN: 8388863,
    GREENYELLOW: 2919182335,
    GREY: 2155905279,
    HONEYDEW: 4043305215,
    HOTPINK: 4285117695,
    INDIANRED: 3445382399,
    INDIGO: 1258324735,
    IVORY: 4294963455,
    KHAKI: 4041641215,
    LAVENDER: 3873897215,
    LAVENDERBLUSH: 4293981695,
    LAWNGREEN: 2096890111,
    LEMONCHIFFON: 4294626815,
    LIGHTBLUE: 2916673279,
    LIGHTCORAL: 4034953471,
    LIGHTCYAN: 3774873599,
    LIGHTGOLDENRODYELLOW: 4210742015,
    LIGHTGRAY: 3553874943,
    LIGHTGREEN: 2431553791,
    LIGHTGREY: 3553874943,
    LIGHTPINK: 4290167295,
    LIGHTSALMON: 4288707327,
    LIGHTSEAGREEN: 548580095,
    LIGHTSKYBLUE: 2278488831,
    LIGHTSLATEGRAY: 2005441023,
    LIGHTSLATEGREY: 2005441023,
    LIGHTSTEELBLUE: 2965692159,
    LIGHTYELLOW: 4294959359,
    LIME: 16711935,
    LIMEGREEN: 852308735,
    LINEN: 4210091775,
    MAGENTA: 4278255615,
    MAROON: 2147483903,
    MEDIUMAQUAMARINE: 1724754687,
    MEDIUMBLUE: 52735,
    MEDIUMORCHID: 3126187007,
    MEDIUMPURPLE: 2473647103,
    MEDIUMSEAGREEN: 1018393087,
    MEDIUMSLATEBLUE: 2070474495,
    MEDIUMSPRINGGREEN: 16423679,
    MEDIUMTURQUOISE: 1221709055,
    MEDIUMVIOLETRED: 3340076543,
    MIDNIGHTBLUE: 421097727,
    MINTCREAM: 4127193855,
    MISTYROSE: 4293190143,
    MOCCASIN: 4293178879,
    NAVAJOWHITE: 4292783615,
    NAVY: 33023,
    OLDLACE: 4260751103,
    OLIVE: 2155872511,
    OLIVEDRAB: 1804477439,
    ORANGE: 4289003775,
    ORANGERED: 4282712319,
    ORCHID: 3664828159,
    PALEGOLDENROD: 4008225535,
    PALEGREEN: 2566625535,
    PALETURQUOISE: 2951671551,
    PALEVIOLETRED: 3681588223,
    PAPAYAWHIP: 4293907967,
    PEACHPUFF: 4292524543,
    PERU: 3448061951,
    PINK: 4290825215,
    PLUM: 3718307327,
    POWDERBLUE: 2967529215,
    PURPLE: 2147516671,
    REBECCAPURPLE: 1714657791,
    RED: 4278190335,
    ROSYBROWN: 3163525119,
    ROYALBLUE: 1097458175,
    SADDLEBROWN: 2336560127,
    SALMON: 4202722047,
    SANDYBROWN: 4104413439,
    SEAGREEN: 780883967,
    SEASHELL: 4294307583,
    SIENNA: 2689740287,
    SILVER: 3233857791,
    SKYBLUE: 2278484991,
    SLATEBLUE: 1784335871,
    SLATEGRAY: 1887473919,
    SLATEGREY: 1887473919,
    SNOW: 4294638335,
    SPRINGGREEN: 16744447,
    STEELBLUE: 1182971135,
    TAN: 3535047935,
    TEAL: 8421631,
    THISTLE: 3636451583,
    TOMATO: 4284696575,
    TRANSPARENT: 0,
    TURQUOISE: 1088475391,
    VIOLET: 4001558271,
    WHEAT: 4125012991,
    WHITE: 4294967295,
    WHITESMOKE: 4126537215,
    YELLOW: 4294902015,
    YELLOWGREEN: 2597139199
}
  , vAe = {
    name: "background-clip",
    initialValue: "border-box",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.map(function(t) {
            if (sr(t))
                switch (t.value) {
                case "padding-box":
                    return 1;
                case "content-box":
                    return 2
                }
            return 0
        })
    }
}
  , yAe = {
    name: "background-color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
}
  , M1 = function(n, e) {
    var t = hA.parse(n, e[0])
      , r = e[1];
    return r && br(r) ? {
        color: t,
        stop: r
    } : {
        color: t,
        stop: null
    }
}
  , oN = function(n, e) {
    var t = n[0]
      , r = n[n.length - 1];
    t.stop === null && (t.stop = ii),
    r.stop === null && (r.stop = Jc);
    for (var i = [], s = 0, o = 0; o < n.length; o++) {
        var a = n[o].stop;
        if (a !== null) {
            var l = bn(a, e);
            l > s ? i.push(l) : i.push(s),
            s = l
        } else
            i.push(null)
    }
    for (var c = null, o = 0; o < i.length; o++) {
        var A = i[o];
        if (A === null)
            c === null && (c = o);
        else if (c !== null) {
            for (var u = o - c, f = i[c - 1], h = (A - f) / (u + 1), d = 1; d <= u; d++)
                i[c + d - 1] = h * d;
            c = null
        }
    }
    return n.map(function(m, g) {
        var p = m.color;
        return {
            color: p,
            stop: Math.max(Math.min(1, i[g] / e), 0)
        }
    })
}
  , wAe = function(n, e, t) {
    var r = e / 2
      , i = t / 2
      , s = bn(n[0], e) - r
      , o = i - bn(n[1], t);
    return (Math.atan2(o, s) + Math.PI * 2) % (Math.PI * 2)
}
  , _Ae = function(n, e, t) {
    var r = typeof n == "number" ? n : wAe(n, e, t)
      , i = Math.abs(e * Math.sin(r)) + Math.abs(t * Math.cos(r))
      , s = e / 2
      , o = t / 2
      , a = i / 2
      , l = Math.sin(r - Math.PI / 2) * a
      , c = Math.cos(r - Math.PI / 2) * a;
    return [i, s - c, s + c, o - l, o + l]
}
  , Ho = function(n, e) {
    return Math.sqrt(n * n + e * e)
}
  , aN = function(n, e, t, r, i) {
    var s = [[0, 0], [0, e], [n, 0], [n, e]];
    return s.reduce(function(o, a) {
        var l = a[0]
          , c = a[1]
          , A = Ho(t - l, r - c);
        return (i ? A < o.optimumDistance : A > o.optimumDistance) ? {
            optimumCorner: a,
            optimumDistance: A
        } : o
    }, {
        optimumDistance: i ? 1 / 0 : -1 / 0,
        optimumCorner: null
    }).optimumCorner
}
  , xAe = function(n, e, t, r, i) {
    var s = 0
      , o = 0;
    switch (n.size) {
    case 0:
        n.shape === 0 ? s = o = Math.min(Math.abs(e), Math.abs(e - r), Math.abs(t), Math.abs(t - i)) : n.shape === 1 && (s = Math.min(Math.abs(e), Math.abs(e - r)),
        o = Math.min(Math.abs(t), Math.abs(t - i)));
        break;
    case 2:
        if (n.shape === 0)
            s = o = Math.min(Ho(e, t), Ho(e, t - i), Ho(e - r, t), Ho(e - r, t - i));
        else if (n.shape === 1) {
            var a = Math.min(Math.abs(t), Math.abs(t - i)) / Math.min(Math.abs(e), Math.abs(e - r))
              , l = aN(r, i, e, t, !0)
              , c = l[0]
              , A = l[1];
            s = Ho(c - e, (A - t) / a),
            o = a * s
        }
        break;
    case 1:
        n.shape === 0 ? s = o = Math.max(Math.abs(e), Math.abs(e - r), Math.abs(t), Math.abs(t - i)) : n.shape === 1 && (s = Math.max(Math.abs(e), Math.abs(e - r)),
        o = Math.max(Math.abs(t), Math.abs(t - i)));
        break;
    case 3:
        if (n.shape === 0)
            s = o = Math.max(Ho(e, t), Ho(e, t - i), Ho(e - r, t), Ho(e - r, t - i));
        else if (n.shape === 1) {
            var a = Math.max(Math.abs(t), Math.abs(t - i)) / Math.max(Math.abs(e), Math.abs(e - r))
              , u = aN(r, i, e, t, !1)
              , c = u[0]
              , A = u[1];
            s = Ho(c - e, (A - t) / a),
            o = a * s
        }
        break
    }
    return Array.isArray(n.size) && (s = bn(n.size[0], r),
    o = n.size.length === 2 ? bn(n.size[1], i) : s),
    [s, o]
}
  , bAe = function(n, e) {
    var t = fo(180)
      , r = [];
    return ll(e).forEach(function(i, s) {
        if (s === 0) {
            var o = i[0];
            if (o.type === 20 && o.value === "to") {
                t = R8(i);
                return
            } else if (I8(o)) {
                t = B1.parse(n, o);
                return
            }
        }
        var a = M1(n, i);
        r.push(a)
    }),
    {
        angle: t,
        stops: r,
        type: 1
    }
}
  , ly = function(n, e) {
    var t = fo(180)
      , r = [];
    return ll(e).forEach(function(i, s) {
        if (s === 0) {
            var o = i[0];
            if (o.type === 20 && ["top", "left", "right", "bottom"].indexOf(o.value) !== -1) {
                t = R8(i);
                return
            } else if (I8(o)) {
                t = (B1.parse(n, o) + fo(270)) % fo(360);
                return
            }
        }
        var a = M1(n, i);
        r.push(a)
    }),
    {
        angle: t,
        stops: r,
        type: 1
    }
}
  , EAe = function(n, e) {
    var t = fo(180)
      , r = []
      , i = 1
      , s = 0
      , o = 3
      , a = [];
    return ll(e).forEach(function(l, c) {
        var A = l[0];
        if (c === 0) {
            if (sr(A) && A.value === "linear") {
                i = 1;
                return
            } else if (sr(A) && A.value === "radial") {
                i = 2;
                return
            }
        }
        if (A.type === 18) {
            if (A.name === "from") {
                var u = hA.parse(n, A.values[0]);
                r.push({
                    stop: ii,
                    color: u
                })
            } else if (A.name === "to") {
                var u = hA.parse(n, A.values[0]);
                r.push({
                    stop: Jc,
                    color: u
                })
            } else if (A.name === "color-stop") {
                var f = A.values.filter(E1);
                if (f.length === 2) {
                    var u = hA.parse(n, f[1])
                      , h = f[0];
                    b1(h) && r.push({
                        stop: {
                            type: 16,
                            number: h.number * 100,
                            flags: h.flags
                        },
                        color: u
                    })
                }
            }
        }
    }),
    i === 1 ? {
        angle: (t + fo(180)) % fo(360),
        stops: r,
        type: i
    } : {
        size: o,
        shape: s,
        stops: r,
        position: a,
        type: i
    }
}
  , U8 = "closest-side"
  , F8 = "farthest-side"
  , P8 = "closest-corner"
  , L8 = "farthest-corner"
  , D8 = "circle"
  , N8 = "ellipse"
  , O8 = "cover"
  , k8 = "contain"
  , BAe = function(n, e) {
    var t = 0
      , r = 3
      , i = []
      , s = [];
    return ll(e).forEach(function(o, a) {
        var l = !0;
        if (a === 0) {
            var c = !1;
            l = o.reduce(function(u, f) {
                if (c)
                    if (sr(f))
                        switch (f.value) {
                        case "center":
                            return s.push(t2),
                            u;
                        case "top":
                        case "left":
                            return s.push(ii),
                            u;
                        case "right":
                        case "bottom":
                            return s.push(Jc),
                            u
                        }
                    else
                        (br(f) || _A(f)) && s.push(f);
                else if (sr(f))
                    switch (f.value) {
                    case D8:
                        return t = 0,
                        !1;
                    case N8:
                        return t = 1,
                        !1;
                    case "at":
                        return c = !0,
                        !1;
                    case U8:
                        return r = 0,
                        !1;
                    case O8:
                    case F8:
                        return r = 1,
                        !1;
                    case k8:
                    case P8:
                        return r = 2,
                        !1;
                    case L8:
                        return r = 3,
                        !1
                    }
                else if (_A(f) || br(f))
                    return Array.isArray(r) || (r = []),
                    r.push(f),
                    !1;
                return u
            }, l)
        }
        if (l) {
            var A = M1(n, o);
            i.push(A)
        }
    }),
    {
        size: r,
        shape: t,
        stops: i,
        position: s,
        type: 2
    }
}
  , cy = function(n, e) {
    var t = 0
      , r = 3
      , i = []
      , s = [];
    return ll(e).forEach(function(o, a) {
        var l = !0;
        if (a === 0 ? l = o.reduce(function(A, u) {
            if (sr(u))
                switch (u.value) {
                case "center":
                    return s.push(t2),
                    !1;
                case "top":
                case "left":
                    return s.push(ii),
                    !1;
                case "right":
                case "bottom":
                    return s.push(Jc),
                    !1
                }
            else if (br(u) || _A(u))
                return s.push(u),
                !1;
            return A
        }, l) : a === 1 && (l = o.reduce(function(A, u) {
            if (sr(u))
                switch (u.value) {
                case D8:
                    return t = 0,
                    !1;
                case N8:
                    return t = 1,
                    !1;
                case k8:
                case U8:
                    return r = 0,
                    !1;
                case F8:
                    return r = 1,
                    !1;
                case P8:
                    return r = 2,
                    !1;
                case O8:
                case L8:
                    return r = 3,
                    !1
                }
            else if (_A(u) || br(u))
                return Array.isArray(r) || (r = []),
                r.push(u),
                !1;
            return A
        }, l)),
        l) {
            var c = M1(n, o);
            i.push(c)
        }
    }),
    {
        size: r,
        shape: t,
        stops: i,
        position: s,
        type: 2
    }
}
  , MAe = function(n) {
    return n.type === 1
}
  , SAe = function(n) {
    return n.type === 2
}
  , n2 = {
    name: "image",
    parse: function(n, e) {
        if (e.type === 22) {
            var t = {
                url: e.value,
                type: 0
            };
            return n.cache.addImage(e.value),
            t
        }
        if (e.type === 18) {
            var r = Q8[e.name];
            if (typeof r > "u")
                throw new Error('Attempting to parse an unsupported image function "' + e.name + '"');
            return r(n, e.values)
        }
        throw new Error("Unsupported image type " + e.type)
    }
};
function CAe(n) {
    return !(n.type === 20 && n.value === "none") && (n.type !== 18 || !!Q8[n.name])
}
var Q8 = {
    "linear-gradient": bAe,
    "-moz-linear-gradient": ly,
    "-ms-linear-gradient": ly,
    "-o-linear-gradient": ly,
    "-webkit-linear-gradient": ly,
    "radial-gradient": BAe,
    "-moz-radial-gradient": cy,
    "-ms-radial-gradient": cy,
    "-o-radial-gradient": cy,
    "-webkit-radial-gradient": cy,
    "-webkit-gradient": EAe
}, TAe = {
    name: "background-image",
    initialValue: "none",
    type: 1,
    prefix: !1,
    parse: function(n, e) {
        if (e.length === 0)
            return [];
        var t = e[0];
        return t.type === 20 && t.value === "none" ? [] : e.filter(function(r) {
            return E1(r) && CAe(r)
        }).map(function(r) {
            return n2.parse(n, r)
        })
    }
}, IAe = {
    name: "background-origin",
    initialValue: "border-box",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.map(function(t) {
            if (sr(t))
                switch (t.value) {
                case "padding-box":
                    return 1;
                case "content-box":
                    return 2
                }
            return 0
        })
    }
}, RAe = {
    name: "background-position",
    initialValue: "0% 0%",
    type: 1,
    prefix: !1,
    parse: function(n, e) {
        return ll(e).map(function(t) {
            return t.filter(br)
        }).map(B8)
    }
}, UAe = {
    name: "background-repeat",
    initialValue: "repeat",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return ll(e).map(function(t) {
            return t.filter(sr).map(function(r) {
                return r.value
            }).join(" ")
        }).map(FAe)
    }
}, FAe = function(n) {
    switch (n) {
    case "no-repeat":
        return 1;
    case "repeat-x":
    case "repeat no-repeat":
        return 2;
    case "repeat-y":
    case "no-repeat repeat":
        return 3;
    case "repeat":
    default:
        return 0
    }
}, Ad;
(function(n) {
    n.AUTO = "auto",
    n.CONTAIN = "contain",
    n.COVER = "cover"
}
)(Ad || (Ad = {}));
var PAe = {
    name: "background-size",
    initialValue: "0",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return ll(e).map(function(t) {
            return t.filter(LAe)
        })
    }
}, LAe = function(n) {
    return sr(n) || br(n)
}, S1 = function(n) {
    return {
        name: "border-" + n + "-color",
        initialValue: "transparent",
        prefix: !1,
        type: 3,
        format: "color"
    }
}, DAe = S1("top"), NAe = S1("right"), OAe = S1("bottom"), kAe = S1("left"), C1 = function(n) {
    return {
        name: "border-radius-" + n,
        initialValue: "0 0",
        prefix: !1,
        type: 1,
        parse: function(e, t) {
            return B8(t.filter(br))
        }
    }
}, QAe = C1("top-left"), HAe = C1("top-right"), zAe = C1("bottom-right"), GAe = C1("bottom-left"), T1 = function(n) {
    return {
        name: "border-" + n + "-style",
        initialValue: "solid",
        prefix: !1,
        type: 2,
        parse: function(e, t) {
            switch (t) {
            case "none":
                return 0;
            case "dashed":
                return 2;
            case "dotted":
                return 3;
            case "double":
                return 4
            }
            return 1
        }
    }
}, VAe = T1("top"), jAe = T1("right"), WAe = T1("bottom"), KAe = T1("left"), I1 = function(n) {
    return {
        name: "border-" + n + "-width",
        initialValue: "0",
        type: 0,
        prefix: !1,
        parse: function(e, t) {
            return E0(t) ? t.number : 0
        }
    }
}, XAe = I1("top"), YAe = I1("right"), $Ae = I1("bottom"), ZAe = I1("left"), JAe = {
    name: "color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
}, qAe = {
    name: "direction",
    initialValue: "ltr",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "rtl":
            return 1;
        case "ltr":
        default:
            return 0
        }
    }
}, eue = {
    name: "display",
    initialValue: "inline-block",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.filter(sr).reduce(function(t, r) {
            return t | tue(r.value)
        }, 0)
    }
}, tue = function(n) {
    switch (n) {
    case "block":
    case "-webkit-box":
        return 2;
    case "inline":
        return 4;
    case "run-in":
        return 8;
    case "flow":
        return 16;
    case "flow-root":
        return 32;
    case "table":
        return 64;
    case "flex":
    case "-webkit-flex":
        return 128;
    case "grid":
    case "-ms-grid":
        return 256;
    case "ruby":
        return 512;
    case "subgrid":
        return 1024;
    case "list-item":
        return 2048;
    case "table-row-group":
        return 4096;
    case "table-header-group":
        return 8192;
    case "table-footer-group":
        return 16384;
    case "table-row":
        return 32768;
    case "table-cell":
        return 65536;
    case "table-column-group":
        return 131072;
    case "table-column":
        return 262144;
    case "table-caption":
        return 524288;
    case "ruby-base":
        return 1048576;
    case "ruby-text":
        return 2097152;
    case "ruby-base-container":
        return 4194304;
    case "ruby-text-container":
        return 8388608;
    case "contents":
        return 16777216;
    case "inline-block":
        return 33554432;
    case "inline-list-item":
        return 67108864;
    case "inline-table":
        return 134217728;
    case "inline-flex":
        return 268435456;
    case "inline-grid":
        return 536870912
    }
    return 0
}, nue = {
    name: "float",
    initialValue: "none",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "left":
            return 1;
        case "right":
            return 2;
        case "inline-start":
            return 3;
        case "inline-end":
            return 4
        }
        return 0
    }
}, rue = {
    name: "letter-spacing",
    initialValue: "0",
    prefix: !1,
    type: 0,
    parse: function(n, e) {
        return e.type === 20 && e.value === "normal" ? 0 : e.type === 17 || e.type === 15 ? e.number : 0
    }
}, V_;
(function(n) {
    n.NORMAL = "normal",
    n.STRICT = "strict"
}
)(V_ || (V_ = {}));
var iue = {
    name: "line-break",
    initialValue: "normal",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "strict":
            return V_.STRICT;
        case "normal":
        default:
            return V_.NORMAL
        }
    }
}, sue = {
    name: "line-height",
    initialValue: "normal",
    prefix: !1,
    type: 4
}, lN = function(n, e) {
    return sr(n) && n.value === "normal" ? 1.2 * e : n.type === 17 ? e * n.number : br(n) ? bn(n, e) : e
}, oue = {
    name: "list-style-image",
    initialValue: "none",
    type: 0,
    prefix: !1,
    parse: function(n, e) {
        return e.type === 20 && e.value === "none" ? null : n2.parse(n, e)
    }
}, aue = {
    name: "list-style-position",
    initialValue: "outside",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "inside":
            return 0;
        case "outside":
        default:
            return 1
        }
    }
}, lue = {
    name: "list-style-type",
    initialValue: "none",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "disc":
            return 0;
        case "circle":
            return 1;
        case "square":
            return 2;
        case "decimal":
            return 3;
        case "cjk-decimal":
            return 4;
        case "decimal-leading-zero":
            return 5;
        case "lower-roman":
            return 6;
        case "upper-roman":
            return 7;
        case "lower-greek":
            return 8;
        case "lower-alpha":
            return 9;
        case "upper-alpha":
            return 10;
        case "arabic-indic":
            return 11;
        case "armenian":
            return 12;
        case "bengali":
            return 13;
        case "cambodian":
            return 14;
        case "cjk-earthly-branch":
            return 15;
        case "cjk-heavenly-stem":
            return 16;
        case "cjk-ideographic":
            return 17;
        case "devanagari":
            return 18;
        case "ethiopic-numeric":
            return 19;
        case "georgian":
            return 20;
        case "gujarati":
            return 21;
        case "gurmukhi":
            return 22;
        case "hebrew":
            return 22;
        case "hiragana":
            return 23;
        case "hiragana-iroha":
            return 24;
        case "japanese-formal":
            return 25;
        case "japanese-informal":
            return 26;
        case "kannada":
            return 27;
        case "katakana":
            return 28;
        case "katakana-iroha":
            return 29;
        case "khmer":
            return 30;
        case "korean-hangul-formal":
            return 31;
        case "korean-hanja-formal":
            return 32;
        case "korean-hanja-informal":
            return 33;
        case "lao":
            return 34;
        case "lower-armenian":
            return 35;
        case "malayalam":
            return 36;
        case "mongolian":
            return 37;
        case "myanmar":
            return 38;
        case "oriya":
            return 39;
        case "persian":
            return 40;
        case "simp-chinese-formal":
            return 41;
        case "simp-chinese-informal":
            return 42;
        case "tamil":
            return 43;
        case "telugu":
            return 44;
        case "thai":
            return 45;
        case "tibetan":
            return 46;
        case "trad-chinese-formal":
            return 47;
        case "trad-chinese-informal":
            return 48;
        case "upper-armenian":
            return 49;
        case "disclosure-open":
            return 50;
        case "disclosure-closed":
            return 51;
        case "none":
        default:
            return -1
        }
    }
}, R1 = function(n) {
    return {
        name: "margin-" + n,
        initialValue: "0",
        prefix: !1,
        type: 4
    }
}, cue = R1("top"), Aue = R1("right"), uue = R1("bottom"), fue = R1("left"), hue = {
    name: "overflow",
    initialValue: "visible",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.filter(sr).map(function(t) {
            switch (t.value) {
            case "hidden":
                return 1;
            case "scroll":
                return 2;
            case "clip":
                return 3;
            case "auto":
                return 4;
            case "visible":
            default:
                return 0
            }
        })
    }
}, due = {
    name: "overflow-wrap",
    initialValue: "normal",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "break-word":
            return "break-word";
        case "normal":
        default:
            return "normal"
        }
    }
}, U1 = function(n) {
    return {
        name: "padding-" + n,
        initialValue: "0",
        prefix: !1,
        type: 3,
        format: "length-percentage"
    }
}, pue = U1("top"), mue = U1("right"), gue = U1("bottom"), vue = U1("left"), yue = {
    name: "text-align",
    initialValue: "left",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "right":
            return 2;
        case "center":
        case "justify":
            return 1;
        case "left":
        default:
            return 0
        }
    }
}, wue = {
    name: "position",
    initialValue: "static",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "relative":
            return 1;
        case "absolute":
            return 2;
        case "fixed":
            return 3;
        case "sticky":
            return 4
        }
        return 0
    }
}, _ue = {
    name: "text-shadow",
    initialValue: "none",
    type: 1,
    prefix: !1,
    parse: function(n, e) {
        return e.length === 1 && eT(e[0], "none") ? [] : ll(e).map(function(t) {
            for (var r = {
                color: Zg.TRANSPARENT,
                offsetX: ii,
                offsetY: ii,
                blur: ii
            }, i = 0, s = 0; s < t.length; s++) {
                var o = t[s];
                _A(o) ? (i === 0 ? r.offsetX = o : i === 1 ? r.offsetY = o : r.blur = o,
                i++) : r.color = hA.parse(n, o)
            }
            return r
        })
    }
}, xue = {
    name: "text-transform",
    initialValue: "none",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "uppercase":
            return 2;
        case "lowercase":
            return 1;
        case "capitalize":
            return 3
        }
        return 0
    }
}, bue = {
    name: "transform",
    initialValue: "none",
    prefix: !0,
    type: 0,
    parse: function(n, e) {
        if (e.type === 20 && e.value === "none")
            return null;
        if (e.type === 18) {
            var t = Mue[e.name];
            if (typeof t > "u")
                throw new Error('Attempting to parse an unsupported transform function "' + e.name + '"');
            return t(e.values)
        }
        return null
    }
}, Eue = function(n) {
    var e = n.filter(function(t) {
        return t.type === 17
    }).map(function(t) {
        return t.number
    });
    return e.length === 6 ? e : null
}, Bue = function(n) {
    var e = n.filter(function(l) {
        return l.type === 17
    }).map(function(l) {
        return l.number
    })
      , t = e[0]
      , r = e[1];
    e[2],
    e[3];
    var i = e[4]
      , s = e[5];
    e[6],
    e[7],
    e[8],
    e[9],
    e[10],
    e[11];
    var o = e[12]
      , a = e[13];
    return e[14],
    e[15],
    e.length === 16 ? [t, r, i, s, o, a] : null
}, Mue = {
    matrix: Eue,
    matrix3d: Bue
}, cN = {
    type: 16,
    number: 50,
    flags: b0
}, Sue = [cN, cN], Cue = {
    name: "transform-origin",
    initialValue: "50% 50%",
    prefix: !0,
    type: 1,
    parse: function(n, e) {
        var t = e.filter(br);
        return t.length !== 2 ? Sue : [t[0], t[1]]
    }
}, Tue = {
    name: "visible",
    initialValue: "none",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "hidden":
            return 1;
        case "collapse":
            return 2;
        case "visible":
        default:
            return 0
        }
    }
}, ig;
(function(n) {
    n.NORMAL = "normal",
    n.BREAK_ALL = "break-all",
    n.KEEP_ALL = "keep-all"
}
)(ig || (ig = {}));
var Iue = {
    name: "word-break",
    initialValue: "normal",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "break-all":
            return ig.BREAK_ALL;
        case "keep-all":
            return ig.KEEP_ALL;
        case "normal":
        default:
            return ig.NORMAL
        }
    }
}
  , Rue = {
    name: "z-index",
    initialValue: "auto",
    prefix: !1,
    type: 0,
    parse: function(n, e) {
        if (e.type === 20)
            return {
                auto: !0,
                order: 0
            };
        if (b1(e))
            return {
                auto: !1,
                order: e.number
            };
        throw new Error("Invalid z-index number parsed")
    }
}
  , H8 = {
    name: "time",
    parse: function(n, e) {
        if (e.type === 15)
            switch (e.unit.toLowerCase()) {
            case "s":
                return 1e3 * e.number;
            case "ms":
                return e.number
            }
        throw new Error("Unsupported time type")
    }
}
  , Uue = {
    name: "opacity",
    initialValue: "1",
    type: 0,
    prefix: !1,
    parse: function(n, e) {
        return b1(e) ? e.number : 1
    }
}
  , Fue = {
    name: "text-decoration-color",
    initialValue: "transparent",
    prefix: !1,
    type: 3,
    format: "color"
}
  , Pue = {
    name: "text-decoration-line",
    initialValue: "none",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.filter(sr).map(function(t) {
            switch (t.value) {
            case "underline":
                return 1;
            case "overline":
                return 2;
            case "line-through":
                return 3;
            case "none":
                return 4
            }
            return 0
        }).filter(function(t) {
            return t !== 0
        })
    }
}
  , Lue = {
    name: "font-family",
    initialValue: "",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        var t = []
          , r = [];
        return e.forEach(function(i) {
            switch (i.type) {
            case 20:
            case 0:
                t.push(i.value);
                break;
            case 17:
                t.push(i.number.toString());
                break;
            case 4:
                r.push(t.join(" ")),
                t.length = 0;
                break
            }
        }),
        t.length && r.push(t.join(" ")),
        r.map(function(i) {
            return i.indexOf(" ") === -1 ? i : "'" + i + "'"
        })
    }
}
  , Due = {
    name: "font-size",
    initialValue: "0",
    prefix: !1,
    type: 3,
    format: "length"
}
  , Nue = {
    name: "font-weight",
    initialValue: "normal",
    type: 0,
    prefix: !1,
    parse: function(n, e) {
        if (b1(e))
            return e.number;
        if (sr(e))
            switch (e.value) {
            case "bold":
                return 700;
            case "normal":
            default:
                return 400
            }
        return 400
    }
}
  , Oue = {
    name: "font-variant",
    initialValue: "none",
    type: 1,
    prefix: !1,
    parse: function(n, e) {
        return e.filter(sr).map(function(t) {
            return t.value
        })
    }
}
  , kue = {
    name: "font-style",
    initialValue: "normal",
    prefix: !1,
    type: 2,
    parse: function(n, e) {
        switch (e) {
        case "oblique":
            return "oblique";
        case "italic":
            return "italic";
        case "normal":
        default:
            return "normal"
        }
    }
}
  , Pr = function(n, e) {
    return (n & e) !== 0
}
  , Que = {
    name: "duration",
    initialValue: "0s",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        return e.filter(E0).map(function(t) {
            return H8.parse(n, t)
        })
    }
}
  , Hue = {
    name: "box-shadow",
    initialValue: "none",
    type: 1,
    prefix: !1,
    parse: function(n, e) {
        return e.length === 1 && eT(e[0], "none") ? [] : ll(e).map(function(t) {
            for (var r = {
                color: 255,
                offsetX: ii,
                offsetY: ii,
                blur: ii,
                spread: ii,
                inset: !1
            }, i = 0, s = 0; s < t.length; s++) {
                var o = t[s];
                eT(o, "inset") ? r.inset = !0 : _A(o) ? (i === 0 ? r.offsetX = o : i === 1 ? r.offsetY = o : i === 2 ? r.blur = o : r.spread = o,
                i++) : r.color = hA.parse(n, o)
            }
            return r
        })
    }
}
  , zue = {
    name: "paint-order",
    initialValue: "normal",
    prefix: !1,
    type: 1,
    parse: function(n, e) {
        var t = [0, 1, 2]
          , r = [];
        return e.filter(sr).forEach(function(i) {
            switch (i.value) {
            case "stroke":
                r.push(1);
                break;
            case "fill":
                r.push(0);
                break;
            case "markers":
                r.push(2);
                break
            }
        }),
        t.forEach(function(i) {
            r.indexOf(i) === -1 && r.push(i)
        }),
        r
    }
}
  , Gue = {
    name: "-webkit-text-stroke-color",
    initialValue: "currentcolor",
    prefix: !1,
    type: 3,
    format: "color"
}
  , Vue = {
    name: "-webkit-text-stroke-width",
    initialValue: "0",
    type: 0,
    prefix: !1,
    parse: function(n, e) {
        return E0(e) ? e.number : 0
    }
}
  , jue = function() {
    function n(e, t) {
        var r, i;
        this.animationDuration = et(e, Que, t.animationDuration),
        this.backgroundClip = et(e, vAe, t.backgroundClip),
        this.backgroundColor = et(e, yAe, t.backgroundColor),
        this.backgroundImage = et(e, TAe, t.backgroundImage),
        this.backgroundOrigin = et(e, IAe, t.backgroundOrigin),
        this.backgroundPosition = et(e, RAe, t.backgroundPosition),
        this.backgroundRepeat = et(e, UAe, t.backgroundRepeat),
        this.backgroundSize = et(e, PAe, t.backgroundSize),
        this.borderTopColor = et(e, DAe, t.borderTopColor),
        this.borderRightColor = et(e, NAe, t.borderRightColor),
        this.borderBottomColor = et(e, OAe, t.borderBottomColor),
        this.borderLeftColor = et(e, kAe, t.borderLeftColor),
        this.borderTopLeftRadius = et(e, QAe, t.borderTopLeftRadius),
        this.borderTopRightRadius = et(e, HAe, t.borderTopRightRadius),
        this.borderBottomRightRadius = et(e, zAe, t.borderBottomRightRadius),
        this.borderBottomLeftRadius = et(e, GAe, t.borderBottomLeftRadius),
        this.borderTopStyle = et(e, VAe, t.borderTopStyle),
        this.borderRightStyle = et(e, jAe, t.borderRightStyle),
        this.borderBottomStyle = et(e, WAe, t.borderBottomStyle),
        this.borderLeftStyle = et(e, KAe, t.borderLeftStyle),
        this.borderTopWidth = et(e, XAe, t.borderTopWidth),
        this.borderRightWidth = et(e, YAe, t.borderRightWidth),
        this.borderBottomWidth = et(e, $Ae, t.borderBottomWidth),
        this.borderLeftWidth = et(e, ZAe, t.borderLeftWidth),
        this.boxShadow = et(e, Hue, t.boxShadow),
        this.color = et(e, JAe, t.color),
        this.direction = et(e, qAe, t.direction),
        this.display = et(e, eue, t.display),
        this.float = et(e, nue, t.cssFloat),
        this.fontFamily = et(e, Lue, t.fontFamily),
        this.fontSize = et(e, Due, t.fontSize),
        this.fontStyle = et(e, kue, t.fontStyle),
        this.fontVariant = et(e, Oue, t.fontVariant),
        this.fontWeight = et(e, Nue, t.fontWeight),
        this.letterSpacing = et(e, rue, t.letterSpacing),
        this.lineBreak = et(e, iue, t.lineBreak),
        this.lineHeight = et(e, sue, t.lineHeight),
        this.listStyleImage = et(e, oue, t.listStyleImage),
        this.listStylePosition = et(e, aue, t.listStylePosition),
        this.listStyleType = et(e, lue, t.listStyleType),
        this.marginTop = et(e, cue, t.marginTop),
        this.marginRight = et(e, Aue, t.marginRight),
        this.marginBottom = et(e, uue, t.marginBottom),
        this.marginLeft = et(e, fue, t.marginLeft),
        this.opacity = et(e, Uue, t.opacity);
        var s = et(e, hue, t.overflow);
        this.overflowX = s[0],
        this.overflowY = s[s.length > 1 ? 1 : 0],
        this.overflowWrap = et(e, due, t.overflowWrap),
        this.paddingTop = et(e, pue, t.paddingTop),
        this.paddingRight = et(e, mue, t.paddingRight),
        this.paddingBottom = et(e, gue, t.paddingBottom),
        this.paddingLeft = et(e, vue, t.paddingLeft),
        this.paintOrder = et(e, zue, t.paintOrder),
        this.position = et(e, wue, t.position),
        this.textAlign = et(e, yue, t.textAlign),
        this.textDecorationColor = et(e, Fue, (r = t.textDecorationColor) !== null && r !== void 0 ? r : t.color),
        this.textDecorationLine = et(e, Pue, (i = t.textDecorationLine) !== null && i !== void 0 ? i : t.textDecoration),
        this.textShadow = et(e, _ue, t.textShadow),
        this.textTransform = et(e, xue, t.textTransform),
        this.transform = et(e, bue, t.transform),
        this.transformOrigin = et(e, Cue, t.transformOrigin),
        this.visibility = et(e, Tue, t.visibility),
        this.webkitTextStrokeColor = et(e, Gue, t.webkitTextStrokeColor),
        this.webkitTextStrokeWidth = et(e, Vue, t.webkitTextStrokeWidth),
        this.wordBreak = et(e, Iue, t.wordBreak),
        this.zIndex = et(e, Rue, t.zIndex)
    }
    return n.prototype.isVisible = function() {
        return this.display > 0 && this.opacity > 0 && this.visibility === 0
    }
    ,
    n.prototype.isTransparent = function() {
        return cd(this.backgroundColor)
    }
    ,
    n.prototype.isTransformed = function() {
        return this.transform !== null
    }
    ,
    n.prototype.isPositioned = function() {
        return this.position !== 0
    }
    ,
    n.prototype.isPositionedWithZIndex = function() {
        return this.isPositioned() && !this.zIndex.auto
    }
    ,
    n.prototype.isFloating = function() {
        return this.float !== 0
    }
    ,
    n.prototype.isInlineLevel = function() {
        return Pr(this.display, 4) || Pr(this.display, 33554432) || Pr(this.display, 268435456) || Pr(this.display, 536870912) || Pr(this.display, 67108864) || Pr(this.display, 134217728)
    }
    ,
    n
}()
  , et = function(n, e, t) {
    var r = new b8
      , i = t !== null && typeof t < "u" ? t.toString() : e.initialValue;
    r.write(i);
    var s = new E8(r.read());
    switch (e.type) {
    case 2:
        var o = s.parseComponentValue();
        return e.parse(n, sr(o) ? o.value : e.initialValue);
    case 0:
        return e.parse(n, s.parseComponentValue());
    case 1:
        return e.parse(n, s.parseComponentValues());
    case 4:
        return s.parseComponentValue();
    case 3:
        switch (e.format) {
        case "angle":
            return B1.parse(n, s.parseComponentValue());
        case "color":
            return hA.parse(n, s.parseComponentValue());
        case "image":
            return n2.parse(n, s.parseComponentValue());
        case "length":
            var a = s.parseComponentValue();
            return _A(a) ? a : ii;
        case "length-percentage":
            var l = s.parseComponentValue();
            return br(l) ? l : ii;
        case "time":
            return H8.parse(n, s.parseComponentValue())
        }
        break
    }
}
  , Wue = "data-html2canvas-debug"
  , Kue = function(n) {
    var e = n.getAttribute(Wue);
    switch (e) {
    case "all":
        return 1;
    case "clone":
        return 2;
    case "parse":
        return 3;
    case "render":
        return 4;
    default:
        return 0
    }
}
  , AN = function(n, e) {
    var t = Kue(n);
    return t === 1 || e === t
}
  , cl = function() {
    function n(e, t) {
        if (this.context = e,
        this.textNodes = [],
        this.elements = [],
        this.flags = 0,
        AN(t, 3))
            debugger ;this.styles = new jue(e,window.getComputedStyle(t, null)),
        Kfe(t) && (this.styles.animationDuration.some(function(r) {
            return r > 0
        }) && (t.style.animationDuration = "0s"),
        this.styles.transform !== null && (t.style.transform = "none")),
        this.bounds = qR(this.context, t),
        AN(t, 4) && (this.flags |= 16)
    }
    return n
}()
  , Xue = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA="
  , uN = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , Tm = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var Ay = 0; Ay < uN.length; Ay++)
    Tm[uN.charCodeAt(Ay)] = Ay;
var Yue = function(n) {
    var e = n.length * .75, t = n.length, r, i = 0, s, o, a, l;
    n[n.length - 1] === "=" && (e--,
    n[n.length - 2] === "=" && e--);
    var c = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && typeof Uint8Array.prototype.slice < "u" ? new ArrayBuffer(e) : new Array(e)
      , A = Array.isArray(c) ? c : new Uint8Array(c);
    for (r = 0; r < t; r += 4)
        s = Tm[n.charCodeAt(r)],
        o = Tm[n.charCodeAt(r + 1)],
        a = Tm[n.charCodeAt(r + 2)],
        l = Tm[n.charCodeAt(r + 3)],
        A[i++] = s << 2 | o >> 4,
        A[i++] = (o & 15) << 4 | a >> 2,
        A[i++] = (a & 3) << 6 | l & 63;
    return c
}
  , $ue = function(n) {
    for (var e = n.length, t = [], r = 0; r < e; r += 2)
        t.push(n[r + 1] << 8 | n[r]);
    return t
}
  , Zue = function(n) {
    for (var e = n.length, t = [], r = 0; r < e; r += 4)
        t.push(n[r + 3] << 24 | n[r + 2] << 16 | n[r + 1] << 8 | n[r]);
    return t
}
  , Mu = 5
  , r2 = 6 + 5
  , xB = 2
  , Jue = r2 - Mu
  , z8 = 65536 >> Mu
  , que = 1 << Mu
  , bB = que - 1
  , efe = 1024 >> Mu
  , tfe = z8 + efe
  , nfe = tfe
  , rfe = 32
  , ife = nfe + rfe
  , sfe = 65536 >> r2
  , ofe = 1 << Jue
  , afe = ofe - 1
  , fN = function(n, e, t) {
    return n.slice ? n.slice(e, t) : new Uint16Array(Array.prototype.slice.call(n, e, t))
}
  , lfe = function(n, e, t) {
    return n.slice ? n.slice(e, t) : new Uint32Array(Array.prototype.slice.call(n, e, t))
}
  , cfe = function(n, e) {
    var t = Yue(n)
      , r = Array.isArray(t) ? Zue(t) : new Uint32Array(t)
      , i = Array.isArray(t) ? $ue(t) : new Uint16Array(t)
      , s = 24
      , o = fN(i, s / 2, r[4] / 2)
      , a = r[5] === 2 ? fN(i, (s + r[4]) / 2) : lfe(r, Math.ceil((s + r[4]) / 4));
    return new Afe(r[0],r[1],r[2],r[3],o,a)
}
  , Afe = function() {
    function n(e, t, r, i, s, o) {
        this.initialValue = e,
        this.errorValue = t,
        this.highStart = r,
        this.highValueIndex = i,
        this.index = s,
        this.data = o
    }
    return n.prototype.get = function(e) {
        var t;
        if (e >= 0) {
            if (e < 55296 || e > 56319 && e <= 65535)
                return t = this.index[e >> Mu],
                t = (t << xB) + (e & bB),
                this.data[t];
            if (e <= 65535)
                return t = this.index[z8 + (e - 55296 >> Mu)],
                t = (t << xB) + (e & bB),
                this.data[t];
            if (e < this.highStart)
                return t = ife - sfe + (e >> r2),
                t = this.index[t],
                t += e >> Mu & afe,
                t = this.index[t],
                t = (t << xB) + (e & bB),
                this.data[t];
            if (e <= 1114111)
                return this.data[this.highValueIndex]
        }
        return this.errorValue
    }
    ,
    n
}()
  , hN = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  , ufe = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (var uy = 0; uy < hN.length; uy++)
    ufe[hN.charCodeAt(uy)] = uy;
var ffe = 1, EB = 2, BB = 3, dN = 4, pN = 5, hfe = 7, mN = 8, MB = 9, SB = 10, gN = 11, vN = 12, yN = 13, wN = 14, CB = 15, dfe = function(n) {
    for (var e = [], t = 0, r = n.length; t < r; ) {
        var i = n.charCodeAt(t++);
        if (i >= 55296 && i <= 56319 && t < r) {
            var s = n.charCodeAt(t++);
            (s & 64512) === 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i),
            t--)
        } else
            e.push(i)
    }
    return e
}, pfe = function() {
    for (var n = [], e = 0; e < arguments.length; e++)
        n[e] = arguments[e];
    if (String.fromCodePoint)
        return String.fromCodePoint.apply(String, n);
    var t = n.length;
    if (!t)
        return "";
    for (var r = [], i = -1, s = ""; ++i < t; ) {
        var o = n[i];
        o <= 65535 ? r.push(o) : (o -= 65536,
        r.push((o >> 10) + 55296, o % 1024 + 56320)),
        (i + 1 === t || r.length > 16384) && (s += String.fromCharCode.apply(String, r),
        r.length = 0)
    }
    return s
}, mfe = cfe(Xue), ro = "×", TB = "÷", gfe = function(n) {
    return mfe.get(n)
}, vfe = function(n, e, t) {
    var r = t - 2
      , i = e[r]
      , s = e[t - 1]
      , o = e[t];
    if (s === EB && o === BB)
        return ro;
    if (s === EB || s === BB || s === dN || o === EB || o === BB || o === dN)
        return TB;
    if (s === mN && [mN, MB, gN, vN].indexOf(o) !== -1 || (s === gN || s === MB) && (o === MB || o === SB) || (s === vN || s === SB) && o === SB || o === yN || o === pN || o === hfe || s === ffe)
        return ro;
    if (s === yN && o === wN) {
        for (; i === pN; )
            i = e[--r];
        if (i === wN)
            return ro
    }
    if (s === CB && o === CB) {
        for (var a = 0; i === CB; )
            a++,
            i = e[--r];
        if (a % 2 === 0)
            return ro
    }
    return TB
}, yfe = function(n) {
    var e = dfe(n)
      , t = e.length
      , r = 0
      , i = 0
      , s = e.map(gfe);
    return {
        next: function() {
            if (r >= t)
                return {
                    done: !0,
                    value: null
                };
            for (var o = ro; r < t && (o = vfe(e, s, ++r)) === ro; )
                ;
            if (o !== ro || r === t) {
                var a = pfe.apply(null, e.slice(i, r));
                return i = r,
                {
                    value: a,
                    done: !1
                }
            }
            return {
                done: !0,
                value: null
            }
        }
    }
}, wfe = function(n) {
    for (var e = yfe(n), t = [], r; !(r = e.next()).done; )
        r.value && t.push(r.value.slice());
    return t
}, _fe = function(n) {
    var e = 123;
    if (n.createRange) {
        var t = n.createRange();
        if (t.getBoundingClientRect) {
            var r = n.createElement("boundtest");
            r.style.height = e + "px",
            r.style.display = "block",
            n.body.appendChild(r),
            t.selectNode(r);
            var i = t.getBoundingClientRect()
              , s = Math.round(i.height);
            if (n.body.removeChild(r),
            s === e)
                return !0
        }
    }
    return !1
}, xfe = function(n) {
    var e = n.createElement("boundtest");
    e.style.width = "50px",
    e.style.display = "block",
    e.style.fontSize = "12px",
    e.style.letterSpacing = "0px",
    e.style.wordSpacing = "0px",
    n.body.appendChild(e);
    var t = n.createRange();
    e.innerHTML = typeof "".repeat == "function" ? "&#128104;".repeat(10) : "";
    var r = e.firstChild
      , i = x1(r.data).map(function(l) {
        return Ar(l)
    })
      , s = 0
      , o = {}
      , a = i.every(function(l, c) {
        t.setStart(r, s),
        t.setEnd(r, s + l.length);
        var A = t.getBoundingClientRect();
        s += l.length;
        var u = A.x > o.x || A.y > o.y;
        return o = A,
        c === 0 ? !0 : u
    });
    return n.body.removeChild(e),
    a
}, bfe = function() {
    return typeof new Image().crossOrigin < "u"
}, Efe = function() {
    return typeof new XMLHttpRequest().responseType == "string"
}, Bfe = function(n) {
    var e = new Image
      , t = n.createElement("canvas")
      , r = t.getContext("2d");
    if (!r)
        return !1;
    e.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
    try {
        r.drawImage(e, 0, 0),
        t.toDataURL()
    } catch {
        return !1
    }
    return !0
}, _N = function(n) {
    return n[0] === 0 && n[1] === 255 && n[2] === 0 && n[3] === 255
}, Mfe = function(n) {
    var e = n.createElement("canvas")
      , t = 100;
    e.width = t,
    e.height = t;
    var r = e.getContext("2d");
    if (!r)
        return Promise.reject(!1);
    r.fillStyle = "rgb(0, 255, 0)",
    r.fillRect(0, 0, t, t);
    var i = new Image
      , s = e.toDataURL();
    i.src = s;
    var o = tT(t, t, 0, 0, i);
    return r.fillStyle = "red",
    r.fillRect(0, 0, t, t),
    xN(o).then(function(a) {
        r.drawImage(a, 0, 0);
        var l = r.getImageData(0, 0, t, t).data;
        r.fillStyle = "red",
        r.fillRect(0, 0, t, t);
        var c = n.createElement("div");
        return c.style.backgroundImage = "url(" + s + ")",
        c.style.height = t + "px",
        _N(l) ? xN(tT(t, t, 0, 0, c)) : Promise.reject(!1)
    }).then(function(a) {
        return r.drawImage(a, 0, 0),
        _N(r.getImageData(0, 0, t, t).data)
    }).catch(function() {
        return !1
    })
}, tT = function(n, e, t, r, i) {
    var s = "http://www.w3.org/2000/svg"
      , o = document.createElementNS(s, "svg")
      , a = document.createElementNS(s, "foreignObject");
    return o.setAttributeNS(null, "width", n.toString()),
    o.setAttributeNS(null, "height", e.toString()),
    a.setAttributeNS(null, "width", "100%"),
    a.setAttributeNS(null, "height", "100%"),
    a.setAttributeNS(null, "x", t.toString()),
    a.setAttributeNS(null, "y", r.toString()),
    a.setAttributeNS(null, "externalResourcesRequired", "true"),
    o.appendChild(a),
    a.appendChild(i),
    o
}, xN = function(n) {
    return new Promise(function(e, t) {
        var r = new Image;
        r.onload = function() {
            return e(r)
        }
        ,
        r.onerror = t,
        r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(n))
    }
    )
}, _s = {
    get SUPPORT_RANGE_BOUNDS() {
        var n = _fe(document);
        return Object.defineProperty(_s, "SUPPORT_RANGE_BOUNDS", {
            value: n
        }),
        n
    },
    get SUPPORT_WORD_BREAKING() {
        var n = _s.SUPPORT_RANGE_BOUNDS && xfe(document);
        return Object.defineProperty(_s, "SUPPORT_WORD_BREAKING", {
            value: n
        }),
        n
    },
    get SUPPORT_SVG_DRAWING() {
        var n = Bfe(document);
        return Object.defineProperty(_s, "SUPPORT_SVG_DRAWING", {
            value: n
        }),
        n
    },
    get SUPPORT_FOREIGNOBJECT_DRAWING() {
        var n = typeof Array.from == "function" && typeof window.fetch == "function" ? Mfe(document) : Promise.resolve(!1);
        return Object.defineProperty(_s, "SUPPORT_FOREIGNOBJECT_DRAWING", {
            value: n
        }),
        n
    },
    get SUPPORT_CORS_IMAGES() {
        var n = bfe();
        return Object.defineProperty(_s, "SUPPORT_CORS_IMAGES", {
            value: n
        }),
        n
    },
    get SUPPORT_RESPONSE_TYPE() {
        var n = Efe();
        return Object.defineProperty(_s, "SUPPORT_RESPONSE_TYPE", {
            value: n
        }),
        n
    },
    get SUPPORT_CORS_XHR() {
        var n = "withCredentials"in new XMLHttpRequest;
        return Object.defineProperty(_s, "SUPPORT_CORS_XHR", {
            value: n
        }),
        n
    },
    get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
        var n = !!(typeof Intl < "u" && Intl.Segmenter);
        return Object.defineProperty(_s, "SUPPORT_NATIVE_TEXT_SEGMENTATION", {
            value: n
        }),
        n
    }
}, sg = function() {
    function n(e, t) {
        this.text = e,
        this.bounds = t
    }
    return n
}(), Sfe = function(n, e, t, r) {
    var i = Ife(e, t)
      , s = []
      , o = 0;
    return i.forEach(function(a) {
        if (t.textDecorationLine.length || a.trim().length > 0)
            if (_s.SUPPORT_RANGE_BOUNDS) {
                var l = bN(r, o, a.length).getClientRects();
                if (l.length > 1) {
                    var c = i2(a)
                      , A = 0;
                    c.forEach(function(f) {
                        s.push(new sg(f,Qu.fromDOMRectList(n, bN(r, A + o, f.length).getClientRects()))),
                        A += f.length
                    })
                } else
                    s.push(new sg(a,Qu.fromDOMRectList(n, l)))
            } else {
                var u = r.splitText(a.length);
                s.push(new sg(a,Cfe(n, r))),
                r = u
            }
        else
            _s.SUPPORT_RANGE_BOUNDS || (r = r.splitText(a.length));
        o += a.length
    }),
    s
}, Cfe = function(n, e) {
    var t = e.ownerDocument;
    if (t) {
        var r = t.createElement("html2canvaswrapper");
        r.appendChild(e.cloneNode(!0));
        var i = e.parentNode;
        if (i) {
            i.replaceChild(r, e);
            var s = qR(n, r);
            return r.firstChild && i.replaceChild(r.firstChild, r),
            s
        }
    }
    return Qu.EMPTY
}, bN = function(n, e, t) {
    var r = n.ownerDocument;
    if (!r)
        throw new Error("Node has no owner document");
    var i = r.createRange();
    return i.setStart(n, e),
    i.setEnd(n, e + t),
    i
}, i2 = function(n) {
    if (_s.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var e = new Intl.Segmenter(void 0,{
            granularity: "grapheme"
        });
        return Array.from(e.segment(n)).map(function(t) {
            return t.segment
        })
    }
    return wfe(n)
}, Tfe = function(n, e) {
    if (_s.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var t = new Intl.Segmenter(void 0,{
            granularity: "word"
        });
        return Array.from(t.segment(n)).map(function(r) {
            return r.segment
        })
    }
    return Ufe(n, e)
}, Ife = function(n, e) {
    return e.letterSpacing !== 0 ? i2(n) : Tfe(n, e)
}, Rfe = [32, 160, 4961, 65792, 65793, 4153, 4241], Ufe = function(n, e) {
    for (var t = Ace(n, {
        lineBreak: e.lineBreak,
        wordBreak: e.overflowWrap === "break-word" ? "break-word" : e.wordBreak
    }), r = [], i, s = function() {
        if (i.value) {
            var o = i.value.slice()
              , a = x1(o)
              , l = "";
            a.forEach(function(c) {
                Rfe.indexOf(c) === -1 ? l += Ar(c) : (l.length && r.push(l),
                r.push(Ar(c)),
                l = "")
            }),
            l.length && r.push(l)
        }
    }; !(i = t.next()).done; )
        s();
    return r
}, Ffe = function() {
    function n(e, t, r) {
        this.text = Pfe(t.data, r.textTransform),
        this.textBounds = Sfe(e, this.text, r, t)
    }
    return n
}(), Pfe = function(n, e) {
    switch (e) {
    case 1:
        return n.toLowerCase();
    case 3:
        return n.replace(Lfe, Dfe);
    case 2:
        return n.toUpperCase();
    default:
        return n
    }
}, Lfe = /(^|\s|:|-|\(|\))([a-z])/g, Dfe = function(n, e, t) {
    return n.length > 0 ? e + t.toUpperCase() : n
}, G8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.src = r.currentSrc || r.src,
        i.intrinsicWidth = r.naturalWidth,
        i.intrinsicHeight = r.naturalHeight,
        i.context.cache.addImage(i.src),
        i
    }
    return e
}(cl), V8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.canvas = r,
        i.intrinsicWidth = r.width,
        i.intrinsicHeight = r.height,
        i
    }
    return e
}(cl), j8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this
          , s = new XMLSerializer
          , o = qR(t, r);
        return r.setAttribute("width", o.width + "px"),
        r.setAttribute("height", o.height + "px"),
        i.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(r)),
        i.intrinsicWidth = r.width.baseVal.value,
        i.intrinsicHeight = r.height.baseVal.value,
        i.context.cache.addImage(i.svg),
        i
    }
    return e
}(cl), W8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.value = r.value,
        i
    }
    return e
}(cl), nT = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.start = r.start,
        i.reversed = typeof r.reversed == "boolean" && r.reversed === !0,
        i
    }
    return e
}(cl), Nfe = [{
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
}], Ofe = [{
    type: 16,
    flags: 0,
    number: 50
}], kfe = function(n) {
    return n.width > n.height ? new Qu(n.left + (n.width - n.height) / 2,n.top,n.height,n.height) : n.width < n.height ? new Qu(n.left,n.top + (n.height - n.width) / 2,n.width,n.width) : n
}, Qfe = function(n) {
    var e = n.type === Hfe ? new Array(n.value.length + 1).join("•") : n.value;
    return e.length === 0 ? n.placeholder || "" : e
}, j_ = "checkbox", W_ = "radio", Hfe = "password", EN = 707406591, s2 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        switch (i.type = r.type.toLowerCase(),
        i.checked = r.checked,
        i.value = Qfe(r),
        (i.type === j_ || i.type === W_) && (i.styles.backgroundColor = 3739148031,
        i.styles.borderTopColor = i.styles.borderRightColor = i.styles.borderBottomColor = i.styles.borderLeftColor = 2779096575,
        i.styles.borderTopWidth = i.styles.borderRightWidth = i.styles.borderBottomWidth = i.styles.borderLeftWidth = 1,
        i.styles.borderTopStyle = i.styles.borderRightStyle = i.styles.borderBottomStyle = i.styles.borderLeftStyle = 1,
        i.styles.backgroundClip = [0],
        i.styles.backgroundOrigin = [0],
        i.bounds = kfe(i.bounds)),
        i.type) {
        case j_:
            i.styles.borderTopRightRadius = i.styles.borderTopLeftRadius = i.styles.borderBottomRightRadius = i.styles.borderBottomLeftRadius = Nfe;
            break;
        case W_:
            i.styles.borderTopRightRadius = i.styles.borderTopLeftRadius = i.styles.borderBottomRightRadius = i.styles.borderBottomLeftRadius = Ofe;
            break
        }
        return i
    }
    return e
}(cl), K8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this
          , s = r.options[r.selectedIndex || 0];
        return i.value = s && s.text || "",
        i
    }
    return e
}(cl), X8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.value = r.value,
        i
    }
    return e
}(cl), Y8 = function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        i.src = r.src,
        i.width = parseInt(r.width, 10) || 0,
        i.height = parseInt(r.height, 10) || 0,
        i.backgroundColor = i.styles.backgroundColor;
        try {
            if (r.contentWindow && r.contentWindow.document && r.contentWindow.document.documentElement) {
                i.tree = Gfe(t, r.contentWindow.document.documentElement);
                var s = r.contentWindow.document.documentElement ? sN(t, getComputedStyle(r.contentWindow.document.documentElement).backgroundColor) : Zg.TRANSPARENT
                  , o = r.contentWindow.document.body ? sN(t, getComputedStyle(r.contentWindow.document.body).backgroundColor) : Zg.TRANSPARENT;
                i.backgroundColor = cd(s) ? cd(o) ? i.styles.backgroundColor : o : s
            }
        } catch {}
        return i
    }
    return e
}(cl), zfe = ["OL", "UL", "MENU"], Rw = function(n, e, t, r) {
    for (var i = e.firstChild, s = void 0; i; i = s)
        if (s = i.nextSibling,
        Wfe(i) && i.data.trim().length > 0)
            t.textNodes.push(new Ffe(n,i,t.styles));
        else if (Z8(i))
            if (nhe(i) && i.assignedNodes)
                i.assignedNodes().forEach(function(a) {
                    return Rw(n, a, t, r)
                });
            else {
                var o = $8(n, i);
                o.styles.isVisible() && (Vfe(i, o, r) ? o.flags |= 4 : jfe(o.styles) && (o.flags |= 2),
                zfe.indexOf(i.tagName) !== -1 && (o.flags |= 8),
                t.elements.push(o),
                i.slot,
                i.shadowRoot ? Rw(n, i.shadowRoot, o, r) : !q8(i) && !J8(i) && !eG(i) && Rw(n, i, o, r))
            }
}, $8 = function(n, e) {
    return ehe(e) ? new G8(n,e) : qfe(e) ? new V8(n,e) : J8(e) ? new j8(n,e) : Yfe(e) ? new W8(n,e) : $fe(e) ? new nT(n,e) : Zfe(e) ? new s2(n,e) : eG(e) ? new K8(n,e) : q8(e) ? new X8(n,e) : the(e) ? new Y8(n,e) : new cl(n,e)
}, Gfe = function(n, e) {
    var t = $8(n, e);
    return t.flags |= 4,
    Rw(n, e, t, t),
    t
}, Vfe = function(n, e, t) {
    return e.styles.isPositionedWithZIndex() || e.styles.opacity < 1 || e.styles.isTransformed() || Jfe(n) && t.styles.isTransparent()
}, jfe = function(n) {
    return n.isPositioned() || n.isFloating()
}, Wfe = function(n) {
    return n.nodeType === Node.TEXT_NODE
}, Z8 = function(n) {
    return n.nodeType === Node.ELEMENT_NODE
}, Kfe = function(n) {
    return Z8(n) && typeof n.style < "u" && !Xfe(n)
}, Xfe = function(n) {
    return typeof n.className == "object"
}, Yfe = function(n) {
    return n.tagName === "LI"
}, $fe = function(n) {
    return n.tagName === "OL"
}, Zfe = function(n) {
    return n.tagName === "INPUT"
}, J8 = function(n) {
    return n.tagName === "svg"
}, Jfe = function(n) {
    return n.tagName === "BODY"
}, qfe = function(n) {
    return n.tagName === "CANVAS"
}, ehe = function(n) {
    return n.tagName === "IMG"
}, the = function(n) {
    return n.tagName === "IFRAME"
}, q8 = function(n) {
    return n.tagName === "TEXTAREA"
}, eG = function(n) {
    return n.tagName === "SELECT"
}, nhe = function(n) {
    return n.tagName === "SLOT"
}, BN = {
    integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
}, MN = {
    integers: [9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ["Ք", "Փ", "Ւ", "Ց", "Ր", "Տ", "Վ", "Ս", "Ռ", "Ջ", "Պ", "Չ", "Ո", "Շ", "Ն", "Յ", "Մ", "Ճ", "Ղ", "Ձ", "Հ", "Կ", "Ծ", "Խ", "Լ", "Ի", "Ժ", "Թ", "Ը", "Է", "Զ", "Ե", "Դ", "Գ", "Բ", "Ա"]
}, rhe = {
    integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ["י׳", "ט׳", "ח׳", "ז׳", "ו׳", "ה׳", "ד׳", "ג׳", "ב׳", "א׳", "ת", "ש", "ר", "ק", "צ", "פ", "ע", "ס", "נ", "מ", "ל", "כ", "יט", "יח", "יז", "טז", "טו", "י", "ט", "ח", "ז", "ו", "ה", "ד", "ג", "ב", "א"]
}, ihe = {
    integers: [1e4, 9e3, 8e3, 7e3, 6e3, 5e3, 4e3, 3e3, 2e3, 1e3, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ["ჵ", "ჰ", "ჯ", "ჴ", "ხ", "ჭ", "წ", "ძ", "ც", "ჩ", "შ", "ყ", "ღ", "ქ", "ფ", "ჳ", "ტ", "ს", "რ", "ჟ", "პ", "ო", "ჲ", "ნ", "მ", "ლ", "კ", "ი", "თ", "ჱ", "ზ", "ვ", "ე", "დ", "გ", "ბ", "ა"]
}, If = function(n, e, t, r, i, s) {
    return n < e || n > t ? o2(n, i, s.length > 0) : r.integers.reduce(function(o, a, l) {
        for (; n >= a; )
            n -= a,
            o += r.values[l];
        return o
    }, "") + s
}, tG = function(n, e, t, r) {
    var i = "";
    do
        t || n--,
        i = r(n) + i,
        n /= e;
    while (n * e >= e);
    return i
}, lr = function(n, e, t, r, i) {
    var s = t - e + 1;
    return (n < 0 ? "-" : "") + (tG(Math.abs(n), s, r, function(o) {
        return Ar(Math.floor(o % s) + e)
    }) + i)
}, WA = function(n, e, t) {
    t === void 0 && (t = ". ");
    var r = e.length;
    return tG(Math.abs(n), r, !1, function(i) {
        return e[Math.floor(i % r)]
    }) + t
}, Xf = 1, Pc = 2, Lc = 4, Im = 8, yl = function(n, e, t, r, i, s) {
    if (n < -9999 || n > 9999)
        return o2(n, 4, i.length > 0);
    var o = Math.abs(n)
      , a = i;
    if (o === 0)
        return e[0] + a;
    for (var l = 0; o > 0 && l <= 4; l++) {
        var c = o % 10;
        c === 0 && Pr(s, Xf) && a !== "" ? a = e[c] + a : c > 1 || c === 1 && l === 0 || c === 1 && l === 1 && Pr(s, Pc) || c === 1 && l === 1 && Pr(s, Lc) && n > 100 || c === 1 && l > 1 && Pr(s, Im) ? a = e[c] + (l > 0 ? t[l - 1] : "") + a : c === 1 && l > 0 && (a = t[l - 1] + a),
        o = Math.floor(o / 10)
    }
    return (n < 0 ? r : "") + a
}, SN = "十百千萬", CN = "拾佰仟萬", TN = "マイナス", IB = "마이너스", o2 = function(n, e, t) {
    var r = t ? ". " : ""
      , i = t ? "、" : ""
      , s = t ? ", " : ""
      , o = t ? " " : "";
    switch (e) {
    case 0:
        return "•" + o;
    case 1:
        return "◦" + o;
    case 2:
        return "◾" + o;
    case 5:
        var a = lr(n, 48, 57, !0, r);
        return a.length < 4 ? "0" + a : a;
    case 4:
        return WA(n, "〇一二三四五六七八九", i);
    case 6:
        return If(n, 1, 3999, BN, 3, r).toLowerCase();
    case 7:
        return If(n, 1, 3999, BN, 3, r);
    case 8:
        return lr(n, 945, 969, !1, r);
    case 9:
        return lr(n, 97, 122, !1, r);
    case 10:
        return lr(n, 65, 90, !1, r);
    case 11:
        return lr(n, 1632, 1641, !0, r);
    case 12:
    case 49:
        return If(n, 1, 9999, MN, 3, r);
    case 35:
        return If(n, 1, 9999, MN, 3, r).toLowerCase();
    case 13:
        return lr(n, 2534, 2543, !0, r);
    case 14:
    case 30:
        return lr(n, 6112, 6121, !0, r);
    case 15:
        return WA(n, "子丑寅卯辰巳午未申酉戌亥", i);
    case 16:
        return WA(n, "甲乙丙丁戊己庚辛壬癸", i);
    case 17:
    case 48:
        return yl(n, "零一二三四五六七八九", SN, "負", i, Pc | Lc | Im);
    case 47:
        return yl(n, "零壹貳參肆伍陸柒捌玖", CN, "負", i, Xf | Pc | Lc | Im);
    case 42:
        return yl(n, "零一二三四五六七八九", SN, "负", i, Pc | Lc | Im);
    case 41:
        return yl(n, "零壹贰叁肆伍陆柒捌玖", CN, "负", i, Xf | Pc | Lc | Im);
    case 26:
        return yl(n, "〇一二三四五六七八九", "十百千万", TN, i, 0);
    case 25:
        return yl(n, "零壱弐参四伍六七八九", "拾百千万", TN, i, Xf | Pc | Lc);
    case 31:
        return yl(n, "영일이삼사오육칠팔구", "십백천만", IB, s, Xf | Pc | Lc);
    case 33:
        return yl(n, "零一二三四五六七八九", "十百千萬", IB, s, 0);
    case 32:
        return yl(n, "零壹貳參四五六七八九", "拾百千", IB, s, Xf | Pc | Lc);
    case 18:
        return lr(n, 2406, 2415, !0, r);
    case 20:
        return If(n, 1, 19999, ihe, 3, r);
    case 21:
        return lr(n, 2790, 2799, !0, r);
    case 22:
        return lr(n, 2662, 2671, !0, r);
    case 22:
        return If(n, 1, 10999, rhe, 3, r);
    case 23:
        return WA(n, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
    case 24:
        return WA(n, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
    case 27:
        return lr(n, 3302, 3311, !0, r);
    case 28:
        return WA(n, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", i);
    case 29:
        return WA(n, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", i);
    case 34:
        return lr(n, 3792, 3801, !0, r);
    case 37:
        return lr(n, 6160, 6169, !0, r);
    case 38:
        return lr(n, 4160, 4169, !0, r);
    case 39:
        return lr(n, 2918, 2927, !0, r);
    case 40:
        return lr(n, 1776, 1785, !0, r);
    case 43:
        return lr(n, 3046, 3055, !0, r);
    case 44:
        return lr(n, 3174, 3183, !0, r);
    case 45:
        return lr(n, 3664, 3673, !0, r);
    case 46:
        return lr(n, 3872, 3881, !0, r);
    case 3:
    default:
        return lr(n, 48, 57, !0, r)
    }
}, IN;
(function(n) {
    n[n.BEFORE = 0] = "BEFORE",
    n[n.AFTER = 1] = "AFTER"
}
)(IN || (IN = {}));
var she = function() {
    function n() {}
    return n.getOrigin = function(e) {
        var t = n._link;
        return t ? (t.href = e,
        t.href = t.href,
        t.protocol + t.hostname + t.port) : "about:blank"
    }
    ,
    n.isSameOrigin = function(e) {
        return n.getOrigin(e) === n._origin
    }
    ,
    n.setContext = function(e) {
        n._link = e.document.createElement("a"),
        n._origin = n.getOrigin(e.location.href)
    }
    ,
    n._origin = "about:blank",
    n
}(), Ye = function() {
    function n(e, t) {
        this.type = 0,
        this.x = e,
        this.y = t
    }
    return n.prototype.add = function(e, t) {
        return new n(this.x + e,this.y + t)
    }
    ,
    n
}(), Rf = function(n, e, t) {
    return new Ye(n.x + (e.x - n.x) * t,n.y + (e.y - n.y) * t)
}, fy = function() {
    function n(e, t, r, i) {
        this.type = 1,
        this.start = e,
        this.startControl = t,
        this.endControl = r,
        this.end = i
    }
    return n.prototype.subdivide = function(e, t) {
        var r = Rf(this.start, this.startControl, e)
          , i = Rf(this.startControl, this.endControl, e)
          , s = Rf(this.endControl, this.end, e)
          , o = Rf(r, i, e)
          , a = Rf(i, s, e)
          , l = Rf(o, a, e);
        return t ? new n(this.start,r,o,l) : new n(l,a,s,this.end)
    }
    ,
    n.prototype.add = function(e, t) {
        return new n(this.start.add(e, t),this.startControl.add(e, t),this.endControl.add(e, t),this.end.add(e, t))
    }
    ,
    n.prototype.reverse = function() {
        return new n(this.end,this.endControl,this.startControl,this.start)
    }
    ,
    n
}(), oo = function(n) {
    return n.type === 1
}, ohe = function() {
    function n(e) {
        var t = e.styles
          , r = e.bounds
          , i = Cm(t.borderTopLeftRadius, r.width, r.height)
          , s = i[0]
          , o = i[1]
          , a = Cm(t.borderTopRightRadius, r.width, r.height)
          , l = a[0]
          , c = a[1]
          , A = Cm(t.borderBottomRightRadius, r.width, r.height)
          , u = A[0]
          , f = A[1]
          , h = Cm(t.borderBottomLeftRadius, r.width, r.height)
          , d = h[0]
          , m = h[1]
          , g = [];
        g.push((s + l) / r.width),
        g.push((d + u) / r.width),
        g.push((o + m) / r.height),
        g.push((c + f) / r.height);
        var p = Math.max.apply(Math, g);
        p > 1 && (s /= p,
        o /= p,
        l /= p,
        c /= p,
        u /= p,
        f /= p,
        d /= p,
        m /= p);
        var v = r.width - l
          , w = r.height - f
          , _ = r.width - u
          , x = r.height - m
          , b = t.borderTopWidth
          , B = t.borderRightWidth
          , S = t.borderBottomWidth
          , I = t.borderLeftWidth
          , M = bn(t.paddingTop, e.bounds.width)
          , L = bn(t.paddingRight, e.bounds.width)
          , D = bn(t.paddingBottom, e.bounds.width)
          , T = bn(t.paddingLeft, e.bounds.width);
        this.topLeftBorderDoubleOuterBox = s > 0 || o > 0 ? Ln(r.left + I / 3, r.top + b / 3, s - I / 3, o - b / 3, ln.TOP_LEFT) : new Ye(r.left + I / 3,r.top + b / 3),
        this.topRightBorderDoubleOuterBox = s > 0 || o > 0 ? Ln(r.left + v, r.top + b / 3, l - B / 3, c - b / 3, ln.TOP_RIGHT) : new Ye(r.left + r.width - B / 3,r.top + b / 3),
        this.bottomRightBorderDoubleOuterBox = u > 0 || f > 0 ? Ln(r.left + _, r.top + w, u - B / 3, f - S / 3, ln.BOTTOM_RIGHT) : new Ye(r.left + r.width - B / 3,r.top + r.height - S / 3),
        this.bottomLeftBorderDoubleOuterBox = d > 0 || m > 0 ? Ln(r.left + I / 3, r.top + x, d - I / 3, m - S / 3, ln.BOTTOM_LEFT) : new Ye(r.left + I / 3,r.top + r.height - S / 3),
        this.topLeftBorderDoubleInnerBox = s > 0 || o > 0 ? Ln(r.left + I * 2 / 3, r.top + b * 2 / 3, s - I * 2 / 3, o - b * 2 / 3, ln.TOP_LEFT) : new Ye(r.left + I * 2 / 3,r.top + b * 2 / 3),
        this.topRightBorderDoubleInnerBox = s > 0 || o > 0 ? Ln(r.left + v, r.top + b * 2 / 3, l - B * 2 / 3, c - b * 2 / 3, ln.TOP_RIGHT) : new Ye(r.left + r.width - B * 2 / 3,r.top + b * 2 / 3),
        this.bottomRightBorderDoubleInnerBox = u > 0 || f > 0 ? Ln(r.left + _, r.top + w, u - B * 2 / 3, f - S * 2 / 3, ln.BOTTOM_RIGHT) : new Ye(r.left + r.width - B * 2 / 3,r.top + r.height - S * 2 / 3),
        this.bottomLeftBorderDoubleInnerBox = d > 0 || m > 0 ? Ln(r.left + I * 2 / 3, r.top + x, d - I * 2 / 3, m - S * 2 / 3, ln.BOTTOM_LEFT) : new Ye(r.left + I * 2 / 3,r.top + r.height - S * 2 / 3),
        this.topLeftBorderStroke = s > 0 || o > 0 ? Ln(r.left + I / 2, r.top + b / 2, s - I / 2, o - b / 2, ln.TOP_LEFT) : new Ye(r.left + I / 2,r.top + b / 2),
        this.topRightBorderStroke = s > 0 || o > 0 ? Ln(r.left + v, r.top + b / 2, l - B / 2, c - b / 2, ln.TOP_RIGHT) : new Ye(r.left + r.width - B / 2,r.top + b / 2),
        this.bottomRightBorderStroke = u > 0 || f > 0 ? Ln(r.left + _, r.top + w, u - B / 2, f - S / 2, ln.BOTTOM_RIGHT) : new Ye(r.left + r.width - B / 2,r.top + r.height - S / 2),
        this.bottomLeftBorderStroke = d > 0 || m > 0 ? Ln(r.left + I / 2, r.top + x, d - I / 2, m - S / 2, ln.BOTTOM_LEFT) : new Ye(r.left + I / 2,r.top + r.height - S / 2),
        this.topLeftBorderBox = s > 0 || o > 0 ? Ln(r.left, r.top, s, o, ln.TOP_LEFT) : new Ye(r.left,r.top),
        this.topRightBorderBox = l > 0 || c > 0 ? Ln(r.left + v, r.top, l, c, ln.TOP_RIGHT) : new Ye(r.left + r.width,r.top),
        this.bottomRightBorderBox = u > 0 || f > 0 ? Ln(r.left + _, r.top + w, u, f, ln.BOTTOM_RIGHT) : new Ye(r.left + r.width,r.top + r.height),
        this.bottomLeftBorderBox = d > 0 || m > 0 ? Ln(r.left, r.top + x, d, m, ln.BOTTOM_LEFT) : new Ye(r.left,r.top + r.height),
        this.topLeftPaddingBox = s > 0 || o > 0 ? Ln(r.left + I, r.top + b, Math.max(0, s - I), Math.max(0, o - b), ln.TOP_LEFT) : new Ye(r.left + I,r.top + b),
        this.topRightPaddingBox = l > 0 || c > 0 ? Ln(r.left + Math.min(v, r.width - B), r.top + b, v > r.width + B ? 0 : Math.max(0, l - B), Math.max(0, c - b), ln.TOP_RIGHT) : new Ye(r.left + r.width - B,r.top + b),
        this.bottomRightPaddingBox = u > 0 || f > 0 ? Ln(r.left + Math.min(_, r.width - I), r.top + Math.min(w, r.height - S), Math.max(0, u - B), Math.max(0, f - S), ln.BOTTOM_RIGHT) : new Ye(r.left + r.width - B,r.top + r.height - S),
        this.bottomLeftPaddingBox = d > 0 || m > 0 ? Ln(r.left + I, r.top + Math.min(x, r.height - S), Math.max(0, d - I), Math.max(0, m - S), ln.BOTTOM_LEFT) : new Ye(r.left + I,r.top + r.height - S),
        this.topLeftContentBox = s > 0 || o > 0 ? Ln(r.left + I + T, r.top + b + M, Math.max(0, s - (I + T)), Math.max(0, o - (b + M)), ln.TOP_LEFT) : new Ye(r.left + I + T,r.top + b + M),
        this.topRightContentBox = l > 0 || c > 0 ? Ln(r.left + Math.min(v, r.width + I + T), r.top + b + M, v > r.width + I + T ? 0 : l - I + T, c - (b + M), ln.TOP_RIGHT) : new Ye(r.left + r.width - (B + L),r.top + b + M),
        this.bottomRightContentBox = u > 0 || f > 0 ? Ln(r.left + Math.min(_, r.width - (I + T)), r.top + Math.min(w, r.height + b + M), Math.max(0, u - (B + L)), f - (S + D), ln.BOTTOM_RIGHT) : new Ye(r.left + r.width - (B + L),r.top + r.height - (S + D)),
        this.bottomLeftContentBox = d > 0 || m > 0 ? Ln(r.left + I + T, r.top + x, Math.max(0, d - (I + T)), m - (S + D), ln.BOTTOM_LEFT) : new Ye(r.left + I + T,r.top + r.height - (S + D))
    }
    return n
}(), ln;
(function(n) {
    n[n.TOP_LEFT = 0] = "TOP_LEFT",
    n[n.TOP_RIGHT = 1] = "TOP_RIGHT",
    n[n.BOTTOM_RIGHT = 2] = "BOTTOM_RIGHT",
    n[n.BOTTOM_LEFT = 3] = "BOTTOM_LEFT"
}
)(ln || (ln = {}));
var Ln = function(n, e, t, r, i) {
    var s = 4 * ((Math.sqrt(2) - 1) / 3)
      , o = t * s
      , a = r * s
      , l = n + t
      , c = e + r;
    switch (i) {
    case ln.TOP_LEFT:
        return new fy(new Ye(n,c),new Ye(n,c - a),new Ye(l - o,e),new Ye(l,e));
    case ln.TOP_RIGHT:
        return new fy(new Ye(n,e),new Ye(n + o,e),new Ye(l,c - a),new Ye(l,c));
    case ln.BOTTOM_RIGHT:
        return new fy(new Ye(l,e),new Ye(l,e + a),new Ye(n + o,c),new Ye(n,c));
    case ln.BOTTOM_LEFT:
    default:
        return new fy(new Ye(l,c),new Ye(l - o,c),new Ye(n,e + a),new Ye(n,e))
    }
}
  , K_ = function(n) {
    return [n.topLeftBorderBox, n.topRightBorderBox, n.bottomRightBorderBox, n.bottomLeftBorderBox]
}
  , ahe = function(n) {
    return [n.topLeftContentBox, n.topRightContentBox, n.bottomRightContentBox, n.bottomLeftContentBox]
}
  , X_ = function(n) {
    return [n.topLeftPaddingBox, n.topRightPaddingBox, n.bottomRightPaddingBox, n.bottomLeftPaddingBox]
}
  , lhe = function() {
    function n(e, t, r) {
        this.offsetX = e,
        this.offsetY = t,
        this.matrix = r,
        this.type = 0,
        this.target = 6
    }
    return n
}()
  , hy = function() {
    function n(e, t) {
        this.path = e,
        this.target = t,
        this.type = 1
    }
    return n
}()
  , che = function() {
    function n(e) {
        this.opacity = e,
        this.type = 2,
        this.target = 6
    }
    return n
}()
  , Ahe = function(n) {
    return n.type === 0
}
  , nG = function(n) {
    return n.type === 1
}
  , uhe = function(n) {
    return n.type === 2
}
  , RN = function(n, e) {
    return n.length === e.length ? n.some(function(t, r) {
        return t === e[r]
    }) : !1
}
  , fhe = function(n, e, t, r, i) {
    return n.map(function(s, o) {
        switch (o) {
        case 0:
            return s.add(e, t);
        case 1:
            return s.add(e + r, t);
        case 2:
            return s.add(e + r, t + i);
        case 3:
            return s.add(e, t + i)
        }
        return s
    })
}
  , rG = function() {
    function n(e) {
        this.element = e,
        this.inlineLevel = [],
        this.nonInlineLevel = [],
        this.negativeZIndex = [],
        this.zeroOrAutoZIndexOrTransformedOrOpacity = [],
        this.positiveZIndex = [],
        this.nonPositionedFloats = [],
        this.nonPositionedInlineLevel = []
    }
    return n
}()
  , iG = function() {
    function n(e, t) {
        if (this.container = e,
        this.parent = t,
        this.effects = [],
        this.curves = new ohe(this.container),
        this.container.styles.opacity < 1 && this.effects.push(new che(this.container.styles.opacity)),
        this.container.styles.transform !== null) {
            var r = this.container.bounds.left + this.container.styles.transformOrigin[0].number
              , i = this.container.bounds.top + this.container.styles.transformOrigin[1].number
              , s = this.container.styles.transform;
            this.effects.push(new lhe(r,i,s))
        }
        if (this.container.styles.overflowX !== 0) {
            var o = K_(this.curves)
              , a = X_(this.curves);
            RN(o, a) ? this.effects.push(new hy(o,6)) : (this.effects.push(new hy(o,2)),
            this.effects.push(new hy(a,4)))
        }
    }
    return n.prototype.getEffects = function(e) {
        for (var t = [2, 3].indexOf(this.container.styles.position) === -1, r = this.parent, i = this.effects.slice(0); r; ) {
            var s = r.effects.filter(function(l) {
                return !nG(l)
            });
            if (t || r.container.styles.position !== 0 || !r.parent) {
                if (i.unshift.apply(i, s),
                t = [2, 3].indexOf(r.container.styles.position) === -1,
                r.container.styles.overflowX !== 0) {
                    var o = K_(r.curves)
                      , a = X_(r.curves);
                    RN(o, a) || i.unshift(new hy(a,6))
                }
            } else
                i.unshift.apply(i, s);
            r = r.parent
        }
        return i.filter(function(l) {
            return Pr(l.target, e)
        })
    }
    ,
    n
}()
  , rT = function(n, e, t, r) {
    n.container.elements.forEach(function(i) {
        var s = Pr(i.flags, 4)
          , o = Pr(i.flags, 2)
          , a = new iG(i,n);
        Pr(i.styles.display, 2048) && r.push(a);
        var l = Pr(i.flags, 8) ? [] : r;
        if (s || o) {
            var c = s || i.styles.isPositioned() ? t : e
              , A = new rG(a);
            if (i.styles.isPositioned() || i.styles.opacity < 1 || i.styles.isTransformed()) {
                var u = i.styles.zIndex.order;
                if (u < 0) {
                    var f = 0;
                    c.negativeZIndex.some(function(d, m) {
                        return u > d.element.container.styles.zIndex.order ? (f = m,
                        !1) : f > 0
                    }),
                    c.negativeZIndex.splice(f, 0, A)
                } else if (u > 0) {
                    var h = 0;
                    c.positiveZIndex.some(function(d, m) {
                        return u >= d.element.container.styles.zIndex.order ? (h = m + 1,
                        !1) : h > 0
                    }),
                    c.positiveZIndex.splice(h, 0, A)
                } else
                    c.zeroOrAutoZIndexOrTransformedOrOpacity.push(A)
            } else
                i.styles.isFloating() ? c.nonPositionedFloats.push(A) : c.nonPositionedInlineLevel.push(A);
            rT(a, A, s ? A : t, l)
        } else
            i.styles.isInlineLevel() ? e.inlineLevel.push(a) : e.nonInlineLevel.push(a),
            rT(a, e, t, l);
        Pr(i.flags, 8) && sG(i, l)
    })
}
  , sG = function(n, e) {
    for (var t = n instanceof nT ? n.start : 1, r = n instanceof nT ? n.reversed : !1, i = 0; i < e.length; i++) {
        var s = e[i];
        s.container instanceof W8 && typeof s.container.value == "number" && s.container.value !== 0 && (t = s.container.value),
        s.listValue = o2(t, s.container.styles.listStyleType, !0),
        t += r ? -1 : 1
    }
}
  , hhe = function(n) {
    var e = new iG(n,null)
      , t = new rG(e)
      , r = [];
    return rT(e, t, t, r),
    sG(e.container, r),
    t
}
  , UN = function(n, e) {
    switch (e) {
    case 0:
        return ho(n.topLeftBorderBox, n.topLeftPaddingBox, n.topRightBorderBox, n.topRightPaddingBox);
    case 1:
        return ho(n.topRightBorderBox, n.topRightPaddingBox, n.bottomRightBorderBox, n.bottomRightPaddingBox);
    case 2:
        return ho(n.bottomRightBorderBox, n.bottomRightPaddingBox, n.bottomLeftBorderBox, n.bottomLeftPaddingBox);
    case 3:
    default:
        return ho(n.bottomLeftBorderBox, n.bottomLeftPaddingBox, n.topLeftBorderBox, n.topLeftPaddingBox)
    }
}
  , dhe = function(n, e) {
    switch (e) {
    case 0:
        return ho(n.topLeftBorderBox, n.topLeftBorderDoubleOuterBox, n.topRightBorderBox, n.topRightBorderDoubleOuterBox);
    case 1:
        return ho(n.topRightBorderBox, n.topRightBorderDoubleOuterBox, n.bottomRightBorderBox, n.bottomRightBorderDoubleOuterBox);
    case 2:
        return ho(n.bottomRightBorderBox, n.bottomRightBorderDoubleOuterBox, n.bottomLeftBorderBox, n.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
        return ho(n.bottomLeftBorderBox, n.bottomLeftBorderDoubleOuterBox, n.topLeftBorderBox, n.topLeftBorderDoubleOuterBox)
    }
}
  , phe = function(n, e) {
    switch (e) {
    case 0:
        return ho(n.topLeftBorderDoubleInnerBox, n.topLeftPaddingBox, n.topRightBorderDoubleInnerBox, n.topRightPaddingBox);
    case 1:
        return ho(n.topRightBorderDoubleInnerBox, n.topRightPaddingBox, n.bottomRightBorderDoubleInnerBox, n.bottomRightPaddingBox);
    case 2:
        return ho(n.bottomRightBorderDoubleInnerBox, n.bottomRightPaddingBox, n.bottomLeftBorderDoubleInnerBox, n.bottomLeftPaddingBox);
    case 3:
    default:
        return ho(n.bottomLeftBorderDoubleInnerBox, n.bottomLeftPaddingBox, n.topLeftBorderDoubleInnerBox, n.topLeftPaddingBox)
    }
}
  , mhe = function(n, e) {
    switch (e) {
    case 0:
        return dy(n.topLeftBorderStroke, n.topRightBorderStroke);
    case 1:
        return dy(n.topRightBorderStroke, n.bottomRightBorderStroke);
    case 2:
        return dy(n.bottomRightBorderStroke, n.bottomLeftBorderStroke);
    case 3:
    default:
        return dy(n.bottomLeftBorderStroke, n.topLeftBorderStroke)
    }
}
  , dy = function(n, e) {
    var t = [];
    return oo(n) ? t.push(n.subdivide(.5, !1)) : t.push(n),
    oo(e) ? t.push(e.subdivide(.5, !0)) : t.push(e),
    t
}
  , ho = function(n, e, t, r) {
    var i = [];
    return oo(n) ? i.push(n.subdivide(.5, !1)) : i.push(n),
    oo(t) ? i.push(t.subdivide(.5, !0)) : i.push(t),
    oo(r) ? i.push(r.subdivide(.5, !0).reverse()) : i.push(r),
    oo(e) ? i.push(e.subdivide(.5, !1).reverse()) : i.push(e),
    i
}
  , oG = function(n) {
    var e = n.bounds
      , t = n.styles;
    return e.add(t.borderLeftWidth, t.borderTopWidth, -(t.borderRightWidth + t.borderLeftWidth), -(t.borderTopWidth + t.borderBottomWidth))
}
  , Y_ = function(n) {
    var e = n.styles
      , t = n.bounds
      , r = bn(e.paddingLeft, t.width)
      , i = bn(e.paddingRight, t.width)
      , s = bn(e.paddingTop, t.width)
      , o = bn(e.paddingBottom, t.width);
    return t.add(r + e.borderLeftWidth, s + e.borderTopWidth, -(e.borderRightWidth + e.borderLeftWidth + r + i), -(e.borderTopWidth + e.borderBottomWidth + s + o))
}
  , ghe = function(n, e) {
    return n === 0 ? e.bounds : n === 2 ? Y_(e) : oG(e)
}
  , vhe = function(n, e) {
    return n === 0 ? e.bounds : n === 2 ? Y_(e) : oG(e)
}
  , RB = function(n, e, t) {
    var r = ghe(Yf(n.styles.backgroundOrigin, e), n)
      , i = vhe(Yf(n.styles.backgroundClip, e), n)
      , s = yhe(Yf(n.styles.backgroundSize, e), t, r)
      , o = s[0]
      , a = s[1]
      , l = Cm(Yf(n.styles.backgroundPosition, e), r.width - o, r.height - a)
      , c = whe(Yf(n.styles.backgroundRepeat, e), l, s, r, i)
      , A = Math.round(r.left + l[0])
      , u = Math.round(r.top + l[1]);
    return [c, A, u, o, a]
}
  , Uf = function(n) {
    return sr(n) && n.value === Ad.AUTO
}
  , py = function(n) {
    return typeof n == "number"
}
  , yhe = function(n, e, t) {
    var r = e[0]
      , i = e[1]
      , s = e[2]
      , o = n[0]
      , a = n[1];
    if (!o)
        return [0, 0];
    if (br(o) && a && br(a))
        return [bn(o, t.width), bn(a, t.height)];
    var l = py(s);
    if (sr(o) && (o.value === Ad.CONTAIN || o.value === Ad.COVER)) {
        if (py(s)) {
            var c = t.width / t.height;
            return c < s != (o.value === Ad.COVER) ? [t.width, t.width / s] : [t.height * s, t.height]
        }
        return [t.width, t.height]
    }
    var A = py(r)
      , u = py(i)
      , f = A || u;
    if (Uf(o) && (!a || Uf(a))) {
        if (A && u)
            return [r, i];
        if (!l && !f)
            return [t.width, t.height];
        if (f && l) {
            var h = A ? r : i * s
              , d = u ? i : r / s;
            return [h, d]
        }
        var m = A ? r : t.width
          , g = u ? i : t.height;
        return [m, g]
    }
    if (l) {
        var p = 0
          , v = 0;
        return br(o) ? p = bn(o, t.width) : br(a) && (v = bn(a, t.height)),
        Uf(o) ? p = v * s : (!a || Uf(a)) && (v = p / s),
        [p, v]
    }
    var w = null
      , _ = null;
    if (br(o) ? w = bn(o, t.width) : a && br(a) && (_ = bn(a, t.height)),
    w !== null && (!a || Uf(a)) && (_ = A && u ? w / r * i : t.height),
    _ !== null && Uf(o) && (w = A && u ? _ / i * r : t.width),
    w !== null && _ !== null)
        return [w, _];
    throw new Error("Unable to calculate background-size for element")
}
  , Yf = function(n, e) {
    var t = n[e];
    return typeof t > "u" ? n[0] : t
}
  , whe = function(n, e, t, r, i) {
    var s = e[0]
      , o = e[1]
      , a = t[0]
      , l = t[1];
    switch (n) {
    case 2:
        return [new Ye(Math.round(r.left),Math.round(r.top + o)), new Ye(Math.round(r.left + r.width),Math.round(r.top + o)), new Ye(Math.round(r.left + r.width),Math.round(l + r.top + o)), new Ye(Math.round(r.left),Math.round(l + r.top + o))];
    case 3:
        return [new Ye(Math.round(r.left + s),Math.round(r.top)), new Ye(Math.round(r.left + s + a),Math.round(r.top)), new Ye(Math.round(r.left + s + a),Math.round(r.height + r.top)), new Ye(Math.round(r.left + s),Math.round(r.height + r.top))];
    case 1:
        return [new Ye(Math.round(r.left + s),Math.round(r.top + o)), new Ye(Math.round(r.left + s + a),Math.round(r.top + o)), new Ye(Math.round(r.left + s + a),Math.round(r.top + o + l)), new Ye(Math.round(r.left + s),Math.round(r.top + o + l))];
    default:
        return [new Ye(Math.round(i.left),Math.round(i.top)), new Ye(Math.round(i.left + i.width),Math.round(i.top)), new Ye(Math.round(i.left + i.width),Math.round(i.height + i.top)), new Ye(Math.round(i.left),Math.round(i.height + i.top))]
    }
}
  , _he = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
  , FN = "Hidden Text"
  , xhe = function() {
    function n(e) {
        this._data = {},
        this._document = e
    }
    return n.prototype.parseMetrics = function(e, t) {
        var r = this._document.createElement("div")
          , i = this._document.createElement("img")
          , s = this._document.createElement("span")
          , o = this._document.body;
        r.style.visibility = "hidden",
        r.style.fontFamily = e,
        r.style.fontSize = t,
        r.style.margin = "0",
        r.style.padding = "0",
        r.style.whiteSpace = "nowrap",
        o.appendChild(r),
        i.src = _he,
        i.width = 1,
        i.height = 1,
        i.style.margin = "0",
        i.style.padding = "0",
        i.style.verticalAlign = "baseline",
        s.style.fontFamily = e,
        s.style.fontSize = t,
        s.style.margin = "0",
        s.style.padding = "0",
        s.appendChild(this._document.createTextNode(FN)),
        r.appendChild(s),
        r.appendChild(i);
        var a = i.offsetTop - s.offsetTop + 2;
        r.removeChild(s),
        r.appendChild(this._document.createTextNode(FN)),
        r.style.lineHeight = "normal",
        i.style.verticalAlign = "super";
        var l = i.offsetTop - r.offsetTop + 2;
        return o.removeChild(r),
        {
            baseline: a,
            middle: l
        }
    }
    ,
    n.prototype.getMetrics = function(e, t) {
        var r = e + " " + t;
        return typeof this._data[r] > "u" && (this._data[r] = this.parseMetrics(e, t)),
        this._data[r]
    }
    ,
    n
}()
  , aG = function() {
    function n(e, t) {
        this.context = e,
        this.options = t
    }
    return n
}()
  , bhe = 1e4;
(function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i._activeEffects = [],
        i.canvas = r.canvas ? r.canvas : document.createElement("canvas"),
        i.ctx = i.canvas.getContext("2d"),
        r.canvas || (i.canvas.width = Math.floor(r.width * r.scale),
        i.canvas.height = Math.floor(r.height * r.scale),
        i.canvas.style.width = r.width + "px",
        i.canvas.style.height = r.height + "px"),
        i.fontMetrics = new xhe(document),
        i.ctx.scale(i.options.scale, i.options.scale),
        i.ctx.translate(-r.x, -r.y),
        i.ctx.textBaseline = "bottom",
        i._activeEffects = [],
        i.context.logger.debug("Canvas renderer initialized (" + r.width + "x" + r.height + ") with scale " + r.scale),
        i
    }
    return e.prototype.applyEffects = function(t) {
        for (var r = this; this._activeEffects.length; )
            this.popEffect();
        t.forEach(function(i) {
            return r.applyEffect(i)
        })
    }
    ,
    e.prototype.applyEffect = function(t) {
        this.ctx.save(),
        uhe(t) && (this.ctx.globalAlpha = t.opacity),
        Ahe(t) && (this.ctx.translate(t.offsetX, t.offsetY),
        this.ctx.transform(t.matrix[0], t.matrix[1], t.matrix[2], t.matrix[3], t.matrix[4], t.matrix[5]),
        this.ctx.translate(-t.offsetX, -t.offsetY)),
        nG(t) && (this.path(t.path),
        this.ctx.clip()),
        this._activeEffects.push(t)
    }
    ,
    e.prototype.popEffect = function() {
        this._activeEffects.pop(),
        this.ctx.restore()
    }
    ,
    e.prototype.renderStack = function(t) {
        return qs(this, void 0, void 0, function() {
            var r;
            return gs(this, function(i) {
                switch (i.label) {
                case 0:
                    return r = t.element.container.styles,
                    r.isVisible() ? [4, this.renderStackContent(t)] : [3, 2];
                case 1:
                    i.sent(),
                    i.label = 2;
                case 2:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.renderNode = function(t) {
        return qs(this, void 0, void 0, function() {
            return gs(this, function(r) {
                switch (r.label) {
                case 0:
                    if (Pr(t.container.flags, 16))
                        debugger ;return t.container.styles.isVisible() ? [4, this.renderNodeBackgroundAndBorders(t)] : [3, 3];
                case 1:
                    return r.sent(),
                    [4, this.renderNodeContent(t)];
                case 2:
                    r.sent(),
                    r.label = 3;
                case 3:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.renderTextWithLetterSpacing = function(t, r, i) {
        var s = this;
        if (r === 0)
            this.ctx.fillText(t.text, t.bounds.left, t.bounds.top + i);
        else {
            var o = i2(t.text);
            o.reduce(function(a, l) {
                return s.ctx.fillText(l, a, t.bounds.top + i),
                a + s.ctx.measureText(l).width
            }, t.bounds.left)
        }
    }
    ,
    e.prototype.createFontStyle = function(t) {
        var r = t.fontVariant.filter(function(o) {
            return o === "normal" || o === "small-caps"
        }).join("")
          , i = Che(t.fontFamily).join(", ")
          , s = E0(t.fontSize) ? "" + t.fontSize.number + t.fontSize.unit : t.fontSize.number + "px";
        return [[t.fontStyle, r, t.fontWeight, s, i].join(" "), i, s]
    }
    ,
    e.prototype.renderTextNode = function(t, r) {
        return qs(this, void 0, void 0, function() {
            var i, s, o, a, l, c, A, u, f = this;
            return gs(this, function(h) {
                return i = this.createFontStyle(r),
                s = i[0],
                o = i[1],
                a = i[2],
                this.ctx.font = s,
                this.ctx.direction = r.direction === 1 ? "rtl" : "ltr",
                this.ctx.textAlign = "left",
                this.ctx.textBaseline = "alphabetic",
                l = this.fontMetrics.getMetrics(o, a),
                c = l.baseline,
                A = l.middle,
                u = r.paintOrder,
                t.textBounds.forEach(function(d) {
                    u.forEach(function(m) {
                        switch (m) {
                        case 0:
                            f.ctx.fillStyle = Hr(r.color),
                            f.renderTextWithLetterSpacing(d, r.letterSpacing, c);
                            var g = r.textShadow;
                            g.length && d.text.trim().length && (g.slice(0).reverse().forEach(function(p) {
                                f.ctx.shadowColor = Hr(p.color),
                                f.ctx.shadowOffsetX = p.offsetX.number * f.options.scale,
                                f.ctx.shadowOffsetY = p.offsetY.number * f.options.scale,
                                f.ctx.shadowBlur = p.blur.number,
                                f.renderTextWithLetterSpacing(d, r.letterSpacing, c)
                            }),
                            f.ctx.shadowColor = "",
                            f.ctx.shadowOffsetX = 0,
                            f.ctx.shadowOffsetY = 0,
                            f.ctx.shadowBlur = 0),
                            r.textDecorationLine.length && (f.ctx.fillStyle = Hr(r.textDecorationColor || r.color),
                            r.textDecorationLine.forEach(function(p) {
                                switch (p) {
                                case 1:
                                    f.ctx.fillRect(d.bounds.left, Math.round(d.bounds.top + c), d.bounds.width, 1);
                                    break;
                                case 2:
                                    f.ctx.fillRect(d.bounds.left, Math.round(d.bounds.top), d.bounds.width, 1);
                                    break;
                                case 3:
                                    f.ctx.fillRect(d.bounds.left, Math.ceil(d.bounds.top + A), d.bounds.width, 1);
                                    break
                                }
                            }));
                            break;
                        case 1:
                            r.webkitTextStrokeWidth && d.text.trim().length && (f.ctx.strokeStyle = Hr(r.webkitTextStrokeColor),
                            f.ctx.lineWidth = r.webkitTextStrokeWidth,
                            f.ctx.lineJoin = window.chrome ? "miter" : "round",
                            f.ctx.strokeText(d.text, d.bounds.left, d.bounds.top + c)),
                            f.ctx.strokeStyle = "",
                            f.ctx.lineWidth = 0,
                            f.ctx.lineJoin = "miter";
                            break
                        }
                    })
                }),
                [2]
            })
        })
    }
    ,
    e.prototype.renderReplacedElement = function(t, r, i) {
        if (i && t.intrinsicWidth > 0 && t.intrinsicHeight > 0) {
            var s = Y_(t)
              , o = X_(r);
            this.path(o),
            this.ctx.save(),
            this.ctx.clip(),
            this.ctx.drawImage(i, 0, 0, t.intrinsicWidth, t.intrinsicHeight, s.left, s.top, s.width, s.height),
            this.ctx.restore()
        }
    }
    ,
    e.prototype.renderNodeContent = function(t) {
        return qs(this, void 0, void 0, function() {
            var r, i, s, o, a, l, v, v, c, A, u, f, _, h, d, x, m, g, p, v, w, _, x;
            return gs(this, function(b) {
                switch (b.label) {
                case 0:
                    this.applyEffects(t.getEffects(4)),
                    r = t.container,
                    i = t.curves,
                    s = r.styles,
                    o = 0,
                    a = r.textNodes,
                    b.label = 1;
                case 1:
                    return o < a.length ? (l = a[o],
                    [4, this.renderTextNode(l, s)]) : [3, 4];
                case 2:
                    b.sent(),
                    b.label = 3;
                case 3:
                    return o++,
                    [3, 1];
                case 4:
                    if (!(r instanceof G8))
                        return [3, 8];
                    b.label = 5;
                case 5:
                    return b.trys.push([5, 7, , 8]),
                    [4, this.context.cache.match(r.src)];
                case 6:
                    return v = b.sent(),
                    this.renderReplacedElement(r, i, v),
                    [3, 8];
                case 7:
                    return b.sent(),
                    this.context.logger.error("Error loading image " + r.src),
                    [3, 8];
                case 8:
                    if (r instanceof V8 && this.renderReplacedElement(r, i, r.canvas),
                    !(r instanceof j8))
                        return [3, 12];
                    b.label = 9;
                case 9:
                    return b.trys.push([9, 11, , 12]),
                    [4, this.context.cache.match(r.svg)];
                case 10:
                    return v = b.sent(),
                    this.renderReplacedElement(r, i, v),
                    [3, 12];
                case 11:
                    return b.sent(),
                    this.context.logger.error("Error loading svg " + r.svg.substring(0, 255)),
                    [3, 12];
                case 12:
                    return r instanceof Y8 && r.tree ? (c = new e(this.context,{
                        scale: this.options.scale,
                        backgroundColor: r.backgroundColor,
                        x: 0,
                        y: 0,
                        width: r.width,
                        height: r.height
                    }),
                    [4, c.render(r.tree)]) : [3, 14];
                case 13:
                    A = b.sent(),
                    r.width && r.height && this.ctx.drawImage(A, 0, 0, r.width, r.height, r.bounds.left, r.bounds.top, r.bounds.width, r.bounds.height),
                    b.label = 14;
                case 14:
                    if (r instanceof s2 && (u = Math.min(r.bounds.width, r.bounds.height),
                    r.type === j_ ? r.checked && (this.ctx.save(),
                    this.path([new Ye(r.bounds.left + u * .39363,r.bounds.top + u * .79), new Ye(r.bounds.left + u * .16,r.bounds.top + u * .5549), new Ye(r.bounds.left + u * .27347,r.bounds.top + u * .44071), new Ye(r.bounds.left + u * .39694,r.bounds.top + u * .5649), new Ye(r.bounds.left + u * .72983,r.bounds.top + u * .23), new Ye(r.bounds.left + u * .84,r.bounds.top + u * .34085), new Ye(r.bounds.left + u * .39363,r.bounds.top + u * .79)]),
                    this.ctx.fillStyle = Hr(EN),
                    this.ctx.fill(),
                    this.ctx.restore()) : r.type === W_ && r.checked && (this.ctx.save(),
                    this.ctx.beginPath(),
                    this.ctx.arc(r.bounds.left + u / 2, r.bounds.top + u / 2, u / 4, 0, Math.PI * 2, !0),
                    this.ctx.fillStyle = Hr(EN),
                    this.ctx.fill(),
                    this.ctx.restore())),
                    Ehe(r) && r.value.length) {
                        switch (f = this.createFontStyle(s),
                        _ = f[0],
                        h = f[1],
                        d = this.fontMetrics.getMetrics(_, h).baseline,
                        this.ctx.font = _,
                        this.ctx.fillStyle = Hr(s.color),
                        this.ctx.textBaseline = "alphabetic",
                        this.ctx.textAlign = Mhe(r.styles.textAlign),
                        x = Y_(r),
                        m = 0,
                        r.styles.textAlign) {
                        case 1:
                            m += x.width / 2;
                            break;
                        case 2:
                            m += x.width;
                            break
                        }
                        g = x.add(m, 0, 0, -x.height / 2 + 1),
                        this.ctx.save(),
                        this.path([new Ye(x.left,x.top), new Ye(x.left + x.width,x.top), new Ye(x.left + x.width,x.top + x.height), new Ye(x.left,x.top + x.height)]),
                        this.ctx.clip(),
                        this.renderTextWithLetterSpacing(new sg(r.value,g), s.letterSpacing, d),
                        this.ctx.restore(),
                        this.ctx.textBaseline = "alphabetic",
                        this.ctx.textAlign = "left"
                    }
                    if (!Pr(r.styles.display, 2048))
                        return [3, 20];
                    if (r.styles.listStyleImage === null)
                        return [3, 19];
                    if (p = r.styles.listStyleImage,
                    p.type !== 0)
                        return [3, 18];
                    v = void 0,
                    w = p.url,
                    b.label = 15;
                case 15:
                    return b.trys.push([15, 17, , 18]),
                    [4, this.context.cache.match(w)];
                case 16:
                    return v = b.sent(),
                    this.ctx.drawImage(v, r.bounds.left - (v.width + 10), r.bounds.top),
                    [3, 18];
                case 17:
                    return b.sent(),
                    this.context.logger.error("Error loading list-style-image " + w),
                    [3, 18];
                case 18:
                    return [3, 20];
                case 19:
                    t.listValue && r.styles.listStyleType !== -1 && (_ = this.createFontStyle(s)[0],
                    this.ctx.font = _,
                    this.ctx.fillStyle = Hr(s.color),
                    this.ctx.textBaseline = "middle",
                    this.ctx.textAlign = "right",
                    x = new Qu(r.bounds.left,r.bounds.top + bn(r.styles.paddingTop, r.bounds.width),r.bounds.width,lN(s.lineHeight, s.fontSize.number) / 2 + 1),
                    this.renderTextWithLetterSpacing(new sg(t.listValue,x), s.letterSpacing, lN(s.lineHeight, s.fontSize.number) / 2 + 2),
                    this.ctx.textBaseline = "bottom",
                    this.ctx.textAlign = "left"),
                    b.label = 20;
                case 20:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.renderStackContent = function(t) {
        return qs(this, void 0, void 0, function() {
            var r, i, p, s, o, p, a, l, p, c, A, p, u, f, p, h, d, p, m, g, p;
            return gs(this, function(v) {
                switch (v.label) {
                case 0:
                    if (Pr(t.element.container.flags, 16))
                        debugger ;return [4, this.renderNodeBackgroundAndBorders(t.element)];
                case 1:
                    v.sent(),
                    r = 0,
                    i = t.negativeZIndex,
                    v.label = 2;
                case 2:
                    return r < i.length ? (p = i[r],
                    [4, this.renderStack(p)]) : [3, 5];
                case 3:
                    v.sent(),
                    v.label = 4;
                case 4:
                    return r++,
                    [3, 2];
                case 5:
                    return [4, this.renderNodeContent(t.element)];
                case 6:
                    v.sent(),
                    s = 0,
                    o = t.nonInlineLevel,
                    v.label = 7;
                case 7:
                    return s < o.length ? (p = o[s],
                    [4, this.renderNode(p)]) : [3, 10];
                case 8:
                    v.sent(),
                    v.label = 9;
                case 9:
                    return s++,
                    [3, 7];
                case 10:
                    a = 0,
                    l = t.nonPositionedFloats,
                    v.label = 11;
                case 11:
                    return a < l.length ? (p = l[a],
                    [4, this.renderStack(p)]) : [3, 14];
                case 12:
                    v.sent(),
                    v.label = 13;
                case 13:
                    return a++,
                    [3, 11];
                case 14:
                    c = 0,
                    A = t.nonPositionedInlineLevel,
                    v.label = 15;
                case 15:
                    return c < A.length ? (p = A[c],
                    [4, this.renderStack(p)]) : [3, 18];
                case 16:
                    v.sent(),
                    v.label = 17;
                case 17:
                    return c++,
                    [3, 15];
                case 18:
                    u = 0,
                    f = t.inlineLevel,
                    v.label = 19;
                case 19:
                    return u < f.length ? (p = f[u],
                    [4, this.renderNode(p)]) : [3, 22];
                case 20:
                    v.sent(),
                    v.label = 21;
                case 21:
                    return u++,
                    [3, 19];
                case 22:
                    h = 0,
                    d = t.zeroOrAutoZIndexOrTransformedOrOpacity,
                    v.label = 23;
                case 23:
                    return h < d.length ? (p = d[h],
                    [4, this.renderStack(p)]) : [3, 26];
                case 24:
                    v.sent(),
                    v.label = 25;
                case 25:
                    return h++,
                    [3, 23];
                case 26:
                    m = 0,
                    g = t.positiveZIndex,
                    v.label = 27;
                case 27:
                    return m < g.length ? (p = g[m],
                    [4, this.renderStack(p)]) : [3, 30];
                case 28:
                    v.sent(),
                    v.label = 29;
                case 29:
                    return m++,
                    [3, 27];
                case 30:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.mask = function(t) {
        this.ctx.beginPath(),
        this.ctx.moveTo(0, 0),
        this.ctx.lineTo(this.canvas.width, 0),
        this.ctx.lineTo(this.canvas.width, this.canvas.height),
        this.ctx.lineTo(0, this.canvas.height),
        this.ctx.lineTo(0, 0),
        this.formatPath(t.slice(0).reverse()),
        this.ctx.closePath()
    }
    ,
    e.prototype.path = function(t) {
        this.ctx.beginPath(),
        this.formatPath(t),
        this.ctx.closePath()
    }
    ,
    e.prototype.formatPath = function(t) {
        var r = this;
        t.forEach(function(i, s) {
            var o = oo(i) ? i.start : i;
            s === 0 ? r.ctx.moveTo(o.x, o.y) : r.ctx.lineTo(o.x, o.y),
            oo(i) && r.ctx.bezierCurveTo(i.startControl.x, i.startControl.y, i.endControl.x, i.endControl.y, i.end.x, i.end.y)
        })
    }
    ,
    e.prototype.renderRepeat = function(t, r, i, s) {
        this.path(t),
        this.ctx.fillStyle = r,
        this.ctx.translate(i, s),
        this.ctx.fill(),
        this.ctx.translate(-i, -s)
    }
    ,
    e.prototype.resizeImage = function(t, r, i) {
        var s;
        if (t.width === r && t.height === i)
            return t;
        var o = (s = this.canvas.ownerDocument) !== null && s !== void 0 ? s : document
          , a = o.createElement("canvas");
        a.width = Math.max(1, r),
        a.height = Math.max(1, i);
        var l = a.getContext("2d");
        return l.drawImage(t, 0, 0, t.width, t.height, 0, 0, r, i),
        a
    }
    ,
    e.prototype.renderBackgroundImage = function(t) {
        return qs(this, void 0, void 0, function() {
            var r, i, s, o, a, l;
            return gs(this, function(c) {
                switch (c.label) {
                case 0:
                    r = t.styles.backgroundImage.length - 1,
                    i = function(A) {
                        var u, f, h, M, R, F, T, y, S, d, M, R, F, T, y, m, g, p, v, w, _, x, b, B, S, I, M, L, D, T, y, E, R, F, O, z, j, Q, C, W, ee, P;
                        return gs(this, function(re) {
                            switch (re.label) {
                            case 0:
                                if (A.type !== 0)
                                    return [3, 5];
                                u = void 0,
                                f = A.url,
                                re.label = 1;
                            case 1:
                                return re.trys.push([1, 3, , 4]),
                                [4, s.context.cache.match(f)];
                            case 2:
                                return u = re.sent(),
                                [3, 4];
                            case 3:
                                return re.sent(),
                                s.context.logger.error("Error loading background-image " + f),
                                [3, 4];
                            case 4:
                                return u && (h = RB(t, r, [u.width, u.height, u.width / u.height]),
                                M = h[0],
                                R = h[1],
                                F = h[2],
                                T = h[3],
                                y = h[4],
                                S = s.ctx.createPattern(s.resizeImage(u, T, y), "repeat"),
                                s.renderRepeat(M, S, R, F)),
                                [3, 6];
                            case 5:
                                MAe(A) ? (d = RB(t, r, [null, null, null]),
                                M = d[0],
                                R = d[1],
                                F = d[2],
                                T = d[3],
                                y = d[4],
                                m = _Ae(A.angle, T, y),
                                g = m[0],
                                p = m[1],
                                v = m[2],
                                w = m[3],
                                _ = m[4],
                                x = document.createElement("canvas"),
                                x.width = T,
                                x.height = y,
                                b = x.getContext("2d"),
                                B = b.createLinearGradient(p, w, v, _),
                                oN(A.stops, g).forEach(function(ue) {
                                    return B.addColorStop(ue.stop, Hr(ue.color))
                                }),
                                b.fillStyle = B,
                                b.fillRect(0, 0, T, y),
                                T > 0 && y > 0 && (S = s.ctx.createPattern(x, "repeat"),
                                s.renderRepeat(M, S, R, F))) : SAe(A) && (I = RB(t, r, [null, null, null]),
                                M = I[0],
                                L = I[1],
                                D = I[2],
                                T = I[3],
                                y = I[4],
                                E = A.position.length === 0 ? [t2] : A.position,
                                R = bn(E[0], T),
                                F = bn(E[E.length - 1], y),
                                O = xAe(A, R, F, T, y),
                                z = O[0],
                                j = O[1],
                                z > 0 && j > 0 && (Q = s.ctx.createRadialGradient(L + R, D + F, 0, L + R, D + F, z),
                                oN(A.stops, z * 2).forEach(function(ue) {
                                    return Q.addColorStop(ue.stop, Hr(ue.color))
                                }),
                                s.path(M),
                                s.ctx.fillStyle = Q,
                                z !== j ? (C = t.bounds.left + .5 * t.bounds.width,
                                W = t.bounds.top + .5 * t.bounds.height,
                                ee = j / z,
                                P = 1 / ee,
                                s.ctx.save(),
                                s.ctx.translate(C, W),
                                s.ctx.transform(1, 0, 0, ee, 0, 0),
                                s.ctx.translate(-C, -W),
                                s.ctx.fillRect(L, P * (D - W) + W, T, y * P),
                                s.ctx.restore()) : s.ctx.fill())),
                                re.label = 6;
                            case 6:
                                return r--,
                                [2]
                            }
                        })
                    }
                    ,
                    s = this,
                    o = 0,
                    a = t.styles.backgroundImage.slice(0).reverse(),
                    c.label = 1;
                case 1:
                    return o < a.length ? (l = a[o],
                    [5, i(l)]) : [3, 4];
                case 2:
                    c.sent(),
                    c.label = 3;
                case 3:
                    return o++,
                    [3, 1];
                case 4:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.renderSolidBorder = function(t, r, i) {
        return qs(this, void 0, void 0, function() {
            return gs(this, function(s) {
                return this.path(UN(i, r)),
                this.ctx.fillStyle = Hr(t),
                this.ctx.fill(),
                [2]
            })
        })
    }
    ,
    e.prototype.renderDoubleBorder = function(t, r, i, s) {
        return qs(this, void 0, void 0, function() {
            var o, a;
            return gs(this, function(l) {
                switch (l.label) {
                case 0:
                    return r < 3 ? [4, this.renderSolidBorder(t, i, s)] : [3, 2];
                case 1:
                    return l.sent(),
                    [2];
                case 2:
                    return o = dhe(s, i),
                    this.path(o),
                    this.ctx.fillStyle = Hr(t),
                    this.ctx.fill(),
                    a = phe(s, i),
                    this.path(a),
                    this.ctx.fill(),
                    [2]
                }
            })
        })
    }
    ,
    e.prototype.renderNodeBackgroundAndBorders = function(t) {
        return qs(this, void 0, void 0, function() {
            var r, i, s, o, a, l, c, A, u = this;
            return gs(this, function(f) {
                switch (f.label) {
                case 0:
                    return this.applyEffects(t.getEffects(2)),
                    r = t.container.styles,
                    i = !cd(r.backgroundColor) || r.backgroundImage.length,
                    s = [{
                        style: r.borderTopStyle,
                        color: r.borderTopColor,
                        width: r.borderTopWidth
                    }, {
                        style: r.borderRightStyle,
                        color: r.borderRightColor,
                        width: r.borderRightWidth
                    }, {
                        style: r.borderBottomStyle,
                        color: r.borderBottomColor,
                        width: r.borderBottomWidth
                    }, {
                        style: r.borderLeftStyle,
                        color: r.borderLeftColor,
                        width: r.borderLeftWidth
                    }],
                    o = Bhe(Yf(r.backgroundClip, 0), t.curves),
                    i || r.boxShadow.length ? (this.ctx.save(),
                    this.path(o),
                    this.ctx.clip(),
                    cd(r.backgroundColor) || (this.ctx.fillStyle = Hr(r.backgroundColor),
                    this.ctx.fill()),
                    [4, this.renderBackgroundImage(t.container)]) : [3, 2];
                case 1:
                    f.sent(),
                    this.ctx.restore(),
                    r.boxShadow.slice(0).reverse().forEach(function(h) {
                        u.ctx.save();
                        var d = K_(t.curves)
                          , m = h.inset ? 0 : bhe
                          , g = fhe(d, -m + (h.inset ? 1 : -1) * h.spread.number, (h.inset ? 1 : -1) * h.spread.number, h.spread.number * (h.inset ? -2 : 2), h.spread.number * (h.inset ? -2 : 2));
                        h.inset ? (u.path(d),
                        u.ctx.clip(),
                        u.mask(g)) : (u.mask(d),
                        u.ctx.clip(),
                        u.path(g)),
                        u.ctx.shadowOffsetX = h.offsetX.number + m,
                        u.ctx.shadowOffsetY = h.offsetY.number,
                        u.ctx.shadowColor = Hr(h.color),
                        u.ctx.shadowBlur = h.blur.number,
                        u.ctx.fillStyle = h.inset ? Hr(h.color) : "rgba(0,0,0,1)",
                        u.ctx.fill(),
                        u.ctx.restore()
                    }),
                    f.label = 2;
                case 2:
                    a = 0,
                    l = 0,
                    c = s,
                    f.label = 3;
                case 3:
                    return l < c.length ? (A = c[l],
                    A.style !== 0 && !cd(A.color) && A.width > 0 ? A.style !== 2 ? [3, 5] : [4, this.renderDashedDottedBorder(A.color, A.width, a, t.curves, 2)] : [3, 11]) : [3, 13];
                case 4:
                    return f.sent(),
                    [3, 11];
                case 5:
                    return A.style !== 3 ? [3, 7] : [4, this.renderDashedDottedBorder(A.color, A.width, a, t.curves, 3)];
                case 6:
                    return f.sent(),
                    [3, 11];
                case 7:
                    return A.style !== 4 ? [3, 9] : [4, this.renderDoubleBorder(A.color, A.width, a, t.curves)];
                case 8:
                    return f.sent(),
                    [3, 11];
                case 9:
                    return [4, this.renderSolidBorder(A.color, a, t.curves)];
                case 10:
                    f.sent(),
                    f.label = 11;
                case 11:
                    a++,
                    f.label = 12;
                case 12:
                    return l++,
                    [3, 3];
                case 13:
                    return [2]
                }
            })
        })
    }
    ,
    e.prototype.renderDashedDottedBorder = function(t, r, i, s, o) {
        return qs(this, void 0, void 0, function() {
            var a, l, c, A, u, f, h, d, m, g, p, v, w, _, x, b, x, b;
            return gs(this, function(B) {
                return this.ctx.save(),
                a = mhe(s, i),
                l = UN(s, i),
                o === 2 && (this.path(l),
                this.ctx.clip()),
                oo(l[0]) ? (c = l[0].start.x,
                A = l[0].start.y) : (c = l[0].x,
                A = l[0].y),
                oo(l[1]) ? (u = l[1].end.x,
                f = l[1].end.y) : (u = l[1].x,
                f = l[1].y),
                i === 0 || i === 2 ? h = Math.abs(c - u) : h = Math.abs(A - f),
                this.ctx.beginPath(),
                o === 3 ? this.formatPath(a) : this.formatPath(l.slice(0, 2)),
                d = r < 3 ? r * 3 : r * 2,
                m = r < 3 ? r * 2 : r,
                o === 3 && (d = r,
                m = r),
                g = !0,
                h <= d * 2 ? g = !1 : h <= d * 2 + m ? (p = h / (2 * d + m),
                d *= p,
                m *= p) : (v = Math.floor((h + m) / (d + m)),
                w = (h - v * d) / (v - 1),
                _ = (h - (v + 1) * d) / v,
                m = _ <= 0 || Math.abs(m - w) < Math.abs(m - _) ? w : _),
                g && (o === 3 ? this.ctx.setLineDash([0, d + m]) : this.ctx.setLineDash([d, m])),
                o === 3 ? (this.ctx.lineCap = "round",
                this.ctx.lineWidth = r) : this.ctx.lineWidth = r * 2 + 1.1,
                this.ctx.strokeStyle = Hr(t),
                this.ctx.stroke(),
                this.ctx.setLineDash([]),
                o === 2 && (oo(l[0]) && (x = l[3],
                b = l[0],
                this.ctx.beginPath(),
                this.formatPath([new Ye(x.end.x,x.end.y), new Ye(b.start.x,b.start.y)]),
                this.ctx.stroke()),
                oo(l[1]) && (x = l[1],
                b = l[2],
                this.ctx.beginPath(),
                this.formatPath([new Ye(x.end.x,x.end.y), new Ye(b.start.x,b.start.y)]),
                this.ctx.stroke())),
                this.ctx.restore(),
                [2]
            })
        })
    }
    ,
    e.prototype.render = function(t) {
        return qs(this, void 0, void 0, function() {
            var r;
            return gs(this, function(i) {
                switch (i.label) {
                case 0:
                    return this.options.backgroundColor && (this.ctx.fillStyle = Hr(this.options.backgroundColor),
                    this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height)),
                    r = hhe(t),
                    [4, this.renderStack(r)];
                case 1:
                    return i.sent(),
                    this.applyEffects([]),
                    [2, this.canvas]
                }
            })
        })
    }
    ,
    e
}
)(aG);
var Ehe = function(n) {
    return n instanceof X8 || n instanceof K8 ? !0 : n instanceof s2 && n.type !== W_ && n.type !== j_
}
  , Bhe = function(n, e) {
    switch (n) {
    case 0:
        return K_(e);
    case 2:
        return ahe(e);
    case 1:
    default:
        return X_(e)
    }
}
  , Mhe = function(n) {
    switch (n) {
    case 1:
        return "center";
    case 2:
        return "right";
    case 0:
    default:
        return "left"
    }
}
  , She = ["-apple-system", "system-ui"]
  , Che = function(n) {
    return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? n.filter(function(e) {
        return She.indexOf(e) === -1
    }) : n
};
(function(n) {
    ua(e, n);
    function e(t, r) {
        var i = n.call(this, t, r) || this;
        return i.canvas = r.canvas ? r.canvas : document.createElement("canvas"),
        i.ctx = i.canvas.getContext("2d"),
        i.options = r,
        i.canvas.width = Math.floor(r.width * r.scale),
        i.canvas.height = Math.floor(r.height * r.scale),
        i.canvas.style.width = r.width + "px",
        i.canvas.style.height = r.height + "px",
        i.ctx.scale(i.options.scale, i.options.scale),
        i.ctx.translate(-r.x, -r.y),
        i.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + r.width + "x" + r.height + " at " + r.x + "," + r.y + ") with scale " + r.scale),
        i
    }
    return e.prototype.render = function(t) {
        return qs(this, void 0, void 0, function() {
            var r, i;
            return gs(this, function(s) {
                switch (s.label) {
                case 0:
                    return r = tT(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, t),
                    [4, The(r)];
                case 1:
                    return i = s.sent(),
                    this.options.backgroundColor && (this.ctx.fillStyle = Hr(this.options.backgroundColor),
                    this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale)),
                    this.ctx.drawImage(i, -this.options.x * this.options.scale, -this.options.y * this.options.scale),
                    [2, this.canvas]
                }
            })
        })
    }
    ,
    e
}
)(aG);
var The = function(n) {
    return new Promise(function(e, t) {
        var r = new Image;
        r.onload = function() {
            e(r)
        }
        ,
        r.onerror = t,
        r.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(n))
    }
    )
};
typeof window < "u" && she.setContext(window);
/*!
 * @pixiv/three-vrm v3.1.4
 * VRM file loader for three.js.
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
var my = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , $t = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , $_ = class extends Lt {
    constructor(n) {
        super(),
        this.weight = 0,
        this.isBinary = !1,
        this.overrideBlink = "none",
        this.overrideLookAt = "none",
        this.overrideMouth = "none",
        this._binds = [],
        this.name = `VRMExpression_${n}`,
        this.expressionName = n,
        this.type = "VRMExpression",
        this.visible = !1
    }
    get overrideBlinkAmount() {
        return this.overrideBlink === "block" ? 0 < this.outputWeight ? 1 : 0 : this.overrideBlink === "blend" ? this.outputWeight : 0
    }
    get overrideLookAtAmount() {
        return this.overrideLookAt === "block" ? 0 < this.outputWeight ? 1 : 0 : this.overrideLookAt === "blend" ? this.outputWeight : 0
    }
    get overrideMouthAmount() {
        return this.overrideMouth === "block" ? 0 < this.outputWeight ? 1 : 0 : this.overrideMouth === "blend" ? this.outputWeight : 0
    }
    get outputWeight() {
        return this.isBinary ? this.weight > .5 ? 1 : 0 : this.weight
    }
    addBind(n) {
        this._binds.push(n)
    }
    applyWeight(n) {
        var e;
        let t = this.outputWeight;
        t *= (e = n == null ? void 0 : n.multiplier) != null ? e : 1,
        this.isBinary && t < 1 && (t = 0),
        this._binds.forEach(r => r.applyWeight(t))
    }
    clearAppliedWeight() {
        this._binds.forEach(n => n.clearAppliedWeight())
    }
}
;
function lG(n, e, t) {
    var r, i;
    const s = n.parser.json
      , o = (r = s.nodes) == null ? void 0 : r[e];
    if (o == null)
        return console.warn(`extractPrimitivesInternal: Attempt to use nodes[${e}] of glTF but the node doesn't exist`),
        null;
    const a = o.mesh;
    if (a == null)
        return null;
    const l = (i = s.meshes) == null ? void 0 : i[a];
    if (l == null)
        return console.warn(`extractPrimitivesInternal: Attempt to use meshes[${a}] of glTF but the mesh doesn't exist`),
        null;
    const c = l.primitives.length
      , A = [];
    return t.traverse(u => {
        A.length < c && u.isMesh && A.push(u)
    }
    ),
    A
}
function PN(n, e) {
    return $t(this, null, function*() {
        const t = yield n.parser.getDependency("node", e);
        return lG(n, e, t)
    })
}
function LN(n) {
    return $t(this, null, function*() {
        const e = yield n.parser.getDependencies("node")
          , t = new Map;
        return e.forEach( (r, i) => {
            const s = lG(n, i, r);
            s != null && t.set(i, s)
        }
        ),
        t
    })
}
var Wr = {
    Aa: "aa",
    Ih: "ih",
    Ou: "ou",
    Ee: "ee",
    Oh: "oh",
    Blink: "blink",
    Happy: "happy",
    Angry: "angry",
    Sad: "sad",
    Relaxed: "relaxed",
    LookUp: "lookUp",
    Surprised: "surprised",
    LookDown: "lookDown",
    LookLeft: "lookLeft",
    LookRight: "lookRight",
    BlinkLeft: "blinkLeft",
    BlinkRight: "blinkRight",
    Neutral: "neutral"
};
function cG(n) {
    return Math.max(Math.min(n, 1), 0)
}
var Z_ = class AG {
    constructor() {
        this.blinkExpressionNames = ["blink", "blinkLeft", "blinkRight"],
        this.lookAtExpressionNames = ["lookLeft", "lookRight", "lookUp", "lookDown"],
        this.mouthExpressionNames = ["aa", "ee", "ih", "oh", "ou"],
        this._expressions = [],
        this._expressionMap = {}
    }
    get expressions() {
        return this._expressions.concat()
    }
    get expressionMap() {
        return Object.assign({}, this._expressionMap)
    }
    get presetExpressionMap() {
        const e = {}
          , t = new Set(Object.values(Wr));
        return Object.entries(this._expressionMap).forEach( ([r,i]) => {
            t.has(r) && (e[r] = i)
        }
        ),
        e
    }
    get customExpressionMap() {
        const e = {}
          , t = new Set(Object.values(Wr));
        return Object.entries(this._expressionMap).forEach( ([r,i]) => {
            t.has(r) || (e[r] = i)
        }
        ),
        e
    }
    copy(e) {
        return this._expressions.concat().forEach(r => {
            this.unregisterExpression(r)
        }
        ),
        e._expressions.forEach(r => {
            this.registerExpression(r)
        }
        ),
        this.blinkExpressionNames = e.blinkExpressionNames.concat(),
        this.lookAtExpressionNames = e.lookAtExpressionNames.concat(),
        this.mouthExpressionNames = e.mouthExpressionNames.concat(),
        this
    }
    clone() {
        return new AG().copy(this)
    }
    getExpression(e) {
        var t;
        return (t = this._expressionMap[e]) != null ? t : null
    }
    registerExpression(e) {
        this._expressions.push(e),
        this._expressionMap[e.expressionName] = e
    }
    unregisterExpression(e) {
        const t = this._expressions.indexOf(e);
        t === -1 && console.warn("VRMExpressionManager: The specified expressions is not registered"),
        this._expressions.splice(t, 1),
        delete this._expressionMap[e.expressionName]
    }
    getValue(e) {
        var t;
        const r = this.getExpression(e);
        return (t = r == null ? void 0 : r.weight) != null ? t : null
    }
    setValue(e, t) {
        const r = this.getExpression(e);
        r && (r.weight = cG(t))
    }
    resetValues() {
        this._expressions.forEach(e => {
            e.weight = 0
        }
        )
    }
    getExpressionTrackName(e) {
        const t = this.getExpression(e);
        return t ? `${t.name}.weight` : null
    }
    update() {
        const e = this._calculateWeightMultipliers();
        this._expressions.forEach(t => {
            t.clearAppliedWeight()
        }
        ),
        this._expressions.forEach(t => {
            let r = 1;
            const i = t.expressionName;
            this.blinkExpressionNames.indexOf(i) !== -1 && (r *= e.blink),
            this.lookAtExpressionNames.indexOf(i) !== -1 && (r *= e.lookAt),
            this.mouthExpressionNames.indexOf(i) !== -1 && (r *= e.mouth),
            t.applyWeight({
                multiplier: r
            })
        }
        )
    }
    _calculateWeightMultipliers() {
        let e = 1
          , t = 1
          , r = 1;
        return this._expressions.forEach(i => {
            e -= i.overrideBlinkAmount,
            t -= i.overrideLookAtAmount,
            r -= i.overrideMouthAmount
        }
        ),
        e = Math.max(0, e),
        t = Math.max(0, t),
        r = Math.max(0, r),
        {
            blink: e,
            lookAt: t,
            mouth: r
        }
    }
}
  , jp = {
    Color: "color",
    EmissionColor: "emissionColor",
    ShadeColor: "shadeColor",
    MatcapColor: "matcapColor",
    RimColor: "rimColor",
    OutlineColor: "outlineColor"
}
  , Ihe = {
    _Color: jp.Color,
    _EmissionColor: jp.EmissionColor,
    _ShadeColor: jp.ShadeColor,
    _RimColor: jp.RimColor,
    _OutlineColor: jp.OutlineColor
}
  , Rhe = new Qe
  , uG = class fG {
    constructor({material: e, type: t, targetValue: r, targetAlpha: i}) {
        this.material = e,
        this.type = t,
        this.targetValue = r,
        this.targetAlpha = i ?? 1;
        const s = this._initColorBindState()
          , o = this._initAlphaBindState();
        this._state = {
            color: s,
            alpha: o
        }
    }
    applyWeight(e) {
        const {color: t, alpha: r} = this._state;
        if (t != null) {
            const {propertyName: i, deltaValue: s} = t
              , o = this.material[i];
            o != null && o.add(Rhe.copy(s).multiplyScalar(e))
        }
        if (r != null) {
            const {propertyName: i, deltaValue: s} = r;
            this.material[i] != null && (this.material[i] += s * e)
        }
    }
    clearAppliedWeight() {
        const {color: e, alpha: t} = this._state;
        if (e != null) {
            const {propertyName: r, initialValue: i} = e
              , s = this.material[r];
            s != null && s.copy(i)
        }
        if (t != null) {
            const {propertyName: r, initialValue: i} = t;
            this.material[r] != null && (this.material[r] = i)
        }
    }
    _initColorBindState() {
        var e, t, r;
        const {material: i, type: s, targetValue: o} = this
          , a = this._getPropertyNameMap()
          , l = (t = (e = a == null ? void 0 : a[s]) == null ? void 0 : e[0]) != null ? t : null;
        if (l == null)
            return console.warn(`Tried to add a material color bind to the material ${(r = i.name) != null ? r : "(no name)"}, the type ${s} but the material or the type is not supported.`),
            null;
        const A = i[l].clone()
          , u = new Qe(o.r - A.r,o.g - A.g,o.b - A.b);
        return {
            propertyName: l,
            initialValue: A,
            deltaValue: u
        }
    }
    _initAlphaBindState() {
        var e, t, r;
        const {material: i, type: s, targetAlpha: o} = this
          , a = this._getPropertyNameMap()
          , l = (t = (e = a == null ? void 0 : a[s]) == null ? void 0 : e[1]) != null ? t : null;
        if (l == null && o !== 1)
            return console.warn(`Tried to add a material alpha bind to the material ${(r = i.name) != null ? r : "(no name)"}, the type ${s} but the material or the type does not support alpha.`),
            null;
        if (l == null)
            return null;
        const c = i[l]
          , A = o - c;
        return {
            propertyName: l,
            initialValue: c,
            deltaValue: A
        }
    }
    _getPropertyNameMap() {
        var e, t;
        return (t = (e = Object.entries(fG._propertyNameMapMap).find( ([r]) => this.material[r] === !0)) == null ? void 0 : e[1]) != null ? t : null
    }
}
;
uG._propertyNameMapMap = {
    isMeshStandardMaterial: {
        color: ["color", "opacity"],
        emissionColor: ["emissive", null]
    },
    isMeshBasicMaterial: {
        color: ["color", "opacity"]
    },
    isMToonMaterial: {
        color: ["color", "opacity"],
        emissionColor: ["emissive", null],
        outlineColor: ["outlineColorFactor", null],
        matcapColor: ["matcapFactor", null],
        rimColor: ["parametricRimColorFactor", null],
        shadeColor: ["shadeColorFactor", null]
    }
};
var DN = uG
  , J_ = class {
    constructor({primitives: n, index: e, weight: t}) {
        this.primitives = n,
        this.index = e,
        this.weight = t
    }
    applyWeight(n) {
        this.primitives.forEach(e => {
            var t;
            ((t = e.morphTargetInfluences) == null ? void 0 : t[this.index]) != null && (e.morphTargetInfluences[this.index] += this.weight * n)
        }
        )
    }
    clearAppliedWeight() {
        this.primitives.forEach(n => {
            var e;
            ((e = n.morphTargetInfluences) == null ? void 0 : e[this.index]) != null && (n.morphTargetInfluences[this.index] = 0)
        }
        )
    }
}
  , NN = new We
  , hG = class dG {
    constructor({material: e, scale: t, offset: r}) {
        var i, s;
        this.material = e,
        this.scale = t,
        this.offset = r;
        const o = (i = Object.entries(dG._propertyNamesMap).find( ([a]) => e[a] === !0)) == null ? void 0 : i[1];
        o == null ? (console.warn(`Tried to add a texture transform bind to the material ${(s = e.name) != null ? s : "(no name)"} but the material is not supported.`),
        this._properties = []) : (this._properties = [],
        o.forEach(a => {
            var l;
            const c = (l = e[a]) == null ? void 0 : l.clone();
            if (!c)
                return null;
            e[a] = c;
            const A = c.offset.clone()
              , u = c.repeat.clone()
              , f = r.clone().sub(A)
              , h = t.clone().sub(u);
            this._properties.push({
                name: a,
                initialOffset: A,
                deltaOffset: f,
                initialScale: u,
                deltaScale: h
            })
        }
        ))
    }
    applyWeight(e) {
        this._properties.forEach(t => {
            const r = this.material[t.name];
            r !== void 0 && (r.offset.add(NN.copy(t.deltaOffset).multiplyScalar(e)),
            r.repeat.add(NN.copy(t.deltaScale).multiplyScalar(e)))
        }
        )
    }
    clearAppliedWeight() {
        this._properties.forEach(e => {
            const t = this.material[e.name];
            t !== void 0 && (t.offset.copy(e.initialOffset),
            t.repeat.copy(e.initialScale))
        }
        )
    }
}
;
hG._propertyNamesMap = {
    isMeshStandardMaterial: ["map", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "roughnessMap", "metalnessMap", "alphaMap"],
    isMeshBasicMaterial: ["map", "specularMap", "alphaMap"],
    isMToonMaterial: ["map", "normalMap", "emissiveMap", "shadeMultiplyTexture", "rimMultiplyTexture", "outlineWidthMultiplyTexture", "uvAnimationMaskTexture"]
};
var ON = hG
  , Uhe = new Set(["1.0", "1.0-beta"])
  , pG = class mG {
    get name() {
        return "VRMExpressionLoaderPlugin"
    }
    constructor(e) {
        this.parser = e
    }
    afterRoot(e) {
        return $t(this, null, function*() {
            e.userData.vrmExpressionManager = yield this._import(e)
        })
    }
    _import(e) {
        return $t(this, null, function*() {
            const t = yield this._v1Import(e);
            if (t)
                return t;
            const r = yield this._v0Import(e);
            return r || null
        })
    }
    _v1Import(e) {
        return $t(this, null, function*() {
            var t, r;
            const i = this.parser.json;
            if (!(((t = i.extensionsUsed) == null ? void 0 : t.indexOf("VRMC_vrm")) !== -1))
                return null;
            const o = (r = i.extensions) == null ? void 0 : r.VRMC_vrm;
            if (!o)
                return null;
            const a = o.specVersion;
            if (!Uhe.has(a))
                return console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),
                null;
            const l = o.expressions;
            if (!l)
                return null;
            const c = new Set(Object.values(Wr))
              , A = new Map;
            l.preset != null && Object.entries(l.preset).forEach( ([f,h]) => {
                if (h != null) {
                    if (!c.has(f)) {
                        console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${f}" detected. Ignoring the expression`);
                        return
                    }
                    A.set(f, h)
                }
            }
            ),
            l.custom != null && Object.entries(l.custom).forEach( ([f,h]) => {
                if (c.has(f)) {
                    console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${f}". Ignoring the expression`);
                    return
                }
                A.set(f, h)
            }
            );
            const u = new Z_;
            return yield Promise.all(Array.from(A.entries()).map(f => $t(this, [f], function*([h,d]) {
                var m, g, p, v, w, _, x;
                const b = new $_(h);
                if (e.scene.add(b),
                b.isBinary = (m = d.isBinary) != null ? m : !1,
                b.overrideBlink = (g = d.overrideBlink) != null ? g : "none",
                b.overrideLookAt = (p = d.overrideLookAt) != null ? p : "none",
                b.overrideMouth = (v = d.overrideMouth) != null ? v : "none",
                (w = d.morphTargetBinds) == null || w.forEach(B => $t(this, null, function*() {
                    var S;
                    if (B.node === void 0 || B.index === void 0)
                        return;
                    const I = yield PN(e, B.node)
                      , M = B.index;
                    if (!I.every(L => Array.isArray(L.morphTargetInfluences) && M < L.morphTargetInfluences.length)) {
                        console.warn(`VRMExpressionLoaderPlugin: ${d.name} attempts to index morph #${M} but not found.`);
                        return
                    }
                    b.addBind(new J_({
                        primitives: I,
                        index: M,
                        weight: (S = B.weight) != null ? S : 1
                    }))
                })),
                d.materialColorBinds || d.textureTransformBinds) {
                    const B = [];
                    e.scene.traverse(S => {
                        const I = S.material;
                        I && B.push(I)
                    }
                    ),
                    (_ = d.materialColorBinds) == null || _.forEach(S => $t(this, null, function*() {
                        B.filter(M => {
                            var L;
                            const D = (L = this.parser.associations.get(M)) == null ? void 0 : L.materials;
                            return S.material === D
                        }
                        ).forEach(M => {
                            b.addBind(new DN({
                                material: M,
                                type: S.type,
                                targetValue: new Qe().fromArray(S.targetValue),
                                targetAlpha: S.targetValue[3]
                            }))
                        }
                        )
                    })),
                    (x = d.textureTransformBinds) == null || x.forEach(S => $t(this, null, function*() {
                        B.filter(M => {
                            var L;
                            const D = (L = this.parser.associations.get(M)) == null ? void 0 : L.materials;
                            return S.material === D
                        }
                        ).forEach(M => {
                            var L, D;
                            b.addBind(new ON({
                                material: M,
                                offset: new We().fromArray((L = S.offset) != null ? L : [0, 0]),
                                scale: new We().fromArray((D = S.scale) != null ? D : [1, 1])
                            }))
                        }
                        )
                    }))
                }
                u.registerExpression(b)
            }))),
            u
        })
    }
    _v0Import(e) {
        return $t(this, null, function*() {
            var t;
            const r = this.parser.json
              , i = (t = r.extensions) == null ? void 0 : t.VRM;
            if (!i)
                return null;
            const s = i.blendShapeMaster;
            if (!s)
                return null;
            const o = new Z_
              , a = s.blendShapeGroups;
            if (!a)
                return o;
            const l = new Set;
            return yield Promise.all(a.map(c => $t(this, null, function*() {
                var A;
                const u = c.presetName
                  , f = u != null && mG.v0v1PresetNameMap[u] || null
                  , h = f ?? c.name;
                if (h == null) {
                    console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");
                    return
                }
                if (l.has(h)) {
                    console.warn(`VRMExpressionLoaderPlugin: An expression preset ${u} has duplicated entries. Ignoring the expression`);
                    return
                }
                l.add(h);
                const d = new $_(h);
                e.scene.add(d),
                d.isBinary = (A = c.isBinary) != null ? A : !1,
                c.binds && c.binds.forEach(g => $t(this, null, function*() {
                    var p;
                    if (g.mesh === void 0 || g.index === void 0)
                        return;
                    const v = [];
                    (p = r.nodes) == null || p.forEach( (_, x) => {
                        _.mesh === g.mesh && v.push(x)
                    }
                    );
                    const w = g.index;
                    yield Promise.all(v.map(_ => $t(this, null, function*() {
                        var x;
                        const b = yield PN(e, _);
                        if (!b.every(B => Array.isArray(B.morphTargetInfluences) && w < B.morphTargetInfluences.length)) {
                            console.warn(`VRMExpressionLoaderPlugin: ${c.name} attempts to index ${w}th morph but not found.`);
                            return
                        }
                        d.addBind(new J_({
                            primitives: b,
                            index: w,
                            weight: .01 * ((x = g.weight) != null ? x : 100)
                        }))
                    })))
                }));
                const m = c.materialValues;
                m && m.length !== 0 && m.forEach(g => {
                    if (g.materialName === void 0 || g.propertyName === void 0 || g.targetValue === void 0)
                        return;
                    const p = [];
                    e.scene.traverse(w => {
                        if (w.material) {
                            const _ = w.material;
                            Array.isArray(_) ? p.push(..._.filter(x => (x.name === g.materialName || x.name === g.materialName + " (Outline)") && p.indexOf(x) === -1)) : _.name === g.materialName && p.indexOf(_) === -1 && p.push(_)
                        }
                    }
                    );
                    const v = g.propertyName;
                    p.forEach(w => {
                        if (v === "_MainTex_ST") {
                            const x = new We(g.targetValue[0],g.targetValue[1])
                              , b = new We(g.targetValue[2],g.targetValue[3]);
                            b.y = 1 - b.y - x.y,
                            d.addBind(new ON({
                                material: w,
                                scale: x,
                                offset: b
                            }));
                            return
                        }
                        const _ = Ihe[v];
                        if (_) {
                            d.addBind(new DN({
                                material: w,
                                type: _,
                                targetValue: new Qe().fromArray(g.targetValue),
                                targetAlpha: g.targetValue[3]
                            }));
                            return
                        }
                        console.warn(v + " is not supported")
                    }
                    )
                }
                ),
                o.registerExpression(d)
            }))),
            o
        })
    }
}
;
pG.v0v1PresetNameMap = {
    a: "aa",
    e: "ee",
    i: "ih",
    o: "oh",
    u: "ou",
    blink: "blink",
    joy: "happy",
    angry: "angry",
    sorrow: "sad",
    fun: "relaxed",
    lookup: "lookUp",
    lookdown: "lookDown",
    lookleft: "lookLeft",
    lookright: "lookRight",
    blink_l: "blinkLeft",
    blink_r: "blinkRight",
    neutral: "neutral"
};
var Fhe = pG
  , a2 = class $f {
    constructor(e, t) {
        this._firstPersonOnlyLayer = $f.DEFAULT_FIRSTPERSON_ONLY_LAYER,
        this._thirdPersonOnlyLayer = $f.DEFAULT_THIRDPERSON_ONLY_LAYER,
        this._initializedLayers = !1,
        this.humanoid = e,
        this.meshAnnotations = t
    }
    copy(e) {
        if (this.humanoid !== e.humanoid)
            throw new Error("VRMFirstPerson: humanoid must be same in order to copy");
        return this.meshAnnotations = e.meshAnnotations.map(t => ({
            meshes: t.meshes.concat(),
            type: t.type
        })),
        this
    }
    clone() {
        return new $f(this.humanoid,this.meshAnnotations).copy(this)
    }
    get firstPersonOnlyLayer() {
        return this._firstPersonOnlyLayer
    }
    get thirdPersonOnlyLayer() {
        return this._thirdPersonOnlyLayer
    }
    setup({firstPersonOnlyLayer: e=$f.DEFAULT_FIRSTPERSON_ONLY_LAYER, thirdPersonOnlyLayer: t=$f.DEFAULT_THIRDPERSON_ONLY_LAYER}={}) {
        this._initializedLayers || (this._firstPersonOnlyLayer = e,
        this._thirdPersonOnlyLayer = t,
        this.meshAnnotations.forEach(r => {
            r.meshes.forEach(i => {
                r.type === "firstPersonOnly" ? (i.layers.set(this._firstPersonOnlyLayer),
                i.traverse(s => s.layers.set(this._firstPersonOnlyLayer))) : r.type === "thirdPersonOnly" ? (i.layers.set(this._thirdPersonOnlyLayer),
                i.traverse(s => s.layers.set(this._thirdPersonOnlyLayer))) : r.type === "auto" && this._createHeadlessModel(i)
            }
            )
        }
        ),
        this._initializedLayers = !0)
    }
    _excludeTriangles(e, t, r, i) {
        let s = 0;
        if (t != null && t.length > 0)
            for (let o = 0; o < e.length; o += 3) {
                const a = e[o]
                  , l = e[o + 1]
                  , c = e[o + 2]
                  , A = t[a]
                  , u = r[a];
                if (A[0] > 0 && i.includes(u[0]) || A[1] > 0 && i.includes(u[1]) || A[2] > 0 && i.includes(u[2]) || A[3] > 0 && i.includes(u[3]))
                    continue;
                const f = t[l]
                  , h = r[l];
                if (f[0] > 0 && i.includes(h[0]) || f[1] > 0 && i.includes(h[1]) || f[2] > 0 && i.includes(h[2]) || f[3] > 0 && i.includes(h[3]))
                    continue;
                const d = t[c]
                  , m = r[c];
                d[0] > 0 && i.includes(m[0]) || d[1] > 0 && i.includes(m[1]) || d[2] > 0 && i.includes(m[2]) || d[3] > 0 && i.includes(m[3]) || (e[s++] = a,
                e[s++] = l,
                e[s++] = c)
            }
        return s
    }
    _createErasedMesh(e, t) {
        const r = new sa(e.geometry.clone(),e.material);
        r.name = `${e.name}(erase)`,
        r.frustumCulled = e.frustumCulled,
        r.layers.set(this._firstPersonOnlyLayer);
        const i = r.geometry
          , s = i.getAttribute("skinIndex")
          , o = s instanceof yD ? [] : s.array
          , a = [];
        for (let m = 0; m < o.length; m += 4)
            a.push([o[m], o[m + 1], o[m + 2], o[m + 3]]);
        const l = i.getAttribute("skinWeight")
          , c = l instanceof yD ? [] : l.array
          , A = [];
        for (let m = 0; m < c.length; m += 4)
            A.push([c[m], c[m + 1], c[m + 2], c[m + 3]]);
        const u = i.getIndex();
        if (!u)
            throw new Error("The geometry doesn't have an index buffer");
        const f = Array.from(u.array)
          , h = this._excludeTriangles(f, A, a, t)
          , d = [];
        for (let m = 0; m < h; m++)
            d[m] = f[m];
        return i.setIndex(d),
        e.onBeforeRender && (r.onBeforeRender = e.onBeforeRender),
        r.bind(new FA(e.skeleton.bones,e.skeleton.boneInverses), new He),
        r
    }
    _createHeadlessModelForSkinnedMesh(e, t) {
        const r = [];
        if (t.skeleton.bones.forEach( (s, o) => {
            this._isEraseTarget(s) && r.push(o)
        }
        ),
        !r.length) {
            t.layers.enable(this._thirdPersonOnlyLayer),
            t.layers.enable(this._firstPersonOnlyLayer);
            return
        }
        t.layers.set(this._thirdPersonOnlyLayer);
        const i = this._createErasedMesh(t, r);
        e.add(i)
    }
    _createHeadlessModel(e) {
        if (e.type === "Group")
            if (e.layers.set(this._thirdPersonOnlyLayer),
            this._isEraseTarget(e))
                e.traverse(t => t.layers.set(this._thirdPersonOnlyLayer));
            else {
                const t = new ri;
                t.name = `_headless_${e.name}`,
                t.layers.set(this._firstPersonOnlyLayer),
                e.parent.add(t),
                e.children.filter(r => r.type === "SkinnedMesh").forEach(r => {
                    const i = r;
                    this._createHeadlessModelForSkinnedMesh(t, i)
                }
                )
            }
        else if (e.type === "SkinnedMesh") {
            const t = e;
            this._createHeadlessModelForSkinnedMesh(e.parent, t)
        } else
            this._isEraseTarget(e) && (e.layers.set(this._thirdPersonOnlyLayer),
            e.traverse(t => t.layers.set(this._thirdPersonOnlyLayer)))
    }
    _isEraseTarget(e) {
        return e === this.humanoid.getRawBoneNode("head") ? !0 : e.parent ? this._isEraseTarget(e.parent) : !1
    }
}
;
a2.DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;
a2.DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
var kN = a2
  , Phe = new Set(["1.0", "1.0-beta"])
  , Lhe = class {
    get name() {
        return "VRMFirstPersonLoaderPlugin"
    }
    constructor(n) {
        this.parser = n
    }
    afterRoot(n) {
        return $t(this, null, function*() {
            const e = n.userData.vrmHumanoid;
            if (e !== null) {
                if (e === void 0)
                    throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");
                n.userData.vrmFirstPerson = yield this._import(n, e)
            }
        })
    }
    _import(n, e) {
        return $t(this, null, function*() {
            if (e == null)
                return null;
            const t = yield this._v1Import(n, e);
            if (t)
                return t;
            const r = yield this._v0Import(n, e);
            return r || null
        })
    }
    _v1Import(n, e) {
        return $t(this, null, function*() {
            var t, r;
            const i = this.parser.json;
            if (!(((t = i.extensionsUsed) == null ? void 0 : t.indexOf("VRMC_vrm")) !== -1))
                return null;
            const o = (r = i.extensions) == null ? void 0 : r.VRMC_vrm;
            if (!o)
                return null;
            const a = o.specVersion;
            if (!Phe.has(a))
                return console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),
                null;
            const l = o.firstPerson;
            if (!l)
                return null;
            const c = []
              , A = yield LN(n);
            return Array.from(A.entries()).forEach( ([u,f]) => {
                var h;
                const d = l.meshAnnotations ? l.meshAnnotations.find(m => m.node === u) : void 0;
                c.push({
                    meshes: f,
                    type: (h = d == null ? void 0 : d.type) != null ? h : "both"
                })
            }
            ),
            new kN(e,c)
        })
    }
    _v0Import(n, e) {
        return $t(this, null, function*() {
            var t;
            const r = this.parser.json
              , i = (t = r.extensions) == null ? void 0 : t.VRM;
            if (!i)
                return null;
            const s = i.firstPerson;
            if (!s)
                return null;
            const o = []
              , a = yield LN(n);
            return Array.from(a.entries()).forEach( ([l,c]) => {
                const A = r.nodes[l]
                  , u = s.meshAnnotations ? s.meshAnnotations.find(f => f.mesh === A.mesh) : void 0;
                o.push({
                    meshes: c,
                    type: this._convertV0FlagToV1Type(u == null ? void 0 : u.firstPersonFlag)
                })
            }
            ),
            new kN(e,o)
        })
    }
    _convertV0FlagToV1Type(n) {
        return n === "FirstPersonOnly" ? "firstPersonOnly" : n === "ThirdPersonOnly" ? "thirdPersonOnly" : n === "Auto" ? "auto" : "both"
    }
}
  , QN = new $
  , HN = new $
  , Dhe = new nt
  , zN = class extends ri {
    constructor(n) {
        super(),
        this.vrmHumanoid = n,
        this._boneAxesMap = new Map,
        Object.values(n.humanBones).forEach(e => {
            const t = new _oe(1);
            t.matrixAutoUpdate = !1,
            t.material.depthTest = !1,
            t.material.depthWrite = !1,
            this.add(t),
            this._boneAxesMap.set(e, t)
        }
        )
    }
    dispose() {
        Array.from(this._boneAxesMap.values()).forEach(n => {
            n.geometry.dispose(),
            n.material.dispose()
        }
        )
    }
    updateMatrixWorld(n) {
        Array.from(this._boneAxesMap.entries()).forEach( ([e,t]) => {
            e.node.updateWorldMatrix(!0, !1),
            e.node.matrixWorld.decompose(QN, Dhe, HN);
            const r = QN.set(.1, .1, .1).divide(HN);
            t.matrix.copy(e.node.matrixWorld).scale(r)
        }
        ),
        super.updateMatrixWorld(n)
    }
}
  , UB = ["hips", "spine", "chest", "upperChest", "neck", "head", "leftEye", "rightEye", "jaw", "leftUpperLeg", "leftLowerLeg", "leftFoot", "leftToes", "rightUpperLeg", "rightLowerLeg", "rightFoot", "rightToes", "leftShoulder", "leftUpperArm", "leftLowerArm", "leftHand", "rightShoulder", "rightUpperArm", "rightLowerArm", "rightHand", "leftThumbMetacarpal", "leftThumbProximal", "leftThumbDistal", "leftIndexProximal", "leftIndexIntermediate", "leftIndexDistal", "leftMiddleProximal", "leftMiddleIntermediate", "leftMiddleDistal", "leftRingProximal", "leftRingIntermediate", "leftRingDistal", "leftLittleProximal", "leftLittleIntermediate", "leftLittleDistal", "rightThumbMetacarpal", "rightThumbProximal", "rightThumbDistal", "rightIndexProximal", "rightIndexIntermediate", "rightIndexDistal", "rightMiddleProximal", "rightMiddleIntermediate", "rightMiddleDistal", "rightRingProximal", "rightRingIntermediate", "rightRingDistal", "rightLittleProximal", "rightLittleIntermediate", "rightLittleDistal"]
  , Jg = {
    Hips: "hips",
    Spine: "spine",
    Chest: "chest",
    UpperChest: "upperChest",
    Neck: "neck",
    Head: "head",
    LeftEye: "leftEye",
    RightEye: "rightEye",
    Jaw: "jaw",
    LeftUpperLeg: "leftUpperLeg",
    LeftLowerLeg: "leftLowerLeg",
    LeftFoot: "leftFoot",
    LeftToes: "leftToes",
    RightUpperLeg: "rightUpperLeg",
    RightLowerLeg: "rightLowerLeg",
    RightFoot: "rightFoot",
    RightToes: "rightToes",
    LeftShoulder: "leftShoulder",
    LeftUpperArm: "leftUpperArm",
    LeftLowerArm: "leftLowerArm",
    LeftHand: "leftHand",
    RightShoulder: "rightShoulder",
    RightUpperArm: "rightUpperArm",
    RightLowerArm: "rightLowerArm",
    RightHand: "rightHand",
    LeftThumbMetacarpal: "leftThumbMetacarpal",
    LeftThumbProximal: "leftThumbProximal",
    LeftThumbDistal: "leftThumbDistal",
    LeftIndexProximal: "leftIndexProximal",
    LeftIndexIntermediate: "leftIndexIntermediate",
    LeftIndexDistal: "leftIndexDistal",
    LeftMiddleProximal: "leftMiddleProximal",
    LeftMiddleIntermediate: "leftMiddleIntermediate",
    LeftMiddleDistal: "leftMiddleDistal",
    LeftRingProximal: "leftRingProximal",
    LeftRingIntermediate: "leftRingIntermediate",
    LeftRingDistal: "leftRingDistal",
    LeftLittleProximal: "leftLittleProximal",
    LeftLittleIntermediate: "leftLittleIntermediate",
    LeftLittleDistal: "leftLittleDistal",
    RightThumbMetacarpal: "rightThumbMetacarpal",
    RightThumbProximal: "rightThumbProximal",
    RightThumbDistal: "rightThumbDistal",
    RightIndexProximal: "rightIndexProximal",
    RightIndexIntermediate: "rightIndexIntermediate",
    RightIndexDistal: "rightIndexDistal",
    RightMiddleProximal: "rightMiddleProximal",
    RightMiddleIntermediate: "rightMiddleIntermediate",
    RightMiddleDistal: "rightMiddleDistal",
    RightRingProximal: "rightRingProximal",
    RightRingIntermediate: "rightRingIntermediate",
    RightRingDistal: "rightRingDistal",
    RightLittleProximal: "rightLittleProximal",
    RightLittleIntermediate: "rightLittleIntermediate",
    RightLittleDistal: "rightLittleDistal"
}
  , Nhe = {
    hips: null,
    spine: "hips",
    chest: "spine",
    upperChest: "chest",
    neck: "upperChest",
    head: "neck",
    leftEye: "head",
    rightEye: "head",
    jaw: "head",
    leftUpperLeg: "hips",
    leftLowerLeg: "leftUpperLeg",
    leftFoot: "leftLowerLeg",
    leftToes: "leftFoot",
    rightUpperLeg: "hips",
    rightLowerLeg: "rightUpperLeg",
    rightFoot: "rightLowerLeg",
    rightToes: "rightFoot",
    leftShoulder: "upperChest",
    leftUpperArm: "leftShoulder",
    leftLowerArm: "leftUpperArm",
    leftHand: "leftLowerArm",
    rightShoulder: "upperChest",
    rightUpperArm: "rightShoulder",
    rightLowerArm: "rightUpperArm",
    rightHand: "rightLowerArm",
    leftThumbMetacarpal: "leftHand",
    leftThumbProximal: "leftThumbMetacarpal",
    leftThumbDistal: "leftThumbProximal",
    leftIndexProximal: "leftHand",
    leftIndexIntermediate: "leftIndexProximal",
    leftIndexDistal: "leftIndexIntermediate",
    leftMiddleProximal: "leftHand",
    leftMiddleIntermediate: "leftMiddleProximal",
    leftMiddleDistal: "leftMiddleIntermediate",
    leftRingProximal: "leftHand",
    leftRingIntermediate: "leftRingProximal",
    leftRingDistal: "leftRingIntermediate",
    leftLittleProximal: "leftHand",
    leftLittleIntermediate: "leftLittleProximal",
    leftLittleDistal: "leftLittleIntermediate",
    rightThumbMetacarpal: "rightHand",
    rightThumbProximal: "rightThumbMetacarpal",
    rightThumbDistal: "rightThumbProximal",
    rightIndexProximal: "rightHand",
    rightIndexIntermediate: "rightIndexProximal",
    rightIndexDistal: "rightIndexIntermediate",
    rightMiddleProximal: "rightHand",
    rightMiddleIntermediate: "rightMiddleProximal",
    rightMiddleDistal: "rightMiddleIntermediate",
    rightRingProximal: "rightHand",
    rightRingIntermediate: "rightRingProximal",
    rightRingDistal: "rightRingIntermediate",
    rightLittleProximal: "rightHand",
    rightLittleIntermediate: "rightLittleProximal",
    rightLittleDistal: "rightLittleIntermediate"
};
function gG(n) {
    return n.invert ? n.invert() : n.inverse(),
    n
}
var KA = new $
  , XA = new nt
  , iT = class {
    constructor(n) {
        this.humanBones = n,
        this.restPose = this.getAbsolutePose()
    }
    getAbsolutePose() {
        const n = {};
        return Object.keys(this.humanBones).forEach(e => {
            const t = e
              , r = this.getBoneNode(t);
            r && (KA.copy(r.position),
            XA.copy(r.quaternion),
            n[t] = {
                position: KA.toArray(),
                rotation: XA.toArray()
            })
        }
        ),
        n
    }
    getPose() {
        const n = {};
        return Object.keys(this.humanBones).forEach(e => {
            const t = e
              , r = this.getBoneNode(t);
            if (!r)
                return;
            KA.set(0, 0, 0),
            XA.identity();
            const i = this.restPose[t];
            i != null && i.position && KA.fromArray(i.position).negate(),
            i != null && i.rotation && gG(XA.fromArray(i.rotation)),
            KA.add(r.position),
            XA.premultiply(r.quaternion),
            n[t] = {
                position: KA.toArray(),
                rotation: XA.toArray()
            }
        }
        ),
        n
    }
    setPose(n) {
        Object.entries(n).forEach( ([e,t]) => {
            const r = e
              , i = this.getBoneNode(r);
            if (!i)
                return;
            const s = this.restPose[r];
            s && (t != null && t.position && (i.position.fromArray(t.position),
            s.position && i.position.add(KA.fromArray(s.position))),
            t != null && t.rotation && (i.quaternion.fromArray(t.rotation),
            s.rotation && i.quaternion.multiply(XA.fromArray(s.rotation))))
        }
        )
    }
    resetPose() {
        Object.entries(this.restPose).forEach( ([n,e]) => {
            const t = this.getBoneNode(n);
            t && (e != null && e.position && t.position.fromArray(e.position),
            e != null && e.rotation && t.quaternion.fromArray(e.rotation))
        }
        )
    }
    getBone(n) {
        var e;
        return (e = this.humanBones[n]) != null ? e : void 0
    }
    getBoneNode(n) {
        var e, t;
        return (t = (e = this.humanBones[n]) == null ? void 0 : e.node) != null ? t : null
    }
}
  , FB = new $
  , Ohe = new nt
  , khe = new $
  , GN = class vG extends iT {
    static _setupTransforms(e) {
        const t = new Lt;
        t.name = "VRMHumanoidRig";
        const r = {}
          , i = {}
          , s = {};
        UB.forEach(a => {
            var l;
            const c = e.getBoneNode(a);
            if (c) {
                const A = new $
                  , u = new nt;
                c.updateWorldMatrix(!0, !1),
                c.matrixWorld.decompose(A, u, FB),
                r[a] = A,
                i[a] = c.quaternion.clone();
                const f = new nt;
                (l = c.parent) == null || l.matrixWorld.decompose(FB, f, FB),
                s[a] = f
            }
        }
        );
        const o = {};
        return UB.forEach(a => {
            var l;
            const c = e.getBoneNode(a);
            if (c) {
                const A = r[a];
                let u = a, f;
                for (; f == null && (u = Nhe[u],
                u != null); )
                    f = r[u];
                const h = new Lt;
                h.name = "Normalized_" + c.name,
                (u ? (l = o[u]) == null ? void 0 : l.node : t).add(h),
                h.position.copy(A),
                f && h.position.sub(f),
                o[a] = {
                    node: h
                }
            }
        }
        ),
        {
            rigBones: o,
            root: t,
            parentWorldRotations: s,
            boneRotations: i
        }
    }
    constructor(e) {
        const {rigBones: t, root: r, parentWorldRotations: i, boneRotations: s} = vG._setupTransforms(e);
        super(t),
        this.original = e,
        this.root = r,
        this._parentWorldRotations = i,
        this._boneRotations = s
    }
    update() {
        UB.forEach(e => {
            const t = this.original.getBoneNode(e);
            if (t != null) {
                const r = this.getBoneNode(e)
                  , i = this._parentWorldRotations[e]
                  , s = Ohe.copy(i).invert()
                  , o = this._boneRotations[e];
                if (t.quaternion.copy(r.quaternion).multiply(i).premultiply(s).multiply(o),
                e === "hips") {
                    const a = r.getWorldPosition(khe);
                    t.parent.updateWorldMatrix(!0, !1);
                    const l = t.parent.matrixWorld
                      , c = a.applyMatrix4(l.invert());
                    t.position.copy(c)
                }
            }
        }
        )
    }
}
  , VN = class yG {
    get restPose() {
        return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),
        this.rawRestPose
    }
    get rawRestPose() {
        return this._rawHumanBones.restPose
    }
    get normalizedRestPose() {
        return this._normalizedHumanBones.restPose
    }
    get humanBones() {
        return this._rawHumanBones.humanBones
    }
    get rawHumanBones() {
        return this._rawHumanBones.humanBones
    }
    get normalizedHumanBones() {
        return this._normalizedHumanBones.humanBones
    }
    get normalizedHumanBonesRoot() {
        return this._normalizedHumanBones.root
    }
    constructor(e, t) {
        var r;
        this.autoUpdateHumanBones = (r = t == null ? void 0 : t.autoUpdateHumanBones) != null ? r : !0,
        this._rawHumanBones = new iT(e),
        this._normalizedHumanBones = new GN(this._rawHumanBones)
    }
    copy(e) {
        return this.autoUpdateHumanBones = e.autoUpdateHumanBones,
        this._rawHumanBones = new iT(e.humanBones),
        this._normalizedHumanBones = new GN(this._rawHumanBones),
        this
    }
    clone() {
        return new yG(this.humanBones,{
            autoUpdateHumanBones: this.autoUpdateHumanBones
        }).copy(this)
    }
    getAbsolutePose() {
        return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),
        this.getRawAbsolutePose()
    }
    getRawAbsolutePose() {
        return this._rawHumanBones.getAbsolutePose()
    }
    getNormalizedAbsolutePose() {
        return this._normalizedHumanBones.getAbsolutePose()
    }
    getPose() {
        return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),
        this.getRawPose()
    }
    getRawPose() {
        return this._rawHumanBones.getPose()
    }
    getNormalizedPose() {
        return this._normalizedHumanBones.getPose()
    }
    setPose(e) {
        return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),
        this.setRawPose(e)
    }
    setRawPose(e) {
        return this._rawHumanBones.setPose(e)
    }
    setNormalizedPose(e) {
        return this._normalizedHumanBones.setPose(e)
    }
    resetPose() {
        return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),
        this.resetRawPose()
    }
    resetRawPose() {
        return this._rawHumanBones.resetPose()
    }
    resetNormalizedPose() {
        return this._normalizedHumanBones.resetPose()
    }
    getBone(e) {
        return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),
        this.getRawBone(e)
    }
    getRawBone(e) {
        return this._rawHumanBones.getBone(e)
    }
    getNormalizedBone(e) {
        return this._normalizedHumanBones.getBone(e)
    }
    getBoneNode(e) {
        return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),
        this.getRawBoneNode(e)
    }
    getRawBoneNode(e) {
        return this._rawHumanBones.getBoneNode(e)
    }
    getNormalizedBoneNode(e) {
        return this._normalizedHumanBones.getBoneNode(e)
    }
    update() {
        this.autoUpdateHumanBones && this._normalizedHumanBones.update()
    }
}
  , Qhe = {
    Hips: "hips",
    Spine: "spine",
    Head: "head",
    LeftUpperLeg: "leftUpperLeg",
    LeftLowerLeg: "leftLowerLeg",
    LeftFoot: "leftFoot",
    RightUpperLeg: "rightUpperLeg",
    RightLowerLeg: "rightLowerLeg",
    RightFoot: "rightFoot",
    LeftUpperArm: "leftUpperArm",
    LeftLowerArm: "leftLowerArm",
    LeftHand: "leftHand",
    RightUpperArm: "rightUpperArm",
    RightLowerArm: "rightLowerArm",
    RightHand: "rightHand"
}
  , Hhe = new Set(["1.0", "1.0-beta"])
  , jN = {
    leftThumbProximal: "leftThumbMetacarpal",
    leftThumbIntermediate: "leftThumbProximal",
    rightThumbProximal: "rightThumbMetacarpal",
    rightThumbIntermediate: "rightThumbProximal"
}
  , zhe = class {
    get name() {
        return "VRMHumanoidLoaderPlugin"
    }
    constructor(n, e) {
        this.parser = n,
        this.helperRoot = e == null ? void 0 : e.helperRoot,
        this.autoUpdateHumanBones = e == null ? void 0 : e.autoUpdateHumanBones
    }
    afterRoot(n) {
        return $t(this, null, function*() {
            n.userData.vrmHumanoid = yield this._import(n)
        })
    }
    _import(n) {
        return $t(this, null, function*() {
            const e = yield this._v1Import(n);
            if (e)
                return e;
            const t = yield this._v0Import(n);
            return t || null
        })
    }
    _v1Import(n) {
        return $t(this, null, function*() {
            var e, t;
            const r = this.parser.json;
            if (!(((e = r.extensionsUsed) == null ? void 0 : e.indexOf("VRMC_vrm")) !== -1))
                return null;
            const s = (t = r.extensions) == null ? void 0 : t.VRMC_vrm;
            if (!s)
                return null;
            const o = s.specVersion;
            if (!Hhe.has(o))
                return console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${o}"`),
                null;
            const a = s.humanoid;
            if (!a)
                return null;
            const l = a.humanBones.leftThumbIntermediate != null || a.humanBones.rightThumbIntermediate != null
              , c = {};
            a.humanBones != null && (yield Promise.all(Object.entries(a.humanBones).map(u => $t(this, [u], function*([f,h]) {
                let d = f;
                const m = h.node;
                if (l) {
                    const p = jN[d];
                    p != null && (d = p)
                }
                const g = yield this.parser.getDependency("node", m);
                if (g == null) {
                    console.warn(`A glTF node bound to the humanoid bone ${d} (index = ${m}) does not exist`);
                    return
                }
                c[d] = {
                    node: g
                }
            }))));
            const A = new VN(this._ensureRequiredBonesExist(c),{
                autoUpdateHumanBones: this.autoUpdateHumanBones
            });
            if (n.scene.add(A.normalizedHumanBonesRoot),
            this.helperRoot) {
                const u = new zN(A);
                this.helperRoot.add(u),
                u.renderOrder = this.helperRoot.renderOrder
            }
            return A
        })
    }
    _v0Import(n) {
        return $t(this, null, function*() {
            var e;
            const r = (e = this.parser.json.extensions) == null ? void 0 : e.VRM;
            if (!r)
                return null;
            const i = r.humanoid;
            if (!i)
                return null;
            const s = {};
            i.humanBones != null && (yield Promise.all(i.humanBones.map(a => $t(this, null, function*() {
                const l = a.bone
                  , c = a.node;
                if (l == null || c == null)
                    return;
                const A = yield this.parser.getDependency("node", c);
                if (A == null) {
                    console.warn(`A glTF node bound to the humanoid bone ${l} (index = ${c}) does not exist`);
                    return
                }
                const u = jN[l]
                  , f = u ?? l;
                if (s[f] != null) {
                    console.warn(`Multiple bone entries for ${f} detected (index = ${c}), ignoring duplicated entries.`);
                    return
                }
                s[f] = {
                    node: A
                }
            }))));
            const o = new VN(this._ensureRequiredBonesExist(s),{
                autoUpdateHumanBones: this.autoUpdateHumanBones
            });
            if (n.scene.add(o.normalizedHumanBonesRoot),
            this.helperRoot) {
                const a = new zN(o);
                this.helperRoot.add(a),
                a.renderOrder = this.helperRoot.renderOrder
            }
            return o
        })
    }
    _ensureRequiredBonesExist(n) {
        const e = Object.values(Qhe).filter(t => n[t] == null);
        if (e.length > 0)
            throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${e.join(", ")}`);
        return n
    }
}
  , WN = class extends Jt {
    constructor() {
        super(),
        this._currentTheta = 0,
        this._currentRadius = 0,
        this.theta = 0,
        this.radius = 0,
        this._currentTheta = 0,
        this._currentRadius = 0,
        this._attrPos = new ct(new Float32Array(65 * 3),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(3 * 63),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        this._currentTheta !== this.theta && (this._currentTheta = this.theta,
        n = !0),
        this._currentRadius !== this.radius && (this._currentRadius = this.radius,
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        this._attrPos.setXYZ(0, 0, 0, 0);
        for (let n = 0; n < 64; n++) {
            const e = n / 63 * this._currentTheta;
            this._attrPos.setXYZ(n + 1, this._currentRadius * Math.sin(e), 0, this._currentRadius * Math.cos(e))
        }
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        for (let n = 0; n < 63; n++)
            this._attrIndex.setXYZ(n * 3, 0, n + 1, n + 2);
        this._attrIndex.needsUpdate = !0
    }
}
  , Ghe = class extends Jt {
    constructor() {
        super(),
        this.radius = 0,
        this._currentRadius = 0,
        this.tail = new $,
        this._currentTail = new $,
        this._attrPos = new ct(new Float32Array(294),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(194),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        this._currentRadius !== this.radius && (this._currentRadius = this.radius,
        n = !0),
        this._currentTail.equals(this.tail) || (this._currentTail.copy(this.tail),
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        for (let n = 0; n < 32; n++) {
            const e = n / 16 * Math.PI;
            this._attrPos.setXYZ(n, Math.cos(e), Math.sin(e), 0),
            this._attrPos.setXYZ(32 + n, 0, Math.cos(e), Math.sin(e)),
            this._attrPos.setXYZ(64 + n, Math.sin(e), 0, Math.cos(e))
        }
        this.scale(this._currentRadius, this._currentRadius, this._currentRadius),
        this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z),
        this._attrPos.setXYZ(96, 0, 0, 0),
        this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z),
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        for (let n = 0; n < 32; n++) {
            const e = (n + 1) % 32;
            this._attrIndex.setXY(n * 2, n, e),
            this._attrIndex.setXY(64 + n * 2, 32 + n, 32 + e),
            this._attrIndex.setXY(128 + n * 2, 64 + n, 64 + e)
        }
        this._attrIndex.setXY(192, 96, 97),
        this._attrIndex.needsUpdate = !0
    }
}
  , gy = new nt
  , KN = new nt
  , Wp = new $
  , XN = new $
  , YN = Math.sqrt(2) / 2
  , Vhe = new nt(0,0,-YN,YN)
  , jhe = new $(0,1,0)
  , Whe = class extends ri {
    constructor(n) {
        super(),
        this.matrixAutoUpdate = !1,
        this.vrmLookAt = n;
        {
            const e = new WN;
            e.radius = .5;
            const t = new qi({
                color: 65280,
                transparent: !0,
                opacity: .5,
                side: _i,
                depthTest: !1,
                depthWrite: !1
            });
            this._meshPitch = new dn(e,t),
            this.add(this._meshPitch)
        }
        {
            const e = new WN;
            e.radius = .5;
            const t = new qi({
                color: 16711680,
                transparent: !0,
                opacity: .5,
                side: _i,
                depthTest: !1,
                depthWrite: !1
            });
            this._meshYaw = new dn(e,t),
            this.add(this._meshYaw)
        }
        {
            const e = new Ghe;
            e.radius = .1;
            const t = new Ac({
                color: 16777215,
                depthTest: !1,
                depthWrite: !1
            });
            this._lineTarget = new w0(e,t),
            this._lineTarget.frustumCulled = !1,
            this.add(this._lineTarget)
        }
    }
    dispose() {
        this._meshYaw.geometry.dispose(),
        this._meshYaw.material.dispose(),
        this._meshPitch.geometry.dispose(),
        this._meshPitch.material.dispose(),
        this._lineTarget.geometry.dispose(),
        this._lineTarget.material.dispose()
    }
    updateMatrixWorld(n) {
        const e = Bt.DEG2RAD * this.vrmLookAt.yaw;
        this._meshYaw.geometry.theta = e,
        this._meshYaw.geometry.update();
        const t = Bt.DEG2RAD * this.vrmLookAt.pitch;
        this._meshPitch.geometry.theta = t,
        this._meshPitch.geometry.update(),
        this.vrmLookAt.getLookAtWorldPosition(Wp),
        this.vrmLookAt.getLookAtWorldQuaternion(gy),
        gy.multiply(this.vrmLookAt.getFaceFrontQuaternion(KN)),
        this._meshYaw.position.copy(Wp),
        this._meshYaw.quaternion.copy(gy),
        this._meshPitch.position.copy(Wp),
        this._meshPitch.quaternion.copy(gy),
        this._meshPitch.quaternion.multiply(KN.setFromAxisAngle(jhe, e)),
        this._meshPitch.quaternion.multiply(Vhe);
        const {target: r, autoUpdate: i} = this.vrmLookAt;
        r != null && i && (r.getWorldPosition(XN).sub(Wp),
        this._lineTarget.geometry.tail.copy(XN),
        this._lineTarget.geometry.update(),
        this._lineTarget.position.copy(Wp)),
        super.updateMatrixWorld(n)
    }
}
  , Khe = new $
  , Xhe = new $;
function sT(n, e) {
    return n.matrixWorld.decompose(Khe, e, Xhe),
    e
}
function Uw(n) {
    return [Math.atan2(-n.z, n.x), Math.atan2(n.y, Math.sqrt(n.x * n.x + n.z * n.z))]
}
function $N(n) {
    const e = Math.round(n / 2 / Math.PI);
    return n - 2 * Math.PI * e
}
var ZN = new $(0,0,1)
  , Yhe = new $
  , $he = new $
  , Zhe = new $
  , Jhe = new nt
  , PB = new nt
  , JN = new nt
  , qhe = new nt
  , LB = new nr
  , wG = class _G {
    constructor(e, t) {
        this.offsetFromHeadBone = new $,
        this.autoUpdate = !0,
        this.faceFront = new $(0,0,1),
        this.humanoid = e,
        this.applier = t,
        this._yaw = 0,
        this._pitch = 0,
        this._needsUpdate = !0,
        this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new nt)
    }
    get yaw() {
        return this._yaw
    }
    set yaw(e) {
        this._yaw = e,
        this._needsUpdate = !0
    }
    get pitch() {
        return this._pitch
    }
    set pitch(e) {
        this._pitch = e,
        this._needsUpdate = !0
    }
    get euler() {
        return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),
        this.getEuler(new nr)
    }
    getEuler(e) {
        return e.set(Bt.DEG2RAD * this._pitch, Bt.DEG2RAD * this._yaw, 0, "YXZ")
    }
    copy(e) {
        if (this.humanoid !== e.humanoid)
            throw new Error("VRMLookAt: humanoid must be same in order to copy");
        return this.offsetFromHeadBone.copy(e.offsetFromHeadBone),
        this.applier = e.applier,
        this.autoUpdate = e.autoUpdate,
        this.target = e.target,
        this.faceFront.copy(e.faceFront),
        this
    }
    clone() {
        return new _G(this.humanoid,this.applier).copy(this)
    }
    reset() {
        this._yaw = 0,
        this._pitch = 0,
        this._needsUpdate = !0
    }
    getLookAtWorldPosition(e) {
        const t = this.humanoid.getRawBoneNode("head");
        return e.copy(this.offsetFromHeadBone).applyMatrix4(t.matrixWorld)
    }
    getLookAtWorldQuaternion(e) {
        const t = this.humanoid.getRawBoneNode("head");
        return sT(t, e)
    }
    getFaceFrontQuaternion(e) {
        if (this.faceFront.distanceToSquared(ZN) < .01)
            return e.copy(this._restHeadWorldQuaternion).invert();
        const [t,r] = Uw(this.faceFront);
        return LB.set(0, .5 * Math.PI + t, r, "YZX"),
        e.setFromEuler(LB).premultiply(qhe.copy(this._restHeadWorldQuaternion).invert())
    }
    getLookAtWorldDirection(e) {
        return this.getLookAtWorldQuaternion(PB),
        this.getFaceFrontQuaternion(JN),
        e.copy(ZN).applyQuaternion(PB).applyQuaternion(JN).applyEuler(this.getEuler(LB))
    }
    lookAt(e) {
        const t = Jhe.copy(this._restHeadWorldQuaternion).multiply(gG(this.getLookAtWorldQuaternion(PB)))
          , r = this.getLookAtWorldPosition($he)
          , i = Zhe.copy(e).sub(r).applyQuaternion(t).normalize()
          , [s,o] = Uw(this.faceFront)
          , [a,l] = Uw(i)
          , c = $N(a - s)
          , A = $N(o - l);
        this._yaw = Bt.RAD2DEG * c,
        this._pitch = Bt.RAD2DEG * A,
        this._needsUpdate = !0
    }
    update(e) {
        this.target != null && this.autoUpdate && this.lookAt(this.target.getWorldPosition(Yhe)),
        this._needsUpdate && (this._needsUpdate = !1,
        this.applier.applyYawPitch(this._yaw, this._pitch))
    }
}
;
wG.EULER_ORDER = "YXZ";
var ede = wG
  , tde = new $(0,0,1)
  , ya = new nt
  , Ff = new nt
  , Zs = new nr(0,0,0,"YXZ")
  , Fw = class {
    constructor(n, e, t, r, i) {
        this.humanoid = n,
        this.rangeMapHorizontalInner = e,
        this.rangeMapHorizontalOuter = t,
        this.rangeMapVerticalDown = r,
        this.rangeMapVerticalUp = i,
        this.faceFront = new $(0,0,1),
        this._restQuatLeftEye = new nt,
        this._restQuatRightEye = new nt,
        this._restLeftEyeParentWorldQuat = new nt,
        this._restRightEyeParentWorldQuat = new nt;
        const s = this.humanoid.getRawBoneNode("leftEye")
          , o = this.humanoid.getRawBoneNode("rightEye");
        s && (this._restQuatLeftEye.copy(s.quaternion),
        sT(s.parent, this._restLeftEyeParentWorldQuat)),
        o && (this._restQuatRightEye.copy(o.quaternion),
        sT(o.parent, this._restRightEyeParentWorldQuat))
    }
    applyYawPitch(n, e) {
        const t = this.humanoid.getRawBoneNode("leftEye")
          , r = this.humanoid.getRawBoneNode("rightEye")
          , i = this.humanoid.getNormalizedBoneNode("leftEye")
          , s = this.humanoid.getNormalizedBoneNode("rightEye");
        t && (e < 0 ? Zs.x = -Bt.DEG2RAD * this.rangeMapVerticalDown.map(-e) : Zs.x = Bt.DEG2RAD * this.rangeMapVerticalUp.map(e),
        n < 0 ? Zs.y = -Bt.DEG2RAD * this.rangeMapHorizontalInner.map(-n) : Zs.y = Bt.DEG2RAD * this.rangeMapHorizontalOuter.map(n),
        ya.setFromEuler(Zs),
        this._getWorldFaceFrontQuat(Ff),
        i.quaternion.copy(Ff).multiply(ya).multiply(Ff.invert()),
        ya.copy(this._restLeftEyeParentWorldQuat),
        t.quaternion.copy(i.quaternion).multiply(ya).premultiply(ya.invert()).multiply(this._restQuatLeftEye)),
        r && (e < 0 ? Zs.x = -Bt.DEG2RAD * this.rangeMapVerticalDown.map(-e) : Zs.x = Bt.DEG2RAD * this.rangeMapVerticalUp.map(e),
        n < 0 ? Zs.y = -Bt.DEG2RAD * this.rangeMapHorizontalOuter.map(-n) : Zs.y = Bt.DEG2RAD * this.rangeMapHorizontalInner.map(n),
        ya.setFromEuler(Zs),
        this._getWorldFaceFrontQuat(Ff),
        s.quaternion.copy(Ff).multiply(ya).multiply(Ff.invert()),
        ya.copy(this._restRightEyeParentWorldQuat),
        r.quaternion.copy(s.quaternion).multiply(ya).premultiply(ya.invert()).multiply(this._restQuatRightEye))
    }
    lookAt(n) {
        console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
        const e = Bt.RAD2DEG * n.y
          , t = Bt.RAD2DEG * n.x;
        this.applyYawPitch(e, t)
    }
    _getWorldFaceFrontQuat(n) {
        if (this.faceFront.distanceToSquared(tde) < .01)
            return n.identity();
        const [e,t] = Uw(this.faceFront);
        return Zs.set(0, .5 * Math.PI + e, t, "YZX"),
        n.setFromEuler(Zs)
    }
}
;
Fw.type = "bone";
var oT = class {
    constructor(n, e, t, r, i) {
        this.expressions = n,
        this.rangeMapHorizontalInner = e,
        this.rangeMapHorizontalOuter = t,
        this.rangeMapVerticalDown = r,
        this.rangeMapVerticalUp = i
    }
    applyYawPitch(n, e) {
        e < 0 ? (this.expressions.setValue("lookDown", 0),
        this.expressions.setValue("lookUp", this.rangeMapVerticalUp.map(-e))) : (this.expressions.setValue("lookUp", 0),
        this.expressions.setValue("lookDown", this.rangeMapVerticalDown.map(e))),
        n < 0 ? (this.expressions.setValue("lookLeft", 0),
        this.expressions.setValue("lookRight", this.rangeMapHorizontalOuter.map(-n))) : (this.expressions.setValue("lookRight", 0),
        this.expressions.setValue("lookLeft", this.rangeMapHorizontalOuter.map(n)))
    }
    lookAt(n) {
        console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
        const e = Bt.RAD2DEG * n.y
          , t = Bt.RAD2DEG * n.x;
        this.applyYawPitch(e, t)
    }
}
;
oT.type = "expression";
var qN = class {
    constructor(n, e) {
        this.inputMaxValue = n,
        this.outputScale = e
    }
    map(n) {
        return this.outputScale * cG(n / this.inputMaxValue)
    }
}
  , nde = new Set(["1.0", "1.0-beta"])
  , vy = .01
  , rde = class {
    get name() {
        return "VRMLookAtLoaderPlugin"
    }
    constructor(n, e) {
        this.parser = n,
        this.helperRoot = e == null ? void 0 : e.helperRoot
    }
    afterRoot(n) {
        return $t(this, null, function*() {
            const e = n.userData.vrmHumanoid;
            if (e === null)
                return;
            if (e === void 0)
                throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");
            const t = n.userData.vrmExpressionManager;
            if (t !== null) {
                if (t === void 0)
                    throw new Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");
                n.userData.vrmLookAt = yield this._import(n, e, t)
            }
        })
    }
    _import(n, e, t) {
        return $t(this, null, function*() {
            if (e == null || t == null)
                return null;
            const r = yield this._v1Import(n, e, t);
            if (r)
                return r;
            const i = yield this._v0Import(n, e, t);
            return i || null
        })
    }
    _v1Import(n, e, t) {
        return $t(this, null, function*() {
            var r, i, s;
            const o = this.parser.json;
            if (!(((r = o.extensionsUsed) == null ? void 0 : r.indexOf("VRMC_vrm")) !== -1))
                return null;
            const l = (i = o.extensions) == null ? void 0 : i.VRMC_vrm;
            if (!l)
                return null;
            const c = l.specVersion;
            if (!nde.has(c))
                return console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${c}"`),
                null;
            const A = l.lookAt;
            if (!A)
                return null;
            const u = A.type === "expression" ? 1 : 10
              , f = this._v1ImportRangeMap(A.rangeMapHorizontalInner, u)
              , h = this._v1ImportRangeMap(A.rangeMapHorizontalOuter, u)
              , d = this._v1ImportRangeMap(A.rangeMapVerticalDown, u)
              , m = this._v1ImportRangeMap(A.rangeMapVerticalUp, u);
            let g;
            A.type === "expression" ? g = new oT(t,f,h,d,m) : g = new Fw(e,f,h,d,m);
            const p = this._importLookAt(e, g);
            return p.offsetFromHeadBone.fromArray((s = A.offsetFromHeadBone) != null ? s : [0, .06, 0]),
            p
        })
    }
    _v1ImportRangeMap(n, e) {
        var t, r;
        let i = (t = n == null ? void 0 : n.inputMaxValue) != null ? t : 90;
        const s = (r = n == null ? void 0 : n.outputScale) != null ? r : e;
        return i < vy && (console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),
        i = vy),
        new qN(i,s)
    }
    _v0Import(n, e, t) {
        return $t(this, null, function*() {
            var r, i, s, o;
            const l = (r = this.parser.json.extensions) == null ? void 0 : r.VRM;
            if (!l)
                return null;
            const c = l.firstPerson;
            if (!c)
                return null;
            const A = c.lookAtTypeName === "BlendShape" ? 1 : 10
              , u = this._v0ImportDegreeMap(c.lookAtHorizontalInner, A)
              , f = this._v0ImportDegreeMap(c.lookAtHorizontalOuter, A)
              , h = this._v0ImportDegreeMap(c.lookAtVerticalDown, A)
              , d = this._v0ImportDegreeMap(c.lookAtVerticalUp, A);
            let m;
            c.lookAtTypeName === "BlendShape" ? m = new oT(t,u,f,h,d) : m = new Fw(e,u,f,h,d);
            const g = this._importLookAt(e, m);
            return c.firstPersonBoneOffset ? g.offsetFromHeadBone.set((i = c.firstPersonBoneOffset.x) != null ? i : 0, (s = c.firstPersonBoneOffset.y) != null ? s : .06, -((o = c.firstPersonBoneOffset.z) != null ? o : 0)) : g.offsetFromHeadBone.set(0, .06, 0),
            g.faceFront.set(0, 0, -1),
            m instanceof Fw && m.faceFront.set(0, 0, -1),
            g
        })
    }
    _v0ImportDegreeMap(n, e) {
        var t, r;
        const i = n == null ? void 0 : n.curve;
        JSON.stringify(i) !== "[0,0,0,1,1,1,1,0]" && console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");
        let s = (t = n == null ? void 0 : n.xRange) != null ? t : 90;
        const o = (r = n == null ? void 0 : n.yRange) != null ? r : e;
        return s < vy && (console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),
        s = vy),
        new qN(s,o)
    }
    _importLookAt(n, e) {
        const t = new ede(n,e);
        if (this.helperRoot) {
            const r = new Whe(t);
            this.helperRoot.add(r),
            r.renderOrder = this.helperRoot.renderOrder
        }
        return t
    }
}
;
function ide(n, e) {
    return typeof n != "string" || n === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(n) && (e = e.replace(/(^https?:\/\/[^/]+).*/i, "$1")),
    /^(https?:)?\/\//i.test(n) || /^data:.*,.*$/i.test(n) || /^blob:.*$/i.test(n) ? n : e + n)
}
var sde = new Set(["1.0", "1.0-beta"])
  , ode = class {
    get name() {
        return "VRMMetaLoaderPlugin"
    }
    constructor(n, e) {
        var t, r, i;
        this.parser = n,
        this.needThumbnailImage = (t = e == null ? void 0 : e.needThumbnailImage) != null ? t : !1,
        this.acceptLicenseUrls = (r = e == null ? void 0 : e.acceptLicenseUrls) != null ? r : ["https://vrm.dev/licenses/1.0/"],
        this.acceptV0Meta = (i = e == null ? void 0 : e.acceptV0Meta) != null ? i : !0
    }
    afterRoot(n) {
        return $t(this, null, function*() {
            n.userData.vrmMeta = yield this._import(n)
        })
    }
    _import(n) {
        return $t(this, null, function*() {
            const e = yield this._v1Import(n);
            if (e != null)
                return e;
            const t = yield this._v0Import(n);
            return t ?? null
        })
    }
    _v1Import(n) {
        return $t(this, null, function*() {
            var e, t, r;
            const i = this.parser.json;
            if (!(((e = i.extensionsUsed) == null ? void 0 : e.indexOf("VRMC_vrm")) !== -1))
                return null;
            const o = (t = i.extensions) == null ? void 0 : t.VRMC_vrm;
            if (o == null)
                return null;
            const a = o.specVersion;
            if (!sde.has(a))
                return console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),
                null;
            const l = o.meta;
            if (!l)
                return null;
            const c = l.licenseUrl;
            if (!new Set(this.acceptLicenseUrls).has(c))
                throw new Error(`VRMMetaLoaderPlugin: The license url "${c}" is not accepted`);
            let u;
            return this.needThumbnailImage && l.thumbnailImage != null && (u = (r = yield this._extractGLTFImage(l.thumbnailImage)) != null ? r : void 0),
            {
                metaVersion: "1",
                name: l.name,
                version: l.version,
                authors: l.authors,
                copyrightInformation: l.copyrightInformation,
                contactInformation: l.contactInformation,
                references: l.references,
                thirdPartyLicenses: l.thirdPartyLicenses,
                thumbnailImage: u,
                licenseUrl: l.licenseUrl,
                avatarPermission: l.avatarPermission,
                allowExcessivelyViolentUsage: l.allowExcessivelyViolentUsage,
                allowExcessivelySexualUsage: l.allowExcessivelySexualUsage,
                commercialUsage: l.commercialUsage,
                allowPoliticalOrReligiousUsage: l.allowPoliticalOrReligiousUsage,
                allowAntisocialOrHateUsage: l.allowAntisocialOrHateUsage,
                creditNotation: l.creditNotation,
                allowRedistribution: l.allowRedistribution,
                modification: l.modification,
                otherLicenseUrl: l.otherLicenseUrl
            }
        })
    }
    _v0Import(n) {
        return $t(this, null, function*() {
            var e;
            const r = (e = this.parser.json.extensions) == null ? void 0 : e.VRM;
            if (!r)
                return null;
            const i = r.meta;
            if (!i)
                return null;
            if (!this.acceptV0Meta)
                throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");
            let s;
            return this.needThumbnailImage && i.texture != null && i.texture !== -1 && (s = yield this.parser.getDependency("texture", i.texture)),
            {
                metaVersion: "0",
                allowedUserName: i.allowedUserName,
                author: i.author,
                commercialUssageName: i.commercialUssageName,
                contactInformation: i.contactInformation,
                licenseName: i.licenseName,
                otherLicenseUrl: i.otherLicenseUrl,
                otherPermissionUrl: i.otherPermissionUrl,
                reference: i.reference,
                sexualUssageName: i.sexualUssageName,
                texture: s ?? void 0,
                title: i.title,
                version: i.version,
                violentUssageName: i.violentUssageName
            }
        })
    }
    _extractGLTFImage(n) {
        return $t(this, null, function*() {
            var e;
            const r = (e = this.parser.json.images) == null ? void 0 : e[n];
            if (r == null)
                return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${n}] of glTF as a thumbnail but the image doesn't exist`),
                null;
            let i = r.uri;
            if (r.bufferView != null) {
                const o = yield this.parser.getDependency("bufferView", r.bufferView)
                  , a = new Blob([o],{
                    type: r.mimeType
                });
                i = URL.createObjectURL(a)
            }
            return i == null ? (console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${n}] of glTF as a thumbnail but the image couldn't load properly`),
            null) : yield new zz().loadAsync(ide(i, this.parser.options.path)).catch(o => (console.error(o),
            console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),
            null))
        })
    }
}
  , ade = class {
    constructor(n) {
        this.scene = n.scene,
        this.meta = n.meta,
        this.humanoid = n.humanoid,
        this.expressionManager = n.expressionManager,
        this.firstPerson = n.firstPerson,
        this.lookAt = n.lookAt
    }
    update(n) {
        this.humanoid.update(),
        this.lookAt && this.lookAt.update(n),
        this.expressionManager && this.expressionManager.update()
    }
}
  , lde = class extends ade {
    constructor(n) {
        super(n),
        this.materials = n.materials,
        this.springBoneManager = n.springBoneManager,
        this.nodeConstraintManager = n.nodeConstraintManager
    }
    update(n) {
        super.update(n),
        this.nodeConstraintManager && this.nodeConstraintManager.update(),
        this.springBoneManager && this.springBoneManager.update(n),
        this.materials && this.materials.forEach(e => {
            e.update && e.update(n)
        }
        )
    }
}
  , cde = Object.defineProperty
  , eO = Object.getOwnPropertySymbols
  , Ade = Object.prototype.hasOwnProperty
  , ude = Object.prototype.propertyIsEnumerable
  , tO = (n, e, t) => e in n ? cde(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , nO = (n, e) => {
    for (var t in e || (e = {}))
        Ade.call(e, t) && tO(n, t, e[t]);
    if (eO)
        for (var t of eO(e))
            ude.call(e, t) && tO(n, t, e[t]);
    return n
}
  , pu = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , fde = {
    "": 3e3,
    srgb: 3001
};
function hde(n, e) {
    parseInt(nc, 10) >= 152 ? n.colorSpace = e : n.encoding = fde[e]
}
var dde = class {
    get pending() {
        return Promise.all(this._pendings)
    }
    constructor(n, e) {
        this._parser = n,
        this._materialParams = e,
        this._pendings = []
    }
    assignPrimitive(n, e) {
        e != null && (this._materialParams[n] = e)
    }
    assignColor(n, e, t) {
        e != null && (this._materialParams[n] = new Qe().fromArray(e),
        t && this._materialParams[n].convertSRGBToLinear())
    }
    assignTexture(n, e, t) {
        return pu(this, null, function*() {
            const r = ( () => pu(this, null, function*() {
                e != null && (yield this._parser.assignTexture(this._materialParams, n, e),
                t && hde(this._materialParams[n], "srgb"))
            }))();
            return this._pendings.push(r),
            r
        })
    }
    assignTextureByIndex(n, e, t) {
        return pu(this, null, function*() {
            return this.assignTexture(n, e != null ? {
                index: e
            } : void 0, t)
        })
    }
}
  , pde = `// #define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif

#include <common>

// #include <uv_pars_vertex>
#ifdef MTOON_USE_UV
  varying vec2 vUv;

  // COMPAT: pre-r151 uses a common uvTransform
  #if THREE_VRM_THREE_REVISION < 151
    uniform mat3 uvTransform;
  #endif
#endif

// #include <uv2_pars_vertex>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
    uniform mat3 uv2Transform;
  #endif
#endif

// #include <displacementmap_pars_vertex>
// #include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
  uniform sampler2D outlineWidthMultiplyTexture;
  uniform mat3 outlineWidthMultiplyTextureUvTransform;
#endif

uniform float outlineWidthFactor;

void main() {

  // #include <uv_vertex>
  #ifdef MTOON_USE_UV
    // COMPAT: pre-r151 uses a common uvTransform
    #if THREE_VRM_THREE_REVISION >= 151
      vUv = uv;
    #else
      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
  #endif

  // #include <uv2_vertex>
  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap
  #if THREE_VRM_THREE_REVISION < 151
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
    #endif
  #endif

  #include <color_vertex>

  #include <beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>

  // we need this to compute the outline properly
  objectNormal = normalize( objectNormal );

  #include <defaultnormal_vertex>

  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
    vNormal = normalize( transformedNormal );
  #endif

  #include <begin_vertex>

  #include <morphtarget_vertex>
  #include <skinning_vertex>
  // #include <displacementmap_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>

  vViewPosition = - mvPosition.xyz;

  #ifdef OUTLINE
    float worldNormalLength = length( transformedNormal );
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;

    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;
      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;
      outlineOffset *= outlineTex;
    #endif

    #ifdef OUTLINE_WIDTH_SCREEN
      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );

    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic
  #endif

  #include <worldpos_vertex>
  // #include <envmap_vertex>
  #include <shadowmap_vertex>
  #include <fog_vertex>

}`
  , mde = `// #define PHONG

uniform vec3 litFactor;

uniform float opacity;

uniform vec3 shadeColorFactor;
#ifdef USE_SHADEMULTIPLYTEXTURE
  uniform sampler2D shadeMultiplyTexture;
  uniform mat3 shadeMultiplyTextureUvTransform;
#endif

uniform float shadingShiftFactor;
uniform float shadingToonyFactor;

#ifdef USE_SHADINGSHIFTTEXTURE
  uniform sampler2D shadingShiftTexture;
  uniform mat3 shadingShiftTextureUvTransform;
  uniform float shadingShiftTextureScale;
#endif

uniform float giEqualizationFactor;

uniform vec3 parametricRimColorFactor;
#ifdef USE_RIMMULTIPLYTEXTURE
  uniform sampler2D rimMultiplyTexture;
  uniform mat3 rimMultiplyTextureUvTransform;
#endif
uniform float rimLightingMixFactor;
uniform float parametricRimFresnelPowerFactor;
uniform float parametricRimLiftFactor;

#ifdef USE_MATCAPTEXTURE
  uniform vec3 matcapFactor;
  uniform sampler2D matcapTexture;
  uniform mat3 matcapTextureUvTransform;
#endif

uniform vec3 emissive;
uniform float emissiveIntensity;

uniform vec3 outlineColorFactor;
uniform float outlineLightingMixFactor;

#ifdef USE_UVANIMATIONMASKTEXTURE
  uniform sampler2D uvAnimationMaskTexture;
  uniform mat3 uvAnimationMaskTextureUvTransform;
#endif

uniform float uvAnimationScrollXOffset;
uniform float uvAnimationScrollYOffset;
uniform float uvAnimationRotationPhase;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>

// #include <uv_pars_fragment>
#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
  varying vec2 vUv;
#endif

// #include <uv2_pars_fragment>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
  #endif
#endif

#include <map_pars_fragment>

#ifdef USE_MAP
  uniform mat3 mapUvTransform;
#endif

// #include <alphamap_pars_fragment>

#include <alphatest_pars_fragment>

#include <aomap_pars_fragment>
// #include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>

#ifdef USE_EMISSIVEMAP
  uniform mat3 emissiveMapUvTransform;
#endif

// #include <envmap_common_pars_fragment>
// #include <envmap_pars_fragment>
// #include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>

// #include <bsdfs>
// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>
#if THREE_VRM_THREE_REVISION < 151
  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
  }
#endif

#include <lights_pars_begin>

#include <normal_pars_fragment>

// #include <lights_phong_pars_fragment>
varying vec3 vViewPosition;

struct MToonMaterial {
  vec3 diffuseColor;
  vec3 shadeColor;
  float shadingShift;
};

float linearstep( float a, float b, float t ) {
  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );
}

/**
 * Convert NdotL into toon shading factor using shadingShift and shadingToony
 */
float getShading(
  const in float dotNL,
  const in float shadow,
  const in float shadingShift
) {
  float shading = dotNL;
  shading = shading + shadingShift;
  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );
  shading *= shadow;
  return shading;
}

/**
 * Mix diffuseColor and shadeColor using shading factor and light color
 */
vec3 getDiffuse(
  const in MToonMaterial material,
  const in float shading,
  in vec3 lightColor
) {
  #ifdef DEBUG_LITSHADERATE
    return vec3( BRDF_Lambert( shading * lightColor ) );
  #endif

  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );

  // The "comment out if you want to PBR absolutely" line
  #ifdef V0_COMPAT_SHADE
    col = min( col, material.diffuseColor );
  #endif

  return col;
}

// COMPAT: pre-r156 uses a struct GeometricContext
#if THREE_VRM_THREE_REVISION >= 157
  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#else
  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#endif

#define RE_Direct RE_Direct_MToon
#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon
#define Material_LightProbeLOD( material ) (0)

#include <shadowmap_pars_fragment>
// #include <bumpmap_pars_fragment>

// #include <normalmap_pars_fragment>
#ifdef USE_NORMALMAP

  uniform sampler2D normalMap;
  uniform mat3 normalMapUvTransform;
  uniform vec2 normalScale;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

  uniform mat3 normalMatrix;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )

  // Per-Pixel Tangent Space Normal Mapping
  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  // three-vrm specific change: it requires \`uv\` as an input in order to support uv scrolls

  // Temporary compat against shader change @ Three.js r126, r151
  #if THREE_VRM_THREE_REVISION >= 151

    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = surf_norm;

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

      return mat3( T * scale, B * scale, N );

    }

  #else

    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = normalize( surf_norm );

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0
      // TODO: Is this still required? Or shall I make a PR about it?
      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {
        return surf_norm;
      }

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

  #endif

#endif

// #include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// == post correction ==========================================================
void postCorrection() {
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
  #include <dithering_fragment>
}

// == main procedure ===========================================================
void main() {
  #include <clipping_planes_fragment>

  vec2 uv = vec2(0.5, 0.5);

  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
    uv = vUv;

    float uvAnimMask = 1.0;
    #ifdef USE_UVANIMATIONMASKTEXTURE
      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;
      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;
    #endif

    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );
    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );
    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;
    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;
  #endif

  #ifdef DEBUG_UV
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
      gl_FragColor = vec4( uv, 0.0, 1.0 );
    #endif
    return;
  #endif

  vec4 diffuseColor = vec4( litFactor, opacity );
  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;

  #include <logdepthbuf_fragment>

  // #include <map_fragment>
  #ifdef USE_MAP
    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;
    vec4 sampledDiffuseColor = texture2D( map, mapUv );
    #ifdef DECODE_VIDEO_TEXTURE
      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    #endif
    diffuseColor *= sampledDiffuseColor;
  #endif

  // #include <color_fragment>
  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    diffuseColor.rgb *= vColor;
  #endif

  // #include <alphamap_fragment>

  #include <alphatest_fragment>

  // #include <specularmap_fragment>

  // #include <normal_fragment_begin>
  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

  #ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

  #else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

      normal *= faceDirection;

    #endif

  #endif

  #ifdef USE_NORMALMAP

    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;

  #endif

  #ifdef USE_NORMALMAP_TANGENTSPACE

    #ifdef USE_TANGENT

      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn[0] *= faceDirection;
      tbn[1] *= faceDirection;

    #endif

  #endif

  #ifdef USE_CLEARCOAT_NORMALMAP

    #ifdef USE_TANGENT

      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn2[0] *= faceDirection;
      tbn2[1] *= faceDirection;

    #endif

  #endif

  // non perturbed normal for clearcoat among others

  vec3 nonPerturbedNormal = normal;

  #ifdef OUTLINE
    normal *= -1.0;
  #endif

  // #include <normal_fragment_maps>

  // COMPAT: pre-r151
  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

      normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

      normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

  // COMPAT: pre-r151
  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    // COMPAT: pre-r151
    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )

      normal = normalize( tbn * mapN );

    #else

      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );

    #endif

  #endif

  // #include <emissivemap_fragment>
  #ifdef USE_EMISSIVEMAP
    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;
    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;
  #endif

  #ifdef DEBUG_NORMAL
    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );
    return;
  #endif

  // -- MToon: lighting --------------------------------------------------------
  // accumulation
  // #include <lights_phong_fragment>
  MToonMaterial material;

  material.diffuseColor = diffuseColor.rgb;

  material.shadeColor = shadeColorFactor;
  #ifdef USE_SHADEMULTIPLYTEXTURE
    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;
  #endif

  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    material.shadeColor.rgb *= vColor;
  #endif

  material.shadingShift = shadingShiftFactor;
  #ifdef USE_SHADINGSHIFTTEXTURE
    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;
  #endif

  // #include <lights_fragment_begin>

  // MToon Specific changes:
  // Since we want to take shadows into account of shading instead of irradiance,
  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.

  // COMPAT: pre-r156 uses a struct GeometricContext
  #if THREE_VRM_THREE_REVISION >= 157
    vec3 geometryPosition = - vViewPosition;
    vec3 geometryNormal = normal;
    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    vec3 geometryClearcoatNormal;

    #ifdef USE_CLEARCOAT

      geometryClearcoatNormal = clearcoatNormal;

    #endif
  #else
    GeometricContext geometry;

    geometry.position = - vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    #ifdef USE_CLEARCOAT

      geometry.clearcoatNormal = clearcoatNormal;

    #endif
  #endif

  IncidentLight directLight;

  // since these variables will be used in unrolled loop, we have to define in prior
  float shadow;

  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

      pointLight = pointLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getPointLightInfo( pointLight, geometryPosition, directLight );
      #else
        getPointLightInfo( pointLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
      pointLightShadow = pointLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

      spotLight = spotLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getSpotLightInfo( spotLight, geometryPosition, directLight );
      #else
        getSpotLightInfo( spotLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
      spotLightShadow = spotLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

      directionalLight = directionalLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getDirectionalLightInfo( directionalLight, directLight );
      #else
        getDirectionalLightInfo( directionalLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
      directionalLightShadow = directionalLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

  //   RectAreaLight rectAreaLight;

  //   #pragma unroll_loop_start
  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

  //     rectAreaLight = rectAreaLights[ i ];
  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

  //   }
  //   #pragma unroll_loop_end

  // #endif

  #if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    // COMPAT: pre-r156 uses a struct GeometricContext
    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES
    #if THREE_VRM_THREE_REVISION >= 157
      #if defined( USE_LIGHT_PROBES )
        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
      #endif
    #else
      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #endif

    #if ( NUM_HEMI_LIGHTS > 0 )

      #pragma unroll_loop_start
      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

        // COMPAT: pre-r156 uses a struct GeometricContext
        #if THREE_VRM_THREE_REVISION >= 157
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
        #else
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        #endif

      }
      #pragma unroll_loop_end

    #endif

  #endif

  // #if defined( RE_IndirectSpecular )

  //   vec3 radiance = vec3( 0.0 );
  //   vec3 clearcoatRadiance = vec3( 0.0 );

  // #endif

  #include <lights_fragment_maps>
  #include <lights_fragment_end>

  // modulation
  #include <aomap_fragment>

  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;

  #ifdef DEBUG_LITSHADERATE
    gl_FragColor = vec4( col, diffuseColor.a );
    postCorrection();
    return;
  #endif

  // -- MToon: rim lighting -----------------------------------------
  vec3 viewDir = normalize( vViewPosition );

  #ifndef PHYSICALLY_CORRECT_LIGHTS
    reflectedLight.directSpecular /= PI;
  #endif
  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );

  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );

  #ifdef USE_MATCAPTEXTURE
    {
      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );
      vec3 y = cross( viewDir, x ); // guaranteed to be normalized
      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );
      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;
      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;
      rim += matcapFactor * matcap;
    }
  #endif

  #ifdef USE_RIMMULTIPLYTEXTURE
    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;
  #endif

  col += rimMix * rim;

  // -- MToon: Emission --------------------------------------------------------
  col += totalEmissiveRadiance;

  // #include <envmap_fragment>

  // -- Almost done! -----------------------------------------------------------
  #if defined( OUTLINE )
    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );
  #endif

  #ifdef OPAQUE
    diffuseColor.a = 1.0;
  #endif

  gl_FragColor = vec4( col, diffuseColor.a );
  postCorrection();
}
`
  , gde = {
    None: "none",
    Normal: "normal",
    LitShadeRate: "litShadeRate",
    UV: "uv"
}
  , rO = {
    None: "none",
    WorldCoordinates: "worldCoordinates",
    ScreenCoordinates: "screenCoordinates"
}
  , vde = {
    3e3: "",
    3001: "srgb"
};
function DB(n) {
    return parseInt(nc, 10) >= 152 ? n.colorSpace : vde[n.encoding]
}
var xG = class extends mr {
    constructor(n={}) {
        var e;
        super({
            vertexShader: pde,
            fragmentShader: mde
        }),
        this.uvAnimationScrollXSpeedFactor = 0,
        this.uvAnimationScrollYSpeedFactor = 0,
        this.uvAnimationRotationSpeedFactor = 0,
        this.fog = !0,
        this.normalMapType = Kd,
        this._ignoreVertexColor = !0,
        this._v0CompatShade = !1,
        this._debugMode = gde.None,
        this._outlineWidthMode = rO.None,
        this._isOutline = !1,
        n.transparentWithZWrite && (n.depthWrite = !0),
        delete n.transparentWithZWrite,
        n.fog = !0,
        n.lights = !0,
        n.clipping = !0,
        this.uniforms = kR.merge([Ge.common, Ge.normalmap, Ge.emissivemap, Ge.fog, Ge.lights, {
            litFactor: {
                value: new Qe(1,1,1)
            },
            mapUvTransform: {
                value: new dt
            },
            colorAlpha: {
                value: 1
            },
            normalMapUvTransform: {
                value: new dt
            },
            shadeColorFactor: {
                value: new Qe(0,0,0)
            },
            shadeMultiplyTexture: {
                value: null
            },
            shadeMultiplyTextureUvTransform: {
                value: new dt
            },
            shadingShiftFactor: {
                value: 0
            },
            shadingShiftTexture: {
                value: null
            },
            shadingShiftTextureUvTransform: {
                value: new dt
            },
            shadingShiftTextureScale: {
                value: 1
            },
            shadingToonyFactor: {
                value: .9
            },
            giEqualizationFactor: {
                value: .9
            },
            matcapFactor: {
                value: new Qe(1,1,1)
            },
            matcapTexture: {
                value: null
            },
            matcapTextureUvTransform: {
                value: new dt
            },
            parametricRimColorFactor: {
                value: new Qe(0,0,0)
            },
            rimMultiplyTexture: {
                value: null
            },
            rimMultiplyTextureUvTransform: {
                value: new dt
            },
            rimLightingMixFactor: {
                value: 1
            },
            parametricRimFresnelPowerFactor: {
                value: 5
            },
            parametricRimLiftFactor: {
                value: 0
            },
            emissive: {
                value: new Qe(0,0,0)
            },
            emissiveIntensity: {
                value: 1
            },
            emissiveMapUvTransform: {
                value: new dt
            },
            outlineWidthMultiplyTexture: {
                value: null
            },
            outlineWidthMultiplyTextureUvTransform: {
                value: new dt
            },
            outlineWidthFactor: {
                value: 0
            },
            outlineColorFactor: {
                value: new Qe(0,0,0)
            },
            outlineLightingMixFactor: {
                value: 1
            },
            uvAnimationMaskTexture: {
                value: null
            },
            uvAnimationMaskTextureUvTransform: {
                value: new dt
            },
            uvAnimationScrollXOffset: {
                value: 0
            },
            uvAnimationScrollYOffset: {
                value: 0
            },
            uvAnimationRotationPhase: {
                value: 0
            }
        }, (e = n.uniforms) != null ? e : {}]),
        this.setValues(n),
        this._uploadUniformsWorkaround(),
        this.customProgramCacheKey = () => [...Object.entries(this._generateDefines()).map( ([t,r]) => `${t}:${r}`), this.matcapTexture ? `matcapTextureColorSpace:${DB(this.matcapTexture)}` : "", this.shadeMultiplyTexture ? `shadeMultiplyTextureColorSpace:${DB(this.shadeMultiplyTexture)}` : "", this.rimMultiplyTexture ? `rimMultiplyTextureColorSpace:${DB(this.rimMultiplyTexture)}` : ""].join(","),
        this.onBeforeCompile = t => {
            const r = parseInt(nc, 10)
              , i = Object.entries(nO(nO({}, this._generateDefines()), this.defines)).filter( ([s,o]) => !!o).map( ([s,o]) => `#define ${s} ${o}`).join(`
`) + `
`;
            t.vertexShader = i + t.vertexShader,
            t.fragmentShader = i + t.fragmentShader,
            r < 154 && (t.fragmentShader = t.fragmentShader.replace("#include <colorspace_fragment>", "#include <encodings_fragment>"))
        }
    }
    get color() {
        return this.uniforms.litFactor.value
    }
    set color(n) {
        this.uniforms.litFactor.value = n
    }
    get map() {
        return this.uniforms.map.value
    }
    set map(n) {
        this.uniforms.map.value = n
    }
    get normalMap() {
        return this.uniforms.normalMap.value
    }
    set normalMap(n) {
        this.uniforms.normalMap.value = n
    }
    get normalScale() {
        return this.uniforms.normalScale.value
    }
    set normalScale(n) {
        this.uniforms.normalScale.value = n
    }
    get emissive() {
        return this.uniforms.emissive.value
    }
    set emissive(n) {
        this.uniforms.emissive.value = n
    }
    get emissiveIntensity() {
        return this.uniforms.emissiveIntensity.value
    }
    set emissiveIntensity(n) {
        this.uniforms.emissiveIntensity.value = n
    }
    get emissiveMap() {
        return this.uniforms.emissiveMap.value
    }
    set emissiveMap(n) {
        this.uniforms.emissiveMap.value = n
    }
    get shadeColorFactor() {
        return this.uniforms.shadeColorFactor.value
    }
    set shadeColorFactor(n) {
        this.uniforms.shadeColorFactor.value = n
    }
    get shadeMultiplyTexture() {
        return this.uniforms.shadeMultiplyTexture.value
    }
    set shadeMultiplyTexture(n) {
        this.uniforms.shadeMultiplyTexture.value = n
    }
    get shadingShiftFactor() {
        return this.uniforms.shadingShiftFactor.value
    }
    set shadingShiftFactor(n) {
        this.uniforms.shadingShiftFactor.value = n
    }
    get shadingShiftTexture() {
        return this.uniforms.shadingShiftTexture.value
    }
    set shadingShiftTexture(n) {
        this.uniforms.shadingShiftTexture.value = n
    }
    get shadingShiftTextureScale() {
        return this.uniforms.shadingShiftTextureScale.value
    }
    set shadingShiftTextureScale(n) {
        this.uniforms.shadingShiftTextureScale.value = n
    }
    get shadingToonyFactor() {
        return this.uniforms.shadingToonyFactor.value
    }
    set shadingToonyFactor(n) {
        this.uniforms.shadingToonyFactor.value = n
    }
    get giEqualizationFactor() {
        return this.uniforms.giEqualizationFactor.value
    }
    set giEqualizationFactor(n) {
        this.uniforms.giEqualizationFactor.value = n
    }
    get matcapFactor() {
        return this.uniforms.matcapFactor.value
    }
    set matcapFactor(n) {
        this.uniforms.matcapFactor.value = n
    }
    get matcapTexture() {
        return this.uniforms.matcapTexture.value
    }
    set matcapTexture(n) {
        this.uniforms.matcapTexture.value = n
    }
    get parametricRimColorFactor() {
        return this.uniforms.parametricRimColorFactor.value
    }
    set parametricRimColorFactor(n) {
        this.uniforms.parametricRimColorFactor.value = n
    }
    get rimMultiplyTexture() {
        return this.uniforms.rimMultiplyTexture.value
    }
    set rimMultiplyTexture(n) {
        this.uniforms.rimMultiplyTexture.value = n
    }
    get rimLightingMixFactor() {
        return this.uniforms.rimLightingMixFactor.value
    }
    set rimLightingMixFactor(n) {
        this.uniforms.rimLightingMixFactor.value = n
    }
    get parametricRimFresnelPowerFactor() {
        return this.uniforms.parametricRimFresnelPowerFactor.value
    }
    set parametricRimFresnelPowerFactor(n) {
        this.uniforms.parametricRimFresnelPowerFactor.value = n
    }
    get parametricRimLiftFactor() {
        return this.uniforms.parametricRimLiftFactor.value
    }
    set parametricRimLiftFactor(n) {
        this.uniforms.parametricRimLiftFactor.value = n
    }
    get outlineWidthMultiplyTexture() {
        return this.uniforms.outlineWidthMultiplyTexture.value
    }
    set outlineWidthMultiplyTexture(n) {
        this.uniforms.outlineWidthMultiplyTexture.value = n
    }
    get outlineWidthFactor() {
        return this.uniforms.outlineWidthFactor.value
    }
    set outlineWidthFactor(n) {
        this.uniforms.outlineWidthFactor.value = n
    }
    get outlineColorFactor() {
        return this.uniforms.outlineColorFactor.value
    }
    set outlineColorFactor(n) {
        this.uniforms.outlineColorFactor.value = n
    }
    get outlineLightingMixFactor() {
        return this.uniforms.outlineLightingMixFactor.value
    }
    set outlineLightingMixFactor(n) {
        this.uniforms.outlineLightingMixFactor.value = n
    }
    get uvAnimationMaskTexture() {
        return this.uniforms.uvAnimationMaskTexture.value
    }
    set uvAnimationMaskTexture(n) {
        this.uniforms.uvAnimationMaskTexture.value = n
    }
    get uvAnimationScrollXOffset() {
        return this.uniforms.uvAnimationScrollXOffset.value
    }
    set uvAnimationScrollXOffset(n) {
        this.uniforms.uvAnimationScrollXOffset.value = n
    }
    get uvAnimationScrollYOffset() {
        return this.uniforms.uvAnimationScrollYOffset.value
    }
    set uvAnimationScrollYOffset(n) {
        this.uniforms.uvAnimationScrollYOffset.value = n
    }
    get uvAnimationRotationPhase() {
        return this.uniforms.uvAnimationRotationPhase.value
    }
    set uvAnimationRotationPhase(n) {
        this.uniforms.uvAnimationRotationPhase.value = n
    }
    get ignoreVertexColor() {
        return this._ignoreVertexColor
    }
    set ignoreVertexColor(n) {
        this._ignoreVertexColor = n,
        this.needsUpdate = !0
    }
    get v0CompatShade() {
        return this._v0CompatShade
    }
    set v0CompatShade(n) {
        this._v0CompatShade = n,
        this.needsUpdate = !0
    }
    get debugMode() {
        return this._debugMode
    }
    set debugMode(n) {
        this._debugMode = n,
        this.needsUpdate = !0
    }
    get outlineWidthMode() {
        return this._outlineWidthMode
    }
    set outlineWidthMode(n) {
        this._outlineWidthMode = n,
        this.needsUpdate = !0
    }
    get isOutline() {
        return this._isOutline
    }
    set isOutline(n) {
        this._isOutline = n,
        this.needsUpdate = !0
    }
    get isMToonMaterial() {
        return !0
    }
    update(n) {
        this._uploadUniformsWorkaround(),
        this._updateUVAnimation(n)
    }
    copy(n) {
        return super.copy(n),
        this.map = n.map,
        this.normalMap = n.normalMap,
        this.emissiveMap = n.emissiveMap,
        this.shadeMultiplyTexture = n.shadeMultiplyTexture,
        this.shadingShiftTexture = n.shadingShiftTexture,
        this.matcapTexture = n.matcapTexture,
        this.rimMultiplyTexture = n.rimMultiplyTexture,
        this.outlineWidthMultiplyTexture = n.outlineWidthMultiplyTexture,
        this.uvAnimationMaskTexture = n.uvAnimationMaskTexture,
        this.normalMapType = n.normalMapType,
        this.uvAnimationScrollXSpeedFactor = n.uvAnimationScrollXSpeedFactor,
        this.uvAnimationScrollYSpeedFactor = n.uvAnimationScrollYSpeedFactor,
        this.uvAnimationRotationSpeedFactor = n.uvAnimationRotationSpeedFactor,
        this.ignoreVertexColor = n.ignoreVertexColor,
        this.v0CompatShade = n.v0CompatShade,
        this.debugMode = n.debugMode,
        this.outlineWidthMode = n.outlineWidthMode,
        this.isOutline = n.isOutline,
        this.needsUpdate = !0,
        this
    }
    _updateUVAnimation(n) {
        this.uniforms.uvAnimationScrollXOffset.value += n * this.uvAnimationScrollXSpeedFactor,
        this.uniforms.uvAnimationScrollYOffset.value += n * this.uvAnimationScrollYSpeedFactor,
        this.uniforms.uvAnimationRotationPhase.value += n * this.uvAnimationRotationSpeedFactor,
        this.uniforms.alphaTest.value = this.alphaTest,
        this.uniformsNeedUpdate = !0
    }
    _uploadUniformsWorkaround() {
        this.uniforms.opacity.value = this.opacity,
        this._updateTextureMatrix(this.uniforms.map, this.uniforms.mapUvTransform),
        this._updateTextureMatrix(this.uniforms.normalMap, this.uniforms.normalMapUvTransform),
        this._updateTextureMatrix(this.uniforms.emissiveMap, this.uniforms.emissiveMapUvTransform),
        this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture, this.uniforms.shadeMultiplyTextureUvTransform),
        this._updateTextureMatrix(this.uniforms.shadingShiftTexture, this.uniforms.shadingShiftTextureUvTransform),
        this._updateTextureMatrix(this.uniforms.matcapTexture, this.uniforms.matcapTextureUvTransform),
        this._updateTextureMatrix(this.uniforms.rimMultiplyTexture, this.uniforms.rimMultiplyTextureUvTransform),
        this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture, this.uniforms.outlineWidthMultiplyTextureUvTransform),
        this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture, this.uniforms.uvAnimationMaskTextureUvTransform),
        this.uniformsNeedUpdate = !0
    }
    _generateDefines() {
        const n = parseInt(nc, 10)
          , e = this.outlineWidthMultiplyTexture !== null
          , t = this.map !== null || this.normalMap !== null || this.emissiveMap !== null || this.shadeMultiplyTexture !== null || this.shadingShiftTexture !== null || this.rimMultiplyTexture !== null || this.uvAnimationMaskTexture !== null;
        return {
            THREE_VRM_THREE_REVISION: n,
            OUTLINE: this._isOutline,
            MTOON_USE_UV: e || t,
            MTOON_UVS_VERTEX_ONLY: e && !t,
            V0_COMPAT_SHADE: this._v0CompatShade,
            USE_SHADEMULTIPLYTEXTURE: this.shadeMultiplyTexture !== null,
            USE_SHADINGSHIFTTEXTURE: this.shadingShiftTexture !== null,
            USE_MATCAPTEXTURE: this.matcapTexture !== null,
            USE_RIMMULTIPLYTEXTURE: this.rimMultiplyTexture !== null,
            USE_OUTLINEWIDTHMULTIPLYTEXTURE: this._isOutline && this.outlineWidthMultiplyTexture !== null,
            USE_UVANIMATIONMASKTEXTURE: this.uvAnimationMaskTexture !== null,
            IGNORE_VERTEX_COLOR: this._ignoreVertexColor === !0,
            DEBUG_NORMAL: this._debugMode === "normal",
            DEBUG_LITSHADERATE: this._debugMode === "litShadeRate",
            DEBUG_UV: this._debugMode === "uv",
            OUTLINE_WIDTH_SCREEN: this._isOutline && this._outlineWidthMode === rO.ScreenCoordinates
        }
    }
    _updateTextureMatrix(n, e) {
        n.value && (n.value.matrixAutoUpdate && n.value.updateMatrix(),
        e.value.copy(n.value.matrix))
    }
}
  , yde = new Set(["1.0", "1.0-beta"])
  , bG = class Pw {
    get name() {
        return Pw.EXTENSION_NAME
    }
    constructor(e, t={}) {
        var r, i, s, o;
        this.parser = e,
        this.materialType = (r = t.materialType) != null ? r : xG,
        this.renderOrderOffset = (i = t.renderOrderOffset) != null ? i : 0,
        this.v0CompatShade = (s = t.v0CompatShade) != null ? s : !1,
        this.debugMode = (o = t.debugMode) != null ? o : "none",
        this._mToonMaterialSet = new Set
    }
    beforeRoot() {
        return pu(this, null, function*() {
            this._removeUnlitExtensionIfMToonExists()
        })
    }
    afterRoot(e) {
        return pu(this, null, function*() {
            e.userData.vrmMToonMaterials = Array.from(this._mToonMaterialSet)
        })
    }
    getMaterialType(e) {
        return this._getMToonExtension(e) ? this.materialType : null
    }
    extendMaterialParams(e, t) {
        const r = this._getMToonExtension(e);
        return r ? this._extendMaterialParams(r, t) : null
    }
    loadMesh(e) {
        return pu(this, null, function*() {
            var t;
            const r = this.parser
              , s = (t = r.json.meshes) == null ? void 0 : t[e];
            if (s == null)
                throw new Error(`MToonMaterialLoaderPlugin: Attempt to use meshes[${e}] of glTF but the mesh doesn't exist`);
            const o = s.primitives
              , a = yield r.loadMesh(e);
            if (o.length === 1) {
                const l = a
                  , c = o[0].material;
                c != null && this._setupPrimitive(l, c)
            } else {
                const l = a;
                for (let c = 0; c < o.length; c++) {
                    const A = l.children[c]
                      , u = o[c].material;
                    u != null && this._setupPrimitive(A, u)
                }
            }
            return a
        })
    }
    _removeUnlitExtensionIfMToonExists() {
        const r = this.parser.json.materials;
        r == null || r.map( (i, s) => {
            var o;
            this._getMToonExtension(s) && ((o = i.extensions) != null && o.KHR_materials_unlit) && delete i.extensions.KHR_materials_unlit
        }
        )
    }
    _getMToonExtension(e) {
        var t, r;
        const o = (t = this.parser.json.materials) == null ? void 0 : t[e];
        if (o == null) {
            console.warn(`MToonMaterialLoaderPlugin: Attempt to use materials[${e}] of glTF but the material doesn't exist`);
            return
        }
        const a = (r = o.extensions) == null ? void 0 : r[Pw.EXTENSION_NAME];
        if (a == null)
            return;
        const l = a.specVersion;
        if (!yde.has(l)) {
            console.warn(`MToonMaterialLoaderPlugin: Unknown ${Pw.EXTENSION_NAME} specVersion "${l}"`);
            return
        }
        return a
    }
    _extendMaterialParams(e, t) {
        return pu(this, null, function*() {
            var r;
            delete t.metalness,
            delete t.roughness;
            const i = new dde(this.parser,t);
            i.assignPrimitive("transparentWithZWrite", e.transparentWithZWrite),
            i.assignColor("shadeColorFactor", e.shadeColorFactor),
            i.assignTexture("shadeMultiplyTexture", e.shadeMultiplyTexture, !0),
            i.assignPrimitive("shadingShiftFactor", e.shadingShiftFactor),
            i.assignTexture("shadingShiftTexture", e.shadingShiftTexture, !0),
            i.assignPrimitive("shadingShiftTextureScale", (r = e.shadingShiftTexture) == null ? void 0 : r.scale),
            i.assignPrimitive("shadingToonyFactor", e.shadingToonyFactor),
            i.assignPrimitive("giEqualizationFactor", e.giEqualizationFactor),
            i.assignColor("matcapFactor", e.matcapFactor),
            i.assignTexture("matcapTexture", e.matcapTexture, !0),
            i.assignColor("parametricRimColorFactor", e.parametricRimColorFactor),
            i.assignTexture("rimMultiplyTexture", e.rimMultiplyTexture, !0),
            i.assignPrimitive("rimLightingMixFactor", e.rimLightingMixFactor),
            i.assignPrimitive("parametricRimFresnelPowerFactor", e.parametricRimFresnelPowerFactor),
            i.assignPrimitive("parametricRimLiftFactor", e.parametricRimLiftFactor),
            i.assignPrimitive("outlineWidthMode", e.outlineWidthMode),
            i.assignPrimitive("outlineWidthFactor", e.outlineWidthFactor),
            i.assignTexture("outlineWidthMultiplyTexture", e.outlineWidthMultiplyTexture, !1),
            i.assignColor("outlineColorFactor", e.outlineColorFactor),
            i.assignPrimitive("outlineLightingMixFactor", e.outlineLightingMixFactor),
            i.assignTexture("uvAnimationMaskTexture", e.uvAnimationMaskTexture, !1),
            i.assignPrimitive("uvAnimationScrollXSpeedFactor", e.uvAnimationScrollXSpeedFactor),
            i.assignPrimitive("uvAnimationScrollYSpeedFactor", e.uvAnimationScrollYSpeedFactor),
            i.assignPrimitive("uvAnimationRotationSpeedFactor", e.uvAnimationRotationSpeedFactor),
            i.assignPrimitive("v0CompatShade", this.v0CompatShade),
            i.assignPrimitive("debugMode", this.debugMode),
            yield i.pending
        })
    }
    _setupPrimitive(e, t) {
        const r = this._getMToonExtension(t);
        if (r) {
            const i = this._parseRenderOrder(r);
            e.renderOrder = i + this.renderOrderOffset,
            this._generateOutline(e),
            this._addToMaterialSet(e);
            return
        }
    }
    _shouldGenerateOutline(e) {
        return typeof e.outlineWidthMode == "string" && e.outlineWidthMode !== "none" && typeof e.outlineWidthFactor == "number" && e.outlineWidthFactor > 0
    }
    _generateOutline(e) {
        const t = e.material;
        if (!(t instanceof as) || !this._shouldGenerateOutline(t))
            return;
        e.material = [t];
        const r = t.clone();
        r.name += " (Outline)",
        r.isOutline = !0,
        r.side = oi,
        e.material.push(r);
        const i = e.geometry
          , s = i.index ? i.index.count : i.attributes.position.count / 3;
        i.addGroup(0, s, 0),
        i.addGroup(0, s, 1)
    }
    _addToMaterialSet(e) {
        const t = e.material
          , r = new Set;
        Array.isArray(t) ? t.forEach(i => r.add(i)) : r.add(t);
        for (const i of r)
            this._mToonMaterialSet.add(i)
    }
    _parseRenderOrder(e) {
        var t;
        return (e.transparentWithZWrite ? 0 : 19) + ((t = e.renderQueueOffsetNumber) != null ? t : 0)
    }
}
;
bG.EXTENSION_NAME = "VRMC_materials_mtoon";
var wde = bG
  , _de = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , EG = class aT {
    get name() {
        return aT.EXTENSION_NAME
    }
    constructor(e) {
        this.parser = e
    }
    extendMaterialParams(e, t) {
        return _de(this, null, function*() {
            const r = this._getHDREmissiveMultiplierExtension(e);
            if (r == null)
                return;
            console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.");
            const i = r.emissiveMultiplier;
            t.emissiveIntensity = i
        })
    }
    _getHDREmissiveMultiplierExtension(e) {
        var t, r;
        const o = (t = this.parser.json.materials) == null ? void 0 : t[e];
        if (o == null) {
            console.warn(`VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${e}] of glTF but the material doesn't exist`);
            return
        }
        const a = (r = o.extensions) == null ? void 0 : r[aT.EXTENSION_NAME];
        if (a != null)
            return a
    }
}
;
EG.EXTENSION_NAME = "VRMC_materials_hdr_emissiveMultiplier";
var xde = EG
  , bde = Object.defineProperty
  , Ede = Object.defineProperties
  , Bde = Object.getOwnPropertyDescriptors
  , iO = Object.getOwnPropertySymbols
  , Mde = Object.prototype.hasOwnProperty
  , Sde = Object.prototype.propertyIsEnumerable
  , sO = (n, e, t) => e in n ? bde(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , wa = (n, e) => {
    for (var t in e || (e = {}))
        Mde.call(e, t) && sO(n, t, e[t]);
    if (iO)
        for (var t of iO(e))
            Sde.call(e, t) && sO(n, t, e[t]);
    return n
}
  , oO = (n, e) => Ede(n, Bde(e))
  , Cde = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
);
function Pf(n) {
    return Math.pow(n, 2.2)
}
var Tde = class {
    get name() {
        return "VRMMaterialsV0CompatPlugin"
    }
    constructor(n) {
        var e;
        this.parser = n,
        this._renderQueueMapTransparent = new Map,
        this._renderQueueMapTransparentZWrite = new Map;
        const t = this.parser.json;
        t.extensionsUsed = (e = t.extensionsUsed) != null ? e : [],
        t.extensionsUsed.indexOf("KHR_texture_transform") === -1 && t.extensionsUsed.push("KHR_texture_transform")
    }
    beforeRoot() {
        return Cde(this, null, function*() {
            var n;
            const e = this.parser.json
              , t = (n = e.extensions) == null ? void 0 : n.VRM
              , r = t == null ? void 0 : t.materialProperties;
            r && (this._populateRenderQueueMap(r),
            r.forEach( (i, s) => {
                var o, a;
                const l = (o = e.materials) == null ? void 0 : o[s];
                if (l == null) {
                    console.warn(`VRMMaterialsV0CompatPlugin: Attempt to use materials[${s}] of glTF but the material doesn't exist`);
                    return
                }
                if (i.shader === "VRM/MToon") {
                    const c = this._parseV0MToonProperties(i, l);
                    e.materials[s] = c
                } else if ((a = i.shader) != null && a.startsWith("VRM/Unlit")) {
                    const c = this._parseV0UnlitProperties(i, l);
                    e.materials[s] = c
                } else
                    i.shader === "VRM_USE_GLTFSHADER" || console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${i.shader}`)
            }
            ))
        })
    }
    _parseV0MToonProperties(n, e) {
        var t, r, i, s, o, a, l, c, A, u, f, h, d, m, g, p, v, w, _, x, b, B, S, I, M, L, D, T, y, E, R, F, O, z, j, Q, C, W, ee, P, re, ue, le, me, ie, ge, _e, se, H, fe, Ae, J, q, he, X;
        const G = (r = (t = n.keywordMap) == null ? void 0 : t._ALPHABLEND_ON) != null ? r : !1
          , Y = ((i = n.floatProperties) == null ? void 0 : i._ZWrite) === 1 && G
          , de = this._v0ParseRenderQueue(n)
          , ae = (o = (s = n.keywordMap) == null ? void 0 : s._ALPHATEST_ON) != null ? o : !1
          , Ee = G ? "BLEND" : ae ? "MASK" : "OPAQUE"
          , V = ae ? (l = (a = n.floatProperties) == null ? void 0 : a._Cutoff) != null ? l : .5 : void 0
          , N = ((A = (c = n.floatProperties) == null ? void 0 : c._CullMode) != null ? A : 2) === 0
          , K = this._portTextureTransform(n)
          , oe = ((f = (u = n.vectorProperties) == null ? void 0 : u._Color) != null ? f : [1, 1, 1, 1]).map( (ke, Xe) => Xe === 3 ? ke : Pf(ke))
          , pe = (h = n.textureProperties) == null ? void 0 : h._MainTex
          , ve = pe != null ? {
            index: pe,
            extensions: wa({}, K)
        } : void 0
          , Ce = (m = (d = n.floatProperties) == null ? void 0 : d._BumpScale) != null ? m : 1
          , Le = (g = n.textureProperties) == null ? void 0 : g._BumpMap
          , Re = Le != null ? {
            index: Le,
            scale: Ce,
            extensions: wa({}, K)
        } : void 0
          , $e = ((v = (p = n.vectorProperties) == null ? void 0 : p._EmissionColor) != null ? v : [0, 0, 0, 1]).map(Pf)
          , ce = (w = n.textureProperties) == null ? void 0 : w._EmissionMap
          , Pe = ce != null ? {
            index: ce,
            extensions: wa({}, K)
        } : void 0
          , Se = ((x = (_ = n.vectorProperties) == null ? void 0 : _._ShadeColor) != null ? x : [.97, .81, .86, 1]).map(Pf)
          , Te = (b = n.textureProperties) == null ? void 0 : b._ShadeTexture
          , Fe = Te != null ? {
            index: Te,
            extensions: wa({}, K)
        } : void 0;
        let De = (S = (B = n.floatProperties) == null ? void 0 : B._ShadeShift) != null ? S : 0
          , Ze = (M = (I = n.floatProperties) == null ? void 0 : I._ShadeToony) != null ? M : .9;
        Ze = Bt.lerp(Ze, 1, .5 + .5 * De),
        De = -De - (1 - Ze);
        const At = (D = (L = n.floatProperties) == null ? void 0 : L._IndirectLightIntensity) != null ? D : .1
          , Pn = At ? 1 - At : void 0
          , rt = (T = n.textureProperties) == null ? void 0 : T._SphereAdd
          , xt = rt != null ? [1, 1, 1] : void 0
          , Tr = rt != null ? {
            index: rt
        } : void 0
          , tn = (E = (y = n.floatProperties) == null ? void 0 : y._RimLightingMix) != null ? E : 0
          , qt = (R = n.textureProperties) == null ? void 0 : R._RimTexture
          , Jr = qt != null ? {
            index: qt,
            extensions: wa({}, K)
        } : void 0
          , en = ((O = (F = n.vectorProperties) == null ? void 0 : F._RimColor) != null ? O : [0, 0, 0, 1]).map(Pf)
          , nn = (j = (z = n.floatProperties) == null ? void 0 : z._RimFresnelPower) != null ? j : 1
          , Ks = (C = (Q = n.floatProperties) == null ? void 0 : Q._RimLift) != null ? C : 0
          , Xt = ["none", "worldCoordinates", "screenCoordinates"][(ee = (W = n.floatProperties) == null ? void 0 : W._OutlineWidthMode) != null ? ee : 0];
        let Yt = (re = (P = n.floatProperties) == null ? void 0 : P._OutlineWidth) != null ? re : 0;
        Yt = .01 * Yt;
        const Ii = (ue = n.textureProperties) == null ? void 0 : ue._OutlineWidthTexture
          , rn = Ii != null ? {
            index: Ii,
            extensions: wa({}, K)
        } : void 0
          , sn = ((me = (le = n.vectorProperties) == null ? void 0 : le._OutlineColor) != null ? me : [0, 0, 0]).map(Pf)
          , un = ((ge = (ie = n.floatProperties) == null ? void 0 : ie._OutlineColorMode) != null ? ge : 0) === 1 ? (se = (_e = n.floatProperties) == null ? void 0 : _e._OutlineLightingMix) != null ? se : 1 : 0
          , on = (H = n.textureProperties) == null ? void 0 : H._UvAnimMaskTexture
          , te = on != null ? {
            index: on,
            extensions: wa({}, K)
        } : void 0
          , ye = (Ae = (fe = n.floatProperties) == null ? void 0 : fe._UvAnimScrollX) != null ? Ae : 0;
        let Be = (q = (J = n.floatProperties) == null ? void 0 : J._UvAnimScrollY) != null ? q : 0;
        Be != null && (Be = -Be);
        const Me = (X = (he = n.floatProperties) == null ? void 0 : he._UvAnimRotation) != null ? X : 0
          , we = {
            specVersion: "1.0",
            transparentWithZWrite: Y,
            renderQueueOffsetNumber: de,
            shadeColorFactor: Se,
            shadeMultiplyTexture: Fe,
            shadingShiftFactor: De,
            shadingToonyFactor: Ze,
            giEqualizationFactor: Pn,
            matcapFactor: xt,
            matcapTexture: Tr,
            rimLightingMixFactor: tn,
            rimMultiplyTexture: Jr,
            parametricRimColorFactor: en,
            parametricRimFresnelPowerFactor: nn,
            parametricRimLiftFactor: Ks,
            outlineWidthMode: Xt,
            outlineWidthFactor: Yt,
            outlineWidthMultiplyTexture: rn,
            outlineColorFactor: sn,
            outlineLightingMixFactor: un,
            uvAnimationMaskTexture: te,
            uvAnimationScrollXSpeedFactor: ye,
            uvAnimationScrollYSpeedFactor: Be,
            uvAnimationRotationSpeedFactor: Me
        };
        return oO(wa({}, e), {
            pbrMetallicRoughness: {
                baseColorFactor: oe,
                baseColorTexture: ve
            },
            normalTexture: Re,
            emissiveTexture: Pe,
            emissiveFactor: $e,
            alphaMode: Ee,
            alphaCutoff: V,
            doubleSided: N,
            extensions: {
                VRMC_materials_mtoon: we
            }
        })
    }
    _parseV0UnlitProperties(n, e) {
        var t, r, i, s, o;
        const a = n.shader === "VRM/UnlitTransparentZWrite"
          , l = n.shader === "VRM/UnlitTransparent" || a
          , c = this._v0ParseRenderQueue(n)
          , A = n.shader === "VRM/UnlitCutout"
          , u = l ? "BLEND" : A ? "MASK" : "OPAQUE"
          , f = A ? (r = (t = n.floatProperties) == null ? void 0 : t._Cutoff) != null ? r : .5 : void 0
          , h = this._portTextureTransform(n)
          , d = ((s = (i = n.vectorProperties) == null ? void 0 : i._Color) != null ? s : [1, 1, 1, 1]).map(Pf)
          , m = (o = n.textureProperties) == null ? void 0 : o._MainTex
          , g = m != null ? {
            index: m,
            extensions: wa({}, h)
        } : void 0
          , p = {
            specVersion: "1.0",
            transparentWithZWrite: a,
            renderQueueOffsetNumber: c,
            shadeColorFactor: d,
            shadeMultiplyTexture: g
        };
        return oO(wa({}, e), {
            pbrMetallicRoughness: {
                baseColorFactor: d,
                baseColorTexture: g
            },
            alphaMode: u,
            alphaCutoff: f,
            extensions: {
                VRMC_materials_mtoon: p
            }
        })
    }
    _portTextureTransform(n) {
        var e, t, r, i, s;
        const o = (e = n.vectorProperties) == null ? void 0 : e._MainTex;
        if (o == null)
            return {};
        const a = [(t = o == null ? void 0 : o[0]) != null ? t : 0, (r = o == null ? void 0 : o[1]) != null ? r : 0]
          , l = [(i = o == null ? void 0 : o[2]) != null ? i : 1, (s = o == null ? void 0 : o[3]) != null ? s : 1];
        return a[1] = 1 - l[1] - a[1],
        {
            KHR_texture_transform: {
                offset: a,
                scale: l
            }
        }
    }
    _v0ParseRenderQueue(n) {
        var e, t;
        const r = n.shader === "VRM/UnlitTransparentZWrite"
          , i = ((e = n.keywordMap) == null ? void 0 : e._ALPHABLEND_ON) != null || n.shader === "VRM/UnlitTransparent" || r
          , s = ((t = n.floatProperties) == null ? void 0 : t._ZWrite) === 1 || r;
        let o = 0;
        if (i) {
            const a = n.renderQueue;
            a != null && (s ? o = this._renderQueueMapTransparentZWrite.get(a) : o = this._renderQueueMapTransparent.get(a))
        }
        return o
    }
    _populateRenderQueueMap(n) {
        const e = new Set
          , t = new Set;
        n.forEach(r => {
            var i, s;
            const o = r.shader === "VRM/UnlitTransparentZWrite"
              , a = ((i = r.keywordMap) == null ? void 0 : i._ALPHABLEND_ON) != null || r.shader === "VRM/UnlitTransparent" || o
              , l = ((s = r.floatProperties) == null ? void 0 : s._ZWrite) === 1 || o;
            if (a) {
                const c = r.renderQueue;
                c != null && (l ? t.add(c) : e.add(c))
            }
        }
        ),
        e.size > 10 && console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${e.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),
        t.size > 10 && console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${t.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),
        Array.from(e).sort().forEach( (r, i) => {
            const s = Math.min(Math.max(i - e.size + 1, -9), 0);
            this._renderQueueMapTransparent.set(r, s)
        }
        ),
        Array.from(t).sort().forEach( (r, i) => {
            const s = Math.min(Math.max(i, 0), 9);
            this._renderQueueMapTransparentZWrite.set(r, s)
        }
        )
    }
}
  , aO = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , Cc = new $
  , NB = class extends ri {
    constructor(n) {
        super(),
        this._attrPosition = new ct(new Float32Array([0, 0, 0, 0, 0, 0]),3),
        this._attrPosition.setUsage(Lq);
        const e = new Jt;
        e.setAttribute("position", this._attrPosition);
        const t = new Ac({
            color: 16711935,
            depthTest: !1,
            depthWrite: !1
        });
        this._line = new Yd(e,t),
        this.add(this._line),
        this.constraint = n
    }
    updateMatrixWorld(n) {
        Cc.setFromMatrixPosition(this.constraint.destination.matrixWorld),
        this._attrPosition.setXYZ(0, Cc.x, Cc.y, Cc.z),
        this.constraint.source && Cc.setFromMatrixPosition(this.constraint.source.matrixWorld),
        this._attrPosition.setXYZ(1, Cc.x, Cc.y, Cc.z),
        this._attrPosition.needsUpdate = !0,
        super.updateMatrixWorld(n)
    }
}
;
function lO(n, e) {
    return e.set(n.elements[12], n.elements[13], n.elements[14])
}
var Ide = new $
  , Rde = new $;
function Ude(n, e) {
    return n.decompose(Ide, e, Rde),
    e
}
function q_(n) {
    return n.invert ? n.invert() : n.inverse(),
    n
}
var l2 = class {
    constructor(n, e) {
        this.destination = n,
        this.source = e,
        this.weight = 1
    }
}
  , Fde = new $
  , Pde = new $
  , Lde = new $
  , Dde = new nt
  , Nde = new nt
  , Ode = new nt
  , kde = class extends l2 {
    get aimAxis() {
        return this._aimAxis
    }
    set aimAxis(n) {
        this._aimAxis = n,
        this._v3AimAxis.set(n === "PositiveX" ? 1 : n === "NegativeX" ? -1 : 0, n === "PositiveY" ? 1 : n === "NegativeY" ? -1 : 0, n === "PositiveZ" ? 1 : n === "NegativeZ" ? -1 : 0)
    }
    get dependencies() {
        const n = new Set([this.source]);
        return this.destination.parent && n.add(this.destination.parent),
        n
    }
    constructor(n, e) {
        super(n, e),
        this._aimAxis = "PositiveX",
        this._v3AimAxis = new $(1,0,0),
        this._dstRestQuat = new nt
    }
    setInitState() {
        this._dstRestQuat.copy(this.destination.quaternion)
    }
    update() {
        this.destination.updateWorldMatrix(!0, !1),
        this.source.updateWorldMatrix(!0, !1);
        const n = Dde.identity()
          , e = Nde.identity();
        this.destination.parent && (Ude(this.destination.parent.matrixWorld, n),
        q_(e.copy(n)));
        const t = Fde.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(n)
          , r = lO(this.source.matrixWorld, Pde).sub(lO(this.destination.matrixWorld, Lde)).normalize()
          , i = Ode.setFromUnitVectors(t, r).premultiply(e).multiply(n).multiply(this._dstRestQuat);
        this.destination.quaternion.copy(this._dstRestQuat).slerp(i, this.weight)
    }
}
;
function Qde(n, e) {
    const t = [n];
    let r = n.parent;
    for (; r !== null; )
        t.unshift(r),
        r = r.parent;
    t.forEach(i => {
        e(i)
    }
    )
}
var Hde = class {
    constructor() {
        this._constraints = new Set,
        this._objectConstraintsMap = new Map
    }
    get constraints() {
        return this._constraints
    }
    addConstraint(n) {
        this._constraints.add(n);
        let e = this._objectConstraintsMap.get(n.destination);
        e == null && (e = new Set,
        this._objectConstraintsMap.set(n.destination, e)),
        e.add(n)
    }
    deleteConstraint(n) {
        this._constraints.delete(n),
        this._objectConstraintsMap.get(n.destination).delete(n)
    }
    setInitState() {
        const n = new Set
          , e = new Set;
        for (const t of this._constraints)
            this._processConstraint(t, n, e, r => r.setInitState())
    }
    update() {
        const n = new Set
          , e = new Set;
        for (const t of this._constraints)
            this._processConstraint(t, n, e, r => r.update())
    }
    _processConstraint(n, e, t, r) {
        if (t.has(n))
            return;
        if (e.has(n))
            throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");
        e.add(n);
        const i = n.dependencies;
        for (const s of i)
            Qde(s, o => {
                const a = this._objectConstraintsMap.get(o);
                if (a)
                    for (const l of a)
                        this._processConstraint(l, e, t, r)
            }
            );
        r(n),
        t.add(n)
    }
}
  , zde = new nt
  , Gde = new nt
  , Vde = class extends l2 {
    get dependencies() {
        return new Set([this.source])
    }
    constructor(n, e) {
        super(n, e),
        this._dstRestQuat = new nt,
        this._invSrcRestQuat = new nt
    }
    setInitState() {
        this._dstRestQuat.copy(this.destination.quaternion),
        q_(this._invSrcRestQuat.copy(this.source.quaternion))
    }
    update() {
        const n = zde.copy(this._invSrcRestQuat).multiply(this.source.quaternion)
          , e = Gde.copy(this._dstRestQuat).multiply(n);
        this.destination.quaternion.copy(this._dstRestQuat).slerp(e, this.weight)
    }
}
  , jde = new $
  , Wde = new nt
  , Kde = new nt
  , Xde = class extends l2 {
    get rollAxis() {
        return this._rollAxis
    }
    set rollAxis(n) {
        this._rollAxis = n,
        this._v3RollAxis.set(n === "X" ? 1 : 0, n === "Y" ? 1 : 0, n === "Z" ? 1 : 0)
    }
    get dependencies() {
        return new Set([this.source])
    }
    constructor(n, e) {
        super(n, e),
        this._rollAxis = "X",
        this._v3RollAxis = new $(1,0,0),
        this._dstRestQuat = new nt,
        this._invDstRestQuat = new nt,
        this._invSrcRestQuatMulDstRestQuat = new nt
    }
    setInitState() {
        this._dstRestQuat.copy(this.destination.quaternion),
        q_(this._invDstRestQuat.copy(this._dstRestQuat)),
        q_(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)
    }
    update() {
        const n = Wde.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat)
          , e = jde.copy(this._v3RollAxis).applyQuaternion(n)
          , r = Kde.setFromUnitVectors(e, this._v3RollAxis).premultiply(this._dstRestQuat).multiply(n);
        this.destination.quaternion.copy(this._dstRestQuat).slerp(r, this.weight)
    }
}
  , Yde = new Set(["1.0", "1.0-beta"])
  , BG = class Rm {
    get name() {
        return Rm.EXTENSION_NAME
    }
    constructor(e, t) {
        this.parser = e,
        this.helperRoot = t == null ? void 0 : t.helperRoot
    }
    afterRoot(e) {
        return aO(this, null, function*() {
            e.userData.vrmNodeConstraintManager = yield this._import(e)
        })
    }
    _import(e) {
        return aO(this, null, function*() {
            var t;
            const r = this.parser.json;
            if (!(((t = r.extensionsUsed) == null ? void 0 : t.indexOf(Rm.EXTENSION_NAME)) !== -1))
                return null;
            const s = new Hde
              , o = yield this.parser.getDependencies("node");
            return o.forEach( (a, l) => {
                var c;
                const A = r.nodes[l]
                  , u = (c = A == null ? void 0 : A.extensions) == null ? void 0 : c[Rm.EXTENSION_NAME];
                if (u == null)
                    return;
                const f = u.specVersion;
                if (!Yde.has(f)) {
                    console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${Rm.EXTENSION_NAME} specVersion "${f}"`);
                    return
                }
                const h = u.constraint;
                if (h.roll != null) {
                    const d = this._importRollConstraint(a, o, h.roll);
                    s.addConstraint(d)
                } else if (h.aim != null) {
                    const d = this._importAimConstraint(a, o, h.aim);
                    s.addConstraint(d)
                } else if (h.rotation != null) {
                    const d = this._importRotationConstraint(a, o, h.rotation);
                    s.addConstraint(d)
                }
            }
            ),
            e.scene.updateMatrixWorld(),
            s.setInitState(),
            s
        })
    }
    _importRollConstraint(e, t, r) {
        const {source: i, rollAxis: s, weight: o} = r
          , a = t[i]
          , l = new Xde(e,a);
        if (s != null && (l.rollAxis = s),
        o != null && (l.weight = o),
        this.helperRoot) {
            const c = new NB(l);
            this.helperRoot.add(c)
        }
        return l
    }
    _importAimConstraint(e, t, r) {
        const {source: i, aimAxis: s, weight: o} = r
          , a = t[i]
          , l = new kde(e,a);
        if (s != null && (l.aimAxis = s),
        o != null && (l.weight = o),
        this.helperRoot) {
            const c = new NB(l);
            this.helperRoot.add(c)
        }
        return l
    }
    _importRotationConstraint(e, t, r) {
        const {source: i, weight: s} = r
          , o = t[i]
          , a = new Vde(e,o);
        if (s != null && (a.weight = s),
        this.helperRoot) {
            const l = new NB(a);
            this.helperRoot.add(l)
        }
        return a
    }
}
;
BG.EXTENSION_NAME = "VRMC_node_constraint";
var $de = BG
  , yy = (n, e, t) => new Promise( (r, i) => {
    var s = l => {
        try {
            a(t.next(l))
        } catch (c) {
            i(c)
        }
    }
      , o = l => {
        try {
            a(t.throw(l))
        } catch (c) {
            i(c)
        }
    }
      , a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
    a((t = t.apply(n, e)).next())
}
)
  , c2 = class {
}
  , OB = new $
  , YA = new $
  , MG = class extends c2 {
    get type() {
        return "capsule"
    }
    constructor(n) {
        var e, t, r, i;
        super(),
        this.offset = (e = n == null ? void 0 : n.offset) != null ? e : new $(0,0,0),
        this.tail = (t = n == null ? void 0 : n.tail) != null ? t : new $(0,0,0),
        this.radius = (r = n == null ? void 0 : n.radius) != null ? r : 0,
        this.inside = (i = n == null ? void 0 : n.inside) != null ? i : !1
    }
    calculateCollision(n, e, t, r) {
        OB.copy(this.offset).applyMatrix4(n),
        YA.copy(this.tail).applyMatrix4(n),
        YA.sub(OB);
        const i = YA.lengthSq();
        r.copy(e).sub(OB);
        const s = YA.dot(r);
        s <= 0 || (i <= s || YA.multiplyScalar(s / i),
        r.sub(YA));
        const o = this.inside ? this.radius - t - r.length() : r.length() - t - this.radius;
        return r.normalize(),
        this.inside && r.negate(),
        o
    }
}
  , kB = new $
  , cO = new dt
  , SG = class extends c2 {
    get type() {
        return "plane"
    }
    constructor(n) {
        var e, t;
        super(),
        this.offset = (e = n == null ? void 0 : n.offset) != null ? e : new $(0,0,0),
        this.normal = (t = n == null ? void 0 : n.normal) != null ? t : new $(0,0,1)
    }
    calculateCollision(n, e, t, r) {
        r.copy(this.offset).applyMatrix4(n),
        r.negate().add(e),
        cO.getNormalMatrix(n),
        kB.copy(this.normal).applyNormalMatrix(cO).normalize();
        const i = r.dot(kB) - t;
        return r.copy(kB),
        i
    }
}
  , CG = class extends c2 {
    get type() {
        return "sphere"
    }
    constructor(n) {
        var e, t, r;
        super(),
        this.offset = (e = n == null ? void 0 : n.offset) != null ? e : new $(0,0,0),
        this.radius = (t = n == null ? void 0 : n.radius) != null ? t : 0,
        this.inside = (r = n == null ? void 0 : n.inside) != null ? r : !1
    }
    calculateCollision(n, e, t, r) {
        r.copy(this.offset).applyMatrix4(n),
        r.negate().add(e);
        const i = this.inside ? this.radius - t - r.length() : r.length() - t - this.radius;
        return r.normalize(),
        this.inside && r.negate(),
        i
    }
}
  , _a = new $
  , Zde = class extends Jt {
    constructor(n) {
        super(),
        this.worldScale = 1,
        this._currentRadius = 0,
        this._currentOffset = new $,
        this._currentTail = new $,
        this._shape = n,
        this._attrPos = new ct(new Float32Array(396),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(264),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        const e = this._shape.radius / this.worldScale;
        this._currentRadius !== e && (this._currentRadius = e,
        n = !0),
        this._currentOffset.equals(this._shape.offset) || (this._currentOffset.copy(this._shape.offset),
        n = !0);
        const t = _a.copy(this._shape.tail).divideScalar(this.worldScale);
        this._currentTail.distanceToSquared(t) > 1e-10 && (this._currentTail.copy(t),
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        _a.copy(this._currentTail).sub(this._currentOffset);
        const n = _a.length() / this._currentRadius;
        for (let r = 0; r <= 16; r++) {
            const i = r / 16 * Math.PI;
            this._attrPos.setXYZ(r, -Math.sin(i), -Math.cos(i), 0),
            this._attrPos.setXYZ(17 + r, n + Math.sin(i), Math.cos(i), 0),
            this._attrPos.setXYZ(34 + r, -Math.sin(i), 0, -Math.cos(i)),
            this._attrPos.setXYZ(51 + r, n + Math.sin(i), 0, Math.cos(i))
        }
        for (let r = 0; r < 32; r++) {
            const i = r / 16 * Math.PI;
            this._attrPos.setXYZ(68 + r, 0, Math.sin(i), Math.cos(i)),
            this._attrPos.setXYZ(100 + r, n, Math.sin(i), Math.cos(i))
        }
        const e = Math.atan2(_a.y, Math.sqrt(_a.x * _a.x + _a.z * _a.z))
          , t = -Math.atan2(_a.z, _a.x);
        this.rotateZ(e),
        this.rotateY(t),
        this.scale(this._currentRadius, this._currentRadius, this._currentRadius),
        this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z),
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        for (let n = 0; n < 34; n++) {
            const e = (n + 1) % 34;
            this._attrIndex.setXY(n * 2, n, e),
            this._attrIndex.setXY(68 + n * 2, 34 + n, 34 + e)
        }
        for (let n = 0; n < 32; n++) {
            const e = (n + 1) % 32;
            this._attrIndex.setXY(136 + n * 2, 68 + n, 68 + e),
            this._attrIndex.setXY(200 + n * 2, 100 + n, 100 + e)
        }
        this._attrIndex.needsUpdate = !0
    }
}
  , Jde = class extends Jt {
    constructor(n) {
        super(),
        this.worldScale = 1,
        this._currentOffset = new $,
        this._currentNormal = new $,
        this._shape = n,
        this._attrPos = new ct(new Float32Array(6 * 3),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(10),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        this._currentOffset.equals(this._shape.offset) || (this._currentOffset.copy(this._shape.offset),
        n = !0),
        this._currentNormal.equals(this._shape.normal) || (this._currentNormal.copy(this._shape.normal),
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        this._attrPos.setXYZ(0, -.5, -.5, 0),
        this._attrPos.setXYZ(1, .5, -.5, 0),
        this._attrPos.setXYZ(2, .5, .5, 0),
        this._attrPos.setXYZ(3, -.5, .5, 0),
        this._attrPos.setXYZ(4, 0, 0, 0),
        this._attrPos.setXYZ(5, 0, 0, .25),
        this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z),
        this.lookAt(this._currentNormal),
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        this._attrIndex.setXY(0, 0, 1),
        this._attrIndex.setXY(2, 1, 2),
        this._attrIndex.setXY(4, 2, 3),
        this._attrIndex.setXY(6, 3, 0),
        this._attrIndex.setXY(8, 4, 5),
        this._attrIndex.needsUpdate = !0
    }
}
  , qde = class extends Jt {
    constructor(n) {
        super(),
        this.worldScale = 1,
        this._currentRadius = 0,
        this._currentOffset = new $,
        this._shape = n,
        this._attrPos = new ct(new Float32Array(32 * 3 * 3),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(64 * 3),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        const e = this._shape.radius / this.worldScale;
        this._currentRadius !== e && (this._currentRadius = e,
        n = !0),
        this._currentOffset.equals(this._shape.offset) || (this._currentOffset.copy(this._shape.offset),
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        for (let n = 0; n < 32; n++) {
            const e = n / 16 * Math.PI;
            this._attrPos.setXYZ(n, Math.cos(e), Math.sin(e), 0),
            this._attrPos.setXYZ(32 + n, 0, Math.cos(e), Math.sin(e)),
            this._attrPos.setXYZ(64 + n, Math.sin(e), 0, Math.cos(e))
        }
        this.scale(this._currentRadius, this._currentRadius, this._currentRadius),
        this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z),
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        for (let n = 0; n < 32; n++) {
            const e = (n + 1) % 32;
            this._attrIndex.setXY(n * 2, n, e),
            this._attrIndex.setXY(64 + n * 2, 32 + n, 32 + e),
            this._attrIndex.setXY(128 + n * 2, 64 + n, 64 + e)
        }
        this._attrIndex.needsUpdate = !0
    }
}
  , epe = new $
  , QB = class extends ri {
    constructor(n) {
        if (super(),
        this.matrixAutoUpdate = !1,
        this.collider = n,
        this.collider.shape instanceof CG)
            this._geometry = new qde(this.collider.shape);
        else if (this.collider.shape instanceof MG)
            this._geometry = new Zde(this.collider.shape);
        else if (this.collider.shape instanceof SG)
            this._geometry = new Jde(this.collider.shape);
        else
            throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");
        const e = new Ac({
            color: 16711935,
            depthTest: !1,
            depthWrite: !1
        });
        this._line = new w0(this._geometry,e),
        this.add(this._line)
    }
    dispose() {
        this._geometry.dispose()
    }
    updateMatrixWorld(n) {
        this.collider.updateWorldMatrix(!0, !1),
        this.matrix.copy(this.collider.matrixWorld);
        const e = this.matrix.elements;
        this._geometry.worldScale = epe.set(e[0], e[1], e[2]).length(),
        this._geometry.update(),
        super.updateMatrixWorld(n)
    }
}
  , tpe = class extends Jt {
    constructor(n) {
        super(),
        this.worldScale = 1,
        this._currentRadius = 0,
        this._currentTail = new $,
        this._springBone = n,
        this._attrPos = new ct(new Float32Array(294),3),
        this.setAttribute("position", this._attrPos),
        this._attrIndex = new ct(new Uint16Array(194),1),
        this.setIndex(this._attrIndex),
        this._buildIndex(),
        this.update()
    }
    update() {
        let n = !1;
        const e = this._springBone.settings.hitRadius / this.worldScale;
        this._currentRadius !== e && (this._currentRadius = e,
        n = !0),
        this._currentTail.equals(this._springBone.initialLocalChildPosition) || (this._currentTail.copy(this._springBone.initialLocalChildPosition),
        n = !0),
        n && this._buildPosition()
    }
    _buildPosition() {
        for (let n = 0; n < 32; n++) {
            const e = n / 16 * Math.PI;
            this._attrPos.setXYZ(n, Math.cos(e), Math.sin(e), 0),
            this._attrPos.setXYZ(32 + n, 0, Math.cos(e), Math.sin(e)),
            this._attrPos.setXYZ(64 + n, Math.sin(e), 0, Math.cos(e))
        }
        this.scale(this._currentRadius, this._currentRadius, this._currentRadius),
        this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z),
        this._attrPos.setXYZ(96, 0, 0, 0),
        this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z),
        this._attrPos.needsUpdate = !0
    }
    _buildIndex() {
        for (let n = 0; n < 32; n++) {
            const e = (n + 1) % 32;
            this._attrIndex.setXY(n * 2, n, e),
            this._attrIndex.setXY(64 + n * 2, 32 + n, 32 + e),
            this._attrIndex.setXY(128 + n * 2, 64 + n, 64 + e)
        }
        this._attrIndex.setXY(192, 96, 97),
        this._attrIndex.needsUpdate = !0
    }
}
  , npe = new $
  , rpe = class extends ri {
    constructor(n) {
        super(),
        this.matrixAutoUpdate = !1,
        this.springBone = n,
        this._geometry = new tpe(this.springBone);
        const e = new Ac({
            color: 16776960,
            depthTest: !1,
            depthWrite: !1
        });
        this._line = new w0(this._geometry,e),
        this.add(this._line)
    }
    dispose() {
        this._geometry.dispose()
    }
    updateMatrixWorld(n) {
        this.springBone.bone.updateWorldMatrix(!0, !1),
        this.matrix.copy(this.springBone.bone.matrixWorld);
        const e = this.matrix.elements;
        this._geometry.worldScale = npe.set(e[0], e[1], e[2]).length(),
        this._geometry.update(),
        super.updateMatrixWorld(n)
    }
}
  , Lw = class extends Lt {
    constructor(n) {
        super(),
        this.shape = n
    }
}
  , ipe = new He;
function TG(n) {
    return n.invert ? n.invert() : n.getInverse(ipe.copy(n)),
    n
}
var spe = class {
    constructor(n) {
        this._inverseCache = new He,
        this._shouldUpdateInverse = !0,
        this.matrix = n;
        const e = {
            set: (t, r, i) => (this._shouldUpdateInverse = !0,
            t[r] = i,
            !0)
        };
        this._originalElements = n.elements,
        n.elements = new Proxy(n.elements,e)
    }
    get inverse() {
        return this._shouldUpdateInverse && (TG(this._inverseCache.copy(this.matrix)),
        this._shouldUpdateInverse = !1),
        this._inverseCache
    }
    revert() {
        this.matrix.elements = this._originalElements
    }
}
  , ope = new He
  , wl = new $
  , Kp = new $
  , ape = new $
  , Lf = new $
  , AO = new $
  , Xp = new $
  , uO = new nt
  , Df = new He
  , lpe = new He
  , cpe = class {
    constructor(n, e, t={}, r=[]) {
        this._currentTail = new $,
        this._prevTail = new $,
        this._boneAxis = new $,
        this._worldSpaceBoneLength = 0,
        this._center = null,
        this._initialLocalMatrix = new He,
        this._initialLocalRotation = new nt,
        this._initialLocalChildPosition = new $;
        var i, s, o, a, l, c;
        this.bone = n,
        this.bone.matrixAutoUpdate = !1,
        this.child = e,
        this.settings = {
            hitRadius: (i = t.hitRadius) != null ? i : 0,
            stiffness: (s = t.stiffness) != null ? s : 1,
            gravityPower: (o = t.gravityPower) != null ? o : 0,
            gravityDir: (l = (a = t.gravityDir) == null ? void 0 : a.clone()) != null ? l : new $(0,-1,0),
            dragForce: (c = t.dragForce) != null ? c : .4
        },
        this.colliderGroups = r
    }
    get center() {
        return this._center
    }
    set center(n) {
        var e;
        (e = this._center) != null && e.userData.inverseCacheProxy && (this._center.userData.inverseCacheProxy.revert(),
        delete this._center.userData.inverseCacheProxy),
        this._center = n,
        this._center && (this._center.userData.inverseCacheProxy || (this._center.userData.inverseCacheProxy = new spe(this._center.matrixWorld)))
    }
    get initialLocalChildPosition() {
        return this._initialLocalChildPosition
    }
    get _parentMatrixWorld() {
        return this.bone.parent ? this.bone.parent.matrixWorld : ope
    }
    setInitState() {
        this._initialLocalMatrix.copy(this.bone.matrix),
        this._initialLocalRotation.copy(this.bone.quaternion),
        this.child ? this._initialLocalChildPosition.copy(this.child.position) : this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);
        const n = this._getMatrixWorldToCenter(Df);
        this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(n),
        this._prevTail.copy(this._currentTail),
        this._boneAxis.copy(this._initialLocalChildPosition).normalize()
    }
    reset() {
        this.bone.quaternion.copy(this._initialLocalRotation),
        this.bone.updateMatrix(),
        this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);
        const n = this._getMatrixWorldToCenter(Df);
        this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(n),
        this._prevTail.copy(this._currentTail)
    }
    update(n) {
        if (n <= 0)
            return;
        this._calcWorldSpaceBoneLength(),
        Lf.setFromMatrixPosition(this.bone.matrixWorld);
        let e = this._getMatrixWorldToCenter(Df);
        AO.copy(Lf).applyMatrix4(e);
        const t = uO.setFromRotationMatrix(e)
          , r = lpe.copy(e).multiply(this._parentMatrixWorld)
          , i = Kp.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(r).sub(AO).normalize()
          , s = ape.copy(this.settings.gravityDir).applyQuaternion(t).normalize()
          , o = this._getMatrixCenterToWorld(Df);
        Xp.copy(this._currentTail).add(wl.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.settings.dragForce)).add(wl.copy(i).multiplyScalar(this.settings.stiffness * n)).add(wl.copy(s).multiplyScalar(this.settings.gravityPower * n)).applyMatrix4(o),
        Xp.sub(Lf).normalize().multiplyScalar(this._worldSpaceBoneLength).add(Lf),
        this._collision(Xp),
        e = this._getMatrixWorldToCenter(Df),
        this._prevTail.copy(this._currentTail),
        this._currentTail.copy(wl.copy(Xp).applyMatrix4(e));
        const a = TG(Df.copy(this._parentMatrixWorld).multiply(this._initialLocalMatrix))
          , l = uO.setFromUnitVectors(this._boneAxis, wl.copy(Xp).applyMatrix4(a).normalize());
        this.bone.quaternion.copy(this._initialLocalRotation).multiply(l),
        this.bone.updateMatrix(),
        this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix)
    }
    _collision(n) {
        this.colliderGroups.forEach(e => {
            e.colliders.forEach(t => {
                const r = t.shape.calculateCollision(t.matrixWorld, n, this.settings.hitRadius, wl);
                r < 0 && (n.add(wl.multiplyScalar(-r)),
                n.sub(Lf).normalize().multiplyScalar(this._worldSpaceBoneLength).add(Lf))
            }
            )
        }
        )
    }
    _calcWorldSpaceBoneLength() {
        wl.setFromMatrixPosition(this.bone.matrixWorld),
        this.child ? Kp.setFromMatrixPosition(this.child.matrixWorld) : (Kp.copy(this._initialLocalChildPosition),
        Kp.applyMatrix4(this.bone.matrixWorld)),
        this._worldSpaceBoneLength = wl.sub(Kp).length()
    }
    _getMatrixCenterToWorld(n) {
        return this._center ? n.copy(this._center.matrixWorld) : n.identity(),
        n
    }
    _getMatrixWorldToCenter(n) {
        return this._center ? n.copy(this._center.userData.inverseCacheProxy.inverse) : n.identity(),
        n
    }
}
;
function Ape(n, e) {
    const t = [];
    let r = n;
    for (; r !== null; )
        t.unshift(r),
        r = r.parent;
    t.forEach(i => {
        e(i)
    }
    )
}
function IG(n, e) {
    n.children.forEach(t => {
        e(t) || IG(t, e)
    }
    )
}
var fO = class {
    constructor() {
        this._joints = new Set,
        this._hasWarnedCircularDependency = !1,
        this._objectSpringBonesMap = new Map
    }
    get joints() {
        return this._joints
    }
    get springBones() {
        return console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead."),
        this._joints
    }
    get colliderGroups() {
        const n = new Set;
        return this._joints.forEach(e => {
            e.colliderGroups.forEach(t => {
                n.add(t)
            }
            )
        }
        ),
        Array.from(n)
    }
    get colliders() {
        const n = new Set;
        return this.colliderGroups.forEach(e => {
            e.colliders.forEach(t => {
                n.add(t)
            }
            )
        }
        ),
        Array.from(n)
    }
    addJoint(n) {
        this._joints.add(n);
        let e = this._objectSpringBonesMap.get(n.bone);
        e == null && (e = new Set,
        this._objectSpringBonesMap.set(n.bone, e)),
        e.add(n)
    }
    addSpringBone(n) {
        console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead."),
        this.addJoint(n)
    }
    deleteJoint(n) {
        this._joints.delete(n),
        this._objectSpringBonesMap.get(n.bone).delete(n)
    }
    deleteSpringBone(n) {
        console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead."),
        this.deleteJoint(n)
    }
    setInitState() {
        const n = new Set
          , e = new Set
          , t = new Set;
        for (const r of this._joints)
            this._processSpringBone(r, n, e, t, i => i.setInitState())
    }
    reset() {
        const n = new Set
          , e = new Set
          , t = new Set;
        for (const r of this._joints)
            this._processSpringBone(r, n, e, t, i => i.reset())
    }
    update(n) {
        const e = new Set
          , t = new Set
          , r = new Set;
        for (const i of this._joints)
            this._processSpringBone(i, e, t, r, s => s.update(n)),
            IG(i.bone, s => {
                var o, a;
                return ((a = (o = this._objectSpringBonesMap.get(s)) == null ? void 0 : o.size) != null ? a : 0) > 0 ? !0 : (s.updateWorldMatrix(!1, !1),
                !1)
            }
            )
    }
    _processSpringBone(n, e, t, r, i) {
        if (t.has(n))
            return;
        if (e.has(n)) {
            this._hasWarnedCircularDependency || (console.warn("VRMSpringBoneManager: Circular dependency detected while updating springbones"),
            this._hasWarnedCircularDependency = !0);
            return
        }
        e.add(n);
        const s = this._getDependencies(n);
        for (const o of s)
            Ape(o, a => {
                const l = this._objectSpringBonesMap.get(a);
                if (l)
                    for (const c of l)
                        this._processSpringBone(c, e, t, r, i);
                else
                    r.has(a) || (a.updateWorldMatrix(!1, !1),
                    r.add(a))
            }
            );
        n.bone.updateMatrix(),
        n.bone.updateWorldMatrix(!1, !1),
        i(n),
        r.add(n.bone),
        t.add(n)
    }
    _getDependencies(n) {
        const e = new Set
          , t = n.bone.parent;
        return t && e.add(t),
        n.colliderGroups.forEach(r => {
            r.colliders.forEach(i => {
                e.add(i)
            }
            )
        }
        ),
        e
    }
}
  , hO = "VRMC_springBone_extended_collider"
  , upe = new Set(["1.0", "1.0-beta"])
  , fpe = new Set(["1.0"])
  , RG = class Zf {
    get name() {
        return Zf.EXTENSION_NAME
    }
    constructor(e, t) {
        var r;
        this.parser = e,
        this.jointHelperRoot = t == null ? void 0 : t.jointHelperRoot,
        this.colliderHelperRoot = t == null ? void 0 : t.colliderHelperRoot,
        this.useExtendedColliders = (r = t == null ? void 0 : t.useExtendedColliders) != null ? r : !0
    }
    afterRoot(e) {
        return yy(this, null, function*() {
            e.userData.vrmSpringBoneManager = yield this._import(e)
        })
    }
    _import(e) {
        return yy(this, null, function*() {
            const t = yield this._v1Import(e);
            if (t != null)
                return t;
            const r = yield this._v0Import(e);
            return r ?? null
        })
    }
    _v1Import(e) {
        return yy(this, null, function*() {
            var t, r, i, s, o;
            const a = e.parser.json;
            if (!(((t = a.extensionsUsed) == null ? void 0 : t.indexOf(Zf.EXTENSION_NAME)) !== -1))
                return null;
            const c = new fO
              , A = yield e.parser.getDependencies("node")
              , u = (r = a.extensions) == null ? void 0 : r[Zf.EXTENSION_NAME];
            if (!u)
                return null;
            const f = u.specVersion;
            if (!upe.has(f))
                return console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${Zf.EXTENSION_NAME} specVersion "${f}"`),
                null;
            const h = (i = u.colliders) == null ? void 0 : i.map( (m, g) => {
                var p, v, w, _, x, b, B, S, I, M, L, D, T, y, E;
                const R = A[m.node]
                  , F = m.shape
                  , O = (p = m.extensions) == null ? void 0 : p[hO];
                if (this.useExtendedColliders && O != null) {
                    const z = O.specVersion;
                    if (!fpe.has(z))
                        console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${hO} specVersion "${z}". Fallbacking to the ${Zf.EXTENSION_NAME} definition`);
                    else {
                        const j = O.shape;
                        if (j.sphere)
                            return this._importSphereCollider(R, {
                                offset: new $().fromArray((v = j.sphere.offset) != null ? v : [0, 0, 0]),
                                radius: (w = j.sphere.radius) != null ? w : 0,
                                inside: (_ = j.sphere.inside) != null ? _ : !1
                            });
                        if (j.capsule)
                            return this._importCapsuleCollider(R, {
                                offset: new $().fromArray((x = j.capsule.offset) != null ? x : [0, 0, 0]),
                                radius: (b = j.capsule.radius) != null ? b : 0,
                                tail: new $().fromArray((B = j.capsule.tail) != null ? B : [0, 0, 0]),
                                inside: (S = j.capsule.inside) != null ? S : !1
                            });
                        if (j.plane)
                            return this._importPlaneCollider(R, {
                                offset: new $().fromArray((I = j.plane.offset) != null ? I : [0, 0, 0]),
                                normal: new $().fromArray((M = j.plane.normal) != null ? M : [0, 0, 1])
                            })
                    }
                }
                if (F.sphere)
                    return this._importSphereCollider(R, {
                        offset: new $().fromArray((L = F.sphere.offset) != null ? L : [0, 0, 0]),
                        radius: (D = F.sphere.radius) != null ? D : 0,
                        inside: !1
                    });
                if (F.capsule)
                    return this._importCapsuleCollider(R, {
                        offset: new $().fromArray((T = F.capsule.offset) != null ? T : [0, 0, 0]),
                        radius: (y = F.capsule.radius) != null ? y : 0,
                        tail: new $().fromArray((E = F.capsule.tail) != null ? E : [0, 0, 0]),
                        inside: !1
                    });
                throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${g} has no valid shape`)
            }
            )
              , d = (s = u.colliderGroups) == null ? void 0 : s.map( (m, g) => {
                var p;
                return {
                    colliders: ((p = m.colliders) != null ? p : []).map(w => {
                        const _ = h == null ? void 0 : h[w];
                        if (_ == null)
                            throw new Error(`VRMSpringBoneLoaderPlugin: The colliderGroup #${g} attempted to use a collider #${w} but not found`);
                        return _
                    }
                    ),
                    name: m.name
                }
            }
            );
            return (o = u.springs) == null || o.forEach( (m, g) => {
                var p;
                const v = m.joints
                  , w = (p = m.colliderGroups) == null ? void 0 : p.map(b => {
                    const B = d == null ? void 0 : d[b];
                    if (B == null)
                        throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${g} attempted to use a colliderGroup ${b} but not found`);
                    return B
                }
                )
                  , _ = m.center != null ? A[m.center] : void 0;
                let x;
                v.forEach(b => {
                    if (x) {
                        const B = x.node
                          , S = A[B]
                          , I = b.node
                          , M = A[I]
                          , L = {
                            hitRadius: x.hitRadius,
                            dragForce: x.dragForce,
                            gravityPower: x.gravityPower,
                            stiffness: x.stiffness,
                            gravityDir: x.gravityDir != null ? new $().fromArray(x.gravityDir) : void 0
                        }
                          , D = this._importJoint(S, M, L, w);
                        _ && (D.center = _),
                        c.addJoint(D)
                    }
                    x = b
                }
                )
            }
            ),
            c.setInitState(),
            c
        })
    }
    _v0Import(e) {
        return yy(this, null, function*() {
            var t, r, i;
            const s = e.parser.json;
            if (!(((t = s.extensionsUsed) == null ? void 0 : t.indexOf("VRM")) !== -1))
                return null;
            const a = (r = s.extensions) == null ? void 0 : r.VRM
              , l = a == null ? void 0 : a.secondaryAnimation;
            if (!l)
                return null;
            const c = l == null ? void 0 : l.boneGroups;
            if (!c)
                return null;
            const A = new fO
              , u = yield e.parser.getDependencies("node")
              , f = (i = l.colliderGroups) == null ? void 0 : i.map(h => {
                var d;
                const m = u[h.node];
                return {
                    colliders: ((d = h.colliders) != null ? d : []).map( (p, v) => {
                        var w, _, x;
                        const b = new $(0,0,0);
                        return p.offset && b.set((w = p.offset.x) != null ? w : 0, (_ = p.offset.y) != null ? _ : 0, p.offset.z ? -p.offset.z : 0),
                        this._importSphereCollider(m, {
                            offset: b,
                            radius: (x = p.radius) != null ? x : 0,
                            inside: !1
                        })
                    }
                    )
                }
            }
            );
            return c == null || c.forEach( (h, d) => {
                const m = h.bones;
                m && m.forEach(g => {
                    var p, v, w, _;
                    const x = u[g]
                      , b = new $;
                    h.gravityDir ? b.set((p = h.gravityDir.x) != null ? p : 0, (v = h.gravityDir.y) != null ? v : 0, (w = h.gravityDir.z) != null ? w : 0) : b.set(0, -1, 0);
                    const B = h.center != null ? u[h.center] : void 0
                      , S = {
                        hitRadius: h.hitRadius,
                        dragForce: h.dragForce,
                        gravityPower: h.gravityPower,
                        stiffness: h.stiffiness,
                        gravityDir: b
                    }
                      , I = (_ = h.colliderGroups) == null ? void 0 : _.map(M => {
                        const L = f == null ? void 0 : f[M];
                        if (L == null)
                            throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${d} attempted to use a colliderGroup ${M} but not found`);
                        return L
                    }
                    );
                    x.traverse(M => {
                        var L;
                        const D = (L = M.children[0]) != null ? L : null
                          , T = this._importJoint(M, D, S, I);
                        B && (T.center = B),
                        A.addJoint(T)
                    }
                    )
                }
                )
            }
            ),
            e.scene.updateMatrixWorld(),
            A.setInitState(),
            A
        })
    }
    _importJoint(e, t, r, i) {
        const s = new cpe(e,t,r,i);
        if (this.jointHelperRoot) {
            const o = new rpe(s);
            this.jointHelperRoot.add(o),
            o.renderOrder = this.jointHelperRoot.renderOrder
        }
        return s
    }
    _importSphereCollider(e, t) {
        const r = new CG(t)
          , i = new Lw(r);
        if (e.add(i),
        this.colliderHelperRoot) {
            const s = new QB(i);
            this.colliderHelperRoot.add(s),
            s.renderOrder = this.colliderHelperRoot.renderOrder
        }
        return i
    }
    _importCapsuleCollider(e, t) {
        const r = new MG(t)
          , i = new Lw(r);
        if (e.add(i),
        this.colliderHelperRoot) {
            const s = new QB(i);
            this.colliderHelperRoot.add(s),
            s.renderOrder = this.colliderHelperRoot.renderOrder
        }
        return i
    }
    _importPlaneCollider(e, t) {
        const r = new SG(t)
          , i = new Lw(r);
        if (e.add(i),
        this.colliderHelperRoot) {
            const s = new QB(i);
            this.colliderHelperRoot.add(s),
            s.renderOrder = this.colliderHelperRoot.renderOrder
        }
        return i
    }
}
;
RG.EXTENSION_NAME = "VRMC_springBone";
var hpe = RG
  , dpe = class {
    get name() {
        return "VRMLoaderPlugin"
    }
    constructor(n, e) {
        var t, r, i, s, o, a, l, c, A, u;
        this.parser = n;
        const f = e == null ? void 0 : e.helperRoot
          , h = e == null ? void 0 : e.autoUpdateHumanBones;
        this.expressionPlugin = (t = e == null ? void 0 : e.expressionPlugin) != null ? t : new Fhe(n),
        this.firstPersonPlugin = (r = e == null ? void 0 : e.firstPersonPlugin) != null ? r : new Lhe(n),
        this.humanoidPlugin = (i = e == null ? void 0 : e.humanoidPlugin) != null ? i : new zhe(n,{
            helperRoot: f,
            autoUpdateHumanBones: h
        }),
        this.lookAtPlugin = (s = e == null ? void 0 : e.lookAtPlugin) != null ? s : new rde(n,{
            helperRoot: f
        }),
        this.metaPlugin = (o = e == null ? void 0 : e.metaPlugin) != null ? o : new ode(n),
        this.mtoonMaterialPlugin = (a = e == null ? void 0 : e.mtoonMaterialPlugin) != null ? a : new wde(n),
        this.materialsHDREmissiveMultiplierPlugin = (l = e == null ? void 0 : e.materialsHDREmissiveMultiplierPlugin) != null ? l : new xde(n),
        this.materialsV0CompatPlugin = (c = e == null ? void 0 : e.materialsV0CompatPlugin) != null ? c : new Tde(n),
        this.springBonePlugin = (A = e == null ? void 0 : e.springBonePlugin) != null ? A : new hpe(n,{
            colliderHelperRoot: f,
            jointHelperRoot: f
        }),
        this.nodeConstraintPlugin = (u = e == null ? void 0 : e.nodeConstraintPlugin) != null ? u : new $de(n,{
            helperRoot: f
        })
    }
    beforeRoot() {
        return my(this, null, function*() {
            yield this.materialsV0CompatPlugin.beforeRoot(),
            yield this.mtoonMaterialPlugin.beforeRoot()
        })
    }
    loadMesh(n) {
        return my(this, null, function*() {
            return yield this.mtoonMaterialPlugin.loadMesh(n)
        })
    }
    getMaterialType(n) {
        const e = this.mtoonMaterialPlugin.getMaterialType(n);
        return e ?? null
    }
    extendMaterialParams(n, e) {
        return my(this, null, function*() {
            yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(n, e),
            yield this.mtoonMaterialPlugin.extendMaterialParams(n, e)
        })
    }
    afterRoot(n) {
        return my(this, null, function*() {
            yield this.metaPlugin.afterRoot(n),
            yield this.humanoidPlugin.afterRoot(n),
            yield this.expressionPlugin.afterRoot(n),
            yield this.lookAtPlugin.afterRoot(n),
            yield this.firstPersonPlugin.afterRoot(n),
            yield this.springBonePlugin.afterRoot(n),
            yield this.nodeConstraintPlugin.afterRoot(n),
            yield this.mtoonMaterialPlugin.afterRoot(n);
            const e = n.userData.vrmMeta
              , t = n.userData.vrmHumanoid;
            if (e && t) {
                const r = new lde({
                    scene: n.scene,
                    expressionManager: n.userData.vrmExpressionManager,
                    firstPerson: n.userData.vrmFirstPerson,
                    humanoid: t,
                    lookAt: n.userData.vrmLookAt,
                    meta: e,
                    materials: n.userData.vrmMToonMaterials,
                    springBoneManager: n.userData.vrmSpringBoneManager,
                    nodeConstraintManager: n.userData.vrmNodeConstraintManager
                });
                n.userData.vrm = r
            }
        })
    }
}
;
function dO(n) {
    if (Object.values(n).forEach(e => {
        e != null && e.isTexture && e.dispose()
    }
    ),
    n.isShaderMaterial) {
        const e = n.uniforms;
        e && Object.values(e).forEach(t => {
            const r = t.value;
            r != null && r.isTexture && r.dispose()
        }
        )
    }
    n.dispose()
}
function ppe(n) {
    const e = n.geometry;
    e && e.dispose();
    const t = n.skeleton;
    t && t.dispose();
    const r = n.material;
    r && (Array.isArray(r) ? r.forEach(i => dO(i)) : r && dO(r))
}
function mpe(n) {
    n.traverse(ppe)
}
function gpe(n, e) {
    var t;
    const r = (t = e == null ? void 0 : e.experimentalSameBoneCounts) != null ? t : !1
      , i = [];
    n.traverse(a => {
        a.type === "SkinnedMesh" && i.push(a)
    }
    );
    const s = new Map;
    let o = 0;
    for (const a of i) {
        const c = a.geometry.getAttribute("skinIndex")
          , A = []
          , u = []
          , f = {}
          , h = c.array;
        for (let d = 0; d < h.length; d++) {
            const m = h[d];
            f[m] == null && (f[m] = A.length,
            A.push(a.skeleton.bones[m]),
            u.push(a.skeleton.boneInverses[m])),
            h[d] = f[m]
        }
        c.copyArray(h),
        c.needsUpdate = !0,
        s.set(a, {
            bones: A,
            boneInverses: u
        }),
        o = Math.max(o, A.length)
    }
    for (const a of i) {
        const {bones: l, boneInverses: c} = s.get(a);
        if (r)
            for (let u = l.length; u < o; u++)
                l[u] = l[0],
                c[u] = c[0];
        const A = new FA(l,c);
        a.bind(A, new He)
    }
}
function vpe(n) {
    const e = new Map;
    n.traverse(t => {
        var r, i, s, o;
        if (!t.isMesh)
            return;
        const a = t
          , l = a.geometry
          , c = l.index;
        if (c == null)
            return;
        const A = e.get(l);
        if (A != null) {
            a.geometry = A;
            return
        }
        const u = new Jt;
        u.name = l.name,
        u.morphTargetsRelative = l.morphTargetsRelative,
        l.groups.forEach(m => {
            u.addGroup(m.start, m.count, m.materialIndex)
        }
        ),
        u.boundingBox = (i = (r = l.boundingBox) == null ? void 0 : r.clone()) != null ? i : null,
        u.boundingSphere = (o = (s = l.boundingSphere) == null ? void 0 : s.clone()) != null ? o : null,
        u.setDrawRange(l.drawRange.start, l.drawRange.count),
        u.userData = l.userData,
        e.set(l, u);
        const f = []
          , h = [];
        {
            const m = c.array
              , g = new m.constructor(m.length);
            let p = 0;
            for (let v = 0; v < m.length; v++) {
                const w = m[v];
                let _ = f[w];
                _ == null && (f[w] = p,
                h[p] = w,
                _ = p,
                p++),
                g[v] = _
            }
            u.setIndex(new ct(g,1,!1))
        }
        Object.keys(l.attributes).forEach(m => {
            const g = l.attributes[m];
            if (g.isInterleavedBufferAttribute)
                throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
            const p = g.array
              , {itemSize: v, normalized: w} = g
              , _ = new p.constructor(h.length * v);
            h.forEach( (x, b) => {
                for (let B = 0; B < v; B++)
                    _[b * v + B] = p[x * v + B]
            }
            ),
            u.setAttribute(m, new ct(_,v,w))
        }
        );
        let d = !0;
        Object.keys(l.morphAttributes).forEach(m => {
            u.morphAttributes[m] = [];
            const g = l.morphAttributes[m];
            for (let p = 0; p < g.length; p++) {
                const v = g[p];
                if (v.isInterleavedBufferAttribute)
                    throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
                const w = v.array
                  , {itemSize: _, normalized: x} = v
                  , b = new w.constructor(h.length * _);
                h.forEach( (B, S) => {
                    for (let I = 0; I < _; I++)
                        b[S * _ + I] = w[B * _ + I]
                }
                ),
                d = d && b.every(B => B === 0),
                u.morphAttributes[m][p] = new ct(b,_,x)
            }
        }
        ),
        d && (u.morphAttributes = {}),
        a.geometry = u
    }
    ),
    Array.from(e.keys()).forEach(t => {
        t.dispose()
    }
    )
}
function ype(n) {
    var e;
    ((e = n.meta) == null ? void 0 : e.metaVersion) === "0" && (n.scene.rotation.y = Math.PI)
}
var B0 = class {
    constructor() {}
}
;
B0.deepDispose = mpe;
B0.removeUnnecessaryJoints = gpe;
B0.removeUnnecessaryVertices = vpe;
B0.rotateVRM0 = ype;
/*!
 * @pixiv/three-vrm-core v3.1.4
 * The implementation of core features of VRM, for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-core is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
/*!
 * @pixiv/three-vrm-materials-mtoon v3.1.4
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
/*!
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.1.4
 * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
/*!
 * @pixiv/three-vrm-materials-v0compat v3.1.4
 * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
/*!
 * @pixiv/three-vrm-node-constraint v3.1.4
 * Node constraint module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-node-constraint is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
/*!
 * @pixiv/three-vrm-springbone v3.1.4
 * Spring bone module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2024 pixiv Inc.
 * @pixiv/three-vrm-springbone is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */
var yr;
(function(n) {
    n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
    n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
    n[n.BYTE = 5120] = "BYTE",
    n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    n[n.SHORT = 5122] = "SHORT",
    n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    n[n.FLOAT = 5126] = "FLOAT",
    n[n.LINEAR = 9729] = "LINEAR",
    n[n.REPEAT = 10497] = "REPEAT"
}
)(yr || (yr = {}));
const ex = "blend_"
  , pO = "vrmColliderSphere";
class wpe {
    parse(e, t, r, i) {
        const s = e.humanoid
          , o = e.meta
          , a = e.materials
          , l = {}
          , c = {}
          , A = {}
          , u = e.lookAt
          , f = {
            generator: "UniGLTF-2.0.0",
            version: "2.0"
        };
        if (t)
            if (s)
                if (o)
                    if (a) {
                        if (!u)
                            throw new Error("lookAt is undefined or null")
                    } else
                        throw new Error("materials is undefined or null");
                else
                    throw new Error("meta is undefined or null");
            else
                throw new Error("humanoid is undefined or null");
        else
            throw new Error("avatar is undefined or null");
        const h = a.filter( (ie, ge, _e) => _e.findIndex(se => se.name === ie.name.replace(" (Outline)", "")) === ge).map(ie => ie)
          , d = h.map(ie => ie.name)
          , m = r ? {
            name: "icon",
            imageBitmap: r.image
        } : null
          , g = h.filter(ie => ie.map).map(ie => {
            if (!ie.map)
                throw new Error(ie.name + " map is null");
            return {
                name: ie.name,
                imageBitmap: ie.map.image
            }
        }
        )
          , p = h.filter(ie => ie.userData.shadeTexture).map(ie => {
            if (!ie.userData.shadeTexture)
                throw new Error(ie.userData.shadeTexture + " map is null");
            return {
                name: ie.name + "_shade",
                imageBitmap: ie.userData.shadeTexture.image
            }
        }
        )
          , v = g.concat(p)
          , w = Bpe(v, m)
          , _ = Mpe(w)
          , x = Spe(w)
          , b = Epe(h, v)
          , B = t.children.filter(ie => ie.children.length > 0 && ie.children[0].type === Li.Bone)[0]
          , S = UG(B).filter(ie => ie.name !== pO)
          , I = S.map(ie => ie.name)
          , M = S.map(ie => ({
            children: ie.children.filter(ge => ge.name !== pO).map(ge => I.indexOf(ge.name)),
            name: ie.name,
            rotation: [ie.quaternion.x, ie.quaternion.y, ie.quaternion.z, ie.quaternion.w],
            scale: [ie.scale.x, ie.scale.y, ie.scale.z],
            translation: [ie.position.x, ie.position.y, ie.position.z]
        }))
          , L = []
          , D = t.children.filter(ie => ie.type === Li.Group || ie.type === Li.SkinnedMesh)
          , T = [];
        D.forEach(ie => {
            const ge = ie.type === Li.Group ? ie.children[0] : ie
              , _e = ge.geometry.attributes;
            T.push(new _l(_e.position,yr.FLOAT,cn.POSITION,Vo.VEC3,ge.name,void 0)),
            T.push(new _l(_e.normal,yr.FLOAT,cn.NORMAL,Vo.VEC3,ge.name,void 0)),
            T.push(new _l(_e.uv,yr.FLOAT,cn.UV,Vo.VEC2,ge.name,void 0)),
            T.push(new _l(_e.skinWeight,yr.FLOAT,cn.SKIN_WEIGHT,Vo.VEC4,ge.name,void 0)),
            T.push(new _l(_e.skinIndex,yr.UNSIGNED_SHORT,cn.SKIN_INDEX,Vo.VEC4,ge.name,void 0)),
            (ie.type === Li.Group ? ie.children.map(H => H) : [ie]).forEach(H => {
                if (!H.geometry.index)
                    throw new Error(H.name + " geometry.index is null");
                T.push(new _l(H.geometry.index,yr.UNSIGNED_INT,cn.INDEX,Vo.SCALAR,ge.name,H.name))
            }
            ),
            ge.morphTargetDictionary || (ge.morphTargetDictionary = {},
            ge.morphTargetInfluences = [],
            ge.geometry.morphAttributes = {},
            ge.updateMorphTargets()),
            ge.geometry.userData.targetNames = [];
            for (const H in e.expressionManager.expressionMap) {
                const fe = e.expressionManager.expressionMap[H]
                  , Ae = fe._binds.map(q => ({
                    node: S.length,
                    index: q.index,
                    weight: q.weight
                }));
                let J = !1;
                for (const q in Wr)
                    if (H.toLowerCase() === Wr[q].toLowerCase()) {
                        l[Wr[q]] = {
                            morphTargetBinds: Ae,
                            isBinary: fe.isBinary,
                            overrideBlink: fe.overrideBlink,
                            overrideLookAt: fe.overrideLookAt,
                            overrideMouth: fe.overrideMouth
                        },
                        J = !0;
                        break
                    }
                !J && H.toLowerCase() === "surprise" && (l.surprised = {
                    morphTargetBinds: Ae,
                    isBinary: fe.isBinary,
                    overrideBlink: fe.overrideBlink,
                    overrideLookAt: fe.overrideLookAt,
                    overrideMouth: fe.overrideMouth
                },
                J = !0),
                J === !1 && (c[H] = {
                    morphTargetBinds: Ae,
                    isBinary: fe.isBinary,
                    overrideBlink: fe.overrideBlink,
                    overrideLookAt: fe.overrideLookAt,
                    overrideMouth: fe.overrideMouth
                })
            }
            for (const H in ge.morphTargetDictionary) {
                ge.geometry.userData.targetNames.push(H);
                const fe = ge.morphTargetDictionary[H]
                  , Ae = ge.geometry.morphAttributes;
                T.push(new _l(Ae.position[fe],yr.FLOAT,cn.BLEND_POSITION,Vo.VEC3,ge.name,ex + H)),
                T.push(new _l(Ae.normal[fe],yr.FLOAT,cn.BLEND_NORMAL,Vo.VEC3,ge.name,ex + H))
            }
        }
        ),
        Object.keys(l).length > 0 && (A.preset = l),
        Object.keys(c).length > 0 && (A.custom = c),
        D.forEach(ie => {
            const ge = ie.type === Li.Group ? ie.children[0] : ie
              , _e = new Float32Array(ge.skeleton.boneInverses.map(se => se.elements).flat());
            T.push(new _l(new ct(_e,16),yr.FLOAT,cn.BIND_MATRIX,Vo.MAT4,ge.name,ge.name))
        }
        ),
        L.push(...T.map(ie => ({
            bufferView: -1,
            byteOffset: 0,
            componentType: ie.valueType,
            count: ie.attribute.count,
            max: ie.max,
            min: ie.min,
            normalized: !1,
            type: ie.accessorsType
        })));
        const y = xpe(D, T, d);
        D.forEach( (ie, ge) => {
            M.push({
                mesh: ge,
                name: ie.name,
                rotation: [ie.quaternion.x, ie.quaternion.y, ie.quaternion.z, ie.quaternion.w],
                scale: [ie.scale.x, ie.scale.y, ie.scale.z],
                skin: ge,
                translation: [ie.position.x, ie.position.y, ie.position.z]
            })
        }
        );
        const E = bpe(D, T, I)
          , R = {
            offsetFromHeadBone: [0, 0, 0],
            rangeMapHorizontalInner: {
                inputMaxValue: u.applier.rangeMapHorizontalInner.inputMaxValue,
                outputScale: u.applier.rangeMapHorizontalInner.outputScale
            },
            rangeMapHorizontalOuter: {
                inputMaxValue: u.applier.rangeMapHorizontalOuter.inputMaxValue,
                outputScale: u.applier.rangeMapHorizontalOuter.outputScale
            },
            rangeMapVerticalDown: {
                inputMaxValue: u.applier.rangeMapVerticalDown.inputMaxValue,
                outputScale: u.applier.rangeMapVerticalDown.outputScale
            },
            rangeMapVerticalUp: {
                inputMaxValue: u.applier.rangeMapVerticalUp.inputMaxValue,
                outputScale: u.applier.rangeMapVerticalUp.outputScale
            },
            type: "bone"
        }
          , F = {
            humanBones: {}
        };
        for (const ie in s.humanBones)
            F.humanBones[ie] = {
                node: I.indexOf(s.humanBones[ie].node.name)
            };
        const O = o
          , z = [];
        z.push(...v.map(ie => ({
            buffer: mO(ie.imageBitmap),
            type: cn.IMAGE
        }))),
        z.push(...T.map(ie => ({
            buffer: ie.buffer,
            type: ie.type
        }))),
        m && z.push({
            buffer: mO(m.imageBitmap),
            type: cn.IMAGE
        });
        let j = 0
          , Q = 0
          , C = 0;
        const W = z.map( (ie, ge) => {
            const _e = {
                buffer: 0,
                byteLength: ie.buffer.byteLength,
                byteOffset: j,
                target: ie.type === cn.IMAGE || ie.type === cn.BIND_MATRIX ? void 0 : ie.type === cn.INDEX ? yr.ELEMENT_ARRAY_BUFFER : yr.ARRAY_BUFFER
            };
            return j += ie.buffer.byteLength,
            ie.type === cn.IMAGE ? w[Q++].bufferView = ge : L[C++].bufferView = ge,
            _e
        }
        )
          , ee = Cpe(t, M)
          , P = {
            accessors: L,
            asset: f,
            buffers: [{
                byteLength: j
            }],
            bufferViews: W,
            extensions: {
                VRMC_vrm: {
                    expressions: A,
                    humanoid: F,
                    lookAt: R,
                    meta: O,
                    specVersion: "1.0"
                }
            },
            extensionsUsed: ["KHR_materials_unlit", "KHR_texture_transform", "VRMC_materials_mtoon", "VRMC_vrm"],
            images: w,
            materials: b,
            meshes: y,
            nodes: M,
            samplers: _,
            avatar: 0,
            scenes: ee,
            skins: E,
            textures: x
        }
          , re = new gO(cT(JSON.stringify(P, void 0, 2)),"JSON")
          , ue = new gO(Um(z.map(ie => ie.buffer)),"BIN\0")
          , le = Um([re.buffer, ue.buffer])
          , me = Um([cT("glTF"), lT(2, 4), lT(le.byteLength + 12, 4)]);
        i(Um([me, le]))
    }
}
function UG(n) {
    return n.children.length <= 0 ? [n] : [n].concat(n.children.map(e => UG(e)).flat())
}
function mO(n) {
    const e = document.createElement("canvas");
    e.width = n.width,
    e.height = n.height,
    e.getContext("2d").drawImage(n, 0, 0);
    const t = e.toDataURL("image/png")
      , r = atob(t.split(",")[1])
      , i = new ArrayBuffer(r.length)
      , s = new DataView(i);
    for (let o = 0; o < r.length; o++)
        s.setUint8(o, r.charCodeAt(o));
    return i
}
function lT(n, e) {
    const t = new ArrayBuffer(e);
    return new DataView(t).setUint32(0, n, !0),
    t
}
function cT(n) {
    return new TextEncoder().encode(n).buffer
}
function Um(n) {
    let e = 0;
    for (let i = 0; i < n.length; i++)
        e += n[i].byteLength;
    const t = new Uint8Array(e);
    let r = 0;
    for (let i = 0; i < n.length; ++i)
        t.set(new Uint8Array(n[i]), r),
        r += n[i].byteLength;
    return t.buffer
}
function _pe(n, e) {
    const t = e === yr.UNSIGNED_SHORT ? 2 : 4
      , r = n.array;
    let i = 0;
    const s = new ArrayBuffer(n.count * n.itemSize * t)
      , o = new DataView(s);
    for (let a = 0; a < n.count; a++)
        for (let l = 0; l < n.itemSize; l++) {
            let c;
            n.itemSize > 4 ? c = r[a * n.itemSize + l] : l === 0 ? c = n.getX(a) : l === 1 ? c = n.getY(a) : l === 2 ? c = n.getZ(a) : c = n.getW(a),
            e === yr.UNSIGNED_SHORT ? o.setUint16(i, c, !0) : e === yr.UNSIGNED_INT ? o.setUint32(i, c, !0) : o.setFloat32(i, c, !0),
            i += t
        }
    return s
}
let gO = class {
    constructor(e, t) {
        this.data = e,
        this.type = t;
        const r = this.data;
        this.buffer = Um([lT(r.byteLength, 4), cT(this.type), r])
    }
    paddingBinary(e, t) {
        const r = Math.ceil(e.byteLength / 4) * 4;
        if (e.byteLength === r)
            return e;
        const i = new Uint8Array(r);
        i.set(new Uint8Array(e), 0);
        for (let s = e.byteLength; s < r; s++)
            i.set(new Uint8Array(t), s);
        return i.buffer
    }
}
  , _l = class {
    constructor(e, t, r, i, s, o) {
        this.attribute = e,
        this.type = r,
        this.valueType = t,
        this.accessorsType = i,
        this.meshName = s,
        this.name = o,
        this.buffer = _pe(this.attribute, this.valueType),
        this.max = r === cn.POSITION || r === cn.BLEND_POSITION ? [Math.max.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 0)), Math.max.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 1)), Math.max.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 2))] : void 0,
        this.min = r === cn.POSITION || r === cn.BLEND_POSITION ? [Math.min.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 0)), Math.min.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 1)), Math.min.apply(null, Array.from(this.attribute.array).filter( (a, l) => l % 3 === 2))] : void 0
    }
}
;
var zh;
(function(n) {
    n.MeshBasicMaterial = "MeshBasicMaterial",
    n.MeshStandardMaterial = "MeshStandardMaterial",
    n.MToonMaterial = "MToonMaterial"
}
)(zh || (zh = {}));
var Vo;
(function(n) {
    n.SCALAR = "SCALAR",
    n.VEC2 = "VEC2",
    n.VEC3 = "VEC3",
    n.VEC4 = "VEC4",
    n.MAT4 = "MAT4"
}
)(Vo || (Vo = {}));
var cn;
(function(n) {
    n.POSITION = "POSITION",
    n.NORMAL = "NORMAL",
    n.UV = "UV",
    n.INDEX = "INDEX",
    n.SKIN_WEIGHT = "SKIN_WEIGHT",
    n.SKIN_INDEX = "SKIN_INDEX",
    n.BLEND_POSITION = "BLEND_POSITION",
    n.BLEND_NORMAL = "BLEND_NORMAL",
    n.BIND_MATRIX = "BIND_MATRIX",
    n.IMAGE = "IMAGE"
}
)(cn || (cn = {}));
var Li;
(function(n) {
    n.Group = "Group",
    n.SkinnedMesh = "SkinnedMesh",
    n.Object3D = "Object3D",
    n.Bone = "Bone"
}
)(Li || (Li = {}));
const xpe = (n, e, t) => n.map(r => {
    const i = r.type === Li.Group ? r.children[0] : r
      , s = r.type === Li.Group ? r.children.map(o => o) : [r];
    return {
        name: r.name,
        primitives: s.map(o => {
            const a = e.map(c => c.meshName === i.name ? c.type : null)
              , l = Array.isArray(o.material) ? o.material[0].name : o.material.name;
            return {
                attributes: {
                    JOINTS_0: a.indexOf(cn.SKIN_INDEX),
                    NORMAL: a.indexOf(cn.NORMAL),
                    POSITION: a.indexOf(cn.POSITION),
                    TEXCOORD_0: a.indexOf(cn.UV),
                    WEIGHTS_0: a.indexOf(cn.SKIN_WEIGHT)
                },
                extras: {
                    targetNames: o.geometry.userData.targetNames
                },
                indices: e.map(c => c.type === cn.INDEX && c.meshName === i.name ? c.name : null).indexOf(o.name),
                material: t.indexOf(l),
                mode: 4,
                targets: i.geometry.userData.targetNames ? i.geometry.userData.targetNames.map(c => ({
                    NORMAL: e.map(A => A.type === cn.BLEND_NORMAL && A.meshName === i.name ? A.name : null).indexOf(ex + c),
                    POSITION: e.map(A => A.type === cn.BLEND_POSITION && A.meshName === i.name ? A.name : null).indexOf(ex + c)
                })) : void 0
            }
        }
        )
    }
}
)
  , bpe = (n, e, t) => n.map(r => {
    const i = r.type === Li.Group ? r.children[0] : r;
    return {
        inverseBindMatrices: e.map(s => s.type === cn.BIND_MATRIX ? s.meshName : null).indexOf(i.name),
        joints: i.skeleton.bones.map(s => t.indexOf(s.name)),
        skeleton: t.indexOf(i.skeleton.bones[0].name)
    }
}
)
  , Epe = (n, e) => n.map(t => {
    let r, i = null;
    if (t = t.userData.vrmMaterial ? t.userData.vrmMaterial : t,
    t.type === "ShaderMaterial")
        i = t.userData.gltfExtensions.VRMC_materials_mtoon,
        i.shadeMultiplyTexture = {
            index: e.map(A => A.name).indexOf(t.uniforms.shadeMultiplyTexture.name)
        },
        r = t.color ? [1, 1, 1, 1] : void 0;
    else {
        const c = t;
        r = c.color ? [c.color.r, c.color.g, c.color.b, 1] : void 0
    }
    let s = -1;
    t.map ? s = e.map(c => c.name).indexOf(t.name) : t.uniforms && t.uniforms.map && (s = e.map(c => c.name).indexOf(t.uniforms.map.name));
    const o = s >= 0 ? {
        extensions: {
            KHR_texture_transform: {
                offset: [0, 0],
                scale: [1, 1]
            }
        },
        index: s,
        texCoord: 0
    } : void 0
      , a = ( () => {
        switch (t.type) {
        case zh.MeshStandardMaterial:
            return t.metalness;
        case zh.MeshBasicMaterial:
            return 0;
        default:
            return 0
        }
    }
    )()
      , l = ( () => {
        switch (t.type) {
        case zh.MeshStandardMaterial:
            return t.roughness;
        case zh.MeshBasicMaterial:
            return .9;
        default:
            return .9
        }
    }
    )();
    return {
        alphaCutoff: t.alphaTest > 0 ? t.alphaTest : void 0,
        alphaMode: t.transparent ? "BLEND" : t.alphaTest > 0 ? "MASK" : "OPAQUE",
        doubleSided: t.side === 2,
        extensions: t.type === "ShaderMaterial" ? {
            KHR_materials_unlit: {},
            VRMC_materials_mtoon: i
        } : void 0,
        name: t.name,
        pbrMetallicRoughness: {
            baseColorFactor: r,
            baseColorTexture: o,
            metallicFactor: a,
            roughnessFactor: l
        }
    }
}
)
  , Bpe = (n, e) => (e ? n.concat(e) : n).filter(t => t && t.imageBitmap).map(t => ({
    bufferView: -1,
    mimeType: "image/png",
    name: t.name
}))
  , Mpe = n => n.map( () => ({
    magFilter: yr.LINEAR,
    minFilter: yr.LINEAR,
    wrapS: yr.REPEAT,
    wrapT: yr.REPEAT
}))
  , Spe = n => n.map( (e, t) => ({
    sampler: 0,
    source: t
}))
  , Cpe = (n, e) => {
    const t = e.map(r => r.name);
    return [{
        nodes: n.children.filter(r => r.type === Li.Object3D || r.type === Li.SkinnedMesh || r.type === Li.Group || r.type === Li.Bone).map(r => t.indexOf(r.name))
    }]
}
  , FG = 0
  , Tpe = 1
  , PG = 2
  , vO = 2
  , HB = 1.25
  , yO = 1
  , og = 6 * 4 + 4 + 4
  , F1 = 65535
  , Ipe = Math.pow(2, -24)
  , zB = Symbol("SKIP_GENERATION");
function Rpe(n) {
    return n.index ? n.index.count : n.attributes.position.count
}
function Jd(n) {
    return Rpe(n) / 3
}
function Upe(n, e=ArrayBuffer) {
    return n > 65535 ? new Uint32Array(new e(4 * n)) : new Uint16Array(new e(2 * n))
}
function Fpe(n, e) {
    if (!n.index) {
        const t = n.attributes.position.count
          , r = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer
          , i = Upe(t, r);
        n.setIndex(new ct(i,1));
        for (let s = 0; s < t; s++)
            i[s] = s
    }
}
function LG(n, e) {
    const t = Jd(n)
      , r = e || n.drawRange
      , i = r.start / 3
      , s = (r.start + r.count) / 3
      , o = Math.max(0, i)
      , a = Math.min(t, s) - o;
    return [{
        offset: Math.floor(o),
        count: Math.floor(a)
    }]
}
function DG(n, e) {
    if (!n.groups || !n.groups.length)
        return LG(n, e);
    const t = []
      , r = new Set
      , i = e || n.drawRange
      , s = i.start / 3
      , o = (i.start + i.count) / 3;
    for (const l of n.groups) {
        const c = l.start / 3
          , A = (l.start + l.count) / 3;
        r.add(Math.max(s, c)),
        r.add(Math.min(o, A))
    }
    const a = Array.from(r.values()).sort( (l, c) => l - c);
    for (let l = 0; l < a.length - 1; l++) {
        const c = a[l]
          , A = a[l + 1];
        t.push({
            offset: Math.floor(c),
            count: Math.floor(A - c)
        })
    }
    return t
}
function Ppe(n, e) {
    const t = Jd(n)
      , r = DG(n, e).sort( (o, a) => o.offset - a.offset)
      , i = r[r.length - 1];
    i.count = Math.min(t - i.offset, i.count);
    let s = 0;
    return r.forEach( ({count: o}) => s += o),
    t !== s
}
function GB(n, e, t, r, i) {
    let s = 1 / 0
      , o = 1 / 0
      , a = 1 / 0
      , l = -1 / 0
      , c = -1 / 0
      , A = -1 / 0
      , u = 1 / 0
      , f = 1 / 0
      , h = 1 / 0
      , d = -1 / 0
      , m = -1 / 0
      , g = -1 / 0;
    for (let p = e * 6, v = (e + t) * 6; p < v; p += 6) {
        const w = n[p + 0]
          , _ = n[p + 1]
          , x = w - _
          , b = w + _;
        x < s && (s = x),
        b > l && (l = b),
        w < u && (u = w),
        w > d && (d = w);
        const B = n[p + 2]
          , S = n[p + 3]
          , I = B - S
          , M = B + S;
        I < o && (o = I),
        M > c && (c = M),
        B < f && (f = B),
        B > m && (m = B);
        const L = n[p + 4]
          , D = n[p + 5]
          , T = L - D
          , y = L + D;
        T < a && (a = T),
        y > A && (A = y),
        L < h && (h = L),
        L > g && (g = L)
    }
    r[0] = s,
    r[1] = o,
    r[2] = a,
    r[3] = l,
    r[4] = c,
    r[5] = A,
    i[0] = u,
    i[1] = f,
    i[2] = h,
    i[3] = d,
    i[4] = m,
    i[5] = g
}
function Lpe(n, e=null, t=null, r=null) {
    const i = n.attributes.position
      , s = n.index ? n.index.array : null
      , o = Jd(n)
      , a = i.normalized;
    let l;
    e === null ? (l = new Float32Array(o * 6),
    t = 0,
    r = o) : (l = e,
    t = t || 0,
    r = r || o);
    const c = i.array
      , A = i.offset || 0;
    let u = 3;
    i.isInterleavedBufferAttribute && (u = i.data.stride);
    const f = ["getX", "getY", "getZ"];
    for (let h = t; h < t + r; h++) {
        const d = h * 3
          , m = h * 6;
        let g = d + 0
          , p = d + 1
          , v = d + 2;
        s && (g = s[g],
        p = s[p],
        v = s[v]),
        a || (g = g * u + A,
        p = p * u + A,
        v = v * u + A);
        for (let w = 0; w < 3; w++) {
            let _, x, b;
            a ? (_ = i[f[w]](g),
            x = i[f[w]](p),
            b = i[f[w]](v)) : (_ = c[g + w],
            x = c[p + w],
            b = c[v + w]);
            let B = _;
            x < B && (B = x),
            b < B && (B = b);
            let S = _;
            x > S && (S = x),
            b > S && (S = b);
            const I = (S - B) / 2
              , M = w * 2;
            l[m + M + 0] = B + I,
            l[m + M + 1] = I + (Math.abs(B) + I) * Ipe
        }
    }
    return l
}
function tr(n, e, t) {
    return t.min.x = e[n],
    t.min.y = e[n + 1],
    t.min.z = e[n + 2],
    t.max.x = e[n + 3],
    t.max.y = e[n + 4],
    t.max.z = e[n + 5],
    t
}
function wO(n) {
    let e = -1
      , t = -1 / 0;
    for (let r = 0; r < 3; r++) {
        const i = n[r + 3] - n[r];
        i > t && (t = i,
        e = r)
    }
    return e
}
function _O(n, e) {
    e.set(n)
}
function xO(n, e, t) {
    let r, i;
    for (let s = 0; s < 3; s++) {
        const o = s + 3;
        r = n[s],
        i = e[s],
        t[s] = r < i ? r : i,
        r = n[o],
        i = e[o],
        t[o] = r > i ? r : i
    }
}
function wy(n, e, t) {
    for (let r = 0; r < 3; r++) {
        const i = e[n + 2 * r]
          , s = e[n + 2 * r + 1]
          , o = i - s
          , a = i + s;
        o < t[r] && (t[r] = o),
        a > t[r + 3] && (t[r + 3] = a)
    }
}
function Yp(n) {
    const e = n[3] - n[0]
      , t = n[4] - n[1]
      , r = n[5] - n[2];
    return 2 * (e * t + t * r + r * e)
}
const Ml = 32
  , Dpe = (n, e) => n.candidate - e.candidate
  , Tc = new Array(Ml).fill().map( () => ({
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
}))
  , _y = new Float32Array(6);
function Npe(n, e, t, r, i, s) {
    let o = -1
      , a = 0;
    if (s === FG)
        o = wO(e),
        o !== -1 && (a = (e[o] + e[o + 3]) / 2);
    else if (s === Tpe)
        o = wO(n),
        o !== -1 && (a = Ope(t, r, i, o));
    else if (s === PG) {
        const l = Yp(n);
        let c = HB * i;
        const A = r * 6
          , u = (r + i) * 6;
        for (let f = 0; f < 3; f++) {
            const h = e[f]
              , g = (e[f + 3] - h) / Ml;
            if (i < Ml / 4) {
                const p = [...Tc];
                p.length = i;
                let v = 0;
                for (let _ = A; _ < u; _ += 6,
                v++) {
                    const x = p[v];
                    x.candidate = t[_ + 2 * f],
                    x.count = 0;
                    const {bounds: b, leftCacheBounds: B, rightCacheBounds: S} = x;
                    for (let I = 0; I < 3; I++)
                        S[I] = 1 / 0,
                        S[I + 3] = -1 / 0,
                        B[I] = 1 / 0,
                        B[I + 3] = -1 / 0,
                        b[I] = 1 / 0,
                        b[I + 3] = -1 / 0;
                    wy(_, t, b)
                }
                p.sort(Dpe);
                let w = i;
                for (let _ = 0; _ < w; _++) {
                    const x = p[_];
                    for (; _ + 1 < w && p[_ + 1].candidate === x.candidate; )
                        p.splice(_ + 1, 1),
                        w--
                }
                for (let _ = A; _ < u; _ += 6) {
                    const x = t[_ + 2 * f];
                    for (let b = 0; b < w; b++) {
                        const B = p[b];
                        x >= B.candidate ? wy(_, t, B.rightCacheBounds) : (wy(_, t, B.leftCacheBounds),
                        B.count++)
                    }
                }
                for (let _ = 0; _ < w; _++) {
                    const x = p[_]
                      , b = x.count
                      , B = i - x.count
                      , S = x.leftCacheBounds
                      , I = x.rightCacheBounds;
                    let M = 0;
                    b !== 0 && (M = Yp(S) / l);
                    let L = 0;
                    B !== 0 && (L = Yp(I) / l);
                    const D = yO + HB * (M * b + L * B);
                    D < c && (o = f,
                    c = D,
                    a = x.candidate)
                }
            } else {
                for (let w = 0; w < Ml; w++) {
                    const _ = Tc[w];
                    _.count = 0,
                    _.candidate = h + g + w * g;
                    const x = _.bounds;
                    for (let b = 0; b < 3; b++)
                        x[b] = 1 / 0,
                        x[b + 3] = -1 / 0
                }
                for (let w = A; w < u; w += 6) {
                    let b = ~~((t[w + 2 * f] - h) / g);
                    b >= Ml && (b = Ml - 1);
                    const B = Tc[b];
                    B.count++,
                    wy(w, t, B.bounds)
                }
                const p = Tc[Ml - 1];
                _O(p.bounds, p.rightCacheBounds);
                for (let w = Ml - 2; w >= 0; w--) {
                    const _ = Tc[w]
                      , x = Tc[w + 1];
                    xO(_.bounds, x.rightCacheBounds, _.rightCacheBounds)
                }
                let v = 0;
                for (let w = 0; w < Ml - 1; w++) {
                    const _ = Tc[w]
                      , x = _.count
                      , b = _.bounds
                      , S = Tc[w + 1].rightCacheBounds;
                    x !== 0 && (v === 0 ? _O(b, _y) : xO(b, _y, _y)),
                    v += x;
                    let I = 0
                      , M = 0;
                    v !== 0 && (I = Yp(_y) / l);
                    const L = i - v;
                    L !== 0 && (M = Yp(S) / l);
                    const D = yO + HB * (I * v + M * L);
                    D < c && (o = f,
                    c = D,
                    a = _.candidate)
                }
            }
        }
    } else
        console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);
    return {
        axis: o,
        pos: a
    }
}
function Ope(n, e, t, r) {
    let i = 0;
    for (let s = e, o = e + t; s < o; s++)
        i += n[s * 6 + r * 2];
    return i / t
}
class VB {
    constructor() {
        this.boundingData = new Float32Array(6)
    }
}
function kpe(n, e, t, r, i, s) {
    let o = r
      , a = r + i - 1;
    const l = s.pos
      , c = s.axis * 2;
    for (; ; ) {
        for (; o <= a && t[o * 6 + c] < l; )
            o++;
        for (; o <= a && t[a * 6 + c] >= l; )
            a--;
        if (o < a) {
            for (let A = 0; A < 3; A++) {
                let u = e[o * 3 + A];
                e[o * 3 + A] = e[a * 3 + A],
                e[a * 3 + A] = u
            }
            for (let A = 0; A < 6; A++) {
                let u = t[o * 6 + A];
                t[o * 6 + A] = t[a * 6 + A],
                t[a * 6 + A] = u
            }
            o++,
            a--
        } else
            return o
    }
}
function Qpe(n, e, t, r, i, s) {
    let o = r
      , a = r + i - 1;
    const l = s.pos
      , c = s.axis * 2;
    for (; ; ) {
        for (; o <= a && t[o * 6 + c] < l; )
            o++;
        for (; o <= a && t[a * 6 + c] >= l; )
            a--;
        if (o < a) {
            let A = n[o];
            n[o] = n[a],
            n[a] = A;
            for (let u = 0; u < 6; u++) {
                let f = t[o * 6 + u];
                t[o * 6 + u] = t[a * 6 + u],
                t[a * 6 + u] = f
            }
            o++,
            a--
        } else
            return o
    }
}
function Zi(n, e) {
    return e[n + 15] === 65535
}
function Fs(n, e) {
    return e[n + 6]
}
function po(n, e) {
    return e[n + 14]
}
function mo(n) {
    return n + 8
}
function go(n, e) {
    return e[n + 6]
}
function NG(n, e) {
    return e[n + 7]
}
let OG, Fm, Dw, kG;
const Hpe = Math.pow(2, 32);
function AT(n) {
    return "count"in n ? 1 : 1 + AT(n.left) + AT(n.right)
}
function zpe(n, e, t) {
    return OG = new Float32Array(t),
    Fm = new Uint32Array(t),
    Dw = new Uint16Array(t),
    kG = new Uint8Array(t),
    uT(n, e)
}
function uT(n, e) {
    const t = n / 4
      , r = n / 2
      , i = "count"in e
      , s = e.boundingData;
    for (let o = 0; o < 6; o++)
        OG[t + o] = s[o];
    if (i)
        if (e.buffer) {
            const o = e.buffer;
            kG.set(new Uint8Array(o), n);
            for (let a = n, l = n + o.byteLength; a < l; a += og) {
                const c = a / 2;
                Zi(c, Dw) || (Fm[a / 4 + 6] += t)
            }
            return n + o.byteLength
        } else {
            const o = e.offset
              , a = e.count;
            return Fm[t + 6] = o,
            Dw[r + 14] = a,
            Dw[r + 15] = F1,
            n + og
        }
    else {
        const o = e.left
          , a = e.right
          , l = e.splitAxis;
        let c;
        if (c = uT(n + og, o),
        c / 4 > Hpe)
            throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
        return Fm[t + 6] = c / 4,
        c = uT(c, a),
        Fm[t + 7] = l,
        c
    }
}
function Gpe(n, e) {
    const t = (n.index ? n.index.count : n.attributes.position.count) / 3
      , r = t > 2 ** 16
      , i = r ? 4 : 2
      , s = e ? new SharedArrayBuffer(t * i) : new ArrayBuffer(t * i)
      , o = r ? new Uint32Array(s) : new Uint16Array(s);
    for (let a = 0, l = o.length; a < l; a++)
        o[a] = a;
    return o
}
function Vpe(n, e, t, r, i) {
    const {maxDepth: s, verbose: o, maxLeafTris: a, strategy: l, onProgress: c, indirect: A} = i
      , u = n._indirectBuffer
      , f = n.geometry
      , h = f.index ? f.index.array : null
      , d = A ? Qpe : kpe
      , m = Jd(f)
      , g = new Float32Array(6);
    let p = !1;
    const v = new VB;
    return GB(e, t, r, v.boundingData, g),
    _(v, t, r, g),
    v;
    function w(x) {
        c && c(x / m)
    }
    function _(x, b, B, S=null, I=0) {
        if (!p && I >= s && (p = !0,
        o && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`),
        console.warn(f))),
        B <= a || I >= s)
            return w(b + B),
            x.offset = b,
            x.count = B,
            x;
        const M = Npe(x.boundingData, S, e, b, B, l);
        if (M.axis === -1)
            return w(b + B),
            x.offset = b,
            x.count = B,
            x;
        const L = d(u, h, e, b, B, M);
        if (L === b || L === b + B)
            w(b + B),
            x.offset = b,
            x.count = B;
        else {
            x.splitAxis = M.axis;
            const D = new VB
              , T = b
              , y = L - b;
            x.left = D,
            GB(e, T, y, D.boundingData, g),
            _(D, T, y, g, I + 1);
            const E = new VB
              , R = L
              , F = B - y;
            x.right = E,
            GB(e, R, F, E.boundingData, g),
            _(E, R, F, g, I + 1)
        }
        return x
    }
}
function jpe(n, e) {
    const t = n.geometry;
    e.indirect && (n._indirectBuffer = Gpe(t, e.useSharedArrayBuffer),
    Ppe(t, e.range) && !e.verbose && console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),
    n._indirectBuffer || Fpe(t, e);
    const r = e.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer
      , i = Lpe(t)
      , s = e.indirect ? LG(t, e.range) : DG(t, e.range);
    n._roots = s.map(o => {
        const a = Vpe(n, i, o.offset, o.count, e)
          , l = AT(a)
          , c = new r(og * l);
        return zpe(0, a, c),
        c
    }
    )
}
class sc {
    constructor() {
        this.min = 1 / 0,
        this.max = -1 / 0
    }
    setFromPointsField(e, t) {
        let r = 1 / 0
          , i = -1 / 0;
        for (let s = 0, o = e.length; s < o; s++) {
            const l = e[s][t];
            r = l < r ? l : r,
            i = l > i ? l : i
        }
        this.min = r,
        this.max = i
    }
    setFromPoints(e, t) {
        let r = 1 / 0
          , i = -1 / 0;
        for (let s = 0, o = t.length; s < o; s++) {
            const a = t[s]
              , l = e.dot(a);
            r = l < r ? l : r,
            i = l > i ? l : i
        }
        this.min = r,
        this.max = i
    }
    isSeparated(e) {
        return this.min > e.max || e.min > this.max
    }
}
sc.prototype.setFromBox = function() {
    const n = new $;
    return function(t, r) {
        const i = r.min
          , s = r.max;
        let o = 1 / 0
          , a = -1 / 0;
        for (let l = 0; l <= 1; l++)
            for (let c = 0; c <= 1; c++)
                for (let A = 0; A <= 1; A++) {
                    n.x = i.x * l + s.x * (1 - l),
                    n.y = i.y * c + s.y * (1 - c),
                    n.z = i.z * A + s.z * (1 - A);
                    const u = t.dot(n);
                    o = Math.min(u, o),
                    a = Math.max(u, a)
                }
        this.min = o,
        this.max = a
    }
}();
const Wpe = function() {
    const n = new $
      , e = new $
      , t = new $;
    return function(i, s, o) {
        const a = i.start
          , l = n
          , c = s.start
          , A = e;
        t.subVectors(a, c),
        n.subVectors(i.end, i.start),
        e.subVectors(s.end, s.start);
        const u = t.dot(A)
          , f = A.dot(l)
          , h = A.dot(A)
          , d = t.dot(l)
          , g = l.dot(l) * h - f * f;
        let p, v;
        g !== 0 ? p = (u * f - d * h) / g : p = 0,
        v = (u + p * f) / h,
        o.x = p,
        o.y = v
    }
}()
  , A2 = function() {
    const n = new We
      , e = new $
      , t = new $;
    return function(i, s, o, a) {
        Wpe(i, s, n);
        let l = n.x
          , c = n.y;
        if (l >= 0 && l <= 1 && c >= 0 && c <= 1) {
            i.at(l, o),
            s.at(c, a);
            return
        } else if (l >= 0 && l <= 1) {
            c < 0 ? s.at(0, a) : s.at(1, a),
            i.closestPointToPoint(a, !0, o);
            return
        } else if (c >= 0 && c <= 1) {
            l < 0 ? i.at(0, o) : i.at(1, o),
            s.closestPointToPoint(o, !0, a);
            return
        } else {
            let A;
            l < 0 ? A = i.start : A = i.end;
            let u;
            c < 0 ? u = s.start : u = s.end;
            const f = e
              , h = t;
            if (i.closestPointToPoint(u, !0, e),
            s.closestPointToPoint(A, !0, t),
            f.distanceToSquared(u) <= h.distanceToSquared(A)) {
                o.copy(f),
                a.copy(u);
                return
            } else {
                o.copy(A),
                a.copy(h);
                return
            }
        }
    }
}()
  , Kpe = function() {
    const n = new $
      , e = new $
      , t = new Ra
      , r = new Wl;
    return function(s, o) {
        const {radius: a, center: l} = s
          , {a: c, b: A, c: u} = o;
        if (r.start = c,
        r.end = A,
        r.closestPointToPoint(l, !0, n).distanceTo(l) <= a || (r.start = c,
        r.end = u,
        r.closestPointToPoint(l, !0, n).distanceTo(l) <= a) || (r.start = A,
        r.end = u,
        r.closestPointToPoint(l, !0, n).distanceTo(l) <= a))
            return !0;
        const m = o.getPlane(t);
        if (Math.abs(m.distanceToPoint(l)) <= a) {
            const p = m.projectPoint(l, e);
            if (o.containsPoint(p))
                return !0
        }
        return !1
    }
}()
  , Xpe = 1e-15;
function jB(n) {
    return Math.abs(n) < Xpe
}
class ca extends Kr {
    constructor(...e) {
        super(...e),
        this.isExtendedTriangle = !0,
        this.satAxes = new Array(4).fill().map( () => new $),
        this.satBounds = new Array(4).fill().map( () => new sc),
        this.points = [this.a, this.b, this.c],
        this.sphere = new Mi,
        this.plane = new Ra,
        this.needsUpdate = !0
    }
    intersectsSphere(e) {
        return Kpe(e, this)
    }
    update() {
        const e = this.a
          , t = this.b
          , r = this.c
          , i = this.points
          , s = this.satAxes
          , o = this.satBounds
          , a = s[0]
          , l = o[0];
        this.getNormal(a),
        l.setFromPoints(a, i);
        const c = s[1]
          , A = o[1];
        c.subVectors(e, t),
        A.setFromPoints(c, i);
        const u = s[2]
          , f = o[2];
        u.subVectors(t, r),
        f.setFromPoints(u, i);
        const h = s[3]
          , d = o[3];
        h.subVectors(r, e),
        d.setFromPoints(h, i),
        this.sphere.setFromPoints(this.points),
        this.plane.setFromNormalAndCoplanarPoint(a, e),
        this.needsUpdate = !1
    }
}
ca.prototype.closestPointToSegment = function() {
    const n = new $
      , e = new $
      , t = new Wl;
    return function(i, s=null, o=null) {
        const {start: a, end: l} = i
          , c = this.points;
        let A, u = 1 / 0;
        for (let f = 0; f < 3; f++) {
            const h = (f + 1) % 3;
            t.start.copy(c[f]),
            t.end.copy(c[h]),
            A2(t, i, n, e),
            A = n.distanceToSquared(e),
            A < u && (u = A,
            s && s.copy(n),
            o && o.copy(e))
        }
        return this.closestPointToPoint(a, n),
        A = a.distanceToSquared(n),
        A < u && (u = A,
        s && s.copy(n),
        o && o.copy(a)),
        this.closestPointToPoint(l, n),
        A = l.distanceToSquared(n),
        A < u && (u = A,
        s && s.copy(n),
        o && o.copy(l)),
        Math.sqrt(u)
    }
}();
ca.prototype.intersectsTriangle = function() {
    const n = new ca
      , e = new Array(3)
      , t = new Array(3)
      , r = new sc
      , i = new sc
      , s = new $
      , o = new $
      , a = new $
      , l = new $
      , c = new $
      , A = new Wl
      , u = new Wl
      , f = new Wl
      , h = new $;
    function d(m, g, p) {
        const v = m.points;
        let w = 0
          , _ = -1;
        for (let x = 0; x < 3; x++) {
            const {start: b, end: B} = A;
            b.copy(v[x]),
            B.copy(v[(x + 1) % 3]),
            A.delta(o);
            const S = jB(g.distanceToPoint(b));
            if (jB(g.normal.dot(o)) && S) {
                p.copy(A),
                w = 2;
                break
            }
            const I = g.intersectLine(A, h);
            if (!I && S && h.copy(b),
            (I || S) && !jB(h.distanceTo(B))) {
                if (w <= 1)
                    (w === 1 ? p.start : p.end).copy(h),
                    S && (_ = w);
                else if (w >= 2) {
                    (_ === 1 ? p.start : p.end).copy(h),
                    w = 2;
                    break
                }
                if (w++,
                w === 2 && _ === -1)
                    break
            }
        }
        return w
    }
    return function(g, p=null, v=!1) {
        this.needsUpdate && this.update(),
        g.isExtendedTriangle ? g.needsUpdate && g.update() : (n.copy(g),
        n.update(),
        g = n);
        const w = this.plane
          , _ = g.plane;
        if (Math.abs(w.normal.dot(_.normal)) > 1 - 1e-10) {
            const x = this.satBounds
              , b = this.satAxes;
            t[0] = g.a,
            t[1] = g.b,
            t[2] = g.c;
            for (let I = 0; I < 4; I++) {
                const M = x[I]
                  , L = b[I];
                if (r.setFromPoints(L, t),
                M.isSeparated(r))
                    return !1
            }
            const B = g.satBounds
              , S = g.satAxes;
            e[0] = this.a,
            e[1] = this.b,
            e[2] = this.c;
            for (let I = 0; I < 4; I++) {
                const M = B[I]
                  , L = S[I];
                if (r.setFromPoints(L, e),
                M.isSeparated(r))
                    return !1
            }
            for (let I = 0; I < 4; I++) {
                const M = b[I];
                for (let L = 0; L < 4; L++) {
                    const D = S[L];
                    if (s.crossVectors(M, D),
                    r.setFromPoints(s, e),
                    i.setFromPoints(s, t),
                    r.isSeparated(i))
                        return !1
                }
            }
            return p && (v || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),
            p.start.set(0, 0, 0),
            p.end.set(0, 0, 0)),
            !0
        } else {
            const x = d(this, _, u);
            if (x === 1 && g.containsPoint(u.end))
                return p && (p.start.copy(u.end),
                p.end.copy(u.end)),
                !0;
            if (x !== 2)
                return !1;
            const b = d(g, w, f);
            if (b === 1 && this.containsPoint(f.end))
                return p && (p.start.copy(f.end),
                p.end.copy(f.end)),
                !0;
            if (b !== 2)
                return !1;
            if (u.delta(a),
            f.delta(l),
            a.dot(l) < 0) {
                let T = f.start;
                f.start = f.end,
                f.end = T
            }
            const B = u.start.dot(a)
              , S = u.end.dot(a)
              , I = f.start.dot(a)
              , M = f.end.dot(a)
              , L = S < I
              , D = B < M;
            return B !== M && I !== S && L === D ? !1 : (p && (c.subVectors(u.start, f.start),
            c.dot(a) > 0 ? p.start.copy(u.start) : p.start.copy(f.start),
            c.subVectors(u.end, f.end),
            c.dot(a) < 0 ? p.end.copy(u.end) : p.end.copy(f.end)),
            !0)
        }
    }
}();
ca.prototype.distanceToPoint = function() {
    const n = new $;
    return function(t) {
        return this.closestPointToPoint(t, n),
        t.distanceTo(n)
    }
}();
ca.prototype.distanceToTriangle = function() {
    const n = new $
      , e = new $
      , t = ["a", "b", "c"]
      , r = new Wl
      , i = new Wl;
    return function(o, a=null, l=null) {
        const c = a || l ? r : null;
        if (this.intersectsTriangle(o, c))
            return (a || l) && (a && c.getCenter(a),
            l && c.getCenter(l)),
            0;
        let A = 1 / 0;
        for (let u = 0; u < 3; u++) {
            let f;
            const h = t[u]
              , d = o[h];
            this.closestPointToPoint(d, n),
            f = d.distanceToSquared(n),
            f < A && (A = f,
            a && a.copy(n),
            l && l.copy(d));
            const m = this[h];
            o.closestPointToPoint(m, n),
            f = m.distanceToSquared(n),
            f < A && (A = f,
            a && a.copy(m),
            l && l.copy(n))
        }
        for (let u = 0; u < 3; u++) {
            const f = t[u]
              , h = t[(u + 1) % 3];
            r.set(this[f], this[h]);
            for (let d = 0; d < 3; d++) {
                const m = t[d]
                  , g = t[(d + 1) % 3];
                i.set(o[m], o[g]),
                A2(r, i, n, e);
                const p = n.distanceToSquared(e);
                p < A && (A = p,
                a && a.copy(n),
                l && l.copy(e))
            }
        }
        return Math.sqrt(A)
    }
}();
class zi {
    constructor(e, t, r) {
        this.isOrientedBox = !0,
        this.min = new $,
        this.max = new $,
        this.matrix = new He,
        this.invMatrix = new He,
        this.points = new Array(8).fill().map( () => new $),
        this.satAxes = new Array(3).fill().map( () => new $),
        this.satBounds = new Array(3).fill().map( () => new sc),
        this.alignedSatBounds = new Array(3).fill().map( () => new sc),
        this.needsUpdate = !1,
        e && this.min.copy(e),
        t && this.max.copy(t),
        r && this.matrix.copy(r)
    }
    set(e, t, r) {
        this.min.copy(e),
        this.max.copy(t),
        this.matrix.copy(r),
        this.needsUpdate = !0
    }
    copy(e) {
        this.min.copy(e.min),
        this.max.copy(e.max),
        this.matrix.copy(e.matrix),
        this.needsUpdate = !0
    }
}
zi.prototype.update = function() {
    return function() {
        const e = this.matrix
          , t = this.min
          , r = this.max
          , i = this.points;
        for (let c = 0; c <= 1; c++)
            for (let A = 0; A <= 1; A++)
                for (let u = 0; u <= 1; u++) {
                    const f = 1 * c | 2 * A | 4 * u
                      , h = i[f];
                    h.x = c ? r.x : t.x,
                    h.y = A ? r.y : t.y,
                    h.z = u ? r.z : t.z,
                    h.applyMatrix4(e)
                }
        const s = this.satBounds
          , o = this.satAxes
          , a = i[0];
        for (let c = 0; c < 3; c++) {
            const A = o[c]
              , u = s[c]
              , f = 1 << c
              , h = i[f];
            A.subVectors(a, h),
            u.setFromPoints(A, i)
        }
        const l = this.alignedSatBounds;
        l[0].setFromPointsField(i, "x"),
        l[1].setFromPointsField(i, "y"),
        l[2].setFromPointsField(i, "z"),
        this.invMatrix.copy(this.matrix).invert(),
        this.needsUpdate = !1
    }
}();
zi.prototype.intersectsBox = function() {
    const n = new sc;
    return function(t) {
        this.needsUpdate && this.update();
        const r = t.min
          , i = t.max
          , s = this.satBounds
          , o = this.satAxes
          , a = this.alignedSatBounds;
        if (n.min = r.x,
        n.max = i.x,
        a[0].isSeparated(n) || (n.min = r.y,
        n.max = i.y,
        a[1].isSeparated(n)) || (n.min = r.z,
        n.max = i.z,
        a[2].isSeparated(n)))
            return !1;
        for (let l = 0; l < 3; l++) {
            const c = o[l]
              , A = s[l];
            if (n.setFromBox(c, t),
            A.isSeparated(n))
                return !1
        }
        return !0
    }
}();
zi.prototype.intersectsTriangle = function() {
    const n = new ca
      , e = new Array(3)
      , t = new sc
      , r = new sc
      , i = new $;
    return function(o) {
        this.needsUpdate && this.update(),
        o.isExtendedTriangle ? o.needsUpdate && o.update() : (n.copy(o),
        n.update(),
        o = n);
        const a = this.satBounds
          , l = this.satAxes;
        e[0] = o.a,
        e[1] = o.b,
        e[2] = o.c;
        for (let f = 0; f < 3; f++) {
            const h = a[f]
              , d = l[f];
            if (t.setFromPoints(d, e),
            h.isSeparated(t))
                return !1
        }
        const c = o.satBounds
          , A = o.satAxes
          , u = this.points;
        for (let f = 0; f < 3; f++) {
            const h = c[f]
              , d = A[f];
            if (t.setFromPoints(d, u),
            h.isSeparated(t))
                return !1
        }
        for (let f = 0; f < 3; f++) {
            const h = l[f];
            for (let d = 0; d < 4; d++) {
                const m = A[d];
                if (i.crossVectors(h, m),
                t.setFromPoints(i, e),
                r.setFromPoints(i, u),
                t.isSeparated(r))
                    return !1
            }
        }
        return !0
    }
}();
zi.prototype.closestPointToPoint = function() {
    return function(e, t) {
        return this.needsUpdate && this.update(),
        t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix),
        t
    }
}();
zi.prototype.distanceToPoint = function() {
    const n = new $;
    return function(t) {
        return this.closestPointToPoint(t, n),
        t.distanceTo(n)
    }
}();
zi.prototype.distanceToBox = function() {
    const n = ["x", "y", "z"]
      , e = new Array(12).fill().map( () => new Wl)
      , t = new Array(12).fill().map( () => new Wl)
      , r = new $
      , i = new $;
    return function(o, a=0, l=null, c=null) {
        if (this.needsUpdate && this.update(),
        this.intersectsBox(o))
            return (l || c) && (o.getCenter(i),
            this.closestPointToPoint(i, r),
            o.closestPointToPoint(r, i),
            l && l.copy(r),
            c && c.copy(i)),
            0;
        const A = a * a
          , u = o.min
          , f = o.max
          , h = this.points;
        let d = 1 / 0;
        for (let g = 0; g < 8; g++) {
            const p = h[g];
            i.copy(p).clamp(u, f);
            const v = p.distanceToSquared(i);
            if (v < d && (d = v,
            l && l.copy(p),
            c && c.copy(i),
            v < A))
                return Math.sqrt(v)
        }
        let m = 0;
        for (let g = 0; g < 3; g++)
            for (let p = 0; p <= 1; p++)
                for (let v = 0; v <= 1; v++) {
                    const w = (g + 1) % 3
                      , _ = (g + 2) % 3
                      , x = p << w | v << _
                      , b = 1 << g | p << w | v << _
                      , B = h[x]
                      , S = h[b];
                    e[m].set(B, S);
                    const M = n[g]
                      , L = n[w]
                      , D = n[_]
                      , T = t[m]
                      , y = T.start
                      , E = T.end;
                    y[M] = u[M],
                    y[L] = p ? u[L] : f[L],
                    y[D] = v ? u[D] : f[L],
                    E[M] = f[M],
                    E[L] = p ? u[L] : f[L],
                    E[D] = v ? u[D] : f[L],
                    m++
                }
        for (let g = 0; g <= 1; g++)
            for (let p = 0; p <= 1; p++)
                for (let v = 0; v <= 1; v++) {
                    i.x = g ? f.x : u.x,
                    i.y = p ? f.y : u.y,
                    i.z = v ? f.z : u.z,
                    this.closestPointToPoint(i, r);
                    const w = i.distanceToSquared(r);
                    if (w < d && (d = w,
                    l && l.copy(r),
                    c && c.copy(i),
                    w < A))
                        return Math.sqrt(w)
                }
        for (let g = 0; g < 12; g++) {
            const p = e[g];
            for (let v = 0; v < 12; v++) {
                const w = t[v];
                A2(p, w, r, i);
                const _ = r.distanceToSquared(i);
                if (_ < d && (d = _,
                l && l.copy(r),
                c && c.copy(i),
                _ < A))
                    return Math.sqrt(_)
            }
        }
        return Math.sqrt(d)
    }
}();
class u2 {
    constructor(e) {
        this._getNewPrimitive = e,
        this._primitives = []
    }
    getPrimitive() {
        const e = this._primitives;
        return e.length === 0 ? this._getNewPrimitive() : e.pop()
    }
    releasePrimitive(e) {
        this._primitives.push(e)
    }
}
class Ype extends u2 {
    constructor() {
        super( () => new ca)
    }
}
const vo = new Ype;
class $pe {
    constructor() {
        this.float32Array = null,
        this.uint16Array = null,
        this.uint32Array = null;
        const e = [];
        let t = null;
        this.setBuffer = r => {
            t && e.push(t),
            t = r,
            this.float32Array = new Float32Array(r),
            this.uint16Array = new Uint16Array(r),
            this.uint32Array = new Uint32Array(r)
        }
        ,
        this.clearBuffer = () => {
            t = null,
            this.float32Array = null,
            this.uint16Array = null,
            this.uint32Array = null,
            e.length !== 0 && this.setBuffer(e.pop())
        }
    }
}
const Fn = new $pe;
let eA, Gh;
const Nf = []
  , xy = new u2( () => new Hn);
function Zpe(n, e, t, r, i, s) {
    eA = xy.getPrimitive(),
    Gh = xy.getPrimitive(),
    Nf.push(eA, Gh),
    Fn.setBuffer(n._roots[e]);
    const o = fT(0, n.geometry, t, r, i, s);
    Fn.clearBuffer(),
    xy.releasePrimitive(eA),
    xy.releasePrimitive(Gh),
    Nf.pop(),
    Nf.pop();
    const a = Nf.length;
    return a > 0 && (Gh = Nf[a - 1],
    eA = Nf[a - 2]),
    o
}
function fT(n, e, t, r, i=null, s=0, o=0) {
    const {float32Array: a, uint16Array: l, uint32Array: c} = Fn;
    let A = n * 2;
    if (Zi(A, l)) {
        const f = Fs(n, c)
          , h = po(A, l);
        return tr(n, a, eA),
        r(f, h, !1, o, s + n, eA)
    } else {
        let M = function(D) {
            const {uint16Array: T, uint32Array: y} = Fn;
            let E = D * 2;
            for (; !Zi(E, T); )
                D = mo(D),
                E = D * 2;
            return Fs(D, y)
        }
          , L = function(D) {
            const {uint16Array: T, uint32Array: y} = Fn;
            let E = D * 2;
            for (; !Zi(E, T); )
                D = go(D, y),
                E = D * 2;
            return Fs(D, y) + po(E, T)
        };
        const f = mo(n)
          , h = go(n, c);
        let d = f, m = h, g, p, v, w;
        if (i && (v = eA,
        w = Gh,
        tr(d, a, v),
        tr(m, a, w),
        g = i(v),
        p = i(w),
        p < g)) {
            d = h,
            m = f;
            const D = g;
            g = p,
            p = D,
            v = w
        }
        v || (v = eA,
        tr(d, a, v));
        const _ = Zi(d * 2, l)
          , x = t(v, _, g, o + 1, s + d);
        let b;
        if (x === vO) {
            const D = M(d)
              , y = L(d) - D;
            b = r(D, y, !0, o + 1, s + d, v)
        } else
            b = x && fT(d, e, t, r, i, s, o + 1);
        if (b)
            return !0;
        w = Gh,
        tr(m, a, w);
        const B = Zi(m * 2, l)
          , S = t(w, B, p, o + 1, s + m);
        let I;
        if (S === vO) {
            const D = M(m)
              , y = L(m) - D;
            I = r(D, y, !0, o + 1, s + m, w)
        } else
            I = S && fT(m, e, t, r, i, s, o + 1);
        return !!I
    }
}
const $p = new $
  , WB = new $;
function Jpe(n, e, t={}, r=0, i=1 / 0) {
    const s = r * r
      , o = i * i;
    let a = 1 / 0
      , l = null;
    if (n.shapecast({
        boundsTraverseOrder: A => ($p.copy(e).clamp(A.min, A.max),
        $p.distanceToSquared(e)),
        intersectsBounds: (A, u, f) => f < a && f < o,
        intersectsTriangle: (A, u) => {
            A.closestPointToPoint(e, $p);
            const f = e.distanceToSquared($p);
            return f < a && (WB.copy($p),
            a = f,
            l = u),
            f < s
        }
    }),
    a === 1 / 0)
        return null;
    const c = Math.sqrt(a);
    return t.point ? t.point.copy(WB) : t.point = WB.clone(),
    t.distance = c,
    t.faceIndex = l,
    t
}
const qpe = parseInt(nc) >= 169
  , $A = new $
  , ZA = new $
  , JA = new $
  , by = new We
  , Ey = new We
  , By = new We
  , bO = new $
  , EO = new $
  , BO = new $
  , Zp = new $;
function eme(n, e, t, r, i, s, o, a) {
    let l;
    if (s === oi ? l = n.intersectTriangle(r, t, e, !0, i) : l = n.intersectTriangle(e, t, r, s !== _i, i),
    l === null)
        return null;
    const c = n.origin.distanceTo(i);
    return c < o || c > a ? null : {
        distance: c,
        point: i.clone()
    }
}
function tme(n, e, t, r, i, s, o, a, l, c, A) {
    $A.fromBufferAttribute(e, s),
    ZA.fromBufferAttribute(e, o),
    JA.fromBufferAttribute(e, a);
    const u = eme(n, $A, ZA, JA, Zp, l, c, A);
    if (u) {
        const f = new $;
        Kr.getBarycoord(Zp, $A, ZA, JA, f),
        r && (by.fromBufferAttribute(r, s),
        Ey.fromBufferAttribute(r, o),
        By.fromBufferAttribute(r, a),
        u.uv = Kr.getInterpolation(Zp, $A, ZA, JA, by, Ey, By, new We)),
        i && (by.fromBufferAttribute(i, s),
        Ey.fromBufferAttribute(i, o),
        By.fromBufferAttribute(i, a),
        u.uv1 = Kr.getInterpolation(Zp, $A, ZA, JA, by, Ey, By, new We)),
        t && (bO.fromBufferAttribute(t, s),
        EO.fromBufferAttribute(t, o),
        BO.fromBufferAttribute(t, a),
        u.normal = Kr.getInterpolation(Zp, $A, ZA, JA, bO, EO, BO, new $),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a: s,
            b: o,
            c: a,
            normal: new $,
            materialIndex: 0
        };
        Kr.getNormal($A, ZA, JA, h.normal),
        u.face = h,
        u.faceIndex = s,
        qpe && (u.barycoord = f)
    }
    return u
}
function P1(n, e, t, r, i, s, o) {
    const a = r * 3;
    let l = a + 0
      , c = a + 1
      , A = a + 2;
    const u = n.index;
    n.index && (l = u.getX(l),
    c = u.getX(c),
    A = u.getX(A));
    const {position: f, normal: h, uv: d, uv1: m} = n.attributes
      , g = tme(t, f, h, d, m, l, c, A, e, s, o);
    return g ? (g.faceIndex = r,
    i && i.push(g),
    g) : null
}
function Mr(n, e, t, r) {
    const i = n.a
      , s = n.b
      , o = n.c;
    let a = e
      , l = e + 1
      , c = e + 2;
    t && (a = t.getX(a),
    l = t.getX(l),
    c = t.getX(c)),
    i.x = r.getX(a),
    i.y = r.getY(a),
    i.z = r.getZ(a),
    s.x = r.getX(l),
    s.y = r.getY(l),
    s.z = r.getZ(l),
    o.x = r.getX(c),
    o.y = r.getY(c),
    o.z = r.getZ(c)
}
function nme(n, e, t, r, i, s, o, a) {
    const {geometry: l, _indirectBuffer: c} = n;
    for (let A = r, u = r + i; A < u; A++)
        P1(l, e, t, A, s, o, a)
}
function rme(n, e, t, r, i, s, o) {
    const {geometry: a, _indirectBuffer: l} = n;
    let c = 1 / 0
      , A = null;
    for (let u = r, f = r + i; u < f; u++) {
        let h;
        h = P1(a, e, t, u, null, s, o),
        h && h.distance < c && (A = h,
        c = h.distance)
    }
    return A
}
function ime(n, e, t, r, i, s, o) {
    const {geometry: a} = t
      , {index: l} = a
      , c = a.attributes.position;
    for (let A = n, u = e + n; A < u; A++) {
        let f;
        if (f = A,
        Mr(o, f * 3, l, c),
        o.needsUpdate = !0,
        r(o, f, i, s))
            return !0
    }
    return !1
}
function sme(n, e=null) {
    e && Array.isArray(e) && (e = new Set(e));
    const t = n.geometry
      , r = t.index ? t.index.array : null
      , i = t.attributes.position;
    let s, o, a, l, c = 0;
    const A = n._roots;
    for (let f = 0, h = A.length; f < h; f++)
        s = A[f],
        o = new Uint32Array(s),
        a = new Uint16Array(s),
        l = new Float32Array(s),
        u(0, c),
        c += s.byteLength;
    function u(f, h, d=!1) {
        const m = f * 2;
        if (a[m + 15] === F1) {
            const p = o[f + 6]
              , v = a[m + 14];
            let w = 1 / 0
              , _ = 1 / 0
              , x = 1 / 0
              , b = -1 / 0
              , B = -1 / 0
              , S = -1 / 0;
            for (let I = 3 * p, M = 3 * (p + v); I < M; I++) {
                let L = r[I];
                const D = i.getX(L)
                  , T = i.getY(L)
                  , y = i.getZ(L);
                D < w && (w = D),
                D > b && (b = D),
                T < _ && (_ = T),
                T > B && (B = T),
                y < x && (x = y),
                y > S && (S = y)
            }
            return l[f + 0] !== w || l[f + 1] !== _ || l[f + 2] !== x || l[f + 3] !== b || l[f + 4] !== B || l[f + 5] !== S ? (l[f + 0] = w,
            l[f + 1] = _,
            l[f + 2] = x,
            l[f + 3] = b,
            l[f + 4] = B,
            l[f + 5] = S,
            !0) : !1
        } else {
            const p = f + 8
              , v = o[f + 6]
              , w = p + h
              , _ = v + h;
            let x = d
              , b = !1
              , B = !1;
            e ? x || (b = e.has(w),
            B = e.has(_),
            x = !b && !B) : (b = !0,
            B = !0);
            const S = x || b
              , I = x || B;
            let M = !1;
            S && (M = u(p, h, x));
            let L = !1;
            I && (L = u(v, h, x));
            const D = M || L;
            if (D)
                for (let T = 0; T < 3; T++) {
                    const y = p + T
                      , E = v + T
                      , R = l[y]
                      , F = l[y + 3]
                      , O = l[E]
                      , z = l[E + 3];
                    l[f + T] = R < O ? R : O,
                    l[f + T + 3] = F > z ? F : z
                }
            return D
        }
    }
}
function xA(n, e, t, r, i) {
    let s, o, a, l, c, A;
    const u = 1 / t.direction.x
      , f = 1 / t.direction.y
      , h = 1 / t.direction.z
      , d = t.origin.x
      , m = t.origin.y
      , g = t.origin.z;
    let p = e[n]
      , v = e[n + 3]
      , w = e[n + 1]
      , _ = e[n + 3 + 1]
      , x = e[n + 2]
      , b = e[n + 3 + 2];
    return u >= 0 ? (s = (p - d) * u,
    o = (v - d) * u) : (s = (v - d) * u,
    o = (p - d) * u),
    f >= 0 ? (a = (w - m) * f,
    l = (_ - m) * f) : (a = (_ - m) * f,
    l = (w - m) * f),
    s > l || a > o || ((a > s || isNaN(s)) && (s = a),
    (l < o || isNaN(o)) && (o = l),
    h >= 0 ? (c = (x - g) * h,
    A = (b - g) * h) : (c = (b - g) * h,
    A = (x - g) * h),
    s > A || c > o) ? !1 : ((c > s || s !== s) && (s = c),
    (A < o || o !== o) && (o = A),
    s <= i && o >= r)
}
function ome(n, e, t, r, i, s, o, a) {
    const {geometry: l, _indirectBuffer: c} = n;
    for (let A = r, u = r + i; A < u; A++) {
        let f = c ? c[A] : A;
        P1(l, e, t, f, s, o, a)
    }
}
function ame(n, e, t, r, i, s, o) {
    const {geometry: a, _indirectBuffer: l} = n;
    let c = 1 / 0
      , A = null;
    for (let u = r, f = r + i; u < f; u++) {
        let h;
        h = P1(a, e, t, l ? l[u] : u, null, s, o),
        h && h.distance < c && (A = h,
        c = h.distance)
    }
    return A
}
function lme(n, e, t, r, i, s, o) {
    const {geometry: a} = t
      , {index: l} = a
      , c = a.attributes.position;
    for (let A = n, u = e + n; A < u; A++) {
        let f;
        if (f = t.resolveTriangleIndex(A),
        Mr(o, f * 3, l, c),
        o.needsUpdate = !0,
        r(o, f, i, s))
            return !0
    }
    return !1
}
function cme(n, e, t, r, i, s, o) {
    Fn.setBuffer(n._roots[e]),
    hT(0, n, t, r, i, s, o),
    Fn.clearBuffer()
}
function hT(n, e, t, r, i, s, o) {
    const {float32Array: a, uint16Array: l, uint32Array: c} = Fn
      , A = n * 2;
    if (Zi(A, l)) {
        const f = Fs(n, c)
          , h = po(A, l);
        nme(e, t, r, f, h, i, s, o)
    } else {
        const f = mo(n);
        xA(f, a, r, s, o) && hT(f, e, t, r, i, s, o);
        const h = go(n, c);
        xA(h, a, r, s, o) && hT(h, e, t, r, i, s, o)
    }
}
const Ame = ["x", "y", "z"];
function ume(n, e, t, r, i, s) {
    Fn.setBuffer(n._roots[e]);
    const o = dT(0, n, t, r, i, s);
    return Fn.clearBuffer(),
    o
}
function dT(n, e, t, r, i, s) {
    const {float32Array: o, uint16Array: a, uint32Array: l} = Fn;
    let c = n * 2;
    if (Zi(c, a)) {
        const u = Fs(n, l)
          , f = po(c, a);
        return rme(e, t, r, u, f, i, s)
    } else {
        const u = NG(n, l)
          , f = Ame[u]
          , d = r.direction[f] >= 0;
        let m, g;
        d ? (m = mo(n),
        g = go(n, l)) : (m = go(n, l),
        g = mo(n));
        const v = xA(m, o, r, i, s) ? dT(m, e, t, r, i, s) : null;
        if (v) {
            const x = v.point[f];
            if (d ? x <= o[g + u] : x >= o[g + u + 3])
                return v
        }
        const _ = xA(g, o, r, i, s) ? dT(g, e, t, r, i, s) : null;
        return v && _ ? v.distance <= _.distance ? v : _ : v || _ || null
    }
}
const My = new Hn
  , Of = new ca
  , kf = new ca
  , Jp = new He
  , MO = new zi
  , Sy = new zi;
function fme(n, e, t, r) {
    Fn.setBuffer(n._roots[e]);
    const i = pT(0, n, t, r);
    return Fn.clearBuffer(),
    i
}
function pT(n, e, t, r, i=null) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = Fn;
    let l = n * 2;
    if (i === null && (t.boundingBox || t.computeBoundingBox(),
    MO.set(t.boundingBox.min, t.boundingBox.max, r),
    i = MO),
    Zi(l, o)) {
        const A = e.geometry
          , u = A.index
          , f = A.attributes.position
          , h = t.index
          , d = t.attributes.position
          , m = Fs(n, a)
          , g = po(l, o);
        if (Jp.copy(r).invert(),
        t.boundsTree)
            return tr(n, s, Sy),
            Sy.matrix.copy(Jp),
            Sy.needsUpdate = !0,
            t.boundsTree.shapecast({
                intersectsBounds: v => Sy.intersectsBox(v),
                intersectsTriangle: v => {
                    v.a.applyMatrix4(r),
                    v.b.applyMatrix4(r),
                    v.c.applyMatrix4(r),
                    v.needsUpdate = !0;
                    for (let w = m * 3, _ = (g + m) * 3; w < _; w += 3)
                        if (Mr(kf, w, u, f),
                        kf.needsUpdate = !0,
                        v.intersectsTriangle(kf))
                            return !0;
                    return !1
                }
            });
        for (let p = m * 3, v = (g + m) * 3; p < v; p += 3) {
            Mr(Of, p, u, f),
            Of.a.applyMatrix4(Jp),
            Of.b.applyMatrix4(Jp),
            Of.c.applyMatrix4(Jp),
            Of.needsUpdate = !0;
            for (let w = 0, _ = h.count; w < _; w += 3)
                if (Mr(kf, w, h, d),
                kf.needsUpdate = !0,
                Of.intersectsTriangle(kf))
                    return !0
        }
    } else {
        const A = n + 8
          , u = a[n + 6];
        return tr(A, s, My),
        !!(i.intersectsBox(My) && pT(A, e, t, r, i) || (tr(u, s, My),
        i.intersectsBox(My) && pT(u, e, t, r, i)))
    }
}
const Cy = new He
  , KB = new zi
  , qp = new zi
  , hme = new $
  , dme = new $
  , pme = new $
  , mme = new $;
function gme(n, e, t, r={}, i={}, s=0, o=1 / 0) {
    e.boundingBox || e.computeBoundingBox(),
    KB.set(e.boundingBox.min, e.boundingBox.max, t),
    KB.needsUpdate = !0;
    const a = n.geometry
      , l = a.attributes.position
      , c = a.index
      , A = e.attributes.position
      , u = e.index
      , f = vo.getPrimitive()
      , h = vo.getPrimitive();
    let d = hme
      , m = dme
      , g = null
      , p = null;
    i && (g = pme,
    p = mme);
    let v = 1 / 0
      , w = null
      , _ = null;
    return Cy.copy(t).invert(),
    qp.matrix.copy(Cy),
    n.shapecast({
        boundsTraverseOrder: x => KB.distanceToBox(x),
        intersectsBounds: (x, b, B) => B < v && B < o ? (b && (qp.min.copy(x.min),
        qp.max.copy(x.max),
        qp.needsUpdate = !0),
        !0) : !1,
        intersectsRange: (x, b) => {
            if (e.boundsTree)
                return e.boundsTree.shapecast({
                    boundsTraverseOrder: S => qp.distanceToBox(S),
                    intersectsBounds: (S, I, M) => M < v && M < o,
                    intersectsRange: (S, I) => {
                        for (let M = S, L = S + I; M < L; M++) {
                            Mr(h, 3 * M, u, A),
                            h.a.applyMatrix4(t),
                            h.b.applyMatrix4(t),
                            h.c.applyMatrix4(t),
                            h.needsUpdate = !0;
                            for (let D = x, T = x + b; D < T; D++) {
                                Mr(f, 3 * D, c, l),
                                f.needsUpdate = !0;
                                const y = f.distanceToTriangle(h, d, g);
                                if (y < v && (m.copy(d),
                                p && p.copy(g),
                                v = y,
                                w = D,
                                _ = M),
                                y < s)
                                    return !0
                            }
                        }
                    }
                });
            {
                const B = Jd(e);
                for (let S = 0, I = B; S < I; S++) {
                    Mr(h, 3 * S, u, A),
                    h.a.applyMatrix4(t),
                    h.b.applyMatrix4(t),
                    h.c.applyMatrix4(t),
                    h.needsUpdate = !0;
                    for (let M = x, L = x + b; M < L; M++) {
                        Mr(f, 3 * M, c, l),
                        f.needsUpdate = !0;
                        const D = f.distanceToTriangle(h, d, g);
                        if (D < v && (m.copy(d),
                        p && p.copy(g),
                        v = D,
                        w = M,
                        _ = S),
                        D < s)
                            return !0
                    }
                }
            }
        }
    }),
    vo.releasePrimitive(f),
    vo.releasePrimitive(h),
    v === 1 / 0 ? null : (r.point ? r.point.copy(m) : r.point = m.clone(),
    r.distance = v,
    r.faceIndex = w,
    i && (i.point ? i.point.copy(p) : i.point = p.clone(),
    i.point.applyMatrix4(Cy),
    m.applyMatrix4(Cy),
    i.distance = m.sub(i.point).length(),
    i.faceIndex = _),
    r)
}
function vme(n, e=null) {
    e && Array.isArray(e) && (e = new Set(e));
    const t = n.geometry
      , r = t.index ? t.index.array : null
      , i = t.attributes.position;
    let s, o, a, l, c = 0;
    const A = n._roots;
    for (let f = 0, h = A.length; f < h; f++)
        s = A[f],
        o = new Uint32Array(s),
        a = new Uint16Array(s),
        l = new Float32Array(s),
        u(0, c),
        c += s.byteLength;
    function u(f, h, d=!1) {
        const m = f * 2;
        if (a[m + 15] === F1) {
            const p = o[f + 6]
              , v = a[m + 14];
            let w = 1 / 0
              , _ = 1 / 0
              , x = 1 / 0
              , b = -1 / 0
              , B = -1 / 0
              , S = -1 / 0;
            for (let I = p, M = p + v; I < M; I++) {
                const L = 3 * n.resolveTriangleIndex(I);
                for (let D = 0; D < 3; D++) {
                    let T = L + D;
                    T = r ? r[T] : T;
                    const y = i.getX(T)
                      , E = i.getY(T)
                      , R = i.getZ(T);
                    y < w && (w = y),
                    y > b && (b = y),
                    E < _ && (_ = E),
                    E > B && (B = E),
                    R < x && (x = R),
                    R > S && (S = R)
                }
            }
            return l[f + 0] !== w || l[f + 1] !== _ || l[f + 2] !== x || l[f + 3] !== b || l[f + 4] !== B || l[f + 5] !== S ? (l[f + 0] = w,
            l[f + 1] = _,
            l[f + 2] = x,
            l[f + 3] = b,
            l[f + 4] = B,
            l[f + 5] = S,
            !0) : !1
        } else {
            const p = f + 8
              , v = o[f + 6]
              , w = p + h
              , _ = v + h;
            let x = d
              , b = !1
              , B = !1;
            e ? x || (b = e.has(w),
            B = e.has(_),
            x = !b && !B) : (b = !0,
            B = !0);
            const S = x || b
              , I = x || B;
            let M = !1;
            S && (M = u(p, h, x));
            let L = !1;
            I && (L = u(v, h, x));
            const D = M || L;
            if (D)
                for (let T = 0; T < 3; T++) {
                    const y = p + T
                      , E = v + T
                      , R = l[y]
                      , F = l[y + 3]
                      , O = l[E]
                      , z = l[E + 3];
                    l[f + T] = R < O ? R : O,
                    l[f + T + 3] = F > z ? F : z
                }
            return D
        }
    }
}
function yme(n, e, t, r, i, s, o) {
    Fn.setBuffer(n._roots[e]),
    mT(0, n, t, r, i, s, o),
    Fn.clearBuffer()
}
function mT(n, e, t, r, i, s, o) {
    const {float32Array: a, uint16Array: l, uint32Array: c} = Fn
      , A = n * 2;
    if (Zi(A, l)) {
        const f = Fs(n, c)
          , h = po(A, l);
        ome(e, t, r, f, h, i, s, o)
    } else {
        const f = mo(n);
        xA(f, a, r, s, o) && mT(f, e, t, r, i, s, o);
        const h = go(n, c);
        xA(h, a, r, s, o) && mT(h, e, t, r, i, s, o)
    }
}
const wme = ["x", "y", "z"];
function _me(n, e, t, r, i, s) {
    Fn.setBuffer(n._roots[e]);
    const o = gT(0, n, t, r, i, s);
    return Fn.clearBuffer(),
    o
}
function gT(n, e, t, r, i, s) {
    const {float32Array: o, uint16Array: a, uint32Array: l} = Fn;
    let c = n * 2;
    if (Zi(c, a)) {
        const u = Fs(n, l)
          , f = po(c, a);
        return ame(e, t, r, u, f, i, s)
    } else {
        const u = NG(n, l)
          , f = wme[u]
          , d = r.direction[f] >= 0;
        let m, g;
        d ? (m = mo(n),
        g = go(n, l)) : (m = go(n, l),
        g = mo(n));
        const v = xA(m, o, r, i, s) ? gT(m, e, t, r, i, s) : null;
        if (v) {
            const x = v.point[f];
            if (d ? x <= o[g + u] : x >= o[g + u + 3])
                return v
        }
        const _ = xA(g, o, r, i, s) ? gT(g, e, t, r, i, s) : null;
        return v && _ ? v.distance <= _.distance ? v : _ : v || _ || null
    }
}
const Ty = new Hn
  , Qf = new ca
  , Hf = new ca
  , em = new He
  , SO = new zi
  , Iy = new zi;
function xme(n, e, t, r) {
    Fn.setBuffer(n._roots[e]);
    const i = vT(0, n, t, r);
    return Fn.clearBuffer(),
    i
}
function vT(n, e, t, r, i=null) {
    const {float32Array: s, uint16Array: o, uint32Array: a} = Fn;
    let l = n * 2;
    if (i === null && (t.boundingBox || t.computeBoundingBox(),
    SO.set(t.boundingBox.min, t.boundingBox.max, r),
    i = SO),
    Zi(l, o)) {
        const A = e.geometry
          , u = A.index
          , f = A.attributes.position
          , h = t.index
          , d = t.attributes.position
          , m = Fs(n, a)
          , g = po(l, o);
        if (em.copy(r).invert(),
        t.boundsTree)
            return tr(n, s, Iy),
            Iy.matrix.copy(em),
            Iy.needsUpdate = !0,
            t.boundsTree.shapecast({
                intersectsBounds: v => Iy.intersectsBox(v),
                intersectsTriangle: v => {
                    v.a.applyMatrix4(r),
                    v.b.applyMatrix4(r),
                    v.c.applyMatrix4(r),
                    v.needsUpdate = !0;
                    for (let w = m, _ = g + m; w < _; w++)
                        if (Mr(Hf, 3 * e.resolveTriangleIndex(w), u, f),
                        Hf.needsUpdate = !0,
                        v.intersectsTriangle(Hf))
                            return !0;
                    return !1
                }
            });
        for (let p = m, v = g + m; p < v; p++) {
            const w = e.resolveTriangleIndex(p);
            Mr(Qf, 3 * w, u, f),
            Qf.a.applyMatrix4(em),
            Qf.b.applyMatrix4(em),
            Qf.c.applyMatrix4(em),
            Qf.needsUpdate = !0;
            for (let _ = 0, x = h.count; _ < x; _ += 3)
                if (Mr(Hf, _, h, d),
                Hf.needsUpdate = !0,
                Qf.intersectsTriangle(Hf))
                    return !0
        }
    } else {
        const A = n + 8
          , u = a[n + 6];
        return tr(A, s, Ty),
        !!(i.intersectsBox(Ty) && vT(A, e, t, r, i) || (tr(u, s, Ty),
        i.intersectsBox(Ty) && vT(u, e, t, r, i)))
    }
}
const Ry = new He
  , XB = new zi
  , tm = new zi
  , bme = new $
  , Eme = new $
  , Bme = new $
  , Mme = new $;
function Sme(n, e, t, r={}, i={}, s=0, o=1 / 0) {
    e.boundingBox || e.computeBoundingBox(),
    XB.set(e.boundingBox.min, e.boundingBox.max, t),
    XB.needsUpdate = !0;
    const a = n.geometry
      , l = a.attributes.position
      , c = a.index
      , A = e.attributes.position
      , u = e.index
      , f = vo.getPrimitive()
      , h = vo.getPrimitive();
    let d = bme
      , m = Eme
      , g = null
      , p = null;
    i && (g = Bme,
    p = Mme);
    let v = 1 / 0
      , w = null
      , _ = null;
    return Ry.copy(t).invert(),
    tm.matrix.copy(Ry),
    n.shapecast({
        boundsTraverseOrder: x => XB.distanceToBox(x),
        intersectsBounds: (x, b, B) => B < v && B < o ? (b && (tm.min.copy(x.min),
        tm.max.copy(x.max),
        tm.needsUpdate = !0),
        !0) : !1,
        intersectsRange: (x, b) => {
            if (e.boundsTree) {
                const B = e.boundsTree;
                return B.shapecast({
                    boundsTraverseOrder: S => tm.distanceToBox(S),
                    intersectsBounds: (S, I, M) => M < v && M < o,
                    intersectsRange: (S, I) => {
                        for (let M = S, L = S + I; M < L; M++) {
                            const D = B.resolveTriangleIndex(M);
                            Mr(h, 3 * D, u, A),
                            h.a.applyMatrix4(t),
                            h.b.applyMatrix4(t),
                            h.c.applyMatrix4(t),
                            h.needsUpdate = !0;
                            for (let T = x, y = x + b; T < y; T++) {
                                const E = n.resolveTriangleIndex(T);
                                Mr(f, 3 * E, c, l),
                                f.needsUpdate = !0;
                                const R = f.distanceToTriangle(h, d, g);
                                if (R < v && (m.copy(d),
                                p && p.copy(g),
                                v = R,
                                w = T,
                                _ = M),
                                R < s)
                                    return !0
                            }
                        }
                    }
                })
            } else {
                const B = Jd(e);
                for (let S = 0, I = B; S < I; S++) {
                    Mr(h, 3 * S, u, A),
                    h.a.applyMatrix4(t),
                    h.b.applyMatrix4(t),
                    h.c.applyMatrix4(t),
                    h.needsUpdate = !0;
                    for (let M = x, L = x + b; M < L; M++) {
                        const D = n.resolveTriangleIndex(M);
                        Mr(f, 3 * D, c, l),
                        f.needsUpdate = !0;
                        const T = f.distanceToTriangle(h, d, g);
                        if (T < v && (m.copy(d),
                        p && p.copy(g),
                        v = T,
                        w = M,
                        _ = S),
                        T < s)
                            return !0
                    }
                }
            }
        }
    }),
    vo.releasePrimitive(f),
    vo.releasePrimitive(h),
    v === 1 / 0 ? null : (r.point ? r.point.copy(m) : r.point = m.clone(),
    r.distance = v,
    r.faceIndex = w,
    i && (i.point ? i.point.copy(p) : i.point = p.clone(),
    i.point.applyMatrix4(Ry),
    m.applyMatrix4(Ry),
    i.distance = m.sub(i.point).length(),
    i.faceIndex = _),
    r)
}
function Cme() {
    return typeof SharedArrayBuffer < "u"
}
const ag = new Fn.constructor
  , tx = new Fn.constructor
  , kc = new u2( () => new Hn)
  , zf = new Hn
  , Gf = new Hn
  , YB = new Hn
  , $B = new Hn;
let ZB = !1;
function Tme(n, e, t, r) {
    if (ZB)
        throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
    ZB = !0;
    const i = n._roots
      , s = e._roots;
    let o, a = 0, l = 0;
    const c = new He().copy(t).invert();
    for (let A = 0, u = i.length; A < u; A++) {
        ag.setBuffer(i[A]),
        l = 0;
        const f = kc.getPrimitive();
        tr(0, ag.float32Array, f),
        f.applyMatrix4(c);
        for (let h = 0, d = s.length; h < d && (tx.setBuffer(s[h]),
        o = zo(0, 0, t, c, r, a, l, 0, 0, f),
        tx.clearBuffer(),
        l += s[h].length,
        !o); h++)
            ;
        if (kc.releasePrimitive(f),
        ag.clearBuffer(),
        a += i[A].length,
        o)
            break
    }
    return ZB = !1,
    o
}
function zo(n, e, t, r, i, s=0, o=0, a=0, l=0, c=null, A=!1) {
    let u, f;
    A ? (u = tx,
    f = ag) : (u = ag,
    f = tx);
    const h = u.float32Array
      , d = u.uint32Array
      , m = u.uint16Array
      , g = f.float32Array
      , p = f.uint32Array
      , v = f.uint16Array
      , w = n * 2
      , _ = e * 2
      , x = Zi(w, m)
      , b = Zi(_, v);
    let B = !1;
    if (b && x)
        A ? B = i(Fs(e, p), po(e * 2, v), Fs(n, d), po(n * 2, m), l, o + e, a, s + n) : B = i(Fs(n, d), po(n * 2, m), Fs(e, p), po(e * 2, v), a, s + n, l, o + e);
    else if (b) {
        const S = kc.getPrimitive();
        tr(e, g, S),
        S.applyMatrix4(t);
        const I = mo(n)
          , M = go(n, d);
        tr(I, h, zf),
        tr(M, h, Gf);
        const L = S.intersectsBox(zf)
          , D = S.intersectsBox(Gf);
        B = L && zo(e, I, r, t, i, o, s, l, a + 1, S, !A) || D && zo(e, M, r, t, i, o, s, l, a + 1, S, !A),
        kc.releasePrimitive(S)
    } else {
        const S = mo(e)
          , I = go(e, p);
        tr(S, g, YB),
        tr(I, g, $B);
        const M = c.intersectsBox(YB)
          , L = c.intersectsBox($B);
        if (M && L)
            B = zo(n, S, t, r, i, s, o, a, l + 1, c, A) || zo(n, I, t, r, i, s, o, a, l + 1, c, A);
        else if (M)
            if (x)
                B = zo(n, S, t, r, i, s, o, a, l + 1, c, A);
            else {
                const D = kc.getPrimitive();
                D.copy(YB).applyMatrix4(t);
                const T = mo(n)
                  , y = go(n, d);
                tr(T, h, zf),
                tr(y, h, Gf);
                const E = D.intersectsBox(zf)
                  , R = D.intersectsBox(Gf);
                B = E && zo(S, T, r, t, i, o, s, l, a + 1, D, !A) || R && zo(S, y, r, t, i, o, s, l, a + 1, D, !A),
                kc.releasePrimitive(D)
            }
        else if (L)
            if (x)
                B = zo(n, I, t, r, i, s, o, a, l + 1, c, A);
            else {
                const D = kc.getPrimitive();
                D.copy($B).applyMatrix4(t);
                const T = mo(n)
                  , y = go(n, d);
                tr(T, h, zf),
                tr(y, h, Gf);
                const E = D.intersectsBox(zf)
                  , R = D.intersectsBox(Gf);
                B = E && zo(I, T, r, t, i, o, s, l, a + 1, D, !A) || R && zo(I, y, r, t, i, o, s, l, a + 1, D, !A),
                kc.releasePrimitive(D)
            }
    }
    return B
}
const Uy = new zi
  , CO = new Hn
  , Ime = {
    strategy: FG,
    maxDepth: 40,
    maxLeafTris: 10,
    useSharedArrayBuffer: !1,
    setBoundingBox: !0,
    onProgress: null,
    indirect: !1,
    verbose: !0,
    range: null
};
class f2 {
    static serialize(e, t={}) {
        t = {
            cloneBuffers: !0,
            ...t
        };
        const r = e.geometry
          , i = e._roots
          , s = e._indirectBuffer
          , o = r.getIndex();
        let a;
        return t.cloneBuffers ? a = {
            roots: i.map(l => l.slice()),
            index: o ? o.array.slice() : null,
            indirectBuffer: s ? s.slice() : null
        } : a = {
            roots: i,
            index: o ? o.array : null,
            indirectBuffer: s
        },
        a
    }
    static deserialize(e, t, r={}) {
        r = {
            setIndex: !0,
            indirect: !!e.indirectBuffer,
            ...r
        };
        const {index: i, roots: s, indirectBuffer: o} = e
          , a = new f2(t,{
            ...r,
            [zB]: !0
        });
        if (a._roots = s,
        a._indirectBuffer = o || null,
        r.setIndex) {
            const l = t.getIndex();
            if (l === null) {
                const c = new ct(e.index,1,!1);
                t.setIndex(c)
            } else
                l.array !== i && (l.array.set(i),
                l.needsUpdate = !0)
        }
        return a
    }
    get indirect() {
        return !!this._indirectBuffer
    }
    constructor(e, t={}) {
        if (e.isBufferGeometry) {
            if (e.index && e.index.isInterleavedBufferAttribute)
                throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")
        } else
            throw new Error("MeshBVH: Only BufferGeometries are supported.");
        if (t = Object.assign({
            ...Ime,
            [zB]: !1
        }, t),
        t.useSharedArrayBuffer && !Cme())
            throw new Error("MeshBVH: SharedArrayBuffer is not available.");
        this.geometry = e,
        this._roots = null,
        this._indirectBuffer = null,
        t[zB] || (jpe(this, t),
        !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new Hn))),
        this.resolveTriangleIndex = t.indirect ? r => this._indirectBuffer[r] : r => r
    }
    refit(e=null) {
        return (this.indirect ? vme : sme)(this, e)
    }
    traverse(e, t=0) {
        const r = this._roots[t]
          , i = new Uint32Array(r)
          , s = new Uint16Array(r);
        o(0);
        function o(a, l=0) {
            const c = a * 2
              , A = s[c + 15] === F1;
            if (A) {
                const u = i[a + 6]
                  , f = s[c + 14];
                e(l, A, new Float32Array(r,a * 4,6), u, f)
            } else {
                const u = a + og / 4
                  , f = i[a + 6]
                  , h = i[a + 7];
                e(l, A, new Float32Array(r,a * 4,6), h) || (o(u, l + 1),
                o(f, l + 1))
            }
        }
    }
    raycast(e, t=Hs, r=0, i=1 / 0) {
        const s = this._roots
          , o = this.geometry
          , a = []
          , l = t.isMaterial
          , c = Array.isArray(t)
          , A = o.groups
          , u = l ? t.side : t
          , f = this.indirect ? yme : cme;
        for (let h = 0, d = s.length; h < d; h++) {
            const m = c ? t[A[h].materialIndex].side : u
              , g = a.length;
            if (f(this, h, m, e, a, r, i),
            c) {
                const p = A[h].materialIndex;
                for (let v = g, w = a.length; v < w; v++)
                    a[v].face.materialIndex = p
            }
        }
        return a
    }
    raycastFirst(e, t=Hs, r=0, i=1 / 0) {
        const s = this._roots
          , o = this.geometry
          , a = t.isMaterial
          , l = Array.isArray(t);
        let c = null;
        const A = o.groups
          , u = a ? t.side : t
          , f = this.indirect ? _me : ume;
        for (let h = 0, d = s.length; h < d; h++) {
            const m = l ? t[A[h].materialIndex].side : u
              , g = f(this, h, m, e, r, i);
            g != null && (c == null || g.distance < c.distance) && (c = g,
            l && (g.face.materialIndex = A[h].materialIndex))
        }
        return c
    }
    intersectsGeometry(e, t) {
        let r = !1;
        const i = this._roots
          , s = this.indirect ? xme : fme;
        for (let o = 0, a = i.length; o < a && (r = s(this, o, e, t),
        !r); o++)
            ;
        return r
    }
    shapecast(e) {
        const t = vo.getPrimitive()
          , r = this.indirect ? lme : ime;
        let {boundsTraverseOrder: i, intersectsBounds: s, intersectsRange: o, intersectsTriangle: a} = e;
        if (o && a) {
            const u = o;
            o = (f, h, d, m, g) => u(f, h, d, m, g) ? !0 : r(f, h, this, a, d, m, t)
        } else
            o || (a ? o = (u, f, h, d) => r(u, f, this, a, h, d, t) : o = (u, f, h) => h);
        let l = !1
          , c = 0;
        const A = this._roots;
        for (let u = 0, f = A.length; u < f; u++) {
            const h = A[u];
            if (l = Zpe(this, u, s, o, i, c),
            l)
                break;
            c += h.byteLength
        }
        return vo.releasePrimitive(t),
        l
    }
    bvhcast(e, t, r) {
        let {intersectsRanges: i, intersectsTriangles: s} = r;
        const o = vo.getPrimitive()
          , a = this.geometry.index
          , l = this.geometry.attributes.position
          , c = this.indirect ? d => {
            const m = this.resolveTriangleIndex(d);
            Mr(o, m * 3, a, l)
        }
        : d => {
            Mr(o, d * 3, a, l)
        }
          , A = vo.getPrimitive()
          , u = e.geometry.index
          , f = e.geometry.attributes.position
          , h = e.indirect ? d => {
            const m = e.resolveTriangleIndex(d);
            Mr(A, m * 3, u, f)
        }
        : d => {
            Mr(A, d * 3, u, f)
        }
        ;
        if (s) {
            const d = (m, g, p, v, w, _, x, b) => {
                for (let B = p, S = p + v; B < S; B++) {
                    h(B),
                    A.a.applyMatrix4(t),
                    A.b.applyMatrix4(t),
                    A.c.applyMatrix4(t),
                    A.needsUpdate = !0;
                    for (let I = m, M = m + g; I < M; I++)
                        if (c(I),
                        o.needsUpdate = !0,
                        s(o, A, I, B, w, _, x, b))
                            return !0
                }
                return !1
            }
            ;
            if (i) {
                const m = i;
                i = function(g, p, v, w, _, x, b, B) {
                    return m(g, p, v, w, _, x, b, B) ? !0 : d(g, p, v, w, _, x, b, B)
                }
            } else
                i = d
        }
        return Tme(this, e, t, i)
    }
    intersectsBox(e, t) {
        return Uy.set(e.min, e.max, t),
        Uy.needsUpdate = !0,
        this.shapecast({
            intersectsBounds: r => Uy.intersectsBox(r),
            intersectsTriangle: r => Uy.intersectsTriangle(r)
        })
    }
    intersectsSphere(e) {
        return this.shapecast({
            intersectsBounds: t => e.intersectsBox(t),
            intersectsTriangle: t => t.intersectsSphere(e)
        })
    }
    closestPointToGeometry(e, t, r={}, i={}, s=0, o=1 / 0) {
        return (this.indirect ? Sme : gme)(this, e, t, r, i, s, o)
    }
    closestPointToPoint(e, t={}, r=0, i=1 / 0) {
        return Jpe(this, e, t, r, i)
    }
    getBoundingBox(e) {
        return e.makeEmpty(),
        this._roots.forEach(r => {
            tr(0, new Float32Array(r), CO),
            e.union(CO)
        }
        ),
        e
    }
}
function TO(n, e, t) {
    return n === null ? null : (n.point.applyMatrix4(e.matrixWorld),
    n.distance = n.point.distanceTo(t.ray.origin),
    n.object = e,
    n)
}
const Fy = new $u
  , IO = new $
  , RO = new He
  , Rme = dn.prototype.raycast
  , Ume = Ese.prototype.raycast
  , UO = new $
  , ei = new dn
  , Py = [];
function Fme(n, e) {
    this.isBatchedMesh ? Pme.call(this, n, e) : Lme.call(this, n, e)
}
function Pme(n, e) {
    if (this.boundsTrees) {
        const t = this.boundsTrees
          , r = this._drawInfo
          , i = this._drawRanges
          , s = this.matrixWorld;
        ei.material = this.material,
        ei.geometry = this.geometry;
        const o = ei.geometry.boundsTree
          , a = ei.geometry.drawRange;
        ei.geometry.boundingSphere === null && (ei.geometry.boundingSphere = new Mi);
        for (let l = 0, c = r.length; l < c; l++) {
            if (!this.getVisibleAt(l))
                continue;
            const A = r[l].geometryIndex;
            if (ei.geometry.boundsTree = t[A],
            this.getMatrixAt(l, ei.matrixWorld).premultiply(s),
            !ei.geometry.boundsTree) {
                this.getBoundingBoxAt(A, ei.geometry.boundingBox),
                this.getBoundingSphereAt(A, ei.geometry.boundingSphere);
                const u = i[A];
                ei.geometry.setDrawRange(u.start, u.count)
            }
            ei.raycast(n, Py);
            for (let u = 0, f = Py.length; u < f; u++) {
                const h = Py[u];
                h.object = this,
                h.batchId = l,
                e.push(h)
            }
            Py.length = 0
        }
        ei.geometry.boundsTree = o,
        ei.geometry.drawRange = a,
        ei.material = null,
        ei.geometry = null
    } else
        Ume.call(this, n, e)
}
function Lme(n, e) {
    if (this.geometry.boundsTree) {
        if (this.material === void 0)
            return;
        RO.copy(this.matrixWorld).invert(),
        Fy.copy(n.ray).applyMatrix4(RO),
        UO.setFromMatrixScale(this.matrixWorld),
        IO.copy(Fy.direction).multiply(UO);
        const t = IO.length()
          , r = n.near / t
          , i = n.far / t
          , s = this.geometry.boundsTree;
        if (n.firstHitOnly === !0) {
            const o = TO(s.raycastFirst(Fy, this.material, r, i), this, n);
            o && e.push(o)
        } else {
            const o = s.raycast(Fy, this.material, r, i);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = TO(o[a], this, n);
                c && e.push(c)
            }
        }
    } else
        Rme.call(this, n, e)
}
function Dme(n={}) {
    return this.boundsTree = new f2(this,n),
    this.boundsTree
}
function Nme() {
    this.boundsTree = null
}
let JB = new $
  , nm = new $;
const FO = []
  , Ly = new jz
  , Ome = .03
  , kme = .03
  , Qme = new qi({
    side: Hs
})
  , Hme = new qi({
    side: oi
});
let Pm;
Jt.prototype.computeBoundsTree = Dme;
Jt.prototype.disposeBoundsTree = Nme;
dn.prototype.raycast = Fme;
const zme = n => {
    const e = n.attributes.position
      , t = n.index
      , r = new Kr
      , i = new $
      , s = new $
      , o = new $
      , a = [];
    for (let l = 0; l < t.array.length / 3; l++) {
        const c = l * 3;
        i.fromBufferAttribute(e, t.getX(c + 0)),
        s.fromBufferAttribute(e, t.getX(c + 1)),
        o.fromBufferAttribute(e, t.getX(c + 2)),
        r.set(i, s, o),
        a.push(r.getNormal(new $))
    }
    n.userData.faceNormals = a
}
  , Gme = n => {
    const e = n.geometry.clone();
    let t = [];
    if (Array.isArray(n.material))
        for (let i = 0; i < n.material.length; i++)
            t.push(n.material[i].clone());
    else
        t = n.material.clone();
    if (!n.userData.isVRM0) {
        const i = e.attributes.position;
        for (let s = 0; s < i.array.length; s += 3)
            i.array[s] = -i.array[s],
            i.array[s + 2] = -i.array[s + 2];
        i.needsUpdate = !0
    }
    const r = new dn(e,t);
    return zme(r.geometry),
    r.geometry.computeBoundsTree({
        strategy: PG
    }),
    r
}
  , Nw = n => {
    n.isMesh && (n.geometry.userData.faceNormals = null,
    n.geometry.dispose(),
    n.geometry.disposeBoundsTree(),
    n.parent && n.parent.remove(n),
    n.userData.cancelMesh && Nw(n.userData.cancelMesh))
}
  , QG = n => {
    var e, t;
    n.userData.cullingClone && (Nw(n.userData.cullingClone),
    n.userData.cullingClone = null,
    Nw(n.userData.cullingCloneP),
    n.userData.cullingCloneP = null,
    Nw(n.userData.cullingCloneN),
    n.userData.cullingCloneN = null,
    ((e = n.userData) == null ? void 0 : e.clippedIndexGeometry) != null && (n.userData.clippedIndexGeometry = null),
    ((t = n.userData) == null ? void 0 : t.origIndexBuffer) != null && (n.userData.origIndexBuffer = null))
}
  , Vme = async n => {
    if (n == null) {
        console.warn("Null parameter for meshes was provided. Skipping mesh culling.");
        return
    }
    if (!Array.isArray(n)) {
        console.warn("No valid mesh array was provided. Skipping mesh culling.");
        return
    }
    if (n.length == 0) {
        console.warn("No mesh array with elements was provided. Skipping mesh culling.");
        return
    }
    const e = [];
    Pm = n[0].parent,
    Pm.lines != null && (Pm.lines.forEach(i => {
        i.visible = !1
    }
    ),
    Pm.lines.length = 0),
    n.forEach(i => {
        if (i.userData.cullLayer != null) {
            i.userData.origIndexBuffer == null && (i.userData.origIndexBuffer = i.geometry.index.clone()),
            e[i.userData.cullLayer] == null && (e[i.userData.cullLayer] = {
                origMeshes: [],
                cloneMeshes: [],
                posMeshes: [],
                negMeshes: [],
                scaleMeshes: [],
                positionMeshes: []
            }),
            i.userData.cullingClone == null && (i.userData.cullingClone = Gme(i),
            i.userData.cullingCloneP = i.userData.cullingClone.clone(),
            i.userData.cullingCloneN = i.userData.cullingClone.clone());
            const s = i.userData.cullingClone
              , o = i.userData.cullingCloneP
              , a = i.userData.cullingCloneN;
            o.material = Qme,
            a.userData.cancelMesh = o,
            a.material = Hme,
            o.userData.maxCullDistance = a.userData.maxCullDistance = i.userData.maxCullDistance,
            e[i.userData.cullLayer].origMeshes.push(i),
            e[i.userData.cullLayer].cloneMeshes.push(s),
            e[i.userData.cullLayer].posMeshes.push(o),
            e[i.userData.cullLayer].negMeshes.push(a),
            i.geometry.setIndex(i.userData.origIndexBuffer)
        }
    }
    );
    for (let i = e.length - 1; i >= 0; i--)
        e[i] == null && e.splice(i, 1);
    let t = [];
    const r = [];
    for (let i = e.length - 1; i >= 0; i--) {
        if (t.length != 0 || e.length >= 1)
            for (let s = 0; s < e[i].origMeshes.length; s++) {
                const o = e[i].origMeshes[s]
                  , a = e[i].cloneMeshes[s]
                  , l = o.userData.origIndexBuffer.array
                  , c = a.geometry.attributes.position.array
                  , A = a.geometry.attributes.normal.array
                  , u = a.geometry.userData.faceNormals;
                r.push({
                    geom: o.geometry,
                    index: Wme(l, c, A, u, t, o.userData.cullDistance)
                })
            }
        t = [...t, ...e[i].posMeshes, ...e[i].negMeshes]
    }
    r.forEach(i => {
        i.geom.setIndex(i.index)
    }
    )
}
  , jme = n => {
    let e = Ome
      , t = kme;
    return n && (isNaN(n) ? Array.isArray(n) && (isNaN(n[0]) || (e = n[0]),
    isNaN(n[1]) || (t = n[1])) : e = n),
    [e, t]
}
  , Wme = (n, e, t, r, i, s, o=!1) => {
    const a = []
      , l = jme(s);
    let c = l[0]
      , A = l[1];
    Ly.far = c + A;
    for (let f = 0; f < n.length / 3; f++) {
        r && nm.set(r[f].x, r[f].y, r[f].z).normalize();
        const h = f * 3;
        let d = [];
        for (let m = 0; m < 3; m++) {
            FO.length = 0;
            const g = n[h + m] * 3;
            r == null && nm.set(t[g], t[g + 1], t[g + 2]).normalize(),
            JB.set(e[g], e[g + 1], e[g + 2]).add(nm.clone().multiplyScalar(c)),
            Ly.set(JB, nm.clone().multiplyScalar(-1));
            const p = Ly.intersectObjects(i, !1, FO);
            for (let v = p.length - 1; v >= 0; v--)
                c - p[v].distance >= p[v].object.userData.maxCullDistance && p.splice(v, 1);
            if (p.length === 0) {
                for (let v = 0; v < 3; v++)
                    a.push(n[h + v]);
                break
            } else {
                const v = p.map(w => w.object);
                for (let w = 0; w < v.length; w++) {
                    const _ = v[w];
                    if (_ != null && _.userData.cancelMesh) {
                        const x = v.indexOf(_.userData.cancelMesh);
                        v[w] = null,
                        x != -1 && x < w && (v[x] = null)
                    }
                }
                if (v.filter(w => w).length === 0) {
                    for (let w = 0; w < 3; w++)
                        a.push(n[h + w]);
                    break
                }
                if (m === 0)
                    d = p.map(w => w.object);
                else if (d = p.map(w => {
                    if (d.indexOf(w.object) !== -1)
                        return w.object
                }
                ),
                d = d.filter(w => w),
                m === 2 && d.filter(w => w).length === 0)
                    for (let w = 0; w < 3; w++)
                        a.push(n[h + w]);
                o && Kme(JB, nm.clone().multiplyScalar(-1), Ly.far, 16711680, Pm)
            }
        }
    }
    const u = new Uint32Array(a);
    return new ct(u,1,!1)
}
;
function Kme(n, e, t, r, i) {
    i.lines == null && (i.lines = []);
    let s = new $;
    s.addVectors(n, e.clone().multiplyScalar(t));
    const o = [];
    o.push(n),
    o.push(s);
    const a = new Jt().setFromPoints(o)
      , l = [];
    l.push(new Qe(0)),
    l.push(new Qe(16777215));
    let c = new Ac({
        color: r
    });
    var A = new Yd(a,c);
    A.renderOrder = 100,
    i.add(A),
    i.lines.push(A)
}
function Xme(n, e=10) {
    if (n <= 0)
        return [];
    const t = n
      , r = [{
        w: e,
        h: e,
        x: 0,
        y: 0
    }];
    function i(o, a, l, c) {
        if (a <= 0)
            return;
        const A = o.w / 2
          , u = [{
            w: A,
            h: A,
            x: l,
            y: c
        }, {
            w: A,
            h: A,
            x: l + A,
            y: c
        }, {
            w: A,
            h: A,
            x: l,
            y: c + A
        }, {
            w: A,
            h: A,
            x: l + A,
            y: c + A
        }];
        r.push(...u);
        const f = r.find(p => p.x === l && p.y === c && p.w === o.w && p.h === o.h);
        if (r.splice(r.indexOf(f), 1),
        n <= r.length)
            return;
        const h = Math.max(...r.map(p => p.w))
          , d = r.find(p => p.w === h)
          , m = d.x
          , g = d.y;
        i({
            w: d.w,
            h: d.h
        }, a - 1, m, g)
    }
    if (n == 1)
        return {
            squares: r,
            fill: 1
        };
    for (i({
        w: e,
        h: e
    }, t, 0, 0),
    r.sort( (o, a) => a.w - o.w); r.length > n; )
        r.pop();
    const s = r.reduce( (o, a) => o + a.w * a.h, 0) / (e * e);
    return {
        squares: r,
        fill: s
    }
}
class L1 {
    constructor(e, t) {
        Ne(this, "width");
        Ne(this, "height");
        Ne(this, "cameraRTT", null);
        Ne(this, "sceneRTT", null);
        Ne(this, "materials", []);
        Ne(this, "quads", []);
        Ne(this, "renderer", null);
        Ne(this, "rtTexture", null);
        this.width = e,
        this.height = t
    }
    _addPlane(e, t=0) {
        if (!this.sceneRTT)
            return;
        const r = new qi({
            side: _i,
            transparent: !0,
            opacity: 1,
            color: new Qe(1,1,1)
        });
        this.materials.push(r);
        const i = new cc(1,1)
          , s = new dn(i,r);
        s.position.z = t * 1e-4,
        s.scale.set(this.width, this.height, 1),
        this.quads.push(s),
        this.sceneRTT.add(s)
    }
    render(e, t, r, i, s=!0) {
        var c;
        const o = ut(e);
        if (o.length === 0 && (e = ut(L1.createSolidColorTexture(r, this.width, this.height))),
        this.renderer == null) {
            this.sceneRTT = new Gg,
            this.cameraRTT = new v0(-this.width / 2,this.width / 2,this.height / 2,-this.height / 2,-1e4,1e4),
            this.cameraRTT.position.z = 100,
            this.sceneRTT.add(this.cameraRTT);
            for (let A = 0; A < o.length; A++) {
                const u = o[A];
                u && this._addPlane(u, A)
            }
            this.renderer = new y0,
            this.renderer.setPixelRatio(1),
            this.renderer.setSize(this.width, this.height),
            this.renderer.autoClear = !1
        } else
            this.cameraRTT && (this.cameraRTT.left = -this.width / 2,
            this.cameraRTT.right = this.width / 2,
            this.cameraRTT.top = this.height / 2,
            this.cameraRTT.bottom = -this.height / 2,
            this.cameraRTT.updateProjectionMatrix()),
            this.quads.forEach(A => {
                A == null || A.scale.set(this.width, this.height, 1)
            }
            ),
            this.renderer.setSize(this.width, this.height);
        if (o.length > this.materials.length) {
            const A = o.length - this.materials.length;
            for (let u = 0; u < A; u++) {
                const f = o[u];
                this._addPlane(f, u)
            }
        } else {
            if (this.materials.length = o.length,
            this.quads.length > o.length)
                for (let A = o.length; A < this.quads.length; A++)
                    (c = this.sceneRTT) == null || c.remove(this.quads[A]);
            this.quads.length = o.length
        }
        this.rtTexture = new tl(this.width,this.height),
        this.rtTexture.texture.colorSpace = s ? Ut : La;
        for (let A = 0; A < o.length; A++) {
            const u = o[A];
            u && (this.materials[A].map = u,
            this.materials[A].color = t.clone())
        }
        this.renderer.setClearColor(r.clone(), i ? 0 : 1),
        this.renderer.setRenderTarget(this.rtTexture),
        this.renderer.clear(),
        this.sceneRTT && this.cameraRTT && this.renderer.render(this.sceneRTT, this.cameraRTT);
        let a = new Uint8ClampedArray(this.rtTexture.width * this.rtTexture.height * 4);
        return this.renderer.readRenderTargetPixels(this.rtTexture, 0, 0, this.width, this.height, a),
        new ImageData(a,this.width,this.height)
    }
    clearRenderer() {
        var e, t;
        (e = this.rtTexture) == null || e.dispose(),
        this.rtTexture = null,
        (t = this.materials) != null && t.length && this.materials.forEach(r => {
            var i;
            (i = r.map) == null || i.dispose(),
            r.map = null
        }
        )
    }
    destroy() {
        var e, t;
        this.cameraRTT = null,
        (e = this.sceneRTT) == null || e.clear(),
        this.sceneRTT = null,
        this.materials.forEach(r => {
            var i;
            (i = r.map) == null || i.dispose(),
            r.map = null
        }
        ),
        this.quads.forEach(r => {
            var i;
            (i = this.sceneRTT) == null || i.remove(r),
            r = null
        }
        ),
        this.materials.length = 0,
        this.quads.length = 0,
        (t = this.renderer) == null || t.dispose(),
        this.renderer = null,
        this.rtTexture = null
    }
    static createSolidColorTexture(e, t, r) {
        const i = t * r
          , s = new Uint8Array(4 * i)
          , o = Math.floor(e.r * 255)
          , a = Math.floor(e.g * 255)
          , l = Math.floor(e.b * 255);
        for (let A = 0; A < i; A++) {
            const u = A * 4;
            s[u] = o,
            s[u + 1] = a,
            s[u + 2] = l,
            s[u + 3] = 255
        }
        const c = new Eu(s,t,r);
        return c.needsUpdate = !0,
        c
    }
}
function nx(n, e) {
    return n = n.length == null ? n : n[0],
    n[e] && n[e].image
}
function Yme(n, e) {
    return n = n.length == null ? n : n[0],
    n[e] && n[e].clone()
}
function tA(n, e, t, r, i) {
    const s = (n - e) / (t - e);
    return r + s * (i - r)
}
const yT = {
    diffuse: ["map"],
    normal: ["normalMap"],
    orm: ["ormMap", "aoMap", "roughnessMap", "metalnessMap"]
}
  , $me = async ({transparentColor: n, meshes: e, includeNonTexturedMeshesInAtlas: t=!1, atlasSize: r=4096, mtoon: i=!0, transparentMaterial: s=!1, transparentTexture: o=!1, twoSidedMaterial: a=!1}) => typeof window > "u" ? await Zme({
    meshes: e,
    atlasSize: r,
    mtoon: i,
    transparentMaterial: s,
    transparentTexture: o
}) : await Jme({
    backColor: n,
    meshes: e,
    atlasSize: r,
    mtoon: i,
    includeNonTexturedMeshesInAtlas: t,
    transparentMaterial: s,
    transparentTexture: o,
    twoSidedMaterial: a
})
  , Zme = async ({meshes: n, atlasSize: e, mtoon: t, transparentMaterial: r, transparentTexture: i}) => {
    const s = e
      , o = ["diffuse"]
      , a = [];
    n.forEach(b => {
        const B = b.material;
        let S = a.find(I => I.material === B);
        if (!S)
            a.push({
                material: B,
                mesh: b
            });
        else {
            const {dest: I} = D1({
                meshes: [S.mesh, b]
            });
            S.mesh.geometry = I
        }
    }
    );
    const l = Object.fromEntries(o.map(b => [b, d2({
        width: s,
        height: s,
        transparent: i
    })]))
      , c = Math.floor(Math.sqrt(n.length) + 1)
      , A = s / c
      , u = new Map(a.map( (b, B) => {
        const S = new We(B % c,Math.floor(B / c)).multiplyScalar(1 / c)
          , I = new We(S.x + 1 / c,S.y + 1 / c);
        return [b.mesh, {
            min: S,
            max: I
        }]
    }
    ))
      , f = []
      , h = [];
    a.forEach(b => {
        const {min: B, max: S} = u.get(b.mesh);
        h.push(S),
        f.push(B)
    }
    );
    const d = new We(Math.max(...h.map(b => b.x)),Math.max(...h.map(b => b.y)))
      , m = new We(Math.min(...f.map(b => b.x)),Math.min(...f.map(b => b.y)))
      , g = 1 / (d.x - m.x)
      , p = 1 / (d.y - m.y)
      , v = A * g
      , w = A * p
      , _ = new Map(a.map(b => {
        let {min: B, max: S} = u.get(b.mesh);
        return B.x = B.x * g,
        B.y = B.y * p,
        S.x = S.x * g,
        S.y = S.y * p,
        [b.mesh, {
            min: B,
            max: S
        }]
    }
    ));
    a.forEach(b => {
        const {material: B, mesh: S} = b
          , {min: I, max: M} = _.get(S);
        o.forEach(y => {
            const E = l[y];
            E.globalCompositeOperation = "source-over";
            let R = nx(B, yT[y].find(F => nx(B, F)));
            if (R !== "" && R !== void 0)
                try {
                    const F = new Uint8ClampedArray(R.data)
                      , O = new ImageData(F,v,w)
                      , z = document.createElement("canvas");
                    z.width = v,
                    z.height = w;
                    const j = z.getContext("2d");
                    j.putImageData(O, 0, 0),
                    j.save(),
                    E.drawImage(z, I.x * s, I.y * s, v, w)
                } catch (F) {
                    console.error("error", F)
                }
            else
                E.fillStyle = y === "diffuse" ? `#${B.color.clone().getHexString()}` : y === "normal" ? "#bcbcff" : y === "orm" ? `#${new Qe(B.aoMapIntensity,B.roughness,B.metalness).getHexString()}` : "#7F7F7F",
                E.fillRect(I.x * s, I.y * s, v, w)
        }
        );
        const L = S.geometry
          , D = L.attributes.uv;
        if (D)
            for (let y = 0; y < D.array.length; y += 2)
                D.array[y] = tA(D.array[y], 0, 1, I.x, M.x),
                D.array[y + 1] = tA(D.array[y + 1], 0, 1, I.y, M.y);
        const T = L.attributes.uv2;
        if (T)
            for (let y = 0; y < T.array.length; y += 2)
                T.array[y] = tA(T.array[y], 0, 1, I.x, M.x),
                T.array[y + 1] = tA(T.array[y + 1], 0, 1, I.y, M.y);
        else
            L.attributes.uv2 = L.attributes.uv
    }
    );
    const x = Object.fromEntries(await Promise.all(o.map(async b => {
        const B = new Un(l[b].canvas);
        return B.flipY = !1,
        [b, B]
    }
    )));
    return {
        bakeObjects: a,
        textures: x,
        uvs: _
    }
}
  , Jme = async ({backColor: n, includeNonTexturedMeshesInAtlas: e=!1, meshes: t, atlasSize: r, mtoon: i, transparentMaterial: s, transparentTexture: o, twoSidedMaterial: a}) => {
    const l = r
      , c = i ? ["diffuse"] : ["diffuse", "orm", "normal"]
      , A = [];
    let u = null;
    t.forEach(F => {
        F = F.clone();
        const O = F.material.length == null ? F.material : F.material[0];
        i && u == null && O.type == "ShaderMaterial" && (u = O.clone());
        let z = A.find(j => {
            j.material
        }
        );
        if (!z)
            A.push({
                material: O,
                mesh: F
            });
        else {
            const {dest: j} = D1({
                meshes: [z.mesh, F]
            });
            z.mesh.geometry = j
        }
    }
    );
    const f = Object.fromEntries(c.map(F => [F, d2({
        width: l,
        height: l,
        transparent: o && F == "diffuse"
    })]))
      , h = new Set
      , d = new Map
      , m = A.map(F => {
        const O = F.mesh.geometry;
        if (e == !1) {
            if (!F.mesh.visible)
                return h.add(F.mesh),
                [F.mesh, 0];
            let z = !0;
            for (const j of c)
                for (const Q of yT[j])
                    if (nx(F.material, Q) && z) {
                        z = !1;
                        break
                    }
            if (z) {
                const j = F.material;
                if (j instanceof mr)
                    return [F.mesh, 2];
                if (d.size == 0)
                    return d.set(j, [F.mesh]),
                    [F.mesh, 1];
                for (let[Q,C] of Array.from(d.entries()))
                    if (( () => Q.color.r.toFixed(5) == j.color.r.toFixed(5) && Q.color.g.toFixed(5) == j.color.g.toFixed(5) && Q.color.b.toFixed(5) == j.color.b.toFixed(5) && Q.emissive.equals(j.emissive) && Q.aoMapIntensity == j.aoMapIntensity && Q.metalness == j.metalness && Q.normalScale.equals(j.normalScale) && Q.roughness == j.roughness && Q.transparent == j.transparent && Q.vertexColors == j.vertexColors)())
                        return C.push(F.mesh),
                        [F.mesh, 0];
                return d.set(j, [F.mesh]),
                [F.mesh, 1]
            }
        }
        return [F.mesh, O.index ? O.index.count / 3 : O.attributes.position.count / 3]
    }
    ).sort( (F, O) => O[1] - F[1])
      , g = m.filter( ([,F]) => F != 0)
      , {squares: p, fill: v} = Xme(g.length, l);
    console.log("squaresplit", v);
    const w = p.map(F => ({
        x: F.x,
        y: F.y,
        width: F.w,
        height: F.h
    }))
      , _ = new Map(w.map( (F, O) => [m[O][0], F]));
    d.forEach(F => {
        if (F.length > 1) {
            const O = _.get(F[0]);
            F.forEach(z => {
                _.set(z, O)
            }
            )
        }
    }
    );
    const x = new Map(Array.from(_.entries()).map( ([F,O]) => {
        const z = new We(O.x,O.y)
          , j = new We(O.x + O.width,O.y + O.height);
        return [F, {
            min: z,
            max: j
        }]
    }
    ))
      , b = [];
    Array.from(_.keys()).forEach(F => {
        if (h.has(F))
            return;
        const {min: O, max: z} = x.get(F);
        b.push(O)
    }
    );
    const B = new We(Math.min(...b.map(F => F.x)),Math.min(...b.map(F => F.y)))
      , S = 1 / (l - B.x)
      , I = 1 / (l - B.y)
      , M = new Map(Array.from(_.keys()).map(F => {
        if (h.has(F))
            return;
        let {min: O, max: z} = x.get(F);
        return O.x = O.x * S,
        O.y = O.y * I,
        z.x = z.x * S,
        z.y = z.y * I,
        [F, {
            min: O,
            max: z
        }]
    }
    ).filter(F => F));
    let L = !1;
    const D = new L1(l,l);
    Array.from(_.keys()).forEach(F => {
        const O = A.find(re => re.mesh === F)
          , {material: z} = O;
        let j, Q;
        const C = M.get(F);
        if (C ? (j = C.min,
        Q = C.max) : (j = new We(0,0),
        Q = new We(0,0)),
        !h.has(O.mesh)) {
            const re = _.get(F).width
              , ue = _.get(F).height;
            c.forEach(le => {
                var H;
                const me = f[le];
                me.globalCompositeOperation = "source-over";
                let ie, ge = new Qe(1,1,1);
                switch (le) {
                case "diffuse":
                    ie = z.color || n,
                    (H = z.uniforms) != null && H.litFactor ? ge = z.uniforms.litFactor.value : ge = z.color;
                    break;
                case "normal":
                    ie = new Qe(12369151);
                    break;
                case "orm":
                    ie = new Qe(0,z.roughness,z.metalness);
                    break;
                default:
                    ie = new Qe(1,1,1);
                    break
                }
                let _e = Yme(z, yT[le].find(fe => nx(z, fe)));
                L == !1 && le == "normal" && _e != null && (L = !0);
                const se = D.render(_e, ge, ie, le == "diffuse" && o, le != "normal");
                createImageBitmap(se).then(fe => me.drawImage(fe, j.x * l, j.y * l, re, ue))
            }
            )
        }
        const W = F.geometry.clone();
        F.geometry = W;
        const ee = W.attributes.uv.clone();
        if (W.attributes.uv = ee,
        ee)
            for (let re = 0; re < W.attributes.uv.array.length; re += 2)
                ee.array[re] = (ee.array[re] % 1 + 1) % 1,
                ee.array[re + 1] = (ee.array[re + 1] % 1 + 1) % 1,
                ee.array[re] = tA(ee.array[re], 0, 1, j.x, Q.x),
                ee.array[re + 1] = tA(ee.array[re + 1], 0, 1, j.y, Q.y);
        const P = W.attributes.uv2;
        if (P)
            for (let re = 0; re < P.array.length; re += 2)
                P.array[re] = (P.array[re] % 1 + 1) % 1,
                P.array[re + 1] = (P.array[re + 1] % 1 + 1) % 1,
                P.array[re] = tA(P.array[re], 0, 1, j.x, Q.x),
                P.array[re + 1] = tA(P.array[re + 1], 0, 1, j.y, Q.y);
        else
            W.attributes.uv2 = W.attributes.uv
    }
    ),
    D.destroy();
    const T = Object.fromEntries(await Promise.all(c.map(async F => {
        const O = new Un(f[F].canvas);
        return O.flipY = !1,
        [F, O]
    }
    )))
      , y = a ? _i : Hs;
    let E;
    const R = s ? "transparent" : "opaque";
    return i ? (E = new Od({
        map: T.diffuse,
        transparent: s,
        side: y
    }),
    u == null && (u = new xG),
    u.side = y,
    u.uniforms.map = T.diffuse,
    u.uniforms.shadeMultiplyTexture = T.diffuse,
    u.transparent = s,
    o && !s && (E.alphaTest = .5,
    u.alphaTest = .5),
    E.userData.vrmMaterial = u,
    E.userData.shadeTexture = T.uniformColor,
    E.name = "mToon_" + R,
    E.map.name = E.name) : (E = new Od({
        map: T.diffuse,
        roughnessMap: T.orm,
        metalnessMap: T.orm,
        normalMap: L ? T.normal : null,
        transparent: s,
        side: y
    }),
    o && !s && (E.alphaTest = .5),
    E.name = "standard_" + R,
    E.roughnessMap != null && (E.roughnessMap.name = E.name + "_orm"),
    E.normalMap != null && (E.normalMap.name = E.name + "_normal")),
    {
        bakeObjects: A,
        material: E
    }
}
;
function HG(n) {
    const e = new Map;
    for (const r of n.skeleton.bones) {
        const i = r.clone(!1);
        e.set(r, i)
    }
    n.skeleton.bones[0].traverse(r => {
        if (r.type !== "Bone")
            return;
        const i = e.get(r);
        for (const s of r.children) {
            const o = e.get(s);
            o && i.add(o)
        }
    }
    );
    const t = new FA(n.skeleton.bones.map(r => e.get(r)));
    return t.boneInverses = n.skeleton.boneInverses,
    t.pose(),
    t
}
function zG(n, e) {
    const t = new Map;
    new $(-1,1,-1),
    new He,
    new $;
    let r = 0;
    n.forEach(l => {
        if (l.skeleton) {
            var c = HG(l);
            const A = c.bones;
            c.bones.forEach( (u, f) => {
                var h;
                if (A.indexOf(u) !== -1) {
                    const d = t.get(u.name);
                    if (d == null) {
                        const m = {
                            index: r,
                            boneInverses: c.boneInverses[f],
                            bone: u.clone(!1),
                            parentName: ((h = u.parent) == null ? void 0 : h.type) == "Bone" ? u.parent.name : null
                        };
                        r++,
                        t.set(u.name, m)
                    } else
                        u.userData.VRMcolliders != null && (d.bone.userData.VRMcolliders == null ? d.bone.userData.VRMcolliders = u.userData.VRMcolliders : u.userData.VRMcollidersID != d.bone.userData.VRMcollidersID && (d.bone.userData.VRMcolliders = [...d.bone.userData.VRMcolliders, ...u.userData.VRMcolliders]))
                }
            }
            )
        }
    }
    );
    const i = []
      , s = [];
    [...t.values()].forEach(l => {
        var c;
        if (i.push(l.bone),
        s.push(l.boneInverses),
        l.parentName != null) {
            const A = (c = t.get(l.parentName)) == null ? void 0 : c.bone;
            A && A.add(l.bone)
        }
    }
    );
    const a = new FA(i,s);
    return a.bones.forEach(l => {
        var A;
        const c = (A = l.userData) == null ? void 0 : A.vrm0RestPosition;
        c && l.position.set(-c.x, c.y, -c.z),
        l.position.set(l.position.x * e, l.position.y * e, l.position.z * e)
    }
    ),
    a
}
function qme(n, e) {
    if (!e.skeleton)
        return;
    const t = new Map;
    if (e.skeleton) {
        e.skeleton.bones.forEach( (o, a) => {
            const l = n.bones.filter(A => A.name === o.name)
              , c = l.length > 0 ? n.bones.indexOf(l[0]) : -1;
            t.set(a, c)
        }
        );
        const r = []
          , i = e.geometry.attributes.skinIndex.array;
        for (let o = 0; o < i.length; o++)
            r[o] = t.get(i[o]);
        const s = new Uint16Array(r);
        return new ct(s,4,!1)
    }
}
function GG(n) {
    const e = [...n];
    return e.sort(),
    e.filter( (t, r) => e.indexOf(t) === r)
}
function ege(n) {
    const t = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array].filter(r => n.constructor === r);
    return t.length && t[0] || null
}
function rx(n, e) {
    const t = [];
    for (let s = 0; s < e.length; s++) {
        const o = s * n.itemSize;
        for (let a = 0; a < n.itemSize; a++)
            t[o + a] = n.array[e[s] * n.itemSize + a]
    }
    const r = ege(n.array)
      , i = new r(t);
    return new ct(i,n.itemSize,n.normalized)
}
function tge(n, e, t) {
    for (let r = 0; r < n.attributes.skinIndex.array.length; r += 4) {
        const i = [n.attributes.skinIndex.array[r], n.attributes.skinIndex.array[r + 1], n.attributes.skinIndex.array[r + 2], n.attributes.skinIndex.array[r + 3]];
        for (let s = 0; s < 4; s++) {
            const o = i[s]
              , a = nge(o, e, t);
            i[s] = a
        }
        n.attributes.skinIndex.array[r] = i[0],
        n.attributes.skinIndex.array[r + 1] = i[1],
        n.attributes.skinIndex.array[r + 2] = i[2],
        n.attributes.skinIndex.array[r + 3] = i[3]
    }
    n.attributes.skinIndex.needsUpdate = !0
}
function nge(n, e, t) {
    const r = e.bones[n]
      , i = t.bones.find(s => s.name === r.name);
    return i ? t.bones.indexOf(i) : -1
}
async function rge(n, e, t) {
    const {scale: r, isVrm0: i, mergeAppliedMorphs: s} = t
      , o = []
      , a = []
      , l = kd(n, "SkinnedMesh")
      , c = jG(e)
      , A = VG(e).map(h => h.id);
    l.forEach(h => {
        const d = h.clone();
        o.push(d),
        Array.isArray(h.material) ? a.push(...h.material) : a.push(h.material)
    }
    );
    const u = zG(o, r)
      , f = new Lt;
    return f.name = "AvatarRoot",
    o.forEach(h => {
        var L, D;
        const d = new Jt
          , m = {};
        for (const T in h.geometry.attributes) {
            const y = h.geometry.attributes[T];
            m[T] = y.clone()
        }
        const g = {
            merge: new Set,
            keep: new Set(c),
            remove: new Set
        };
        if (s) {
            if (!h.morphTargetDictionary || !h.morphTargetInfluences)
                return;
            A.forEach(T => {
                const y = h.morphTargetDictionary[T];
                if (y !== void 0 && h.morphTargetInfluences[y] > 0)
                    g.merge.add(T);
                else
                    return g.remove.add(T),
                    null
            }
            )
        }
        if ((L = h.userData) != null && L.isVRM0)
            for (let T = 0; T < m.position.array.length; T += 3)
                m.position.array[T] *= -1,
                m.position.array[T + 2] *= -1;
        const p = {
            attributes: m,
            morphTargetDictionaries: new Map(l.map(T => [T, T.morphTargetDictionary || {}])),
            morphTargetInfluences: new Map(l.map(T => [T, T.morphTargetInfluences || []])),
            index: null,
            animations: {}
        }
          , {dest: v, destMorphToMerge: w} = D1({
            meshes: [h],
            scale: r,
            morphTargetsProcess: g
        }, i);
        if (i)
            for (let T = 0; T < p.attributes.position.array.length; T += 3)
                p.attributes.position.array[T] *= -1,
                p.attributes.position.array[T + 2] *= -1;
        p.attributes = v.attributes,
        p.morphAttributes = v.morphAttributes,
        d.morphTargetsRelative = !0;
        const _ = h.geometry.index.array
          , x = GG(h.geometry.index.array)
          , b = [];
        for (let T = 0; T < _.length; T++)
            b[T] = x.indexOf(_[T]);
        tge(d, h.skeleton, u);
        const B = new Uint32Array(b)
          , S = new ct(B,1,!1);
        d.setIndex(S);
        for (const T in d.attributes)
            d.setAttribute(T, rx(d.getAttribute(T), x));
        for (const T in d.morphAttributes) {
            const y = d.morphAttributes[T];
            for (let E = 0; E < y.length; E++)
                y[E] = rx(y[E], x)
        }
        const I = d.attributes.position.array;
        for (let T = 0; T < I.length; T += 3)
            if (I[T] *= r,
            I[T + 1] *= r,
            I[T + 2] *= r,
            s) {
                if (!w.morphTargetInfluences)
                    return;
                for (let y = 0; y < w.morphTargetInfluences.length; y++) {
                    const E = (D = w.morphAttributes) == null ? void 0 : D.position[y];
                    if (E)
                        for (let R = 0; R < 3; R++)
                            I[T + R] += E.array[T + R] * w.morphTargetInfluences[y]
                }
            }
        const M = new sa(d,h.material);
        M.name = h.name,
        M.morphTargetInfluences = v.morphTargetInfluences,
        M.morphTargetDictionary = v.morphTargetDictionary,
        M.bind(u),
        f.add(M),
        f.add(u.bones[0])
    }
    ),
    f.userData.atlasMaterial = a,
    f
}
function ige(n) {
    const e = n.parent.name
      , t = new $
      , r = new $;
    n.getWorldPosition(t),
    n.getWorldScale(r),
    n = n.clone();
    const i = new He
      , s = new nt;
    return n.getWorldQuaternion(s),
    i.makeRotationFromQuaternion(s),
    n.userData.boneName = e,
    n.userData.globalPosition = t,
    n.userData.globalScale = r,
    n.userData.globalRotationMatrix = i,
    n
}
function sge(n, e) {
    const t = new sa(e.geometry,e.material)
      , r = n.clone()
      , i = r.bones.findIndex(h => h.name === e.userData.boneName)
      , s = e.userData.globalPosition
      , o = e.userData.globalScale || new $(1,1,1)
      , a = e.userData.globalRotationMatrix;
    t.add(r.bones[0]);
    const l = []
      , c = []
      , A = t.geometry.attributes.position.array
      , u = new $
      , f = e.userData.isVRM0 ? -1 : 1;
    for (let h = 0; h < A.length; h += 3)
        u.set(A[h], A[h + 1], A[h + 2]),
        u.applyMatrix4(a),
        A[h] = f * o.x * u.x + s.x,
        A[h + 1] = o.y * u.y + s.y,
        A[h + 2] = f * o.z * u.z + s.z,
        l.push(i, 0, 0, 0),
        c.push(1, 0, 0, 0);
    return t.geometry.setAttribute("skinIndex", new f1(l,4)),
    t.geometry.setAttribute("skinWeight", new xn(c,4)),
    t.bind(r),
    t
}
async function oge(n, e, t) {
    var T, y;
    let {transparentColor: r=new Qe(1,1,1), mToonAtlasSize: i=4096, mToonAtlasSizeTransp: s=4096, stdAtlasSize: o=4096, stdAtlasSizeTransp: a=4096, includeNonTexturedMeshesInAtlas: l=!1, exportMtoonAtlas: c=!1, exportStdAtlas: A=!0, mergeAppliedMorphs: u=!1, isVrm0: f=!1, scale: h=1, twoSidedMaterial: d=!1} = t;
    const m = kd(n, ["Mesh"]);
    for (let E = 0; E < m.length; E++)
        m[E] = ige(m[E]);
    const g = kd(n, ["SkinnedMesh"])
      , p = [...m, ...g];
    c == !1 && A == !1 && (c = !0);
    let {stdMesh: v, stdTranspMesh: w, mToonMesh: _, mToonTranspMesh: x, requiresTransparency: b} = uge(p);
    c == !1 && (v = [...v, ..._],
    w = [...w, ...x],
    x = [],
    _ = []),
    A == !1 && (_ = [..._, ...v],
    x = [...x, ...w],
    v = [],
    w = []);
    const B = new Lt;
    B.name = "AvatarRoot",
    B.userData.atlasMaterial = [];
    const S = zG(p, h)
      , I = {
        standard: {
            meshArray: v,
            size: o,
            isMtoon: !1,
            transparentMaterial: !1
        },
        standardTransparent: {
            meshArray: w,
            size: a,
            isMtoon: !1,
            transparentMaterial: !0
        },
        mToon: {
            meshArray: _,
            size: i,
            isMtoon: !0,
            transparentMaterial: !1
        },
        mToonTransparent: {
            meshArray: x,
            size: s,
            isMtoon: !0,
            transparentMaterial: !0
        }
    }
      , M = jG(e)
      , L = VG(e).map(E => E.id);
    for (const E in I) {
        const R = I[E]
          , F = R.meshArray;
        if (F.length > 0) {
            const {bakeObjects: O, material: z} = await $me({
                transparentColor: r,
                atlasSize: R.size,
                meshes: F,
                mtoon: R.isMtoon,
                includeNonTexturedMeshesInAtlas: l,
                transparentMaterial: R.transparentMaterial,
                transparentTexture: b,
                twoSidedMaterial: d
            })
              , j = O.map(le => le.mesh)
              , Q = []
              , C = {
                merge: new Set,
                keep: new Set(Object.keys(M)),
                remove: new Set
            };
            j.forEach(le => {
                if (le.type == "Mesh" && (le = sge(S, le)),
                Q.push(le),
                u) {
                    if (!le.morphTargetDictionary || !le.morphTargetInfluences)
                        return;
                    L.forEach(fe => {
                        const Ae = le.morphTargetDictionary[fe];
                        if (Ae !== void 0 && le.morphTargetInfluences[Ae] > 0)
                            C.merge.add(fe);
                        else
                            return C.remove.add(fe),
                            null
                    }
                    )
                }
                const me = le.geometry
                  , ie = me.index.array
                  , ge = GG(le.geometry.index.array)
                  , _e = [];
                for (let fe = 0; fe < ie.length; fe++)
                    _e[fe] = ge.indexOf(ie[fe]);
                const se = new Uint32Array(_e)
                  , H = new ct(se,1,!1);
                me.setIndex(H);
                for (const fe in me.attributes)
                    me.setAttribute(fe, rx(me.getAttribute(fe), ge));
                for (const fe in me.morphAttributes) {
                    const Ae = me.morphAttributes[fe];
                    for (let J = 0; J < Ae.length; J++)
                        Ae[J] = rx(Ae[J], ge)
                }
                me.attributes.uv2 || (me.attributes.uv2 = me.attributes.uv),
                le.skeleton != null && le.geometry.setAttribute("skinIndex", qme(S, le));
                for (let fe = 0; fe < 8; fe++)
                    delete me.attributes[`morphTarget${fe}`],
                    delete me.attributes[`morphNormal${fe}`]
            }
            );
            const {dest: W, destMorphToMerge: ee} = D1({
                meshes: Q,
                scale: h,
                morphTargetsProcess: C
            }, f);
            console.log("destMorphToMerge", ee);
            const P = new Jt;
            for (let le = 0; le < W.attributes.position.array.length; le += 3)
                W.attributes.position.array[le] *= -1,
                W.attributes.position.array[le + 2] *= -1;
            P.attributes = W.attributes,
            P.morphAttributes = W.morphAttributes,
            P.morphTargetsRelative = !0,
            P.setIndex(W.index);
            const re = P.attributes.position.array;
            for (let le = 0; le < re.length; le += 3)
                if (re[le] *= h,
                re[le + 1] *= h,
                re[le + 2] *= h,
                u) {
                    if (!ee.morphTargetInfluences)
                        continue;
                    for (let me = 0; me < ee.morphTargetInfluences.length; me++) {
                        const ie = (T = ee.morphAttributes) == null ? void 0 : T.position[me];
                        if (ie)
                            for (let ge = 0; ge < 3; ge++)
                                re[le + ge] += ie.array[le + ge] * ee.morphTargetInfluences[me]
                    }
                }
            const ue = new sa(P,z);
            ue.name = "CombinedMesh_" + E,
            ue.morphTargetInfluences = W.morphTargetInfluences,
            ue.morphTargetDictionary = W.morphTargetDictionary,
            ue.bind(S),
            B.add(ue),
            ue.userData.bindMorphs = {
                old: M,
                new: {}
            },
            Object.keys(M).forEach(le => {
                const me = ue.morphTargetDictionary[le];
                me !== void 0 && (ue.userData.bindMorphs.new[le] = {
                    index: me,
                    primitives: [ue.id]
                })
            }
            ),
            B.userData.atlasMaterial.push(z)
        }
    }
    const D = (y = Object.values(e).find(E => {
        var R;
        return (R = E == null ? void 0 : E.vrm) == null ? void 0 : R.expressionManager
    }
    )) == null ? void 0 : y.vrm.expressionManager;
    return B.userData.expressionManagerToClone = D,
    B.add(S.bones[0]),
    B
}
function VG(n) {
    var t;
    return ((t = Object.values(n).filter(r => r)[0]) == null ? void 0 : t.traitInfo.manifestData.getAllBlendShapeTraits()) || []
}
function jG(n) {
    const e = Object.values(n).map(i => i == null ? void 0 : i.vrm).filter(i => !!i).map(i => {
        var s;
        return (s = i.expressionManager) == null ? void 0 : s.expressionMap
    }
    )
      , t = {};
    let r = [];
    for (const i of e)
        if (i)
            for (const s of Object.values(i)) {
                if (r.includes(s.expressionName))
                    continue;
                r.push(s.expressionName);
                const o = s._binds;
                !o || o.length == 0 || o.forEach(a => {
                    function l(A) {
                        const f = a.primitives.map(h => h.morphTargetDictionary).filter(h => !!h).find(h => Object.values(h).includes(A));
                        if (f)
                            return Object.entries(f).find( ([,h]) => h == A)
                    }
                    const c = l(a.index);
                    c && (t[c[0]] = {
                        index: c[1],
                        primitives: a.primitives.map(A => A.id)
                    })
                }
                )
            }
    return t
}
function PO({meshes: n, sourceMorphTargetDictionaries: e, destMorphTargetDictionary: t}) {
    const r = [];
    return Object.entries(t).map( ([i,s]) => {
        const o = n.find(l => e.get(l).hasOwnProperty(i))
          , a = o.morphTargetDictionary[i];
        r[s] = o.morphTargetInfluences[a]
    }
    ),
    r
}
function age({sourceAttributes: n}) {
    const e = new Set
      , t = Array.from(n.values());
    t.forEach(i => {
        Object.keys(i).forEach(s => e.add(s))
    }
    );
    const r = {};
    return Array.from(e.keys()).map(i => {
        r[i] = Kz(t.map(s => s[i]).flat().filter(s => s !== void 0))
    }
    ),
    r
}
function LO(n) {
    const {sourceMorphTargetDictionaries: e, morphTargetsProcess: t} = n
      , r = new Set;
    Array.from(e.values()).forEach(o => {
        Object.keys(o).forEach(a => {
            if (!t)
                r.add(a);
            else {
                if (t.remove.has(a) || t.merge.has(a))
                    return;
                t.keep.has(a) && r.add(a)
            }
        }
        )
    }
    );
    const s = {};
    return Array.from(r.keys()).map( (o, a) => {
        s[o] = a
    }
    ),
    s
}
function DO({meshes: n, sourceMorphTargetDictionaries: e, sourceMorphAttributes: t, destMorphTargetDictionary: r, scale: i}) {
    const s = new Set;
    Array.from(t.values()).forEach(A => {
        Object.keys(A).forEach(u => s.add(u))
    }
    );
    const a = Array.from(s)
      , l = {};
    a.forEach(A => {
        l[A] = [],
        Object.entries(r).forEach( ([u,f]) => {
            l[A][f] = [],
            n.forEach(h => {
                let d;
                const m = e.get(h);
                if (m.hasOwnProperty(u) && h.geometry.morphAttributes[A]) {
                    const g = m[u];
                    d = h.geometry.morphAttributes[A][g]
                } else {
                    const g = h.geometry.attributes[A]
                      , p = new g.array.constructor(new Array(g.array.length).fill(0));
                    d = new ct(p,g.itemSize,g.normalized)
                }
                l[A][f].push(d)
            }
            )
        }
        )
    }
    );
    const c = {};
    return a.forEach(A => {
        c[A] = [];
        for (let u = 0; u < Object.entries(r).length; u++) {
            c[A][u] = Kz(l[A][u]);
            const f = c[A][u].array;
            for (let h = 0; h < f.length; h += 3)
                f[h] *= i,
                f[h + 1] *= i,
                f[h + 2] *= i
        }
    }
    ),
    c
}
function lge({meshes: n}) {
    var e = 0
      , t = [];
    return n.forEach(r => {
        const i = r.geometry.index;
        for (var s = 0; s < i.count; ++s)
            t.push(i.getX(s) + e);
        e += r.geometry.attributes.position.count
    }
    ),
    t
}
function D1({meshes: n, scale: e, morphTargetsProcess: t}, r=!1) {
    let i = 0;
    n.forEach(f => {
        var h;
        if (i += f.geometry.attributes.uv.count,
        (h = f.userData) != null && h.isVRM0)
            for (let d = 0; d < f.geometry.attributes.position.array.length; d += 3)
                f.geometry.attributes.position.array[d] *= -1,
                f.geometry.attributes.position.array[d + 2] *= -1
    }
    );
    const s = {
        meshes: n,
        attributes: new Map(n.map(f => [f, f.geometry.attributes])),
        morphAttributes: new Map(n.map(f => [f, f.geometry.morphAttributes])),
        morphTargetDictionaries: new Map(n.map(f => [f, f.morphTargetDictionary || {}])),
        morphTargetInfluences: new Map(n.map(f => [f, f.morphTargetInfluences || []]))
    }
      , o = {
        attributes: null,
        morphTargetDictionary: null,
        morphAttributes: null,
        morphTargetInfluences: null,
        index: null,
        animations: {}
    };
    o.attributes = age({
        sourceAttributes: s.attributes
    });
    const a = LO({
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        morphTargetsProcess: {
            remove: (t == null ? void 0 : t.remove) || new Set,
            keep: (t == null ? void 0 : t.keep) || new Set,
            merge: (t == null ? void 0 : t.merge) || new Set
        }
    });
    o.morphTargetDictionary = a,
    o.morphAttributes = DO({
        meshes: n,
        sourceMorphAttributes: s.morphAttributes,
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        destMorphTargetDictionary: a,
        scale: e
    }),
    o.morphTargetInfluences = PO({
        meshes: n,
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        destMorphTargetDictionary: a
    }),
    o.index = lge({
        meshes: n
    });
    const l = {
        morphAttributes: {},
        morphTargetDictionaries: {},
        morphTargetInfluences: null
    };
    let c = new Set((t == null ? void 0 : t.keep) || []);
    t == null || t.merge.forEach(f => {
        c.add(f)
    }
    );
    const A = LO({
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        morphTargetsProcess: {
            remove: new Set,
            keep: c,
            merge: new Set
        }
    });
    l.morphAttributes = DO({
        meshes: n,
        sourceMorphAttributes: s.morphAttributes,
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        destMorphTargetDictionary: A,
        scale: e
    });
    const u = PO({
        meshes: n,
        sourceMorphTargetDictionaries: s.morphTargetDictionaries,
        destMorphTargetDictionary: A
    });
    return l.morphTargetInfluences = u,
    l.morphTargetDictionaries = A,
    o.animations = {},
    {
        source: s,
        dest: o,
        destMorphToMerge: l
    }
}
function ut(n) {
    return n == null ? [] : Array.isArray(n) ? n : [n]
}
function cge(n, e) {
    let t = n.children.slice();
    t.forEach(r => n.remove(r)),
    n.add(e),
    t.forEach(r => n.add(r))
}
async function Age(n, e) {
    const r = await new PA().load(e);
    r.colorSpace = Ut,
    r.flipY = !1,
    n.traverse(i => {
        if (i instanceof dn) {
            const s = Array.isArray(i.material) ? i.material : [i.material];
            for (let o = 0; o < s.length; o++)
                s[o]instanceof mr ? s[o].name.includes("(Outline)") || (console.log(s[o].name),
                s[o].uniforms.map.value = r,
                s[o].uniforms.shadeMultiplyTexture.value = r) : (s[o].map = r,
                s[o].emissiveMap = r),
                s[o].needsUpdate = !0
        }
    }
    )
}
function Kl(n) {
    return n.replace(/^.*[\\/]/, "").split(".").slice(0, -1).join(".")
}
const qB = n => {
    const e = [];
    for (const t in n) {
        const r = n[t].vrm;
        if (r) {
            const i = r.data.cullingLayer;
            i >= 0 && r.data.cullingMeshes.map(s => {
                s.userData.cullLayer = i,
                s.userData.cullDistance = r.data.cullingDistance,
                s.userData.maxCullDistance = r.data.maxCullingDistance,
                e.push(s)
            }
            )
        }
    }
    Vme(e)
}
;
function uge(n) {
    const e = []
      , t = []
      , r = []
      , i = [];
    let s = !1;
    return n.forEach(o => {
        var c;
        const l = ut(o.material)[0];
        l.type == "ShaderMaterial" ? l.transparent == !0 ? (i.push(o),
        s = !0) : (r.push(o),
        ((c = l.uniforms.alphaTest) == null ? void 0 : c.value) != 0 && (s = !0)) : l.transparent == !0 ? (t.push(o),
        s = !0) : (e.push(o),
        l.alphaTest != 0 && (s = !0))
    }
    ),
    {
        stdMesh: e,
        stdTranspMesh: t,
        mToonMesh: r,
        mToonTranspMesh: i,
        requiresTransparency: s
    }
}
function fge(n) {
    const e = []
      , t = []
      , r = []
      , i = []
      , s = []
      , o = [];
    return n.forEach(a => {
        ut(a.material).forEach(c => {
            c.type == "ShaderMaterial" ? c.transparent == !0 ? o.push(c) : c.uniforms.alphaTest.value != 0 ? s.push(c) : i.push(c) : c.transparent == !0 ? r.push(c) : c.alphaTest != 0 ? t.push(c) : e.push(c)
        }
        )
    }
    ),
    {
        stdMats: e,
        stdCutoutpMats: t,
        stdTranspMats: r,
        mToonMats: i,
        mToonCutoutMats: s,
        mToonTranspMats: o
    }
}
function NO(n, e) {
    n.data == null ? n.data = e : n.data = {
        ...n.data,
        ...e
    }
}
function hge(n, e) {
    if (n.data != null)
        return n.data[e]
}
function dge(n) {
    const e = hge(n, "cullingMeshes");
    e && (e.forEach(t => {
        QG(t)
    }
    ),
    n.data.cullingMeshes = null)
}
function Nn(n) {
    switch (n) {
    case 1:
        return 128;
    case 2:
        return 256;
    case 3:
        return 512;
    case 4:
        return 1024;
    case 5:
        return 2048;
    case 6:
        return 4096;
    case 7:
        return 8192;
    case 8:
        return 16384;
    default:
        return 4096
    }
}
function pge(n) {
    const e = n.scene;
    dge(n),
    e.traverse(t => {
        t.material && wT(t.material),
        t.geometry && (QG(t),
        t.geometry.dispose(),
        t.geometry.disposeBoundsTree())
    }
    ),
    e.parent && e.parent.remove(e),
    B0.deepDispose(e),
    n.expressionManager && n.expressionManager.expressions.forEach(t => {
        t._binds && t._binds.forEach(r => {
            r.primitives && r.primitives.forEach(i => {
                i.geometry.dispose(),
                i.material && wT(i.material)
            }
            )
        }
        )
    }
    );
    for (const t in n)
        n[t] = null
}
const wT = n => {
    var e, t, r, i, s, o;
    if (n.length)
        for (let a = 0; a < n.length; ++a)
            wT(n[a]);
    else
        (e = n.map) != null && e.dispose && n.map.dispose(),
        (t = n.normalMap) != null && t.dispose && n.normalMap.dispose(),
        (r = n.ormMap) != null && r.dispose && n.ormMap.dispose(),
        (i = n.aoMap) != null && i.dispose && n.aoMap.dispose(),
        (s = n.roughnessMap) != null && s.dispose && n.roughnessMap.dispose(),
        (o = n.metalnessMap) != null && o.dispose && n.metalnessMap.dispose(),
        n.dispose()
}
  , h2 = n => {
    let e, t, r = 0;
    return Array.isArray(n) ? (e = n[0] || 0,
    t = n[1] || 0,
    r = n[2] || 0) : (typeof n == "string" || n instanceof String) && n.split("-").forEach(s => {
        switch (s = s.toLowerCase(),
        s) {
        case "left":
            e = -1;
            break;
        case "right":
            e = 1;
            break;
        case "bottom":
        case "down":
            t = -1;
            break;
        case "top":
        case "up":
            t = 1;
            break;
        case "back":
        case "backward":
            r = -1;
            break;
        case "front":
        case "forward":
            r = 1;
            break;
        default:
            console.warn("unkown cameraPosition name: " + s + " in: " + n + ". Please use left, right, bottom, top, back or front");
            break
        }
    }
    ),
    new $(e,t,r)
}
  , WG = () => {
    const n = new Date().getTime()
      , e = Math.random().toString(36).substr(2, 9);
    return n + "-" + e
}
  , mge = n => {
    var t, r, i, s, o, a, l, c, A, u, f;
    const e = n.humanoid.humanBones;
    e.hips.node.parent.name = "rootBone",
    e.upperChest == null && e.neck.node.parent != e.chest && (e.neck.node.parent != e.chest.node ? e.upperChest = {
        node: e.neck.node.parent
    } : e.upperChest != null && (e.upperChest = {
        node: e.neck.node.parent
    },
    e.chest = {
        node: e.neck.node.parent.parent
    })),
    e.leftShoulder == null && (e.leftUpperArm.node.parent != ((t = e.chest) == null ? void 0 : t.node) && e.leftUpperArm.node.parent != ((r = e.upperChest) == null ? void 0 : r.node) && e.leftUpperArm.node.parent != ((i = e.spine) == null ? void 0 : i.node) && e.leftUpperArm.node.parent != ((s = e.neck) == null ? void 0 : s.node) && e.leftUpperArm.node.parent != ((o = e.head) == null ? void 0 : o.node),
    e.leftShoulder = {
        node: e.leftUpperArm.node.parent
    }),
    e.rightShoulder == null && (e.rightUpperArm.node.parent != ((a = e.chest) == null ? void 0 : a.node) && e.rightUpperArm.node.parent != ((l = e.upperChest) == null ? void 0 : l.node) && e.rightUpperArm.node.parent != ((c = e.spine) == null ? void 0 : c.node) && e.rightUpperArm.node.parent != ((A = e.neck) == null ? void 0 : A.node) && e.rightUpperArm.node.parent != ((u = e.head) == null ? void 0 : u.node),
    e.rightShoulder = {
        node: e.rightUpperArm.node.parent
    });
    for (let h in Jg)
        h = h.charAt(0).toLowerCase() + h.slice(1),
        (f = e[h]) != null && f.node && (e[h].node.name = h)
}
;
function KG({candidates: n, predicate: e}) {
    if (!n.length)
        return null;
    const t = n.shift();
    return e(t) ? t : (n = n.concat(t.children),
    KG({
        candidates: n,
        predicate: e
    }))
}
function XG(n, e) {
    return KG({
        candidates: [n],
        predicate: t => t.name === e
    })
}
function YG({candidates: n, predicate: e, results: t=[]}) {
    if (!n.length)
        return t;
    const r = n.shift();
    return e(r) && t.push(r),
    n = n.concat(r.children),
    YG({
        candidates: n,
        predicate: e,
        results: t
    })
}
function kd(n, e) {
    return YG({
        candidates: [n],
        predicate: t => ut(e).includes(t.type)
    })
}
function gge(n, e) {
    if (!n.morphTargetDictionary)
        return !1;
    for (const t of Object.keys(n.morphTargetDictionary))
        if (e[t])
            return !0;
    return !1
}
function d2({width: n, height: e, transparent: t}) {
    const r = document.createElement("canvas");
    r.width = n,
    r.height = e;
    const i = r.getContext("2d");
    return i.fillStyle = "white",
    t && (i.globalAlpha = 0),
    i.fillRect(0, 0, r.width, r.height),
    i.globalAlpha = 1,
    i
}
const vge = {
    mixamorigHips: "hips",
    mixamorigSpine: "spine",
    mixamorigSpine1: "chest",
    mixamorigSpine2: "upperChest",
    mixamorigNeck: "neck",
    mixamorigHead: "head",
    mixamorigLeftShoulder: "leftShoulder",
    mixamorigLeftArm: "leftUpperArm",
    mixamorigLeftForeArm: "leftLowerArm",
    mixamorigLeftHand: "leftHand",
    mixamorigLeftHandThumb1: "leftThumbMetacarpal",
    mixamorigLeftHandThumb2: "leftThumbProximal",
    mixamorigLeftHandThumb3: "leftThumbDistal",
    mixamorigLeftHandIndex1: "leftIndexProximal",
    mixamorigLeftHandIndex2: "leftIndexIntermediate",
    mixamorigLeftHandIndex3: "leftIndexDistal",
    mixamorigLeftHandMiddle1: "leftMiddleProximal",
    mixamorigLeftHandMiddle2: "leftMiddleIntermediate",
    mixamorigLeftHandMiddle3: "leftMiddleDistal",
    mixamorigLeftHandRing1: "leftRingProximal",
    mixamorigLeftHandRing2: "leftRingIntermediate",
    mixamorigLeftHandRing3: "leftRingDistal",
    mixamorigLeftHandPinky1: "leftLittleProximal",
    mixamorigLeftHandPinky2: "leftLittleIntermediate",
    mixamorigLeftHandPinky3: "leftLittleDistal",
    mixamorigRightShoulder: "rightShoulder",
    mixamorigRightArm: "rightUpperArm",
    mixamorigRightForeArm: "rightLowerArm",
    mixamorigRightHand: "rightHand",
    mixamorigRightHandPinky1: "rightLittleProximal",
    mixamorigRightHandPinky2: "rightLittleIntermediate",
    mixamorigRightHandPinky3: "rightLittleDistal",
    mixamorigRightHandRing1: "rightRingProximal",
    mixamorigRightHandRing2: "rightRingIntermediate",
    mixamorigRightHandRing3: "rightRingDistal",
    mixamorigRightHandMiddle1: "rightMiddleProximal",
    mixamorigRightHandMiddle2: "rightMiddleIntermediate",
    mixamorigRightHandMiddle3: "rightMiddleDistal",
    mixamorigRightHandIndex1: "rightIndexProximal",
    mixamorigRightHandIndex2: "rightIndexIntermediate",
    mixamorigRightHandIndex3: "rightIndexDistal",
    mixamorigRightHandThumb1: "rightThumbMetacarpal",
    mixamorigRightHandThumb2: "rightThumbProximal",
    mixamorigRightHandThumb3: "rightThumbDistal",
    mixamorigLeftUpLeg: "leftUpperLeg",
    mixamorigLeftLeg: "leftLowerLeg",
    mixamorigLeftFoot: "leftFoot",
    mixamorigLeftToeBase: "leftToes",
    mixamorigRightUpLeg: "rightUpperLeg",
    mixamorigRightLeg: "rightLowerLeg",
    mixamorigRightFoot: "rightFoot",
    mixamorigRightToeBase: "rightToes"
};
function $G(n, e, t) {
    var m;
    const r = ku.findByName(n, "mixamo.com");
    if (r == null)
        return null;
    const i = []
      , s = new nt
      , o = new nt
      , a = new nt
      , l = new $
      , c = e.getObjectByName("mixamorigHips").position.y
      , A = (m = t.humanoid) == null ? void 0 : m.getNormalizedBoneNode("hips").getWorldPosition(l).y
      , u = t.scene.getWorldPosition(l).y
      , h = Math.abs(A - u) / c;
    return r.tracks.forEach(g => {
        const p = g.clone()
          , v = p.name.split(".")
          , w = v[0]
          , x = vge[w]
          , b = e.getObjectByName(w);
        if (x != null) {
            const B = v[1];
            if (b.getWorldQuaternion(s).invert(),
            b.parent.getWorldQuaternion(o),
            p instanceof nl) {
                for (let S = 0; S < p.values.length; S += 4) {
                    const I = p.values.slice(S, S + 4);
                    a.fromArray(I),
                    a.premultiply(o).multiply(s),
                    a.toArray(I),
                    I.forEach( (M, L) => {
                        p.values[L + S] = M
                    }
                    )
                }
                i.push(new nl(`${x}.${B}`,p.times,p.values.map( (S, I) => {
                    var M;
                    return ((M = t.meta) == null ? void 0 : M.metaVersion) === "0" && I % 2 === 0 ? -S : S
                }
                )))
            } else if (p instanceof ic) {
                const S = p.values.map( (I, M) => {
                    var L;
                    return (((L = t.meta) == null ? void 0 : L.metaVersion) === "0" && M % 3 !== 1 ? -I : I) * h
                }
                );
                i.push(new ic(`${x}.${B}`,p.times,S))
            }
        }
    }
    ),
    new ku("vrmAnimation",r.duration,i)
}
const yge = new Hae
  , wge = new Xz
  , eM = .2
  , _ge = n => Math.floor(Math.random() * n);
class OO {
    constructor(e, t, r, i, s, o, a) {
        var l, c, A, u;
        this.mixer = new woe(t),
        this.actions = [],
        this.to = null,
        this.from = null,
        this.vrm = r,
        this.animationManager = e,
        this.mixamoModel = null,
        this.fadeOutActions = null,
        this.newAnimationWeight = 1,
        this.neckBone = (c = (l = r == null ? void 0 : r.humanoid) == null ? void 0 : l.humanBones) == null ? void 0 : c.neck,
        this.spineBone = (u = (A = r == null ? void 0 : r.humanoid) == null ? void 0 : A.humanBones) == null ? void 0 : u.spine,
        this.timeScale = 1,
        i && (this.setAnimations(i, null, null, a),
        this.to = this.actions[s],
        o != -1 && (this.from = this.actions[o],
        this.from.reset(),
        this.from.time = e.getFromActionTime(),
        this.from.play(),
        this.to.weight = e.getWeightIn(),
        this.from.weight = e.getWeightOut()),
        this.actions[s].reset(),
        this.actions[s].time = e.getToActionTime(),
        this.actions[s].play())
    }
    setTimeScale(e) {
        this.timeScale = e,
        this.actions.forEach(t => {
            t.timeScale = e
        }
        )
    }
    setMouseLookEnabled(e) {
        this.setAnimations(this.animations, this.mixamoModel, e)
    }
    setAnimations(e, t=null, r=null, i=!1) {
        if (r = r ?? this.animationManager.mouseLookEnabled,
        this.animations = e,
        t != null) {
            if (this.vrm != null) {
                const s = $G(e, t, this.vrm);
                s && (e = [s],
                this.mixamoModel = t)
            }
        } else {
            const s = [];
            e.forEach(o => {
                s.push(o.clone())
            }
            ),
            e = s
        }
        if (r && e[0].tracks.map( (s, o) => {
            (s.name === "neck.quaternion" || s.name === "spine.quaternion") && e[0].tracks.splice(o, 1)
        }
        ),
        i) {
            this.actions.forEach(s => {
                s.weight = 0,
                s.stop()
            }
            ),
            this.actions = [],
            this.newAnimationWeight = 1;
            for (let s = 0; s < e.length; s++) {
                const o = this.mixer.clipAction(e[s]);
                o.timeScale = this.timeScale,
                this.actions.push(o)
            }
            this.actions[0].weight = 1,
            this.actions[0].play()
        } else {
            this.fadeOutActions = this.actions,
            this.actions = [],
            this.newAnimationWeight = 0;
            for (let s = 0; s < e.length; s++) {
                const o = this.mixer.clipAction(e[s]);
                o.timeScale = this.timeScale,
                this.actions.push(o)
            }
            this.actions[0].weight = 0,
            this.actions[0].play()
        }
    }
    update(e, t) {
        this.fadeOutActions != null && (this.newAnimationWeight += 1 / 5,
        this.fadeOutActions.forEach(r => {
            r.weight = 1 - this.newAnimationWeight
        }
        ),
        this.newAnimationWeight >= 1 && (this.newAnimationWeight = 1,
        this.fadeOutActions.forEach(r => {
            r.weight = 0,
            r.stop()
        }
        ),
        this.fadeOutActions = null),
        this.actions.forEach(r => {
            r.weight = this.newAnimationWeight
        }
        )),
        this.from != null && (this.from.weight = t),
        this.to != null && (this.to.weight = e),
        this.mixer.update(1 / 30)
    }
    reset() {
        this.mixer.setTime(0),
        this.to.paused = !0
    }
    resume() {
        this.to.paused = !1
    }
    setTime(e) {
        this.mixer.setTime(e)
    }
    getTime() {
        return this.mixer.time
    }
    dispose() {
        this.animationManager.disposeAnimation(this)
    }
}
class xge {
    constructor() {
        this.animationPaths = [],
        this.defaultAnimations = [],
        this.lastAnimID = null,
        this.mainControl = null,
        this.animationControl = null,
        this.animations = null,
        this.paused = !1,
        this.scale = 1,
        this.curLoadAnim = 0,
        this.currentAnimationName = "",
        this.weightIn = NaN,
        this.weightOut = NaN,
        this.lastAnimID = -1,
        this.curAnimID = 0,
        this.animationControls = [],
        this.started = !1,
        this.mouseLookEnabled = !1,
        this.mixamoModel = null,
        this.mixamoAnimations = null,
        this.currentClip = null,
        setInterval( () => {
            this.update()
        }
        , 1e3 / 30)
    }
    enableMouseLook(e) {
        this.mouseLookEnabled = e,
        this.animationControls.forEach(t => {
            t.setMouseLookEnabled(e)
        }
        )
    }
    setScale(e) {
        this.scale = e
    }
    async loadAnimation(e, t, r=0, i=!0, s="", o="") {
        const a = s + (s != "" ? "/" : "") + ut(e)[0];
        o = o == "" ? Kl(a) : o,
        this.currentAnimationName = o;
        const c = await (i ? yge : wge).loadAsync(a);
        c.scale.set(this.scale, this.scale, this.scale),
        this._scaleOffsetHips(c.animations);
        const A = ku.findByName(c.animations, "mixamo.com");
        A != null ? (this.mixamoModel = c.clone(),
        this.mixamoAnimations = c.animations,
        this.currentClip = A) : (this.mixamoModel = null,
        this.animations = c.animations,
        this.currentClip = c.animations[0]),
        this.mainControl == null && (this.curAnimID = 0,
        this.lastAnimID = -1,
        this.mainControl = new OO(this,c,null,c.animations,this.curAnimID,this.lastAnimID,t),
        this.animationControls.push(this.mainControl)),
        this.animationControls.forEach(u => {
            u.setAnimations(c.animations, this.mixamoModel, this.mouseLookEnabled, t)
        }
        ),
        this.setTime(r),
        t ? this.pause() : this.play()
    }
    getCurrentClip() {
        return this.currentClip
    }
    getCurrentClipDuration() {
        return this.currentClip ? this.currentClip.duration : 0
    }
    getCurrentAnimationName() {
        return this.currentAnimationName
    }
    clearCurrentAnimations() {
        this.animationPaths = this.defaultAnimations,
        this.animationControls = [],
        this.mainControl = null
    }
    storeAnimationPaths(e, t, r=!0) {
        const i = ut(e);
        r ? this.animationPaths = [...this.defaultAnimations, ...i.map(s => `${t}/${s}`)] : this.animationPaths = i.map(s => t != "" ? `${t}/${s}` : s)
    }
    storeDefaultAnimationPaths(e, t) {
        const r = ut(e);
        this.defaultAnimations = r.map(i => t != "" ? `${t}/${i}` : i),
        this.animationPaths = this.defaultAnimations
    }
    loadNextAnimation() {
        this.curLoadAnim == this.animationPaths.length - 1 ? this.curLoadAnim = 0 : this.curLoadAnim++,
        this.loadAnimation(this.animationPaths[this.curLoadAnim])
    }
    loadPreviousAnimation() {
        this.curLoadAnim == 0 ? this.curLoadAnim = this.animationPaths.length - 1 : this.curLoadAnim--,
        this.loadAnimation(this.animationPaths[this.curLoadAnim])
    }
    enableScreenshot() {
        this.animationControls.forEach(e => {
            e.reset()
        }
        )
    }
    disableScreenshot() {
        this.animationControls.forEach(e => {
            e.resume()
        }
        )
    }
    _scaleOffsetHips(e) {
        e.forEach(t => {
            for (let r = 0; r < t.tracks.length; r++) {
                const i = t.tracks[r];
                if (i.name.includes(".position"))
                    for (let s = 0; s < i.values.length / 3; s++) {
                        const o = s * 3;
                        i.values[o] /= this.scale,
                        i.values[o + 1] /= this.scale,
                        i.values[o + 2] /= this.scale
                    }
            }
        }
        )
    }
    addVRM(e) {
        if (e == null) {
            console.error("Non Existing VRM was provided.");
            return
        }
        let t = null;
        this.mixamoModel != null ? (t = [$G(this.mixamoAnimations, this.mixamoModel.clone(), e)],
        this.animations == null && (this.animations = t)) : t = this.animations;
        const r = new OO(this,e.scene,e,t,this.curAnimID,this.lastAnimID,this.isPaused());
        this.animationControls.push(r),
        this.started === !1 && t && (this.started = !0,
        this.animRandomizer(t[this.curAnimID].duration)),
        this.update(!0)
    }
    removeVRM(e) {
        const t = this.animationControls.findIndex(r => r.vrm === e);
        t !== -1 && this.animationControls.splice(t, 1)[0].dispose()
    }
    getFromActionTime() {
        return this.mainControl.actions[this.lastAnimID].time
    }
    getToActionTime() {
        return this.mainControl ? this.mainControl.actions[this.curAnimID].time : .1
    }
    getWeightIn() {
        return this.weightIn
    }
    getWeightOut() {
        return this.weightOut
    }
    disposeAnimation(e) {
        if (e != null) {
            const t = this.animationControls.indexOf(e);
            t != -1 && this.animationControls.splice(t, 1)
        }
    }
    dispose() {
        this.animationControls.forEach(e => {
            e.dispose()
        }
        )
    }
    animRandomizer(e) {
        setTimeout( () => {
            this.lastAnimID = this.curAnimID,
            this.curAnimID = _ge(this.animations.length),
            this.curAnimID != this.lastAnimID && this.animationControls.forEach(t => {
                t.from = t.actions[this.lastAnimID],
                t.to = t.actions[this.curAnimID],
                this.weightIn = 0,
                this.weightOut = 1,
                t.to.play(),
                t.to.reset()
            }
            ),
            this.animRandomizer(this.animations[this.curAnimID].duration - eM)
        }
        , e * 1e3)
    }
    pause() {
        this.paused = !0
    }
    play() {
        this.paused = !1
    }
    isPaused() {
        return this.paused
    }
    setTime(e) {
        this.mainControl && this.animationControls.forEach(t => {
            t.setTime(e)
        }
        )
    }
    setFrame(e) {
        this.setTime(e * 30)
    }
    setSpeed(e) {
        this.mainControl && this.animationControls.forEach(t => {
            t.setTimeScale(e)
        }
        )
    }
    update(e=!1) {
        (this.mainControl && !this.paused || e) && (this.animationControls.forEach(t => {
            t.update(this.weightIn, this.weightOut)
        }
        ),
        this.weightIn < 1 ? this.weightIn += 1 / (30 * eM) : this.weightIn = 1,
        this.weightOut > 0 ? this.weightOut -= 1 / (30 * eM) : this.weightOut = 0)
    }
}
const bge = {
    name: "CopyShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
};
class qd {
    constructor() {
        this.isPass = !0,
        this.enabled = !0,
        this.needsSwap = !0,
        this.clear = !1,
        this.renderToScreen = !1
    }
    setSize() {}
    render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }
    dispose() {}
}
const Ege = new v0(-1,1,1,-1,0,1);
class Bge extends Jt {
    constructor() {
        super(),
        this.setAttribute("position", new xn([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
        this.setAttribute("uv", new xn([0, 2, 0, 0, 2, 0],2))
    }
}
const Mge = new Bge;
class p2 {
    constructor(e) {
        this._mesh = new dn(Mge,e)
    }
    dispose() {
        this._mesh.geometry.dispose()
    }
    render(e) {
        e.render(this._mesh, Ege)
    }
    get material() {
        return this._mesh.material
    }
    set material(e) {
        this._mesh.material = e
    }
}
class Sge extends qd {
    constructor(e, t) {
        super(),
        this.textureID = t !== void 0 ? t : "tDiffuse",
        e instanceof mr ? (this.uniforms = e.uniforms,
        this.material = e) : e && (this.uniforms = kR.clone(e.uniforms),
        this.material = new mr({
            name: e.name !== void 0 ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })),
        this.fsQuad = new p2(this.material)
    }
    render(e, t, r) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = r.texture),
        this.fsQuad.material = this.material,
        this.renderToScreen ? (e.setRenderTarget(null),
        this.fsQuad.render(e)) : (e.setRenderTarget(t),
        this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
        this.fsQuad.render(e))
    }
    dispose() {
        this.material.dispose(),
        this.fsQuad.dispose()
    }
}
class kO extends qd {
    constructor(e, t) {
        super(),
        this.scene = e,
        this.camera = t,
        this.clear = !0,
        this.needsSwap = !1,
        this.inverse = !1
    }
    render(e, t, r) {
        const i = e.getContext()
          , s = e.state;
        s.buffers.color.setMask(!1),
        s.buffers.depth.setMask(!1),
        s.buffers.color.setLocked(!0),
        s.buffers.depth.setLocked(!0);
        let o, a;
        this.inverse ? (o = 0,
        a = 1) : (o = 1,
        a = 0),
        s.buffers.stencil.setTest(!0),
        s.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
        s.buffers.stencil.setFunc(i.ALWAYS, o, 4294967295),
        s.buffers.stencil.setClear(a),
        s.buffers.stencil.setLocked(!0),
        e.setRenderTarget(r),
        this.clear && e.clear(),
        e.render(this.scene, this.camera),
        e.setRenderTarget(t),
        this.clear && e.clear(),
        e.render(this.scene, this.camera),
        s.buffers.color.setLocked(!1),
        s.buffers.depth.setLocked(!1),
        s.buffers.color.setMask(!0),
        s.buffers.depth.setMask(!0),
        s.buffers.stencil.setLocked(!1),
        s.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
        s.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
        s.buffers.stencil.setLocked(!0)
    }
}
class Cge extends qd {
    constructor() {
        super(),
        this.needsSwap = !1
    }
    render(e) {
        e.state.buffers.stencil.setLocked(!1),
        e.state.buffers.stencil.setTest(!1)
    }
}
class Tge {
    constructor(e, t) {
        if (this.renderer = e,
        this._pixelRatio = e.getPixelRatio(),
        t === void 0) {
            const r = e.getSize(new We);
            this._width = r.width,
            this._height = r.height,
            t = new tl(this._width * this._pixelRatio,this._height * this._pixelRatio,{
                type: Ha
            }),
            t.texture.name = "EffectComposer.rt1"
        } else
            this._width = t.width,
            this._height = t.height;
        this.renderTarget1 = t,
        this.renderTarget2 = t.clone(),
        this.renderTarget2.texture.name = "EffectComposer.rt2",
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2,
        this.renderToScreen = !0,
        this.passes = [],
        this.copyPass = new Sge(bge),
        this.copyPass.material.blending = jl,
        this.clock = new w1
    }
    swapBuffers() {
        const e = this.readBuffer;
        this.readBuffer = this.writeBuffer,
        this.writeBuffer = e
    }
    addPass(e) {
        this.passes.push(e),
        e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    insertPass(e, t) {
        this.passes.splice(t, 0, e),
        e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    removePass(e) {
        const t = this.passes.indexOf(e);
        t !== -1 && this.passes.splice(t, 1)
    }
    isLastEnabledPass(e) {
        for (let t = e + 1; t < this.passes.length; t++)
            if (this.passes[t].enabled)
                return !1;
        return !0
    }
    render(e) {
        e === void 0 && (e = this.clock.getDelta());
        const t = this.renderer.getRenderTarget();
        let r = !1;
        for (let i = 0, s = this.passes.length; i < s; i++) {
            const o = this.passes[i];
            if (o.enabled !== !1) {
                if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i),
                o.render(this.renderer, this.writeBuffer, this.readBuffer, e, r),
                o.needsSwap) {
                    if (r) {
                        const a = this.renderer.getContext()
                          , l = this.renderer.state.buffers.stencil;
                        l.setFunc(a.NOTEQUAL, 1, 4294967295),
                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e),
                        l.setFunc(a.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                kO !== void 0 && (o instanceof kO ? r = !0 : o instanceof Cge && (r = !1))
            }
        }
        this.renderer.setRenderTarget(t)
    }
    reset(e) {
        if (e === void 0) {
            const t = this.renderer.getSize(new We);
            this._pixelRatio = this.renderer.getPixelRatio(),
            this._width = t.width,
            this._height = t.height,
            e = this.renderTarget1.clone(),
            e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.renderTarget1 = e,
        this.renderTarget2 = e.clone(),
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2
    }
    setSize(e, t) {
        this._width = e,
        this._height = t;
        const r = this._width * this._pixelRatio
          , i = this._height * this._pixelRatio;
        this.renderTarget1.setSize(r, i),
        this.renderTarget2.setSize(r, i);
        for (let s = 0; s < this.passes.length; s++)
            this.passes[s].setSize(r, i)
    }
    setPixelRatio(e) {
        this._pixelRatio = e,
        this.setSize(this._width, this._height)
    }
    dispose() {
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.copyPass.dispose()
    }
}
class Ige extends qd {
    constructor(e, t, r=null, i=null, s=null) {
        super(),
        this.scene = e,
        this.camera = t,
        this.overrideMaterial = r,
        this.clearColor = i,
        this.clearAlpha = s,
        this.clear = !0,
        this.clearDepth = !1,
        this.needsSwap = !1,
        this._oldClearColor = new Qe
    }
    render(e, t, r) {
        const i = e.autoClear;
        e.autoClear = !1;
        let s, o;
        this.overrideMaterial !== null && (o = this.scene.overrideMaterial,
        this.scene.overrideMaterial = this.overrideMaterial),
        this.clearColor !== null && (e.getClearColor(this._oldClearColor),
        e.setClearColor(this.clearColor, e.getClearAlpha())),
        this.clearAlpha !== null && (s = e.getClearAlpha(),
        e.setClearAlpha(this.clearAlpha)),
        this.clearDepth == !0 && e.clearDepth(),
        e.setRenderTarget(this.renderToScreen ? null : r),
        this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
        e.render(this.scene, this.camera),
        this.clearColor !== null && e.setClearColor(this._oldClearColor),
        this.clearAlpha !== null && e.setClearAlpha(s),
        this.overrideMaterial !== null && (this.scene.overrideMaterial = o),
        e.autoClear = i
    }
}
class Rge extends qd {
    constructor(e, t, r) {
        super(),
        this.resolution = e,
        this.fsQuad = new p2(this.material()),
        this.scene = t,
        this.camera = r,
        this.rgbRenderTarget = Dy(e, Nr, !0),
        this.normalRenderTarget = Dy(e, Nr, !1),
        this.normalMaterial = new Wse
    }
    setResolution(e) {
        this.rgbRenderTarget = Dy(e, Nr, !0),
        this.normalRenderTarget = Dy(e, Nr, !1)
    }
    render(e, t) {
        e.setRenderTarget(this.rgbRenderTarget),
        e.render(this.scene, this.camera);
        const r = this.scene.overrideMaterial;
        e.setRenderTarget(this.normalRenderTarget),
        this.scene.overrideMaterial = this.normalMaterial,
        e.render(this.scene, this.camera),
        this.scene.overrideMaterial = r;
        const i = this.fsQuad.material.uniforms;
        i.tDiffuse.value = this.rgbRenderTarget.texture,
        i.tDepth.value = this.rgbRenderTarget.depthTexture,
        i.tNormal.value = this.normalRenderTarget.texture,
        this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t),
        this.clear && e.clear()),
        this.fsQuad.render(e)
    }
    material() {
        return new mr({
            uniforms: {
                tDiffuse: {
                    value: null
                },
                tDepth: {
                    value: null
                },
                tNormal: {
                    value: null
                },
                resolution: {
                    value: new Pt(this.resolution.x,this.resolution.y,1 / this.resolution.x,1 / this.resolution.y)
                }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform sampler2D tNormal;
                uniform vec4 resolution;
                varying vec2 vUv;

                float getDepth(int x, int y) {
                    return texture2D( tDepth, vUv + vec2(x, y) * resolution.zw ).r;
                }

                vec3 getNormal(int x, int y) {
                    return texture2D( tNormal, vUv + vec2(x, y) * resolution.zw ).rgb * 2.0 - 1.0;
                }

                float neighborNormalEdgeIndicator(int x, int y, float depth, vec3 normal) {
                    float depthDiff = getDepth(x, y) - depth;
                    vec3 normalEdgeBias = vec3(1., 1., 1.);
                    float normalDiff = dot(normal - getNormal(x, y), normalEdgeBias);
                    float normalIndicator = clamp(smoothstep(-.01, .01, normalDiff), 0.0, 1.0);
                    float depthIndicator = clamp(sign(depthDiff * .25 + .0025), 0.0, 1.0);
                    return distance(normal, getNormal(x, y)) * depthIndicator * normalIndicator;
                }

                float depthEdgeIndicator() {
                    float depth = getDepth(0, 0);
                    vec3 normal = getNormal(0, 0);
                    float diff = 0.0;
                    diff += clamp(getDepth(1, 0) - depth, 0.0, 1.0);
                    diff += clamp(getDepth(-1, 0) - depth, 0.0, 1.0);
                    diff += clamp(getDepth(0, 1) - depth, 0.0, 1.0);
                    diff += clamp(getDepth(0, -1) - depth, 0.0, 1.0);
                    return floor(smoothstep(0.01, 0.02, diff) * 2.) / 2.;
                }

                float normalEdgeIndicator() {
                    float depth = getDepth(0, 0);
                    vec3 normal = getNormal(0, 0);
                    float indicator = 0.0;
                    indicator += neighborNormalEdgeIndicator(0, -1, depth, normal);
                    indicator += neighborNormalEdgeIndicator(0, 1, depth, normal);
                    indicator += neighborNormalEdgeIndicator(-1, 0, depth, normal);
                    indicator += neighborNormalEdgeIndicator(1, 0, depth, normal);
                    return step(0.1, indicator);
                }

                float lum(vec4 color) {
                    vec4 weights = vec4(.2126, .7152, .0722, .0);
                    return dot(color, weights);
                }

                float smoothSign(float x, float radius) {
                    return smoothstep(-radius, radius, x) * 2.0 - 1.0;
                }

                void main() {
                    vec4 texel = texture2D( tDiffuse, vUv );
                    float tLum = lum(texel);
                    float normalEdgeCoefficient = .3;
                    float depthEdgeCoefficient = .4;
                    float dei = depthEdgeIndicator();
                    float nei = normalEdgeIndicator();
                    float coefficient = dei > 0.0 ? (1.0 - depthEdgeCoefficient * dei) : (1.0 + normalEdgeCoefficient * nei);
                    gl_FragColor = texel * coefficient;
                }
                `
        })
    }
}
function Dy(n, e, t) {
    const r = new tl(n.x,n.y,t ? {
        depthTexture: new HR(n.x,n.y),
        depthBuffer: !0
    } : void 0);
    return r.texture.format = e,
    r.texture.minFilter = Xr,
    r.texture.magFilter = Xr,
    r.texture.generateMipmaps = !1,
    r.stencilBuffer = !1,
    r
}
class Uge extends qd {
    constructor(e) {
        super(),
        this.resolution = e,
        this.fsQuad = new p2(this.material())
    }
    setResolution(e) {
        this.resolution = e
    }
    render(e, t, r) {
        const i = this.fsQuad.material.uniforms;
        i.tDiffuse.value = r.texture,
        this.renderToScreen ? e.setRenderTarget(null) : (e.setRenderTarget(t),
        this.clear && e.clear()),
        this.fsQuad.render(e)
    }
    material() {
        return new mr({
            uniforms: {
                tDiffuse: {
                    value: null
                },
                resolution: {
                    value: new Pt(this.resolution.x,this.resolution.y,1 / this.resolution.x,1 / this.resolution.y)
                }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
                `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec4 resolution;
                varying vec2 vUv;
                void main() {
                    vec2 iuv = (floor(resolution.xy * vUv) + .5) * resolution.zw;
                    vec4 texel = texture2D( tDiffuse, iuv );
                    texel.rgb = pow(texel.rgb, vec3(1.0 / 2.2));
                    gl_FragColor = texel;
                }
                `
        })
    }
}
const rm = new $;
class Fge {
    constructor(e) {
        Ne(this, "camera", null);
        Ne(this, "frameOffset", {
            min: .2,
            max: .2
        });
        Ne(this, "boneOffsets");
        Ne(this, "cameraDir", new $);
        Ne(this, "frameTarget", null);
        this.camera = e || new Fr,
        this.boneOffsets = {
            head: null,
            neck: null,
            chest: null,
            hips: null,
            spine: null,
            leftUpperLeg: null,
            leftLowerLeg: null,
            leftFoot: null,
            rightUpperLeg: null,
            rightLowerLeg: null,
            rightFoot: null
        }
    }
    setupCamera(e, t, r=30) {
        this.camera.position.copy(e),
        this.camera.lookAt(t),
        this.camera.fov = r
    }
    async calculateBoneOffsets(e, t) {
        for (const r in this.boneOffsets) {
            const i = await this._getMinMaxOffsetByBone(e, r, t);
            console.log("result", i),
            this.boneOffsets[r] = i
        }
    }
    setFrameTarget(e) {
        this.frameTarget = e
    }
    frameCloseupShot() {
        this.frameShot("head", "head")
    }
    frameMediumShot() {
        this.frameShot("chest", "head")
    }
    frameCowboyShot() {
        this.frameShot("hips", "head")
    }
    frameFullShot() {
        this.frameShot("leftFoot", "head")
    }
    frameShot(e, t, r=null, i=!1, s=!0) {
        if (!this.frameTarget) {
            console.error("No target object provided, Call setFrameTarget() first;");
            return
        }
        const o = this._getBoneWorldPositionWithOffset(this.frameTarget, e, i)
          , a = this._getBoneWorldPositionWithOffset(this.frameTarget, t, s);
        o.y -= this.frameOffset.max,
        a.y += this.frameOffset.min,
        r = r || new $(0,0,0),
        this.positionCameraBetweenPoints(o, a, r)
    }
    setBottomFrameOffset(e) {
        this.frameOffset.min = e
    }
    setTopFrameOffset(e) {
        this.frameOffset.max = e
    }
    _getBoneWorldPositionWithOffset(e, t, r) {
        const i = this._getFirstBoneWithName(t, e);
        if (!i || !this.boneOffsets[t])
            return console.error(`Bone with name '${t}' not found in the model.`),
            new $;
        const s = new $;
        i.getWorldPosition(s);
        const o = r ? this.boneOffsets[t].max : this.boneOffsets[t].min;
        return s.y += o.y,
        s
    }
    _getFirstBoneWithName(e, t=void 0) {
        let r = null;
        const i = t || this.frameTarget;
        if (!i) {
            console.error("_getFirstBoneWithName: No target object provided, Call setFrameTarget() first or provide a targetObject parameter;");
            return
        }
        return i.traverse(s => {
            if (s instanceof sa) {
                if (!s.geometry) {
                    console.error("Invalid skinned mesh found in children.");
                    return
                }
                const o = s.skeleton.bones.findIndex(a => a.name === e);
                if (o !== -1) {
                    r = s.skeleton.bones[o];
                    return
                }
            }
        }
        ),
        r
    }
    async _getMinMaxOffsetByBone(e, t, r) {
        return new Promise(async (i, s) => {
            (!e || !e.traverse) && (console.error("Invalid parent object provided."),
            s(null));
            const o = new $(1 / 0,1 / 0,1 / 0)
              , a = new $(-1 / 0,-1 / 0,-1 / 0)
              , l = [];
            e.traverse(async u => {
                u instanceof sa && (l.push(this._saveBonesPos(u.skeleton)),
                u.skeleton.pose())
            }
            );
            let c = 0;
            await (u => new Promise(f => setTimeout(f, u)))(10),
            e.traverse(u => {
                if (u instanceof sa) {
                    if (!u.geometry) {
                        console.error("Invalid skinned mesh found in children.");
                        return
                    }
                    const f = u.skeleton.bones.findIndex(g => g.name === t);
                    if (f === -1) {
                        console.error(`Bone with name '${t}' not found in one of the skinned meshes.`);
                        return
                    }
                    const h = u.geometry.getAttribute("position")
                      , d = u.geometry.getAttribute("skinWeight")
                      , m = u.geometry.getAttribute("skinIndex");
                    for (let g = 0; g < h.count; g++) {
                        const p = new $().fromBufferAttribute(h, g).applyMatrix4(u.matrixWorld);
                        if (m.getX(g) === f && d.getX(g) >= r) {
                            const _ = u.skeleton.bones[f]
                              , x = new $().setFromMatrixPosition(_.matrixWorld)
                              , b = p.clone().sub(x);
                            o.min(b),
                            a.max(b)
                        }
                    }
                    this._restoreSavedPose(l[c], u.skeleton),
                    c++
                }
            }
            ),
            i({
                min: o,
                max: a
            })
        }
        )
    }
    _saveBonesPos(e) {
        let t = [];
        return e.bones.forEach(r => {
            t.push({
                position: r.position.clone(),
                rotation: r.rotation.clone(),
                scale: r.scale.clone()
            })
        }
        ),
        t
    }
    _restoreSavedPose(e, t) {
        e && t.bones.forEach( (r, i) => {
            r.position.copy(e[i].position),
            r.rotation.copy(e[i].rotation),
            r.scale.copy(e[i].scale)
        }
        )
    }
    positionCameraBetweenPoints(e, t, r, i=30) {
        const s = new Hn;
        s.expandByPoint(e),
        s.expandByPoint(t),
        this.camera.fov = i;
        const o = this.camera.fov * (Math.PI / 180)
          , l = s.getSize(new $).length() / (2 * Math.tan(o / 2));
        s.getCenter(rm),
        this.camera.position.copy(rm),
        r.y *= .5,
        this.camera.lookAt(rm.clone().sub(r));
        const c = new $;
        this.camera.getWorldDirection(c),
        this.camera.position.addScaledVector(c, -l),
        this.camera.updateProjectionMatrix()
    }
    setCamera(e, t, r=30) {
        this.camera.position.copy(e),
        this.camera.fov = r,
        rm.set(0, 0, -1),
        this.cameraDir = rm.applyQuaternion(this.camera.quaternion),
        this.cameraDir.normalize(),
        this.camera.position.x -= this.cameraDir.x * t,
        this.camera.position.z -= this.cameraDir.z * t
    }
    setCameraFrameWithName(e, t) {
        switch (e.toLowerCase()) {
        case "fullshot":
            this.frameShot("leftFoot", "head", t);
            break;
        case "cowboyshot":
            this.frameShot("hips", "head", t);
            break;
        case "mediumshot":
            this.frameShot("chest", "head", t);
            break;
        case "mediumcloseup":
        case "mediumcloseupshot":
            this.frameShot("chest", "head", t, !0);
            break;
        case "closeup":
        case "closeupshot":
            this.frameShot("head", "head", t);
            break;
        default:
            console.warn("unkown cameraFrame: " + e + ". Please use fullShot, cowboyShot, mediumShot, mediumCloseup or closeup"),
            this.frameShot("leftFoot", "head", t);
            break
        }
    }
    copyCamera(e) {
        this.camera.position.copy(e.position),
        this.camera.quaternion.copy(e.quaternion),
        "fov"in e && (this.camera.fov = e.fov)
    }
}
const ix = 4096;
class Pge {
    constructor(e, t, r) {
        const i = new y0({
            preserveDrawingBuffer: !0,
            antialias: !1,
            alpha: !0
        });
        this.pixelSize = r,
        this.domElement = i.domElement;
        const s = new We(ix,ix);
        i.setClearColor(0, 0),
        i.outputColorSpace = Sr,
        i.setSize(s.x, s.y),
        i.setPixelRatio(window.devicePixelRatio);
        let o = s.clone().divideScalar(r);
        o.x |= 0,
        o.y |= 0;
        const a = new Tge(i);
        a.addPass(new Ige(e,t)),
        this._renderPixelPass = new Rge(o,e,t),
        this._pixelPass = new Uge(o),
        a.addPass(this._renderPixelPass),
        a.addPass(this._pixelPass),
        this.renderer = i,
        this.composer = a
    }
    setSize(e, t) {
        let i = new We(e,t).clone().divideScalar(this.pixelSize);
        i.x |= 0,
        i.y |= 0,
        this.renderer.setSize(e, t),
        this._renderPixelPass.setResolution(i),
        this._pixelPass.setResolution(i)
    }
    setPixelSize(e) {
        this.pixelSize = e
    }
    render() {
        this.composer.render()
    }
}
class Lge {
    constructor(e, t) {
        Ne(this, "cameraFrameManager");
        this.renderer = new y0({
            preserveDrawingBuffer: !0,
            antialias: !0,
            alpha: !0
        }),
        this.renderer.setClearAlpha(0),
        this.renderer.premultipliedAlpha = !1,
        this.scene = t,
        this.characterManager = e,
        this.renderer.outputColorSpace = Ut,
        this.renderer.setSize(ix, ix);
        const r = new Fr(30,1,.1,1e3);
        this.textureLoader = new PA,
        this.sceneBackground = new Qe(.1,.1,.1),
        this.sceneBackgroundAlpha = 1,
        this.usesBackgroundImage = !1,
        this.backgroundMaterial = new qi({
            color: 16777215,
            transparent: !0,
            opacity: .5
        });
        const i = new cc(1e3,1e3)
          , s = new dn(i,this.backgroundMaterial);
        s.renderOrder = -1,
        this.backgroundPlane = s,
        this.pixelRenderer = new Pge(t,r,20),
        this.cameraFrameManager = new Fge(r),
        this.cameraFrameManager.setFrameTarget(this.characterManager.characterModel)
    }
    setScene(e) {
        this.scene = e
    }
    get camera() {
        return this.cameraFrameManager.camera
    }
    setupCamera(e, t, r=30) {
        this.cameraFrameManager.setupCamera(e, t, r)
    }
    _getCharacterMinMax() {
        let e = Number.POSITIVE_INFINITY
          , t = Number.NEGATIVE_INFINITY;
        return this.characterManager.characterModel.traverse(r => {
            r.geometry && (r.geometry.computeBoundingBox(),
            r.geometry.boundingBox && (r.geometry.boundingBox.applyMatrix4(r.matrixWorld),
            r.geometry.boundingBox.min.y < e && (e = r.geometry.boundingBox.min.y),
            r.geometry.boundingBox.max.y > t && (t = r.geometry.boundingBox.max.y)))
        }
        ),
        {
            minY: e,
            maxY: t
        }
    }
    _getBoneWorldPosition(e, t=void 0) {
        const r = this.cameraFrameManager._getFirstBoneWithName(e, t);
        return r != null ? new $().setFromMatrixPosition(r.matrixWorld) : (console.warn(`Bone with name '${e}' not found in one of the skinned meshes.`),
        new $(0,0,0))
    }
    setBackground(e) {
        if (Array.isArray(e)) {
            const t = e[3] == null ? 1 : e[3];
            this.setBackgroundColor(e[0], e[1], e[2], t)
        } else
            this.setBackgroundImage(e)
    }
    setBackgroundColor(e, t, r, i) {
        const s = new Qe(e,t,r,i);
        this.sceneBackground = s,
        i == null && (i = 1),
        i > 1 && (i = 1),
        i < 0 && (i = 0),
        this.sceneBackgroundAlpha = i,
        this.backgroundMaterial.color = s,
        this.usesBackgroundImage = !1
    }
    setBackgroundImage(e) {
        return new Promise(async (t, r) => {
            try {
                const i = await this.texureLoader.load(e);
                i && (i.wrapS = i.wrapT = zs,
                this.sceneBackground = i,
                this.usesBackgroundImage = !0,
                this.sceneBackgroundAlpha = 1,
                t())
            } catch (i) {
                console.error("Error loading background image: ", i),
                r(i)
            }
        }
        )
    }
    _setBackground() {
        if (this.usesBackgroundImage == !1 && this.sceneBackgroundAlpha != 1)
            if (this.sceneBackgroundAlpha == 0)
                this.scene.background = null;
            else {
                this.scene.background = null,
                this.scene.add(this.backgroundPlane),
                this.backgroundPlane.position.copy(this.camera.position);
                var e = new $(0,0,-1);
                e.applyQuaternion(this.camera.quaternion);
                var t = 100;
                this.backgroundPlane.position.addScaledVector(e, t),
                this.backgroundPlane.lookAt(this.camera.position)
            }
        else
            this.scene.background = this.sceneBackground
    }
    _restoreBackground() {
        this.scene.background = null,
        this.usesBackgroundImage == !1 && this.sceneBackgroundAlpha != 1 && this.scene.remove(this.backgroundPlane)
    }
    getImageData(e, t, r=null) {
        return this._createImage(e, t, r).split("base64,")[1]
    }
    _createImage(e, t, r=null) {
        const i = e / t;
        typeof r == "number" && this.pixelRenderer.setPixelSize(r),
        this.renderer.setSize(e, t),
        this.pixelRenderer.setSize(e, t);
        const s = "image/png";
        this.camera.aspect = i,
        this.camera.updateProjectionMatrix();
        const o = typeof r == "number" ? this.pixelRenderer : this.renderer;
        try {
            this._setBackground(),
            o.render(this.scene, this.camera);
            let a = o.domElement.toDataURL(s);
            return this._restoreBackground(),
            a
        } catch (a) {
            return console.error(a),
            null
        }
    }
    savePixelScreenshot(e, t, r, i) {
        this.pixelRenderer.setPixelSize(i),
        this.pixelRenderer.setSize(t, r);
        const s = this._createImage(t, r, !0)
          , o = "image/octet-stream"
          , a = "image/png";
        this.saveFile(s.replace(a, o), e + ".png")
    }
    saveScreenshot(e, t, r) {
        const i = this._createImage(t, r)
          , s = "image/octet-stream"
          , o = "image/png";
        this.saveFile(i.replace(o, s), e + ".png")
    }
    getScreenshotImage(e, t) {
        const r = this._createImage(e, t)
          , i = new Image;
        return i.src = r,
        i
    }
    getScreenshotTexture(e, t) {
        const r = this.getScreenshotImage(e, t)
          , i = new Un(r);
        return i.needsUpdate = !0,
        i
    }
    getScreenshotBlob(e, t) {
        const r = this._createImage(e, t)
          , i = l8.Buffer.from(r.replace(/^data:image\/\w+;base64,/, ""), "base64");
        return new Blob([i],{
            type: "image/jpeg"
        })
    }
    saveFile(e, t) {
        const r = document.createElement("a");
        typeof r.download == "string" ? (document.body.appendChild(r),
        r.download = t,
        r.href = e,
        r.click(),
        document.body.removeChild(r)) : window.open(e, "_blank").document.write("<title>" + t + "</title><img src='" + e + "'/>")
    }
}
const Dge = 2;
class Nge {
    constructor(e=.5, t=.5, r=1, i=5) {
        this.vrmBlinkers = [],
        this.mode = "ready",
        this.clock = new w1,
        this.closeTime = e,
        this.openTime = t,
        this.continuity = r,
        this.randomness = i,
        this._eyeOpen = 1,
        this._blinkCounter = 0,
        this.isTakingScreenShot = !1,
        this.update()
    }
    addVRM(e) {
        this.vrmBlinkers.push(e)
    }
    removeVRM(e) {
        const t = this.vrmBlinkers.indexOf(e);
        t !== -1 && this.vrmBlinkers.splice(t, 1)
    }
    enableScreenshot() {
        this.isTakingScreenShot = !0,
        this._eyeOpen = Dge,
        this._updateBlinkers()
    }
    disableScreenshot() {
        this.isTakingScreenShot = !1
    }
    update() {
        setInterval( () => {
            if (this.isTakingScreenShot)
                return;
            const e = this.clock.getDelta();
            switch (this.mode) {
            case "closing":
                this._eyeOpen > 0 ? this._eyeOpen -= e / this.closeTime : (this._eyeOpen = 0,
                this.mode = "open"),
                this._updateBlinkers();
                break;
            case "open":
                this._eyeOpen < 1 ? this._eyeOpen += e / this.openTime : (this._eyeOpen = 1,
                this.mode = "ready"),
                this._updateBlinkers();
                break;
            case "ready":
                this._blinkCounter += e,
                this._blinkCounter >= this.continuity && (Math.floor(Math.random() * this.randomness) === 0 && (this.mode = "closing"),
                this._blinkCounter = 0);
                break
            }
        }
        , 1e3 / 30)
    }
    _updateBlinkers() {
        this.vrmBlinkers.forEach(e => {
            e.expressionManager.setValue(Wr.Blink, 1 - this._eyeOpen),
            e.expressionManager.update()
        }
        )
    }
}
class Oge {
    constructor() {
        Ne(this, "vrmEmotion");
        Ne(this, "mode");
        Ne(this, "clock");
        Ne(this, "continuous", !1);
        Ne(this, "emotionPlaying", null);
        Ne(this, "emotionValue", 0);
        Ne(this, "intensity", 1);
        Ne(this, "emotionTime", .1);
        Ne(this, "isTakingScreenShot", !1);
        Ne(this, "_nextEmotion", null);
        Ne(this, "_nextEmotionTime", 0);
        Ne(this, "_nextEmotionValue", 0);
        Ne(this, "_nextIntensity", 1);
        Ne(this, "_nextIsContinuous", !1);
        this.vrmEmotion = [],
        this.mode = "ready",
        this.clock = new w1,
        this.isTakingScreenShot = !1,
        this.update()
    }
    get availableEmotions() {
        var r;
        const e = Object.keys(Wr).map(i => i.toLowerCase())
          , t = [];
        for (const i of this.vrmEmotion)
            for (const s of e) {
                if (s === "blink" || t.includes(s))
                    continue;
                const o = (r = i.expressionManager) == null ? void 0 : r.getExpression(s);
                o && o._binds.length > 0 && t.push(s)
            }
        return t
    }
    addVRM(e) {
        e.expressionManager && this.vrmEmotion.push(e)
    }
    hasEmotion(e) {
        return this.availableEmotions.some(t => t === e)
    }
    removeVRM(e) {
        const t = this.vrmEmotion.indexOf(e);
        t !== -1 && this.vrmEmotion.splice(t, 1)
    }
    enableScreenshot() {
        this.isTakingScreenShot = !0,
        this.emotionPlaying = null,
        this._updateEmotions()
    }
    disableScreenshot() {
        this.isTakingScreenShot = !1
    }
    _isBlink(e) {
        return e === "blink"
    }
    playEmotion(e, t=void 0, r=!1, i=1) {
        if (!this.hasEmotion(e)) {
            console.warn(`Emotion ${e} not available`);
            return
        }
        if (this._isBlink(e)) {
            console.warn("Blink is handled by the BlinkManager, ignoring");
            return
        }
        if (e === this.emotionPlaying && i === this.intensity)
            return;
        const s = Math.min(1, Math.max(0, i));
        if (this.mode === "animating" && this.emotionPlaying) {
            this.continuous = !1,
            this._nextEmotion = e,
            this._nextEmotionTime = t || this.emotionTime,
            this._nextEmotionValue = 0,
            this._nextIntensity = s,
            this._nextIsContinuous = r || !1,
            this.mode = "transition";
            return
        }
        this.emotionPlaying = e,
        this.intensity = s,
        t && (this.emotionTime = t),
        this.continuous = r || !1,
        this.mode = "animating"
    }
    _setIsReady() {
        this.emotionValue = 0,
        this.intensity = 1,
        this.emotionPlaying = null,
        this.continuous = !1,
        this.mode = "ready"
    }
    _removeNextEmotion() {
        this._nextEmotion = null,
        this._nextIntensity = 1,
        this._nextEmotionValue = 0,
        this._nextEmotionTime = 0,
        this._nextIsContinuous = !1
    }
    update() {
        setInterval( () => {
            if (this.isTakingScreenShot)
                return;
            const e = this.clock.getDelta();
            switch (this.mode) {
            case "animating":
                this.emotionPlaying ? (this.emotionValue < this.intensity && (this.emotionValue += e / this.emotionTime,
                this.emotionValue = Math.min(1, this.emotionValue)),
                !this.continuous && this.emotionValue >= this.intensity && (this.mode = "stopping")) : this._setIsReady(),
                this._updateEmotions();
                break;
            case "stopping":
                this.emotionPlaying ? (this.emotionValue > 0 && (this.emotionValue -= e / this.emotionTime,
                this.emotionValue = Math.max(0, this.emotionValue)),
                this.emotionValue <= 0 && this._setIsReady()) : this._setIsReady(),
                this._updateEmotions();
                break;
            case "transition":
                this._nextEmotion ? (this._nextEmotionValue < this._nextIntensity && (this._nextEmotionValue += e / this._nextEmotionTime,
                this.emotionValue = Math.min(this.intensity, this.emotionValue)),
                this.emotionValue > 0 ? this.emotionValue -= e / this._nextEmotionTime : (this.emotionValue = this._nextEmotionValue,
                this.emotionTime = this._nextEmotionTime,
                this.emotionPlaying = this._nextEmotion,
                this.intensity = this._nextIntensity,
                this.continuous = this._nextIsContinuous,
                this.mode = "animating",
                this._removeNextEmotion())) : this.emotionPlaying && (this.mode = "animating"),
                this._updateEmotions()
            }
        }
        , 1e3 / 30)
    }
    _updateEmotions() {
        this.emotionPlaying && this.vrmEmotion.forEach(e => {
            var t, r, i;
            this._nextEmotion && ((t = e.expressionManager) == null || t.setValue(this._nextEmotion, this._nextEmotionValue)),
            (r = e.expressionManager) == null || r.setValue(this.emotionPlaying, this.emotionValue),
            (i = e.expressionManager) == null || i.update()
        }
        )
    }
}
function ZG() {
    return (ZG = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ).apply(this, arguments)
}
function kge() {
    return ZG.apply(this, arguments)
}
function Qge(n, e) {
    return e != null && typeof Symbol < "u" && e[Symbol.hasInstance] ? !!e[Symbol.hasInstance](n) : n instanceof e
}
(function(n) {
    n[n.cBASISTexType2D = 0] = "cBASISTexType2D",
    n[n.cBASISTexType2DArray = 1] = "cBASISTexType2DArray",
    n[n.cBASISTexTypeCubemapArray = 2] = "cBASISTexTypeCubemapArray",
    n[n.cBASISTexTypeVideoFrames = 3] = "cBASISTexTypeVideoFrames",
    n[n.cBASISTexTypeVolume = 4] = "cBASISTexTypeVolume"
}
)(xT || (xT = {})),
function(n) {
    n[n.RAW = 0] = "RAW",
    n[n.PNG = 1] = "PNG",
    n[n.JPG = 2] = "JPG"
}(bT || (bT = {}));
class Hge {
    constructor() {
        this.vkFormat = 0,
        this.typeSize = 1,
        this.pixelWidth = 0,
        this.pixelHeight = 0,
        this.pixelDepth = 0,
        this.layerCount = 0,
        this.faceCount = 1,
        this.supercompressionScheme = 0,
        this.levels = [],
        this.dataFormatDescriptor = [{
            vendorId: 0,
            descriptorType: 0,
            descriptorBlockSize: 0,
            versionNumber: 2,
            colorModel: 0,
            colorPrimaries: 1,
            transferFunction: 2,
            flags: 0,
            texelBlockDimension: [0, 0, 0, 0],
            bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
            samples: []
        }],
        this.keyValue = {},
        this.globalData = null
    }
}
class im {
    constructor(e, t, r, i) {
        this._dataView = void 0,
        this._littleEndian = void 0,
        this._offset = void 0,
        this._dataView = new DataView(e.buffer,e.byteOffset + t,r),
        this._littleEndian = i,
        this._offset = 0
    }
    _nextUint8() {
        let e = this._dataView.getUint8(this._offset);
        return this._offset += 1,
        e
    }
    _nextUint16() {
        let e = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2,
        e
    }
    _nextUint32() {
        let e = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4,
        e
    }
    _nextUint64() {
        let e = this._dataView.getUint32(this._offset, this._littleEndian)
          , t = this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8,
        e + 4294967296 * t
    }
    _nextInt32() {
        let e = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4,
        e
    }
    _nextUint8Array(e) {
        let t = new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + this._offset,e);
        return this._offset += e,
        t
    }
    _skip(e) {
        return this._offset += e,
        this
    }
    _scan(e, t=0) {
        let r = this._offset
          , i = 0;
        for (; this._dataView.getUint8(this._offset) !== t && i < e; )
            i++,
            this._offset++;
        return i < e && this._offset++,
        new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + r,i)
    }
}
let QO = new Uint8Array([0])
  , ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function HO(n) {
    return typeof TextEncoder < "u" ? new TextEncoder().encode(n) : Buffer.from(n)
}
function zO(n) {
    return typeof TextDecoder < "u" ? new TextDecoder().decode(n) : Buffer.from(n).toString("utf8")
}
function sm(n) {
    let e = 0;
    for (let i of n)
        e += i.byteLength;
    let t = new Uint8Array(e)
      , r = 0;
    for (let i of n)
        t.set(new Uint8Array(i), r),
        r += i.byteLength;
    return t
}
function zge(n) {
    let e = new Uint8Array(n.buffer,n.byteOffset,ti.length);
    if (e[0] !== ti[0] || e[1] !== ti[1] || e[2] !== ti[2] || e[3] !== ti[3] || e[4] !== ti[4] || e[5] !== ti[5] || e[6] !== ti[6] || e[7] !== ti[7] || e[8] !== ti[8] || e[9] !== ti[9] || e[10] !== ti[10] || e[11] !== ti[11])
        throw Error("Missing KTX 2.0 identifier.");
    let t = new Hge
      , r = 17 * Uint32Array.BYTES_PER_ELEMENT
      , i = new im(n,ti.length,r,!0);
    t.vkFormat = i._nextUint32(),
    t.typeSize = i._nextUint32(),
    t.pixelWidth = i._nextUint32(),
    t.pixelHeight = i._nextUint32(),
    t.pixelDepth = i._nextUint32(),
    t.layerCount = i._nextUint32(),
    t.faceCount = i._nextUint32();
    let s = i._nextUint32();
    t.supercompressionScheme = i._nextUint32();
    let o = i._nextUint32()
      , a = i._nextUint32()
      , l = i._nextUint32()
      , c = i._nextUint32()
      , A = i._nextUint64()
      , u = i._nextUint64()
      , f = new im(n,ti.length + r,24 * s,!0);
    for (let R = 0; R < s; R++)
        t.levels.push({
            levelData: new Uint8Array(n.buffer,n.byteOffset + f._nextUint64(),f._nextUint64()),
            uncompressedByteLength: f._nextUint64()
        });
    let h = new im(n,o,a,!0)
      , d = {
        vendorId: h._skip(4)._nextUint16(),
        descriptorType: h._nextUint16(),
        versionNumber: h._nextUint16(),
        descriptorBlockSize: h._nextUint16(),
        colorModel: h._nextUint8(),
        colorPrimaries: h._nextUint8(),
        transferFunction: h._nextUint8(),
        flags: h._nextUint8(),
        texelBlockDimension: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
        bytesPlane: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
        samples: []
    }
      , m = (d.descriptorBlockSize / 4 - 6) / 4;
    for (let R = 0; R < m; R++) {
        let F = {
            bitOffset: h._nextUint16(),
            bitLength: h._nextUint8(),
            channelType: h._nextUint8(),
            samplePosition: [h._nextUint8(), h._nextUint8(), h._nextUint8(), h._nextUint8()],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
        };
        64 & F.channelType ? (F.sampleLower = h._nextInt32(),
        F.sampleUpper = h._nextInt32()) : (F.sampleLower = h._nextUint32(),
        F.sampleUpper = h._nextUint32()),
        d.samples[R] = F
    }
    t.dataFormatDescriptor.length = 0,
    t.dataFormatDescriptor.push(d);
    let g = new im(n,l,c,!0);
    for (; g._offset < c; ) {
        let R = g._nextUint32()
          , F = g._scan(R)
          , O = zO(F);
        if (t.keyValue[O] = g._nextUint8Array(R - F.byteLength - 1),
        O.match(/^ktx/i)) {
            let j = zO(t.keyValue[O]);
            t.keyValue[O] = j.substring(0, j.lastIndexOf("\0"))
        }
        let z = R % 4 ? 4 - R % 4 : 0;
        g._skip(z)
    }
    if (u <= 0)
        return t;
    let p = new im(n,A,u,!0)
      , v = p._nextUint16()
      , w = p._nextUint16()
      , _ = p._nextUint32()
      , x = p._nextUint32()
      , b = p._nextUint32()
      , B = p._nextUint32()
      , S = [];
    for (let R = 0; R < s; R++)
        S.push({
            imageFlags: p._nextUint32(),
            rgbSliceByteOffset: p._nextUint32(),
            rgbSliceByteLength: p._nextUint32(),
            alphaSliceByteOffset: p._nextUint32(),
            alphaSliceByteLength: p._nextUint32()
        });
    let I = A + p._offset
      , M = I + _
      , L = M + x
      , D = new Uint8Array(n.buffer,n.byteOffset + I,_)
      , T = new Uint8Array(n.buffer,n.byteOffset + M,x)
      , y = new Uint8Array(n.buffer,n.byteOffset + L,b)
      , E = new Uint8Array(n.buffer,n.byteOffset + (L + b),B);
    return t.globalData = {
        endpointCount: v,
        selectorCount: w,
        imageDescs: S,
        endpointsData: D,
        selectorsData: T,
        tablesData: y,
        extendedData: E
    },
    t
}
function _T() {
    return (_T = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ).apply(this, arguments)
}
let Gge = {
    keepWriter: !1
};
function Vge(n, e={}) {
    e = _T({}, Gge, e);
    let t = new ArrayBuffer(0);
    if (n.globalData) {
        let v = new ArrayBuffer(20 + 20 * n.globalData.imageDescs.length)
          , w = new DataView(v);
        w.setUint16(0, n.globalData.endpointCount, !0),
        w.setUint16(2, n.globalData.selectorCount, !0),
        w.setUint32(4, n.globalData.endpointsData.byteLength, !0),
        w.setUint32(8, n.globalData.selectorsData.byteLength, !0),
        w.setUint32(12, n.globalData.tablesData.byteLength, !0),
        w.setUint32(16, n.globalData.extendedData.byteLength, !0);
        for (let _ = 0; _ < n.globalData.imageDescs.length; _++) {
            let x = n.globalData.imageDescs[_];
            w.setUint32(20 + 20 * _ + 0, x.imageFlags, !0),
            w.setUint32(20 + 20 * _ + 4, x.rgbSliceByteOffset, !0),
            w.setUint32(20 + 20 * _ + 8, x.rgbSliceByteLength, !0),
            w.setUint32(20 + 20 * _ + 12, x.alphaSliceByteOffset, !0),
            w.setUint32(20 + 20 * _ + 16, x.alphaSliceByteLength, !0)
        }
        t = sm([v, n.globalData.endpointsData, n.globalData.selectorsData, n.globalData.tablesData, n.globalData.extendedData])
    }
    let r = []
      , i = n.keyValue;
    for (let v in e.keepWriter || (i = _T({}, n.keyValue, {
        KTXwriter: "KTX-Parse v0.6.0"
    })),
    i) {
        let w = i[v]
          , _ = HO(v)
          , x = typeof w == "string" ? sm([HO(w), QO]) : w
          , b = _.byteLength + 1 + x.byteLength
          , B = b % 4 ? 4 - b % 4 : 0;
        r.push(sm([new Uint32Array([b]), _, QO, x, new Uint8Array(B).fill(0)]))
    }
    let s = sm(r);
    if (n.dataFormatDescriptor.length !== 1 || n.dataFormatDescriptor[0].descriptorType !== 0)
        throw Error("Only BASICFORMAT Data Format Descriptor output supported.");
    let o = n.dataFormatDescriptor[0]
      , a = new ArrayBuffer(28 + 16 * o.samples.length)
      , l = new DataView(a)
      , c = 24 + 16 * o.samples.length;
    if (l.setUint32(0, a.byteLength, !0),
    l.setUint16(4, o.vendorId, !0),
    l.setUint16(6, o.descriptorType, !0),
    l.setUint16(8, o.versionNumber, !0),
    l.setUint16(10, c, !0),
    l.setUint8(12, o.colorModel),
    l.setUint8(13, o.colorPrimaries),
    l.setUint8(14, o.transferFunction),
    l.setUint8(15, o.flags),
    !Array.isArray(o.texelBlockDimension))
        throw Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
    l.setUint8(16, o.texelBlockDimension[0]),
    l.setUint8(17, o.texelBlockDimension[1]),
    l.setUint8(18, o.texelBlockDimension[2]),
    l.setUint8(19, o.texelBlockDimension[3]);
    for (let v = 0; v < 8; v++)
        l.setUint8(20 + v, o.bytesPlane[v]);
    for (let v = 0; v < o.samples.length; v++) {
        let w = o.samples[v]
          , _ = 28 + 16 * v;
        if (w.channelID)
            throw Error("channelID has been renamed to channelType.");
        l.setUint16(_ + 0, w.bitOffset, !0),
        l.setUint8(_ + 2, w.bitLength),
        l.setUint8(_ + 3, w.channelType),
        l.setUint8(_ + 4, w.samplePosition[0]),
        l.setUint8(_ + 5, w.samplePosition[1]),
        l.setUint8(_ + 6, w.samplePosition[2]),
        l.setUint8(_ + 7, w.samplePosition[3]),
        64 & w.channelType ? (l.setInt32(_ + 8, w.sampleLower, !0),
        l.setInt32(_ + 12, w.sampleUpper, !0)) : (l.setUint32(_ + 8, w.sampleLower, !0),
        l.setUint32(_ + 12, w.sampleUpper, !0))
    }
    let A = ti.length + 68 + 24 * n.levels.length
      , u = A + a.byteLength
      , f = t.byteLength > 0 ? u + s.byteLength : 0;
    f % 8 && (f += 8 - f % 8);
    let h = []
      , d = new DataView(new ArrayBuffer(24 * n.levels.length))
      , m = (f || u + s.byteLength) + t.byteLength;
    for (let v = 0; v < n.levels.length; v++) {
        let w = n.levels[v];
        h.push(w.levelData),
        d.setBigUint64(24 * v + 0, BigInt(m), !0),
        d.setBigUint64(24 * v + 8, BigInt(w.levelData.byteLength), !0),
        d.setBigUint64(24 * v + 16, BigInt(w.uncompressedByteLength), !0),
        m += w.levelData.byteLength
    }
    let g = new ArrayBuffer(68)
      , p = new DataView(g);
    return p.setUint32(0, n.vkFormat, !0),
    p.setUint32(4, n.typeSize, !0),
    p.setUint32(8, n.pixelWidth, !0),
    p.setUint32(12, n.pixelHeight, !0),
    p.setUint32(16, n.pixelDepth, !0),
    p.setUint32(20, n.layerCount, !0),
    p.setUint32(24, n.faceCount, !0),
    p.setUint32(28, n.levels.length, !0),
    p.setUint32(32, n.supercompressionScheme, !0),
    p.setUint32(36, A, !0),
    p.setUint32(40, a.byteLength, !0),
    p.setUint32(44, u, !0),
    p.setUint32(48, s.byteLength, !0),
    p.setBigUint64(52, BigInt(t.byteLength > 0 ? f : 0), !0),
    p.setBigUint64(60, BigInt(t.byteLength), !0),
    new Uint8Array(sm([new Uint8Array(ti).buffer, g, d.buffer, a, s, new ArrayBuffer(f > 0 ? f - (u + s.byteLength) : 0), t, ...h]))
}
var xT, bT, jge = {
    enableDebug: !1,
    isUASTC: !0,
    isKTX2File: !0,
    isInputSRGB: !0,
    generateMipmap: !0,
    needSupercompression: !0,
    isSetKTX2SRGBTransferFunc: !0
}, ET = new OffscreenCanvas(128,128), GO = ET.getContext("2d", {
    willReadFrequently: !0
}), JG = typeof document > "u";
function Wge(n) {
    return createImageBitmap(n).then(function(e) {
        return ET.width = e.width,
        ET.height = e.height,
        GO.drawImage(e, 0, 0),
        GO.getImageData(0, 0, e.width, e.height)
    })
}
function Kge(n, e) {
    return e === void 0 && (e = {}),
    Yge().then(function(t) {
        var r = new t.BasisEncoder;
        return Xge(e, r),
        r.setTexType(xT.cBASISTexType2D),
        Qge(n, ArrayBuffer) && (n = new Blob([n])),
        Wge(n).then(function(i) {
            r.setSliceSourceImage(0, new Uint8Array(i.data), i.width, i.height, bT.RAW);
            var s = new Uint8Array(10485760)
              , o = r.encode(s);
            if (o === 0)
                throw "encode failed";
            var a = new Uint8Array(s.buffer,0,o)
              , l = zge(s);
            if (e.kvData) {
                for (var c in e.kvData)
                    l.keyValue[c] = e.kvData[c];
                a = Vge(l, {
                    keepWriter: !0
                })
            }
            return a
        })
    })
}
function Xge(n, e) {
    n === void 0 && (n = {}),
    (n = kge({}, jge, n)).enableDebug !== void 0 && e.setDebug(n.enableDebug),
    n.isUASTC !== void 0 && e.setUASTC(n.isUASTC),
    n.isKTX2File !== void 0 && e.setCreateKTX2File(n.isKTX2File),
    n.isSetKTX2SRGBTransferFunc !== void 0 && e.setKTX2SRGBTransferFunc(n.isSetKTX2SRGBTransferFunc),
    n.generateMipmap !== void 0 && e.setMipGen(n.generateMipmap),
    n.isYFlip !== void 0 && e.setYFlip(n.isYFlip),
    n.qualityLevel !== void 0 && e.setQualityLevel(n.qualityLevel),
    n.compressionLevel !== void 0 && e.setCompressionLevel(n.compressionLevel),
    n.needSupercompression !== void 0 && e.setKTX2UASTCSupercompression(n.needSupercompression),
    n.isNormalMap !== void 0 && e.setNormalMap(n.isNormalMap)
}
var tM = null;
function Yge() {
    return tM || (tM = new Promise(function(n, e) {
        JG ? (importScripts("https://mdn.alipayobjects.com/rms/afts/file/A*SrRkQarYYl4AAAAAAAAAAAAAARQnAQ/basis_encoder.js"),
        fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qFWbTrA0hZYAAAAAAAAAAAAAARQnAQ/basis_encoder.wasm").then(function(t) {
            return t.arrayBuffer()
        }).then(function(t) {
            BASIS({
                wasmBinary: t
            }).then(function(r) {
                r.initializeBasis(),
                n(r)
            }).catch(e)
        }).catch(e)) : Promise.all([fetch("https://mdn.alipayobjects.com/rms/afts/file/A*SrRkQarYYl4AAAAAAAAAAAAAARQnAQ/basis_encoder.js").then(function(t) {
            return t.text()
        }), fetch("https://mdn.alipayobjects.com/rms/afts/file/A*qFWbTrA0hZYAAAAAAAAAAAAAARQnAQ/basis_encoder.wasm").then(function(t) {
            return t.arrayBuffer()
        })]).then(function(t) {
            var r = t[0]
              , i = t[1]
              , s = document.createElement("script");
            s.onload = function() {
                BASIS({
                    wasmBinary: i
                }).then(function(o) {
                    o.initializeBasis(),
                    n(o)
                }).catch(e)
            }
            ,
            s.src = URL.createObjectURL(new Blob([r])),
            s.onerror = e,
            document.body.appendChild(s)
        }).catch(e)
    }
    )),
    tM
}
JG && self.addEventListener("message", function(n) {
    Kge(n.data).then(function(e) {
        self.postMessage(e)
    }).catch(function(e) {
        self.postMessage({
            error: e
        })
    })
});
class $ge {
    constructor(e, t) {
        if (this.gl = e,
        this.libktx = null,
        e !== void 0)
            if (t === void 0 && LIBKTX !== void 0 && (t = LIBKTX),
            t !== void 0)
                this.initializied = this.init(e, t);
            else {
                console.error("Failed to initalize KTXDecoder: ktx library undefined");
                return
            }
        else {
            console.error("Failed to initalize KTXDecoder: WebGL context undefined");
            return
        }
    }
    async init(e, t) {
        this.libktx = await t({
            preinitializedWebGLContext: e
        }),
        this.libktx.GL.makeContextCurrent(this.libktx.GL.createContext(e.canvas, {
            majorVersion: 2
        }))
    }
    stringToUastcFlags(e) {
        return e === "FASTER" ? this.libktx.UastcFlags.LEVEL_FASTER.value : e === "FASTEST" ? this.libktx.UastcFlags.LEVEL_FASTEST.value : e === "SLOWER" ? this.libktx.UastcFlags.LEVEL_SLOWER.value : e === "SLOWEST" ? this.libktx.UastcFlags.LEVEL_VERYSLOW.value : this.libktx.UastcFlags.LEVEL_DEFAULT.value
    }
    stringToSupercmpScheme(e) {
        return e === "Zstd" ? this.libktx.SupercmpScheme.ZSTD : e === "Zlib" ? this.libktx.SupercmpScheme.ZLIB : e === "BasisLZ" ? this.libktx.SupercmpScheme.BASIS_LZ : this.libktx.SupercmpScheme.NONE
    }
    transcodeRGBA(e) {
        if (!e.needsTranscoding)
            return;
        const t = this.libktx.TranscodeTarget.RGBA8888;
        e.transcodeBasis(t, 0) != this.libktx.ErrorCode.SUCCESS && console.warn("Texture transcode failed. See console for details.")
    }
    transcode(e) {
        if (e.gpuFormat = "RGBA8888",
        e.needsTranscoding) {
            let t, r = !1, i = !1, s = !1, o = !1, a = !1;
            r = !!this.gl.getExtension("WEBGL_compressed_texture_astc"),
            i = !!this.gl.getExtension("WEBGL_compressed_texture_etc1"),
            s = !!this.gl.getExtension("WEBGL_compressed_texture_s3tc"),
            o = !!this.gl.getExtension("EXT_texture_compression_bptc"),
            a = !!this.gl.getExtension("WEBGL_compressed_texture_pvrtc") || !!this.gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            r ? (t = this.libktx.TranscodeTarget.ASTC_4x4_RGBA,
            e.gpuFormat = "ASTC_4x4_RGBA") : o ? (t = this.libktx.TranscodeTarget.BC7_RGBA,
            e.gpuFormat = "BC7_RGBA") : s ? (t = this.libktx.TranscodeTarget.BC1_OR_3,
            e.gpuFormat = "BC1_OR_3") : a ? (t = this.libktx.TranscodeTarget.PVRTC1_4_RGBA,
            e.gpuFormat = "PVRTC1_4_RGBA") : i ? (t = this.libktx.TranscodeTarget.ETC,
            e.gpuFormat = "ETC") : (t = this.libktx.TranscodeTarget.RGBA8888,
            e.gpuFormat = "RGBA8888"),
            e.transcodeBasis(t, 0) != this.libktx.ErrorCode.SUCCESS && console.warn("Texture transcode failed. See console for details.")
        }
    }
    async loadKtxFromUri(e) {
        await this.initializied;
        const t = await fetch(e)
          , r = new Uint8Array(await t.arrayBuffer())
          , i = new this.libktx.ktxTexture(r);
        this.transcode(i);
        let s = i.glUpload();
        if (s.texture == null) {
            console.error("Could not load KTX data");
            return
        }
        return s.texture.levels = Math.log2(i.baseWidth),
        s.texture.width = i.baseWidth,
        s.texture.height = i.baseHeight,
        s.texture.gpuSize = i.dataSize,
        s.texture.gpuFormat = i.gpuFormat,
        s.texture.isSRGB = i.isSRGB,
        s.texture
    }
    async loadKtxFromBuffer(e) {
        await this.initializied;
        const t = new this.libktx.ktxTexture(e);
        this.transcode(t);
        const r = t.glUpload();
        if (r.texture == null) {
            console.error("Could not load KTX data");
            return
        }
        return r.texture.levels = Math.log2(t.baseWidth),
        r.texture.width = t.baseWidth,
        r.texture.height = t.baseHeight,
        r.texture.gpuSize = t.dataSize,
        r.texture.gpuFormat = t.gpuFormat,
        r.texture.isSRGB = t.isSRGB,
        r.texture
    }
    async compress(e, t, r, i, s={}) {
        const o = new this.libktx.ktxTexture(e,t,r,i,s.srgb);
        if (!s.hasOwnProperty("basisu_options")) {
            const c = new this.libktx.ktxBasisParams;
            c.uastc = !1,
            c.noSSE = !0,
            c.verbose = !1,
            c.qualityLevel = 100,
            c.compressionLevel = 2,
            s.basisu_options = c
        }
        s.hasOwnProperty("compression_level") || (s.compression_level = 18),
        s.hasOwnProperty("supercmp_scheme") || (s.supercmp_scheme = this.libktx.SupercmpScheme.NONE),
        console.log(s);
        const a = o.compressBasisU(s.basisu_options, s.supercmp_scheme, s.compression_level);
        return Uint8ClampedArray.from(a)
    }
}
class Zge {
    constructor() {
        this.ktxEncoder = null,
        this.libktx = null,
        this.init()
    }
    async init() {
        const t = document.createElement("canvas").getContext("webgl")
          , r = new $ge(t,window.LIBKTX);
        await r.init(t, window.LIBKTX),
        this.ktxEncoder = r,
        this.libktx = r.libktx
    }
    async compress(e, t, r, i, s={}) {
        const o = await new this.libktx.ktxBasisParams
          , a = s;
        return o.uastc = a.uastc !== void 0 ? a.uastc : !1,
        o.noSSE = a.noSSE !== void 0 ? a.noSSE : !1,
        o.verbose = a.verbose !== void 0 ? a.verbose : !1,
        o.normalMap = a.normalMap !== void 0 ? a.normalMap : !1,
        o.compressionLevel = a.compressionLevel !== void 0 ? a.compressionLevel : 1,
        o.qualityLevel = a.qualityLevel !== void 0 ? a.qualityLevel : 60,
        o.maxEndpoints = a.ETC1SmaxEndpoints !== void 0 ? a.ETC1SmaxEndpoints : 0,
        o.endpointRDOThreshold = a.ETC1SEndpointRdoThreshold !== void 0 ? a.ETC1SEndpointRdoThreshold : 1.25,
        o.maxSelectors = a.ETC1SMaxSelectors !== void 0 ? a.ETC1SMaxSelectors : 0,
        o.selectorRDOThreshold = a.ETC1SSelectorRdoThreshold !== void 0 ? a.ETC1SSelectorRdoThreshold : 1.25,
        o.noEndpointRDO = a.ETC1SNoEndpointRdo !== void 0 ? a.ETC1SNoEndpointRdo : !1,
        o.noSelectorRDO = a.ETC1SNoSelectorRdo !== void 0 ? a.ETC1SNoSelectorRdo : !1,
        o.uastcFlags = this.ktxEncoder.stringToUastcFlags(a.uastcFlags),
        o.uastcRDO = o.uastcRDO !== void 0 ? o.uastcRDO : !1,
        o.uastcRDOQualityScalar = a.uastcRDOQualityScalar !== void 0 ? a.uastcRDOQualityScalar : 1,
        o.uastcRDODictSize = a.uastcRDODictSize !== void 0 ? a.uastcRDOQualityScalar : 4096,
        o.uastcRDOMaxSmoothBlockErrorScale = a.uastcRDOMaxSmoothBlockErrorScale !== void 0 ? a.uastcRDOMaxSmoothBlockErrorScale : 10,
        o.uastcRDOMaxSmoothBlockStdDev = a.uastcRDOMaxSmoothBlockStdDev !== void 0 ? a.uastcRDOMaxSmoothBlockStdDev : 18,
        o.uastcRDODontFavorSimplerModes = a.uastcRDODontFavorSimplerModes !== void 0 ? a.uastcRDODontFavorSimplerModes : !1,
        s.basisu_options = o,
        s.hasOwnProperty("supercmp_scheme") ? s.supercmp_scheme = this.ktxEncoder.stringToSupercmpScheme(s.supercmp_scheme) : s.supercmp_scheme = this.libktx.SupercmpScheme.NONE,
        await this.ktxEncoder.compress(e, t, r, i, s)
    }
}
var qn;
(function(n) {
    n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
    n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
    n[n.BYTE = 5120] = "BYTE",
    n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
    n[n.SHORT = 5122] = "SHORT",
    n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
    n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
    n[n.FLOAT = 5126] = "FLOAT",
    n[n.LINEAR = 9729] = "LINEAR",
    n[n.REPEAT = 10497] = "REPEAT"
}
)(qn || (qn = {}));
const BT = "blend_"
  , VO = "vrmColliderSphere";
function Jge(n) {
    var e;
    return {
        title: n.name,
        version: "v0",
        author: ((e = n.authors) == null ? void 0 : e.length) > 0 ? n.authors.join(", ") : "",
        reference: n.references != null ? n.references.join(", ") : "",
        contactInformation: n.contactInformation != null ? n.contactInformation : "",
        otherPermissionUrl: n.otherPermissionUrl,
        allowedUserName: n.avatarPermission != null ? n.avatarPermission : "",
        violentUssageName: n.allowExcessivelyViolentUsage ? "Allow" : "Disallow",
        sexualUssageName: n.allowExcessivelySexualUsage ? "Allow" : "Disallow",
        commercialUssageName: n.commercialUsage == "personalProfit" || n.commercialUsage == "corporation" ? "Allow" : "Disallow",
        licenseName: n.copyrightInformation,
        otherLicenseUrl: n.otherLicenseUrl,
        metaVersion: "0"
    }
}
function qge(n) {
    const e = [];
    for (const t in n.humanBones)
        e.push({
            bone: t,
            node: n.humanBones[t].node
        });
    return {
        humanBones: e
    }
}
function e0e(n) {
    switch (n) {
    case "happy":
        return "joy";
    case "sad":
        return "sorrow";
    case "relaxed":
        return "fun";
    case "aa":
        return "a";
    case "ih":
        return "i";
    case "ou":
        return "u";
    case "ee":
        return "e";
    case "oh":
        return "o";
    default:
        return n
    }
}
function t0e(n) {
    if (n.includes("Thumb")) {
        if (n.includes("Metacarpal"))
            return n.replace("Metacarpal", "Proximal");
        if (n.includes("Proximal"))
            return n.replace("Proximal", "Intermediate")
    }
    return n
}
class n0e {
    async parse(e, t, r, i, s, o, a) {
        var ne;
        const l = Jge(e.meta)
          , c = qge(e.humanoid)
          , A = e.materials
          , u = []
          , f = {
            generator: "UniGLTF-2.0.0",
            version: "2.0"
        };
        if (t)
            if (c)
                if (l) {
                    if (!A)
                        throw new Error("materials is undefined or null")
                } else
                    throw new Error("meta is undefined or null");
            else
                throw new Error("humanoid is undefined or null");
        else
            throw new Error("avatar is undefined or null");
        const h = A.filter( (Y, de, ae) => ae.findIndex(Ee => Ee.name === Y.name.replace(" (Outline)", "")) === de).map(Y => Y)
          , d = h.map(Y => Y.name)
          , m = r ? {
            name: "icon",
            imageBitmap: r.image
        } : null
          , g = h.filter(Y => Y.map).map(Y => {
            if (!Y.map)
                throw new Error(Y.name + " map is null");
            return {
                name: Y.name,
                imageBitmap: Y.map.image
            }
        }
        )
          , p = h.filter(Y => Y.userData.shadeTexture).map(Y => {
            if (!Y.userData.shadeTexture)
                throw new Error(Y.userData.shadeTexture + " map is null");
            return {
                name: Y.name + "_shade",
                imageBitmap: Y.userData.shadeTexture.image
            }
        }
        )
          , v = h.filter(Y => Y.roughnessMap).map(Y => Y.roughnessMap ? {
            name: Y.name + "_orm",
            imageBitmap: Y.roughnessMap.image
        } : null)
          , w = h.filter(Y => Y.roughnessMap).map(Y => Y.normalMap ? {
            name: Y.name + "_normal",
            imageBitmap: Y.normalMap.image
        } : null)
          , _ = [...g, ...p, ...v, ...w].filter(Y => Y !== null)
          , x = l0e(_, m, s ? "image/ktx2" : "image/png")
          , b = c0e(x)
          , B = A0e(x, s)
          , S = a0e(h, _)
          , I = t.children.filter(Y => Y.children.length > 0 && Y.children[0].type === Di.Bone)[0]
          , M = qG(I).filter(Y => Y.name !== VO)
          , L = M.map(Y => Y.name)
          , D = M.map(Y => {
            const de = Y.children.filter(ae => ae.name !== VO).map(ae => L.indexOf(ae.name));
            return {
                name: Y.name,
                rotation: [Y.quaternion.x, Y.quaternion.y, Y.quaternion.z, Y.quaternion.w],
                scale: [Y.scale.x, Y.scale.y, Y.scale.z],
                translation: [Y.position.x, Y.position.y, Y.position.z],
                children: de.length > 0 ? de : void 0
            }
        }
        )
          , T = []
          , y = t.children.filter(Y => Y.type === Di.Group || Y.type === Di.SkinnedMesh)
          , E = [];
        y.forEach( (Y, de) => {
            const ae = Y.type === Di.Group ? Y.children[0] : Y
              , Ee = ae.geometry.attributes
              , V = new Ic(Ee.position,qn.FLOAT,An.POSITION,Sa.VEC3,ae.name,void 0);
            E.push(V);
            const U = E.length - 1
              , N = Ee.normal.array
              , K = new Float32Array(N.length);
            for (let Ce = 0; Ce < N.length; Ce += 3) {
                const Le = N[Ce]
                  , Re = N[Ce + 1]
                  , $e = N[Ce + 2]
                  , ce = Math.sqrt(Le * Le + Re * Re + $e * $e);
                K[Ce] = Le / ce,
                K[Ce + 1] = Re / ce,
                K[Ce + 2] = $e / ce
            }
            const oe = new Ic(new ct(K,3),qn.FLOAT,An.NORMAL,Sa.VEC3,ae.name,void 0);
            E.push(oe),
            E.push(new Ic(Ee.uv,qn.FLOAT,An.UV,Sa.VEC2,ae.name,void 0)),
            E.push(new Ic(Ee.skinWeight,qn.FLOAT,An.SKIN_WEIGHT,Sa.VEC4,ae.name,void 0)),
            E.push(new Ic(Ee.skinIndex,qn.UNSIGNED_SHORT,An.SKIN_INDEX,Sa.VEC4,ae.name,void 0)),
            (Y.type === Di.Group ? Y.children.map(Ce => Ce) : [Y]).forEach(Ce => {
                if (!Ce.geometry.index)
                    throw new Error(Ce.name + " geometry.index is null");
                E.push(new Ic(Ce.geometry.index,qn.UNSIGNED_INT,An.INDEX,Sa.SCALAR,ae.name,Ce.name))
            }
            ),
            ae.morphTargetDictionary || (ae.morphTargetDictionary = {},
            ae.morphTargetInfluences = [],
            ae.geometry.morphAttributes = {},
            ae.updateMorphTargets()),
            ae.geometry.userData.targetNames = [];
            const ve = (Ce, Le, Re, $e) => {
                const ce = []
                  , Pe = [];
                for (let Se = 0; Se < Ce.length; Se += 3) {
                    const Te = Ce[Se]
                      , Fe = Ce[Se + 1]
                      , De = Ce[Se + 2];
                    (Te !== 0 || Fe !== 0 || De !== 0) && (ce.push(Se / 3),
                    Pe.push(Te, Fe, De))
                }
                if (ce.length > 0) {
                    const Se = [...ce].sort( (De, Ze) => De - Ze)
                      , Te = [];
                    for (let De = 0; De < Se.length; De++) {
                        const Ze = Se[De]
                          , At = ce.indexOf(Ze);
                        Te.push(Pe[At * 3], Pe[At * 3 + 1], Pe[At * 3 + 2])
                    }
                    const Fe = {
                        targetMeshDataIndex: U,
                        count: Se.length,
                        indices: new Uint32Array(Se),
                        values: new Float32Array(Te)
                    };
                    E.push(new Ic($e,qn.FLOAT,Re,Sa.VEC3,ae.name,BT + Le,Fe))
                }
            }
            ;
            for (const Ce in ae.morphTargetDictionary) {
                ae.geometry.userData.targetNames.push(Ce);
                const Le = ae.morphTargetDictionary[Ce]
                  , Re = ae.geometry.morphAttributes;
                ve(Re.position[Le].array, Ce, An.BLEND_POSITION, Ee.position),
                Re.normal && ve(Re.normal[Le].array, Ce, An.BLEND_NORMAL, Ee.normal)
            }
        }
        ),
        console.warn("taking only mesh 0 for morph targets now");
        for (const Y in e.expressionManager.expressionMap) {
            const de = e.expressionManager.expressionMap[Y]
              , ae = de._binds.map(Ee => ({
                mesh: 0,
                index: Ee.index,
                weight: Ee.weight * 100
            }));
            if (ae.length > 0) {
                let Ee = !1;
                for (const V in Wr)
                    if (Y === Wr[V] && Y !== "surprised") {
                        u.push({
                            name: Y,
                            presetName: e0e(Y),
                            binds: ae,
                            isBinary: de.isBinary
                        }),
                        Ee = !0;
                        break
                    }
                Ee === !1 && u.push({
                    name: Y,
                    presetName: "unknown",
                    binds: ae,
                    isBinary: de.isBinary
                })
            }
        }
        y.forEach(Y => {
            const de = Y.type === Di.Group ? Y.children[0] : Y
              , ae = new Float32Array(de.skeleton.boneInverses.map(Ee => Ee.elements).flat());
            E.push(new Ic(new ct(ae,16),qn.FLOAT,An.BIND_MATRIX,Sa.MAT4,de.name,de.name))
        }
        ),
        T.push(...E.map(Y => ({
            componentType: Y.valueType,
            count: Y.attribute.count,
            max: Y.max,
            min: Y.min,
            normalized: !1,
            type: Y.accessorsType
        })));
        const R = s0e(y, E, d);
        y.forEach( (Y, de) => {
            D.push({
                mesh: de,
                name: Y.name,
                rotation: [Y.quaternion.x, Y.quaternion.y, Y.quaternion.z, Y.quaternion.w],
                scale: [Y.scale.x, Y.scale.y, Y.scale.z],
                skin: de,
                translation: [Y.position.x, Y.position.y, Y.position.z]
            })
        }
        );
        const F = o0e(y, E, L)
          , O = {
            humanBones: []
        };
        c.humanBones.forEach(Y => {
            L.indexOf(Y.node.name) != -1 && O.humanBones.push({
                bone: t0e(Y.bone),
                node: L.indexOf(Y.node.name),
                useDefaultValues: !0
            })
        }
        );
        const z = {
            floatProperties: {
                _DstBlend: .5,
                _ShadeShift: .5,
                _ShadeToony: .5,
                _ShadingGradeRate: .5
            },
            keywordMap: {
                _NORMALMAP: !1,
                MTOON_OUTLINE_COLOR_FIXED: !0,
                MTOON_OUTLINE_WIDTH_WORLD: !0
            },
            name: "VRMCombinedMat",
            renderQueue: 2e3,
            shader: "VRM/MToon",
            tagMap: {
                RenderType: "Opaque"
            },
            textureProperties: {
                _MainTex: 0,
                _ShadeTexture: 0
            },
            vectorProperties: {
                _Color: [1, 1, 1, 1],
                _EmissionColor: [0, 0, 0, 1],
                _EmissionMap: [0, 0, 1, 1],
                _MainTex: [0, 0, 1, 1],
                _OutlineColor: [0, 0, 0, 1],
                _OutlineWidthTexture: [0, 0, 1, 1],
                _ReceiveShadowTexture: [0, 0, 1, 1],
                _RimColor: [0, 0, 0, 1],
                _RimTexture: [0, 0, 1, 1],
                _ShadeColor: [.9, .9, .9, 1]
            }
        }
          , j = {
            name: "STDCombinedMat",
            shader: "VRM_USE_GLTFSHADER"
        }
          , Q = [];
        h.forEach(Y => {
            Y.type == "ShaderMaterial" ? Q.push(Object.assign({}, z)) : Q.push(Object.assign({}, j))
        }
        );
        const C = l
          , W = {};
        i.forEach(Y => {
            for (let de = 0; de < M.length; de++) {
                const ae = M[de];
                if (W[Y.name] || (W[Y.name] = []),
                ae.name === Y.bones.name) {
                    W[Y.name].push(de);
                    break
                }
            }
        }
        );
        const ee = []
          , P = ((ne = y.find(Y => Y.isSkinnedMesh)) == null ? void 0 : ne.skeleton) || null;
        for (let Y = 0; Y < P.bones.length; Y++) {
            const de = P.bones[Y];
            if (de.userData.VRMcolliders) {
                const ae = {
                    node: L.indexOf(de.name),
                    colliders: [],
                    name: de.name
                };
                de.userData.VRMcolliders.forEach(Ee => {
                    const V = Ee.sphere;
                    ae.colliders.push({
                        radius: V.radius * o,
                        offset: {
                            x: V.offset[0] * o,
                            y: V.offset[1] * o,
                            z: V.offset[2] * o
                        }
                    })
                }
                ),
                ee.push(ae)
            }
        }
        console.log("COLLIDER GROUPS", ee);
        const re = Y => {
            for (let de = 0; de < M.length; de++)
                if (M[de].name === Y)
                    return de;
            return -1
        }
          , ue = [];
        i.forEach(Y => {
            var V;
            const de = Y.settings
              , ae = {
                bones: [],
                center: -1,
                colliderGroups: [],
                dragForce: de.dragForce,
                gravityDir: {
                    x: de.gravityDir.x,
                    y: de.gravityDir.y,
                    z: de.gravityDir.z
                },
                gravityPower: de.gravityPower,
                hitRadius: de.hitRadius,
                stiffiness: de.stiffness
            };
            for (const U of Y.bones) {
                const N = re(U.name);
                if (N === -1) {
                    console.warn("Spring bone " + U.name + " was removed during cleanup process. Skipping.");
                    return
                }
                ae.bones.push(N)
            }
            const Ee = [];
            Y.colliderGroups.forEach(U => {
                const N = U.colliders[0];
                if (N != null) {
                    const K = N.parent
                      , oe = ee.findIndex(pe => pe.name === K.name);
                    oe != -1 ? Ee.includes(oe) || Ee.push(oe) : console.warn("No collider group for bone name: ", K.name + " was found")
                } else
                    console.warn("No colliders definition were present in vrm file file for: ", Y.name + " spring bones")
            }
            ),
            ae.colliderGroups.push(...Ee),
            ae.center = re((V = Y.center) == null ? void 0 : V.name),
            ae.center == -1 && console.debug("no center bone for spring bone " + Y.name),
            ue.push(ae)
        }
        );
        const le = {
            boneGroups: ue,
            colliderGroups: ee
        };
        console.log(le),
        C.texture = m ? x.length - 1 : void 0;
        const me = await Promise.all(_.map(async Y => ({
            buffer: s ? await jO(Y.imageBitmap) : WO(Y.imageBitmap),
            type: An.IMAGE
        })));
        E.forEach( (Y, de) => {
            Y.buffer ? me.push({
                buffer: Y.buffer,
                typeString: "",
                type: Y.type
            }) : Y.sparse && (me.push({
                buffer: Y.sparse.indices,
                typeString: "indices",
                type: Y.type,
                count: Y.sparse.count
            }),
            me.push({
                buffer: Y.sparse.values,
                typeString: "values",
                type: Y.type
            })),
            me.length - 1
        }
        ),
        m && me.push({
            buffer: s ? await jO(m.imageBitmap) : WO(m.imageBitmap),
            type: An.IMAGE
        });
        let ie = 0
          , ge = 0
          , _e = 0
          , se = 0;
        const H = me.map(Y => {
            const de = {
                buffer: 0,
                byteLength: Y.buffer.byteLength,
                byteOffset: ie,
                target: Y.type === An.IMAGE || Y.type === An.BIND_MATRIX || Y.typeString === "indices" || Y.typeString === "values" ? void 0 : Y.type === An.INDEX ? qn.ELEMENT_ARRAY_BUFFER : qn.ARRAY_BUFFER
            };
            return ie += Y.buffer.byteLength,
            Y.type === An.IMAGE ? (x[ge++].bufferView = se,
            se++) : E[_e].sparse ? (T[_e].sparse == null && (T[_e].sparse = {}),
            Y.typeString === "indices" && (T[_e].sparse.count = Y.count,
            T[_e].sparse[Y.typeString] = {
                bufferView: se,
                byteOffset: 0,
                componentType: qn.UNSIGNED_INT
            }),
            Y.typeString === "values" && (T[_e].sparse[Y.typeString] = {
                bufferView: se,
                byteOffset: 0
            }),
            Y.typeString === "values" && _e++,
            se++) : (E[_e].bufferIndex = se,
            T[_e].bufferView = se,
            _e++,
            se++),
            de
        }
        )
          , fe = u0e(t, D);
        r0e(C);
        const Ae = ["KHR_materials_unlit", "KHR_texture_transform", "VRM"];
        s && Ae.push("KHR_texture_basisu");
        for (const Y of F) {
            const de = T.filter(ae => ae.type == "MAT4");
            for (let ae of de)
                if (Y.joints.length != ae.count)
                    throw new Error(`The number of joints in the skin is not equal to the number of Accessors of type MAT4. Got ${Y.joints.length} when accessors show ${ae.count} This is usually because of a bone count mismatch in your VRMs!`)
        }
        const J = {
            accessors: T,
            asset: f,
            buffers: [{
                byteLength: ie
            }],
            bufferViews: H,
            extensions: {
                VRM: {
                    blendShapeMaster: {
                        blendShapeGroups: u
                    },
                    firstPerson: {
                        firstPersonBone: 44,
                        firstPersonBoneOffset: new $,
                        lookAtHorizontalInner: {
                            curve: [0, 0, 0, 1, 1, 1, 1, 0],
                            xRange: 90,
                            yRange: 10
                        },
                        lookAtHorizontalOuter: {
                            curve: [0, 0, 0, 1, 1, 1, 1, 0],
                            xRange: 90,
                            yRange: 10
                        },
                        lookAtTypeName: "Bone",
                        lookAtVerticalDown: {
                            curve: [0, 0, 0, 1, 1, 1, 1, 0],
                            xRange: 90,
                            yRange: 10
                        },
                        lookAtVerticalUp: {
                            curve: [0, 0, 0, 1, 1, 1, 1, 0],
                            xRange: 90,
                            yRange: 10
                        }
                    },
                    materialProperties: Q,
                    humanoid: O,
                    meta: C,
                    secondaryAnimation: le,
                    specVersion: "0.0"
                }
            },
            extensionsUsed: Ae,
            images: x,
            materials: S,
            meshes: R,
            nodes: D,
            samplers: b,
            scenes: fe,
            skins: F,
            textures: B
        };
        console.log("output", J);
        const q = new KO(ST(JSON.stringify(J, void 0, 2)),"JSON")
          , he = new KO(Lm(me.map(Y => Y.buffer)),"BIN\0")
          , X = Lm([q.buffer, he.buffer])
          , G = Lm([ST("glTF"), MT(2, 4), MT(X.byteLength + 12, 4)]);
        a(Lm([G, X]))
    }
}
function r0e(n) {
    n.title = n.title || "Character",
    n.version = n.version || "1",
    n.author = n.author || "Anon",
    n.contactInformation = n.contactInformation || "",
    n.reference = n.reference || "",
    n.allowedUserName = n.allowedUserName || "Everyone",
    n.violentUssageName = n.violentUssageName || "Disallow",
    n.sexualUssageName = n.sexualUssageName || "Disallow",
    n.commercialUssageName = n.commercialUssageName || "Disallow",
    n.otherPermissionUrl = n.otherPermissionUrl || "",
    n.licenseName = n.licenseName || "Redistribution_Prohibited",
    n.otherLicenseUrl = n.otherLicenseUrl || ""
}
function qG(n) {
    return n.children.length <= 0 ? [n] : [n].concat(n.children.map(e => qG(e)).flat())
}
const i0e = new Zge;
async function jO(n) {
    const e = await createImageBitmap(n)
      , t = document.createElement("canvas");
    t.width = e.width,
    t.height = e.height;
    const r = t.getContext("2d");
    r.drawImage(e, 0, 0);
    const i = r.getImageData(0, 0, t.width, t.height)
      , s = new Uint8Array(i.data.buffer);
    return await i0e.compress(s, t.width, t.height, 4, {
        normalMap: !1,
        uastc: !1,
        qualityLevel: 50,
        compressionLevel: 2,
        uastcFlags: "DEFAULT",
        compressionUASTC_Rdo_Level: 18,
        uastcRDO: !1,
        uastcRDOQualityScalar: 1,
        uastcRDODictSize: 4096,
        uastcRDOMaxSmoothBlockErrorScale: 10,
        uastcRDOMaxSmoothBlockStdDev: 18,
        uastcRDODontFavorSimplerModes: !1,
        ETC1SQualityLevel: 128,
        ETC1SmaxEndpoints: 0,
        ETC1SEndpointRdoThreshold: 1.25,
        ETC1SMaxSelectors: 0,
        ETC1SSelectorRdoThreshold: 1.25,
        ETC1SNoEndpointRdo: !1,
        ETC1SNoSelectorRdo: !1,
        supercmp_scheme: "Zstd"
    })
}
function WO(n) {
    const e = document.createElement("canvas");
    e.width = n.width,
    e.height = n.height,
    e.getContext("2d").drawImage(n, 0, 0);
    const t = e.toDataURL("image/png")
      , r = atob(t.split(",")[1])
      , i = (4 - r.length % 4) % 4
      , s = new ArrayBuffer(r.length + i)
      , o = new DataView(s);
    for (let a = 0; a < r.length; a++)
        o.setUint8(a, r.charCodeAt(a));
    for (let a = r.length; a < r.length + i; a++)
        o.setUint8(a, 0);
    return s
}
function MT(n, e) {
    const t = new ArrayBuffer(e);
    return new DataView(t).setUint32(0, n, !0),
    t
}
function ST(n) {
    return new TextEncoder().encode(n).buffer
}
function Lm(n) {
    let e = 0;
    for (let i = 0; i < n.length; i++)
        e += n[i].byteLength;
    const t = new Uint8Array(e);
    let r = 0;
    for (let i = 0; i < n.length; ++i)
        t.set(new Uint8Array(n[i]), r),
        r += n[i].byteLength;
    return t.buffer
}
function nM(n, e) {
    const t = e === qn.UNSIGNED_SHORT ? 2 : 4
      , r = n.array;
    let i = 0;
    const s = new ArrayBuffer(n.count * n.itemSize * t)
      , o = new DataView(s);
    for (let a = 0; a < n.count; a++)
        for (let l = 0; l < n.itemSize; l++) {
            let c;
            n.itemSize > 4 ? c = r[a * n.itemSize + l] : l === 0 ? c = n.getX(a) : l === 1 ? c = n.getY(a) : l === 2 ? c = n.getZ(a) : c = n.getW(a),
            e === qn.UNSIGNED_SHORT ? o.setUint16(i, c, !0) : e === qn.UNSIGNED_INT ? o.setUint32(i, c, !0) : o.setFloat32(i, c, !0),
            i += t
        }
    return s
}
class KO {
    constructor(e, t) {
        this.data = e,
        this.type = t;
        const r = this.padBuffer(this.data, t === "JSON" ? 32 : 0);
        this.buffer = Lm([MT(r.byteLength, 4), ST(this.type), r])
    }
    padBuffer(e, t) {
        const r = Math.ceil(e.byteLength / 4) * 4;
        if (e.byteLength === r)
            return e;
        const i = new ArrayBuffer(r);
        return new Uint8Array(i).set(new Uint8Array(e)),
        new Uint8Array(i).fill(t, e.byteLength),
        i
    }
}
const XO = n => {
    const e = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]
      , t = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    for (let r = 0; r < n.length; r += 3)
        e[0] = Math.max(e[0], n[r]),
        e[1] = Math.max(e[1], n[r + 1]),
        e[2] = Math.max(e[2], n[r + 2]),
        t[0] = Math.min(t[0], n[r]),
        t[1] = Math.min(t[1], n[r + 1]),
        t[2] = Math.min(t[2], n[r + 2]);
    return {
        max: e,
        min: t
    }
}
;
class Ic {
    constructor(e, t, r, i, s, o, a) {
        if (this.attribute = e,
        this.type = r,
        this.valueType = t,
        this.accessorsType = i,
        this.meshName = s,
        this.name = o,
        a) {
            const {indices: l, values: c, count: A, targetMeshDataIndex: u} = a
              , f = new ct(l,1)
              , h = new ct(c,e.itemSize);
            if (this.targetMeshDataIndex = u,
            this.sparse = {
                targetMeshDataIndex: u,
                count: A,
                indices: nM(f, qn.UNSIGNED_INT),
                values: nM(h, qn.FLOAT)
            },
            r === An.POSITION || r === An.BLEND_POSITION) {
                const {min: d, max: m} = XO(c);
                this.max = m,
                this.min = d
            }
        } else if (this.buffer = nM(this.attribute, this.valueType),
        r === An.POSITION || r === An.BLEND_POSITION) {
            const {min: l, max: c} = XO(this.attribute.array);
            this.max = c,
            this.min = l
        }
    }
}
var Vh;
(function(n) {
    n.MeshBasicMaterial = "MeshBasicMaterial",
    n.MeshStandardMaterial = "MeshStandardMaterial",
    n.MToonMaterial = "MToonMaterial"
}
)(Vh || (Vh = {}));
var Sa;
(function(n) {
    n.SCALAR = "SCALAR",
    n.VEC2 = "VEC2",
    n.VEC3 = "VEC3",
    n.VEC4 = "VEC4",
    n.MAT4 = "MAT4"
}
)(Sa || (Sa = {}));
var An;
(function(n) {
    n.POSITION = "POSITION",
    n.NORMAL = "NORMAL",
    n.UV = "UV",
    n.INDEX = "INDEX",
    n.SKIN_WEIGHT = "SKIN_WEIGHT",
    n.SKIN_INDEX = "SKIN_INDEX",
    n.BLEND_POSITION = "BLEND_POSITION",
    n.BLEND_NORMAL = "BLEND_NORMAL",
    n.BIND_MATRIX = "BIND_MATRIX",
    n.IMAGE = "IMAGE"
}
)(An || (An = {}));
var Di;
(function(n) {
    n.Group = "Group",
    n.SkinnedMesh = "SkinnedMesh",
    n.Object3D = "Object3D",
    n.Bone = "Bone"
}
)(Di || (Di = {}));
const s0e = (n, e, t) => n.map(r => {
    const i = r.type === Di.Group ? r.children[0] : r
      , s = r.type === Di.Group ? r.children.map(o => o) : [r];
    return {
        name: r.name,
        primitives: s.map(o => {
            const a = e.map(c => c.meshName === i.name ? c.type : null)
              , l = Array.isArray(o.material) ? o.material[0].name : o.material.name;
            return {
                attributes: {
                    JOINTS_0: a.indexOf(An.SKIN_INDEX),
                    NORMAL: a.indexOf(An.NORMAL),
                    POSITION: a.indexOf(An.POSITION),
                    TEXCOORD_0: a.indexOf(An.UV),
                    WEIGHTS_0: a.indexOf(An.SKIN_WEIGHT)
                },
                extras: {
                    targetNames: o.geometry.userData.targetNames
                },
                indices: e.map(c => c.type === An.INDEX && c.meshName === i.name ? c.name : null).indexOf(o.name),
                material: t.indexOf(l),
                mode: 4,
                targets: i.geometry.userData.targetNames ? i.geometry.userData.targetNames.map(c => {
                    const A = e.map(h => h.type === An.BLEND_NORMAL && h.meshName === i.name ? h.name : null).indexOf(BT + c)
                      , u = e.map(h => h.type === An.BLEND_POSITION && h.meshName === i.name ? h.name : null).indexOf(BT + c)
                      , f = {};
                    return u !== -1 && (f.POSITION = u),
                    A !== -1 && (f.NORMAL = A),
                    f
                }
                ) : void 0
            }
        }
        )
    }
}
)
  , o0e = (n, e, t) => n.map(r => {
    const i = r.type === Di.Group ? r.children[0] : r;
    return {
        inverseBindMatrices: e.map(s => s.type === An.BIND_MATRIX ? s.meshName : null).indexOf(i.name),
        joints: i.skeleton.bones.map(s => t.indexOf(s.name)).filter(s => s !== -1),
        skeleton: t.indexOf(i.skeleton.bones[0].name)
    }
}
)
  , a0e = (n, e) => n.map(t => {
    let r, i = null;
    if (t = t.userData.vrmMaterial ? t.userData.vrmMaterial : t,
    t.type === "ShaderMaterial")
        i = {},
        i.shadeMultiplyTexture = {
            index: e.map(d => d.name).indexOf(t.uniforms.shadeMultiplyTexture.name)
        },
        r = t.color ? [1, 1, 1, 1] : void 0;
    else {
        const h = t;
        r = h.color ? [h.color.r, h.color.g, h.color.b, 1] : void 0
    }
    let s = -1;
    t.map ? s = e.map(h => h.name).indexOf(t.name) : t.uniforms && t.uniforms.map && (s = e.map(h => h.name).indexOf(t.uniforms.map.name));
    let o = -1;
    t.roughnessMap && (o = e.map(h => h.name).indexOf(t.name + "_orm"));
    let a = -1;
    t.normalMap && (a = e.map(h => h.name).indexOf(t.name + "_normal"));
    const l = s >= 0 ? {
        extensions: {
            KHR_texture_transform: {
                offset: [0, 0],
                scale: [1, 1]
            }
        },
        index: s,
        texCoord: 0
    } : void 0
      , c = {
        baseColorFactor: r,
        baseColorTexture: l
    }
      , A = o >= 0 ? {
        index: o,
        texCoord: 0
    } : void 0
      , u = a >= 0 ? {
        index: a,
        texCoord: 0
    } : void 0;
    if (A)
        c.metallicRoughnessTexture = A;
    else {
        const h = ( () => {
            switch (t.type) {
            case Vh.MeshStandardMaterial:
                return t.metalness;
            case Vh.MeshBasicMaterial:
                return 0;
            default:
                return 0
            }
        }
        )()
          , d = ( () => {
            switch (t.type) {
            case Vh.MeshStandardMaterial:
                return t.roughness;
            case Vh.MeshBasicMaterial:
                return .9;
            default:
                return .9
            }
        }
        )();
        c.metallicFactor = h,
        c.roughnessFactor = d
    }
    const f = {
        alphaCutoff: t.alphaTest > 0 ? t.alphaTest : void 0,
        alphaMode: t.transparent ? "BLEND" : t.alphaTest > 0 ? "MASK" : "OPAQUE",
        doubleSided: t.side === 2,
        extensions: t.type === "ShaderMaterial" ? {
            KHR_materials_unlit: {}
        } : void 0,
        name: t.name,
        pbrMetallicRoughness: c
    };
    return u && (f.normalTexture = u),
    f
}
)
  , l0e = (n, e, t) => (e ? n.concat(e) : n).filter(r => r && r.imageBitmap).map(r => ({
    bufferView: -1,
    mimeType: t,
    name: r.name
}))
  , c0e = n => n.map( () => ({
    magFilter: qn.LINEAR,
    minFilter: qn.LINEAR,
    wrapS: qn.REPEAT,
    wrapT: qn.REPEAT
}))
  , A0e = (n, e) => e ? n.map( (t, r) => ({
    sampler: 0,
    extensions: {
        KHR_texture_basisu: {
            source: r
        }
    }
})) : n.map( (t, r) => ({
    sampler: 0,
    source: r
}))
  , u0e = (n, e) => {
    const t = e.map(r => r.name);
    return [{
        nodes: n.children.filter(r => r.type === Di.Object3D || r.type === Di.SkinnedMesh || r.type === Di.Group || r.type === Di.Bone).map(r => t.indexOf(r.name))
    }]
}
;
function f0e(n, e, t) {
    var a, l;
    const r = []
      , i = [];
    for (const c in n)
        ((l = (a = n[c]) == null ? void 0 : a.vrm) == null ? void 0 : l.meta) != null && (n[c].vrm.meta.authors != null ? i.push(n[c].vrm.meta) : r.push(n[c].vrm.meta));
    r.length + i.length == 1 && (r.length == 1 ? r[0].title != null && (t = r[0].title) : i[0].name != null && (t = i[0].name)),
    e != null && (e.authors != null ? i.push(e) : r.push(e));
    const s = d0e(r)
      , o = h0e(s, i);
    return o.licenseUrl = "https://vrm.dev/licenses/1.0/",
    o.name = t,
    o
}
function h0e(n, e) {
    let {authors: t=[], otherLicenseUrl: r=[], contactInformation: i=[], references: s=[], allowExcessivelyViolentUsage: o=void 0, allowExcessivelySexualUsage: a=void 0, commercialUsage: l=void 0, copyrightInformation: c="", avatarPermission: A=void 0, otherPermissionUrl: u=[]} = n, f, h, d, m = "unnecessary", g, p = [];
    e.forEach(S => {
        t = t.concat(ut(S.authors)),
        r = r.concat(ut(S.otherLicenseUrl)),
        i = i.concat(ut(S.contactInformation)),
        s = s.concat(ut(S.references)),
        u = u.concat(ut(S.otherPermissionUrl)),
        S.allowExcessivelyViolentUsage === !1 && (o = !1),
        S.allowExcessivelySexualUsage === !1 && (a = !1),
        l = Nl(g0e, l, S.commercialUsage),
        c = Nl(eV, c, S.copyrightInformation),
        A = Nl(v0e, A, S.avatarPermission),
        S.allowAntisocialOrHateUsage === !1 && (f = f = !1),
        S.allowPoliticalOrReligiousUsage === !1 && (h = h = !1),
        S.allowRedistribution === !1 && (d = d = !1),
        S.creditNotation === "required" && (m = "required"),
        p = p.concat(ut(S.thirdPartyLicenses)),
        g = Nl(m0e, g, S.modification)
    }
    );
    const v = [...new Set(t)].filter(S => S != "" && S != null && S != "undefined")
      , w = [...new Set(r)].filter(S => S != "" && S != null && S != "undefined")
      , _ = [...new Set(i)].filter(S => S != "" && S != null && S != "undefined")
      , x = [...new Set(s)].filter(S => S != "" && S != null && S != "undefined")
      , b = [...new Set(u)].filter(S => S != "" && S != null && S != "undefined")
      , B = [...new Set(p)].filter(S => S != "" && S != null && S != "undefined");
    return {
        authors: v,
        otherLicenseUrl: w.length == 0 ? "" : w.join(", "),
        contactInformation: _.length == 0 ? "" : _.join(", "),
        references: x,
        otherPermissionUrl: b.length == 0 ? "" : b.join(", "),
        thirdPartyLicenses: B.length == 0 ? "" : B.join(", "),
        allowExcessivelyViolentUsage: o,
        allowExcessivelySexualUsage: a,
        commercialUsage: l,
        copyrightInformation: c,
        avatarPermission: A,
        allowAntisocialOrHateUsage: f,
        allowPoliticalOrReligiousUsage: h,
        allowRedistribution: d,
        creditNotation: m,
        modification: g
    }
}
function d0e(n) {
    let e = [], t = [], r = [], i = [], s = [], o, a, l, c, A;
    n.forEach(g => {
        e = e.concat(ut(g.author)),
        t = t.concat(ut(g.contactInformation)),
        r = r.concat(ut(g.reference)),
        i = i.concat(ut(g.otherPermissionUrl)),
        s = s.concat(ut(g.otherLicenseUrl)),
        o = Nl(y0e, o, g.allowedUsername),
        a = Nl(rM, a, g.violentUssageName),
        l = Nl(rM, l, g.sexualUssageName),
        c = Nl(rM, c, g.commercialUssageName),
        A = Nl(eV, A, g.licenseName)
    }
    );
    const u = [...new Set(e)].filter(g => g != "" && g != null && g != "undefined")
      , f = [...new Set(t)].filter(g => g != "" && g != null && g != "undefined")
      , h = [...new Set(r)].filter(g => g != "" && g != null && g != "undefined")
      , d = [...new Set(i)].filter(g => g != "" && g != null && g != "undefined")
      , m = [...new Set(s)].filter(g => g != "" && g != null && g != "undefined");
    return {
        authors: u,
        otherLicenseUrl: m,
        contactInformation: f,
        references: h,
        allowExcessivelyViolentUsage: a === "Allow",
        allowExcessivelySexualUsage: l === "Allow",
        commercialUsage: c === "Allow" ? "personalProfit" : "personalNonProfit",
        copyrightInformation: A,
        avatarPermission: p0e(o),
        otherPermissionUrl: d
    }
}
function p0e(n) {
    if (n == "OnlyAuthor")
        return "onlyAuthor";
    if (n == "ExplicitlyLicensedPerson")
        return "onlySeparatelyLicensedPerson";
    if (n == "Everyone")
        return "everyone"
}
const m0e = {
    prohibited: 0,
    allowModification: 1,
    allowModificationRedistribution: 2
}
  , g0e = {
    personalNonProfit: 0,
    personalProfit: 1,
    corporation: 2
}
  , v0e = {
    onlyAuthor: 0,
    onlySeparatelyLicensedPerson: 1,
    everyone: 2
}
  , y0e = {
    OnlyAuthor: 0,
    ExplicitlyLicensedPerson: 1,
    Everyone: 2
}
  , rM = {
    Disallow: 0,
    Allow: 1
}
  , eV = {
    Redistribution_Prohibited: 0,
    Other: 1,
    CC_BY_NC_ND: 2,
    CC_BY_ND: 3,
    CC_BY_NC_SA: 4,
    CC_BY_SA: 5,
    CC_BY_NC: 6,
    CC_BY: 7,
    CC0: 8
};
function Nl(n, e, t) {
    return e === void 0 ? t : t == null || !(t in n) || n[e] < n[t] ? e : t
}
function tV(n) {
    const e = n.clone()
      , t = [];
    return n.traverse(r => {
        r.userData.origIndexBuffer && t.push(r.userData.origIndexBuffer)
    }
    ),
    e.traverse(r => {
        r.userData.origIndexBuffer && (r.userData.origIndexBuffer = t.shift())
    }
    ),
    e
}
function w0e(n) {
    const e = tV(n);
    let t;
    const r = [];
    e.traverse(s => {
        if (!t && s.isSkinnedMesh && (t = HG(s)),
        s.isSkinnedMesh) {
            if (s.geometry = s.geometry.clone(),
            s.skeleton = t,
            r.push(s),
            Array.isArray(s.material)) {
                const o = s.material;
                s.material = new Od,
                s.material.map = o[0].map
            }
            s.userData.origIndexBuffer && s.geometry.setIndex(s.userData.origIndexBuffer)
        }
    }
    );
    const i = new ri;
    return r.forEach(s => {
        i.add(s)
    }
    ),
    i.add(t.bones[0]),
    i
}
async function _0e(n, e, t) {
    const r = await m2(n, t)
      , i = await nV(r, e, t);
    return new Blob([i],{
        type: "model/gltf-binary"
    })
}
function x0e(n, e, t, r) {
    return new Promise(async (i, s) => {
        const o = `${t && t !== "" ? t : "AvatarCreatorModel"}`;
        b0e(n, e, r).then(a => {
            iV(a, `${o}.vrm`),
            i()
        }
        )
    }
    )
}
async function b0e(n, e, t) {
    const r = await m2(n, e, t);
    return nV(r, e, t)
}
function m2(n, e, t) {
    const r = tV(n);
    t.mergeAppliedMorphs = !0;
    const {createTextureAtlas: i=!0} = t;
    return i ? oge(r, e, t) : (console.log("no atlas"),
    rge(r, e, t))
}
async function E0e(n, e="", t) {
    const r = `${e && e !== "" ? e : "AvatarCreatorModel"}`
      , {optimized: i=!0} = t
      , s = i ? await m2(n, t) : w0e(n);
    B0e(s).then(o => {
        if (o instanceof ArrayBuffer)
            iV(o, `${r}.glb`);
        else {
            const a = JSON.stringify(o, null, 2);
            R0e(a, `${r}.gltf`)
        }
    }
    )
}
function B0e(n) {
    return new Promise(e => new ZR().parse(n, r => {
        e(r)
    }
    , r => {
        console.error("Error parsing", r)
    }
    , {
        trs: !1,
        onlyVisible: !1,
        truncateDrawRange: !0,
        binary: !0,
        forcePowerOfTwoTextures: !1,
        maxTextureSize: 1024
    }))
}
function M0e(n) {
    var r, i;
    const e = [];
    for (const s in n)
        if (((i = (r = n[s]) == null ? void 0 : r.vrm) == null ? void 0 : i.springBoneManager) != null) {
            const o = n[s].vrm.springBoneManager.joints;
            for (const a of o)
                e.some(c => c.name === a.bone.name) || e.push({
                    name: a.bone.name,
                    settings: a.settings,
                    bone: a.bone,
                    colliderGroups: a.colliderGroups,
                    center: a.center
                })
        }
    const t = [];
    return e.forEach(s => {
        if (e.find(a => {
            var l;
            return a.name == ((l = s.bone.parent) == null ? void 0 : l.name)
        }
        ) == null) {
            t.push({
                bones: [s],
                settings: s.settings,
                center: s.center,
                colliderGroups: s.colliderGroups,
                name: s.bone.name
            });
            return
        }
    }
    ),
    e.map(s => {
        const o = t.find(a => a.bones.find(l => {
            var c;
            return l.name == ((c = s.bone.parent) == null ? void 0 : c.name)
        }
        ) != null);
        o != null && o.bones.push({
            name: s.name,
            bone: s.bone
        })
    }
    ),
    t
}
function S0e(n) {
    var r, i;
    const e = [];
    for (const s in n)
        if (((i = (r = n[s]) == null ? void 0 : r.vrm) == null ? void 0 : i.springBoneManager) != null) {
            const o = n[s].vrm.springBoneManager.joints;
            for (const a of o)
                e.some(c => c.name === a.bone.name) || e.push({
                    name: a.bone.name,
                    settings: a.settings,
                    bone: a.bone,
                    colliderGroups: a.colliderGroups,
                    center: a.center
                })
        }
    const t = [];
    return e.forEach(s => {
        for (const o in Jg)
            if (s.bone.parent.name == Jg[o]) {
                t.push(s);
                break
            }
    }
    ),
    t
}
function C0e(n) {
    const e = {};
    return n.skeleton.bones.map(t => {
        for (const r in Jg)
            if (Jg[r] === t.name) {
                e[t.name] = {
                    node: t
                };
                break
            }
    }
    ),
    e
}
function T0e(n, e, t) {
    const r = kd(n, "SkinnedMesh");
    return {
        humanBones: C0e(r[0]),
        materials: n.userData.atlasMaterial,
        meta: I0e(e),
        ...t.mergeAppliedMorphs ? {
            expressionManager: P0e(n)
        } : {}
    }
}
function I0e(n) {
    return n = n || {},
    {
        ...{
            authors: ["CharacterStudio"],
            metaVersion: "1",
            version: "v1",
            name: "CharacterCreator",
            licenseUrl: "https://vrm.dev/licenses/1.0/",
            commercialUssageName: "personalNonProfit",
            contactInformation: "https://m3org.com/",
            allowExcessivelyViolentUsage: !1,
            allowExcessivelySexualUsage: !1,
            allowPoliticalOrReligiousUsage: !1,
            allowAntisocialOrHateUsage: !1,
            creditNotation: "required",
            allowRedistribution: !1,
            modification: "prohibited"
        },
        ...n
    }
}
function nV(n, e, t) {
    const {screenshot: r=null, isVrm0: i=!1, vrmMeta: s=null, scale: o=1, vrmName: a="CharacterCreator"} = t
      , l = f0e(e, s, a);
    return new Promise(async c => {
        const A = t.outputVRM0 ?? t.isVrm0 ?? !0
          , u = A ? new n0e : new wpe
          , f = {
            ...F0e(e),
            ...T0e(n, l, t)
        };
        let h;
        n.traverse(g => {
            g.isSkinnedMesh && (h = g)
        }
        ),
        ( () => {
            for (let g = 0; g < h.skeleton.bones.length; g++) {
                const p = h.skeleton.bones[g];
                p.position.x *= -1,
                p.position.z *= -1
            }
            h.skeleton.bones.forEach(g => {
                g.updateMatrix(),
                g.updateMatrixWorld()
            }
            ),
            h.skeleton.calculateInverses(),
            h.skeleton.computeBoneTexture(),
            h.skeleton.update()
        }
        )();
        const m = A ? M0e(e) : S0e(e);
        A ? u.parse(f, n, r, m, t.ktxCompression, o, g => {
            c(g)
        }
        ) : u.parse(f, n, r, g => {
            c(g)
        }
        )
    }
    )
}
function rV(n, e) {
    const t = document.createElement("a");
    t.style.display = "none",
    document.body.appendChild(t),
    t.href = URL.createObjectURL(n),
    t.download = e,
    t.click()
}
function R0e(n, e) {
    rV(new Blob([n],{
        type: "text/plain"
    }), e)
}
function iV(n, e) {
    rV(U0e(n), e)
}
function U0e(n) {
    return new Blob([n],{
        type: "application/octet-stream"
    })
}
function F0e(n) {
    for (const e in n)
        if (n[e].vrm)
            return n[e].vrm
}
function P0e(n) {
    const e = new Z_;
    let t = n.userData.expressionManagerToClone;
    if (!t) {
        t = new Z_;
        for (const r of Object.values(Wr)) {
            const i = new $_(r);
            t.registerExpression(i)
        }
    }
    e.copy(t),
    n.userData.expressionManagerToClone = null;
    for (const r of n.children) {
        if (!r.isMesh && !r.isSkinnedMesh || !r.morphTargetDictionary)
            continue;
        const i = r.userData.bindMorphs;
        if (!i || !gge(r, i.old))
            continue;
        const o = (c, A) => {
            var u;
            return ((u = c.find(f => f.index == A)) == null ? void 0 : u.weight) || 0
        }
          , a = Object.entries(Wr).flat()
          , l = Object.keys(i.old).filter(c => a.includes(c));
        for (const c of Object.keys(t.expressionMap)) {
            const A = t.expressionMap[c];
            if (!A)
                continue;
            const u = A._binds;
            if (!u || u.length == 0) {
                e.unregisterExpression(A);
                continue
            }
            for (const f of l) {
                const h = i.new[f] || i.new[f.toLowerCase()]
                  , d = i.old[f] || i.old[f.toLowerCase()];
                if (h) {
                    const m = [];
                    n.traverse(v => {
                        !v.isMesh && !v.isSkinnedMesh || h.primitives.includes(v.id) && m.push(v)
                    }
                    ),
                    e.unregisterExpression(A),
                    A._binds = [];
                    const g = o(u, d.index)
                      , p = new $_(A.expressionName);
                    p.copy(A),
                    console.log("adding bind", A.expressionName),
                    p.addBind(new J_({
                        index: h.index,
                        weight: g,
                        primitives: m
                    })),
                    e.registerExpression(p)
                } else
                    e.unregisterExpression(A)
            }
        }
        for (const c of e.expressions) {
            const u = L0e(c)[0][0]
              , f = c._binds
              , h = i.new[u].index
              , d = f.map(m => new J_({
                index: h,
                weight: m.weight,
                primitives: [r]
            }));
            c._binds = d
        }
    }
    return e
}
function L0e(n) {
    const e = n._binds;
    return e ? e.map(r => {
        let i = [];
        return r.primitives.forEach(s => {
            const o = Object.entries(s.morphTargetDictionary).find( ([a,l]) => l == r.index);
            o && i.push(o[0])
        }
        ),
        i
    }
    ) : []
}
function sV(n, e) {
    return e && n ? n.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : n || e
}
const D0e = n => {
    const t = n.parser.json.meshes
      , r = n.parser.associations;
    n.scene.traverse(i => {
        var s;
        if (i instanceof sa && i.morphTargetDictionary) {
            let o = !1;
            const a = r.get(i);
            if (typeof a > "u")
                return;
            const l = a.meshes || 0
              , c = a.primitives || 0
              , A = t[l]
              , u = A == null ? void 0 : A.primitives[c];
            if ((s = u == null ? void 0 : u.extras) != null && s.targetNames) {
                const f = u.extras.targetNames;
                for (let h = 0; h < f.length; h++)
                    i.morphTargetDictionary[f[h]] = h,
                    o = !0
            }
            if (o)
                for (const f in i.morphTargetDictionary)
                    isNaN(parseInt(f)) || delete i.morphTargetDictionary[f]
        }
    }
    )
}
  , N0e = n => {
    var e, t;
    (e = n.parser.json.extensions) != null && e.VRM ? O0e(n) : (t = n.parser.json.extensions) != null && t.VRMC_vrm ? k0e(n) : console.warn("No valid vrm file was provided")
}
  , O0e = n => {
    var a, l, c;
    const e = n.parser.json
      , t = n.scene
      , r = e.nodes
      , i = (c = (l = (a = e.extensions) == null ? void 0 : a.VRM) == null ? void 0 : l.secondaryAnimation) == null ? void 0 : c.colliderGroups
      , s = []
      , o = r.map(A => oV(A.name, s));
    i != null && i.forEach(A => {
        const u = o[A.node]
          , f = XG(t, u);
        if (f != null) {
            const h = A.colliders;
            f.userData.VRMcolliders = h.map(d => ({
                sphere: {
                    radius: d.radius,
                    offset: [d.offset.x, d.offset.y, d.offset.z]
                }
            }))
        }
        f.userData.VRMcollidersID = WG()
    }
    )
}
  , k0e = n => {
    var l, c, A, u;
    const e = n.parser.json
      , t = n.scene
      , r = e.nodes
      , i = (c = (l = e.extensions) == null ? void 0 : l.VRMC_springBone) == null ? void 0 : c.colliderGroups
      , s = (u = (A = e.extensions) == null ? void 0 : A.VRMC_springBone) == null ? void 0 : u.colliders
      , o = []
      , a = r.map(f => oV(f.name, o));
    i != null && i.forEach(f => {
        const h = ut(f.colliders);
        let d = -1
          , m = null;
        h.forEach(g => {
            if (d != s[g].node) {
                d = s[g].node;
                const p = a[d];
                m = XG(t, p),
                m.userData.VRMcolliders = []
            }
            if (m != null) {
                const p = s[g].shape;
                for (const v in p) {
                    const w = p[v];
                    w != null && w.offset && (w.offset[0] = -w.offset[0])
                }
                m.userData.VRMcollidersID = WG(),
                m.userData.VRMcolliders.push(p)
            } else
                console.error("no node with name " + a[d] + " was found")
        }
        )
    }
    )
}
  , Q0e = n => {
    const e = [];
    return n.scene.traverse(t => {
        var r;
        (r = t.userData) != null && r.VRMcolliders && t.userData.VRMcolliders.length > 0 && e.push(t)
    }
    ),
    e
}
  , oV = (n, e) => {
    const t = Ct.sanitizeNodeName(n || "");
    return t in e ? t + "_" + ++e[t] : (e[t] = 0,
    t)
}
  , sx = [0, 400, 560, 2400, 4800]
  , ox = [0, 500, 700, 3e3, 6e3]
  , CT = []
  , Sl = []
  , g2 = 1024
  , aV = 44100;
for (let n = 0; n < sx.length; n++)
    Sl[n] = Math.round(2 * g2 / aV * sx[n]);
for (let n = 0; n < ox.length; n++)
    CT[n] = Math.round(2 * g2 / aV * ox[n]);
class ax {
    constructor(e) {
        this.vrm = e;
        const t = (r, i) => {
            requestAnimationFrame(t),
            this.update(r, i)
        }
        ;
        t()
    }
    start(e) {
        this.audioContext = new AudioContext,
        this.mediaStreamSource = this.audioContext.createMediaStreamSource(e),
        this.meter = ax.createAudioMeter(this.audioContext),
        this.mediaStreamSource.connect(this.meter)
    }
    startFromAudioFile(e) {
        this.audioContext || (this.audioContext = new AudioContext),
        this.userSpeechAnalyzer || (this.userSpeechAnalyzer = this.audioContext.createAnalyser()),
        this.userSpeechAnalyzer.smoothingTimeConstant = .5,
        this.userSpeechAnalyzer.fftSize = g2,
        this.mediaStreamSource && this.mediaStreamSource.stop(),
        this.audioContext.decodeAudioData(e).then(t => {
            this.mediaStreamSource = this.audioContext.createBufferSource(),
            this.mediaStreamSource.buffer = t,
            this.meter = ax.createAudioMeter(this.audioContext),
            this.mediaStreamSource.connect(this.meter),
            this.mediaStreamSource.connect(this.audioContext.destination),
            this.mediaStreamSource.start(),
            this.mediaStreamSource.connect(this.userSpeechAnalyzer)
        }
        )
    }
    destroy() {
        var e, t, r;
        return (e = this.meter) == null || e.shutdown(),
        this.meter = null,
        (t = this.mediaStreamSource) == null || t.disconnect(),
        ((r = this.audioContext) == null ? void 0 : r.close().catch( () => {}
        )) || Promise.resolve()
    }
    update(e) {
        if (this.meter) {
            const {volume: t} = this.meter;
            if (t < .01)
                this.vrm.expressionManager.setValue(Wr.Oh, 0),
                this.vrm.expressionManager.setValue(Wr.Ah, 0),
                this.vrm.expressionManager.setValue(Wr.Ee, 0);
            else {
                const {ah: r, oh: i, ee: s} = this.update2();
                this.vrm.expressionManager.setValue(Wr.Oh, i),
                this.vrm.expressionManager.setValue(Wr.Ah, r),
                this.vrm.expressionManager.setValue(Wr.Ee, s),
                this.vrm.expressionManager.update(e)
            }
        }
    }
    update2() {
        function e(c) {
            const u = new Float32Array(c.length);
            for (let f = 0; f < c.length; f++)
                u[f] = .5 + (c[f] + 20) / 140;
            return u
        }
        const t = new Float32Array(this.userSpeechAnalyzer.frequencyBinCount);
        this.userSpeechAnalyzer.getFloatFrequencyData(t);
        const r = e(t)
          , i = new Float32Array(sx.length)
          , s = new Float32Array(ox.length);
        for (let c = 0; c < sx.length - 1; c++) {
            for (let A = Sl[c]; A <= Sl[c + 1]; A++)
                r[A] > 0 && (i[c] += r[A]);
            i[c] /= Sl[c + 1] - Sl[c]
        }
        for (let c = 0; c < ox.length - 1; c++) {
            for (let A = Sl[c]; A <= Sl[c + 1]; A++)
                r[A] > 0 && (s[c] += r[A]);
            i[c] /= Sl[c + 1] - Sl[c],
            s[c] = s[c] / (CT[c + 1] - CT[c])
        }
        const o = Math.max(s[1], i[1]) > .2 ? 1 - 2 * Math.max(i[2], s[2]) : (1 - 2 * Math.max(i[2], s[2])) * 5 * Math.max(i[1], s[1])
          , a = 3 * Math.max(i[3], s[3])
          , l = .8 * (Math.max(i[1], s[1]) - Math.max(i[3], s[3]));
        return {
            oh: o,
            ee: l,
            ah: a
        }
    }
    static createAudioMeter(e) {
        const t = e.createScriptProcessor(512);
        return t.onaudioprocess = r => {
            const i = r.inputBuffer.getChannelData(0)
              , s = i.length;
            let o = 0, a;
            for (let c = 0; c < s; c++)
                a = i[c],
                Math.abs(a) >= t.clipLevel && (t.clipping = !0,
                t.lastClip = window.performance.now()),
                o += a * a;
            const l = Math.sqrt(o / s);
            t.volume = Math.max(l, t.volume * t.averaging)
        }
        ,
        t.clipping = !1,
        t.lastClip = 0,
        t.volume = 0,
        t.clipLevel = .98,
        t.averaging = .95,
        t.clipLag = 750,
        t.connect(e.destination),
        t.checkClipping = () => t.clipping ? (t.lastClip + t.clipLag < window.performance.now() && (t.clipping = !1),
        t.clipping) : !1,
        t.shutdown = () => {
            t.disconnect(),
            t.onaudioprocess = null
        }
        ,
        t
    }
}
const iM = new $;
class H0e {
    constructor(e, t, r) {
        this.bonesInfo = [],
        this.curMousePos = new We,
        this.hotzoneSection = s(),
        this.enabled = !1,
        this.userActivated = !1,
        this.lookInterest = 1,
        this.hasInterest = !0,
        this.interestSpeed = .3,
        this.onCanvas = !0,
        this.camera = r,
        this.maxLookPercent = {
            neck: {
                maxy: 15,
                miny: 10,
                maxx: 30,
                minx: 10
            },
            spine: {
                maxy: 0,
                miny: 0,
                maxx: 30,
                minx: 10
            },
            left: {
                maxy: 15,
                miny: 20,
                maxx: 35,
                minx: 35
            },
            right: {
                maxy: 15,
                miny: 20,
                maxx: 35,
                minx: 35
            }
        },
        window.addEventListener("mousemove", o => {
            this.curMousePos = {
                x: o.clientX,
                y: o.clientY
            }
        }
        );
        const i = document.getElementById(t);
        i && (i.addEventListener("mouseleave", () => {
            this.onCanvas = !1
        }
        ),
        i.addEventListener("mouseenter", () => {
            this.onCanvas = !0
        }
        )),
        window.addEventListener("resize", () => {
            this.hotzoneSection = s()
        }
        );
        function s() {
            const o = window.innerWidth * e / 100
              , a = (window.innerWidth - o) / 2;
            return {
                xStart: a,
                xEnd: window.innerWidth - a,
                yStart: 50,
                yEnd: window.innerHeight - 80
            }
        }
    }
    setActive(e) {
        console.log("is activating"),
        this.userActivated = e
    }
    setCamera(e) {
        this.camera = e
    }
    addVRM(e) {
        const t = e.data.isVRM0 || !1
          , r = e.humanoid.humanBones;
        t || (r.neck.node.userData.inverseLookAt = !0,
        r.spine.node.userData.inverseLookAt = !0,
        r.leftEye && (r.leftEye.node.userData.inverseLookAt = !0),
        r.rightEye && (r.rightEye.node.userData.inverseLookAt = !0));
        const i = {
            vrm: e,
            neckBone: r.neck.node,
            spineBone: r.spine.node,
            leftEyeBone: r.leftEye ? r.leftEye.node : null,
            rightEyeBone: r.rightEye ? r.rightEye.node : null
        };
        this.bonesInfo.push(i)
    }
    removeVRM(e) {
        const t = this.bonesInfo.find(r => r.vrm === e);
        if (t) {
            const r = this.bonesInfo.indexOf(t);
            this.bonesInfo.splice(r, 1)
        }
    }
    _getMouseDegrees(e, t, r) {
        let i = 0, s = 0, o, a, l, c, A = {
            x: window.innerWidth,
            y: window.innerHeight
        };
        return e <= A.x / 2 && (o = A.x / 2 - e,
        a = o / (A.x / 2) * 100,
        i = r.maxx * a / 100 * -1),
        e >= A.x / 2 && (o = e - A.x / 2,
        a = o / (A.x / 2) * 100,
        i = r.minx * a / 100),
        t <= A.y / 2 && (l = A.y / 2 - t,
        c = l / (A.y / 2) * 100,
        s = r.maxy * .5 * c / 100 * -1),
        t >= A.y / 2 && (l = t - A.y / 2,
        c = l / (A.y / 2) * 100,
        s = r.miny * c / 100),
        {
            x: i,
            y: s
        }
    }
    lerp(e, t, r) {
        return (1 - r) * e + r * t
    }
    _moveJoint(e, t) {
        const r = e.userData.inverseLookAt === !0 ? 1 : -1;
        if (Object.keys(e).length !== 0) {
            const i = (this.camera.position.y - 1.8) * window.innerHeight / 2;
            let s = this._getMouseDegrees(this.curMousePos.x, this.curMousePos.y - i, t);
            const o = .8;
            e.rotation.y = this.lerp(Bt.degToRad(s.x), e.rotation.y, o),
            e.rotation.x = this.lerp(Bt.degToRad(s.y * r), e.rotation.x, o)
        }
    }
    update() {
        iM.set(0, 0, 1),
        iM.applyQuaternion(this.camera.quaternion);
        const e = iM.z > 0;
        this.curMousePos.x > this.hotzoneSection.xStart && this.curMousePos.x < this.hotzoneSection.xEnd && this.curMousePos.y > this.hotzoneSection.yStart && this.curMousePos.y < this.hotzoneSection.yEnd && e && this.enabled && this.userActivated && this.bonesInfo.forEach(t => {
            this._moveJoint(t.neckBone, this.maxLookPercent.neck),
            this._moveJoint(t.spineBone, this.maxLookPercent.spine),
            this._moveJoint(t.leftEyeBone, this.maxLookPercent.left),
            this._moveJoint(t.rightEyeBone, this.maxLookPercent.right)
        }
        )
    }
}
class z0e {
    constructor(e) {
        Ne(this, "targetVRMMeshes", []);
        Ne(this, "baseTexture", null);
        Ne(this, "textures", []);
        Ne(this, "applied", new Map);
        Ne(this, "imageDataRenderer");
        this.characterManager = e,
        this.imageDataRenderer = new L1(512,512)
    }
    get scene() {
        return this.characterManager.parentModel
    }
    get manifest() {
        return this.characterManager.manifestData
    }
    get targetMaterial() {
        if (!this.targetVRMMeshes.length)
            throw new Error("No target meshes found, call setTargetVRM");
        let e = this.targetVRMMeshes.map(r => ut(r.material)).flat()
          , t = e[0];
        if (t.map)
            return t;
        for (let r = 1; r < e.length; r++)
            if (e[r].map) {
                t = e[r];
                break
            } else
                continue;
        return t
    }
    setTargetVRM(e, t) {
        this.targetVRMMeshes = [],
        e.scene.traverse(r => {
            r instanceof sa && (t && t.length ? t.includes(r.name) && this.targetVRMMeshes.push(r) : this.targetVRMMeshes.push(r))
        }
        )
    }
    async update() {
        const e = this.targetMaterial
          , t = e.map.image
          , r = t.width
          , i = t.height;
        this.imageDataRenderer.clearRenderer(),
        this.imageDataRenderer.width = r,
        this.imageDataRenderer.height = i;
        const s = this.imageDataRenderer.render(this.textures, e.color || new Qe(1,1,1), new Qe(1,1,1), !0, !0);
        s || console.error("Failed to update OverlayTextureManager, ImageData is undefined");
        const o = d2({
            width: r,
            height: i,
            transparent: !0
        })
          , a = await createImageBitmap(s);
        o.drawImage(a, 0, 0);
        const l = new Un(o.canvas);
        l.colorSpace = Ut,
        l.flipY = !1,
        l.needsUpdate = !0,
        this.targetMaterial.map = l
    }
    async loadOverlayTexture(e, t) {
        const r = new PA
          , i = e.getAllDecals().find(l => l.id === t);
        if (!i)
            throw new Error("Decal " + t + " not found in trait group");
        if (this.targetVRMMeshes.length === 0)
            throw new Error("No target meshes found");
        const s = i.directory;
        if (!s)
            throw new Error("Decal not found in trait group");
        const o = sV(this.manifest.getTraitsDirectory(), s)
          , a = await r.loadAsync(o);
        return a.colorSpace = Ut,
        a.flipY = !1,
        this.textures.length || this.textures.push(this.targetMaterial.map.clone()),
        this.textures.push(a),
        this.applied.set(t, a),
        this.update()
    }
    removeOverlayTexture(e) {
        if (this.applied.has(e)) {
            const t = this.applied.get(e);
            if (!t)
                return this.applied.delete(e),
                Promise.resolve();
            this.textures.splice(this.textures.indexOf(t), 1),
            this.applied.delete(e)
        }
        return this.update()
    }
    removeAllOverlayedTextures() {
        this.textures = [this.textures[0]],
        this.applied.clear(),
        this.update()
    }
}
class G0e {
    constructor(e) {
        Ne(this, "traitRestrictions");
        Ne(this, "restrictionMaps", {});
        Ne(this, "itemRestrictions", new Map);
        Ne(this, "manifestData");
        Ne(this, "logRules", () => {
            const e = [];
            for (const t in this.restrictionMaps) {
                const r = this.restrictionMaps[t];
                r.restrictedTypes.size && e.push(`Trait: ${r.group.trait} is restrciting traits ${Array.from(r.restrictedTraits.values()).join(", ")}`),
                r.restrictedTypes.size && e.push(`Trait: ${r.group.trait} also restricts types ${Array.from(r.restrictedTypes.values()).join(", ")}`)
            }
            this.itemRestrictions.forEach( (t, r) => {
                e.push(`Item ${r} is restricting item ${Array.from(t.values()).join(", ")}`)
            }
            ),
            console.log(e.join(`
`))
        }
        );
        Ne(this, "_setupSpecificItemRestrictions", () => {
            const e = this.manifestData.getAllTraitOptions();
            e.forEach(t => {
                this.itemRestrictions.set(t.id, new Set)
            }
            );
            for (const t of e) {
                if (!t._restrictedItems || t._restrictedItems.length == 0)
                    continue;
                const r = new Set;
                for (const i of t._restrictedItems) {
                    if (!e.find(o => o.id == i)) {
                        console.warn(`[${t.traitGroup.trait}] Restricted item ${i} not found`);
                        continue
                    }
                    r.add(i)
                }
                if (this.itemRestrictions.set(t.id, r),
                r.size > 0)
                    for (const i of r) {
                        const s = this.itemRestrictions.get(i);
                        s && (s.has(t.id) || s.add(t.id))
                    }
            }
            this.itemRestrictions.forEach( (t, r) => {
                t.size == 0 && this.itemRestrictions.delete(r)
            }
            )
        }
        );
        Ne(this, "createTraitRestriction", e => {
            if (this.restrictionMaps[e.trait])
                return this.restrictionMaps[e.trait];
            const t = new V0e(this,e);
            return e.restrictions = t,
            this.restrictionMaps[e.trait] = t,
            t
        }
        );
        Ne(this, "getForbiddenTraits", e => {
            const t = new Set;
            for (const r in this.restrictionMaps) {
                if (!e.includes(r))
                    continue;
                const i = this.restrictionMaps[r];
                for (const s of i.restrictedTraits)
                    t.add(s)
            }
            return Array.from(t.values())
        }
        );
        Ne(this, "getForbiddenTypes", e => {
            const t = new Set;
            for (const r in this.restrictionMaps) {
                if (!e.includes(r))
                    continue;
                const i = this.restrictionMaps[r];
                for (const s of i.restrictedTraits)
                    t.add(s)
            }
            return Array.from(t.values())
        }
        );
        Ne(this, "_validateTraitRestrictions", () => {
            const e = {};
            if (this.traitRestrictions)
                for (const t in this.traitRestrictions)
                    e[t] == null && (e[t] = {
                        restrictedTraits: [],
                        restrictedTypes: []
                    }),
                    e[t].restrictedTraits = ut(this.traitRestrictions[t].restrictedTraits).filter(r => !!r),
                    e[t].restrictedTypes = ut(this.traitRestrictions[t].restrictedTypes).filter(r => !!r);
            this.traitRestrictions = e
        }
        );
        this.manifestData = e,
        this.traitRestrictions = e.traitRestrictions || {},
        this._validateTraitRestrictions()
    }
    _init() {
        this._setupSpecificItemRestrictions(),
        this.logRules()
    }
}
class V0e {
    constructor(e, t) {
        Ne(this, "group");
        Ne(this, "restrictedTraits");
        Ne(this, "restrictedTypes");
        Ne(this, "isTraitAllowed", e => !this.restrictedTraits.has(e));
        Ne(this, "isTypeAllowed", e => !this.restrictedTypes.has(e));
        Ne(this, "isReverseTraitAllowed", e => {
            const t = this.manifestRestrictions.restrictionMaps[e];
            if (t) {
                const r = t.isTraitAllowed(this.traitId);
                return {
                    allowed: r,
                    blockingTrait: r ? void 0 : this.traitId
                }
            }
            return {
                allowed: !0,
                blockingTrait: void 0
            }
        }
        );
        Ne(this, "isReverseTypeAllowed", (e, t) => {
            if (!e)
                return {
                    allowed: !0
                };
            const r = this.manifestRestrictions.restrictionMaps[t];
            if (r) {
                const i = r.isTypeAllowed(e);
                return {
                    allowed: i,
                    blockingType: i ? void 0 : this.traitId
                }
            }
            return {
                allowed: !0
            }
        }
        );
        Ne(this, "isItemAllowed", (e, t) => {
            if (!e)
                return !0;
            const r = this.manifestRestrictions.itemRestrictions.get(e);
            return r ? !r.has(t) : !0
        }
        );
        Ne(this, "isReverseItemAllowed", (e, t) => {
            if (!e)
                return {
                    allowed: !0,
                    blockingItemId: void 0
                };
            const r = this.manifestRestrictions.itemRestrictions.get(t);
            if (r) {
                const i = !r.has(e);
                return {
                    allowed: i,
                    blockingItemId: i ? void 0 : e
                }
            }
            return {
                allowed: !0,
                blockingItemId: void 0
            }
        }
        );
        Ne(this, "isReverseAllowed", (e, t, r, i) => {
            const s = this.isReverseTraitAllowed(t)
              , o = this.isReverseTypeAllowed(e, t)
              , a = this.isReverseItemAllowed(r, i);
            return {
                allowed: s.allowed && o.allowed && a.allowed,
                blocking: {
                    blockingTrait: s.blockingTrait,
                    blockingType: o.blockingType,
                    blockingItemId: a.blockingItemId
                }
            }
        }
        );
        var r, i;
        this.manifestRestrictions = e,
        this.group = t,
        this.restrictedTraits = new Set(((r = this.manifestRestrictions.traitRestrictions[t.trait]) == null ? void 0 : r.restrictedTraits) || []),
        this.restrictedTypes = new Set(((i = this.manifestRestrictions.traitRestrictions[t.trait]) == null ? void 0 : i.restrictedTypes) || []);
        for (const s in this.manifestRestrictions.traitRestrictions) {
            if (s == t.trait)
                continue;
            const o = this.manifestRestrictions.traitRestrictions[s];
            for (const a of this.restrictedTraits) {
                const l = this.manifestRestrictions.restrictionMaps[a];
                l && (l.restrictedTraits.has(t.trait) || l.restrictedTraits.add(s))
            }
            o.restrictedTraits.includes(t.trait) && !this.restrictedTraits.has(s) && this.restrictedTraits.add(s)
        }
    }
    get manifestData() {
        return this.manifestRestrictions.manifestData
    }
    get traitId() {
        return this.group.trait
    }
}
class sM {
    constructor(e) {
        const {assetsLocation: t, traitsDirectory: r, thumbnailsDirectory: i, traitIconsDirectorySvg: s, animationPath: o, exportScale: a, displayScale: l, initialTraits: c, requiredTraits: A, randomTraits: u, colliderTraits: f, lipSyncTraits: h, blinkerTraits: d, traitRestrictions: m, defaultCullingLayer: g, defaultCullingDistance: p, offset: v, vrmMeta: w, traits: _, textureCollections: x, decalCollections: b, colorCollections: B, canDownload: S=!0, downloadOptions: I={}} = e;
        this.assetsLocation = t,
        this.traitsDirectory = r,
        this.thumbnailsDirectory = i,
        this.traitIconsDirectorySvg = s,
        this.displayScale = l || a || 1,
        this.animationPath = ut(o),
        this.requiredTraits = ut(A),
        this.randomTraits = ut(u),
        this.initialTraits = c || [...new Set(this.requiredTraits.concat(this.randomTraits))],
        this.colliderTraits = ut(f),
        this.lipSyncTraits = ut(h),
        this.blinkerTraits = ut(d),
        this.traitRestrictions = m,
        this.defaultCullingLayer = g,
        this.defaultCullingDistance = p,
        this.offset = v,
        this.canDownload = S,
        this.downloadOptions = I;
        const M = () => {
            const D = [];
            for (const T in _)
                D.push(_[T].trait);
            return D
        }
        ;
        this.allTraits = M(),
        M(),
        ( () => {
            I.vrmMeta = I.vrmMeta || w,
            I.scale = I.scale || a || 1,
            I.mToonAtlasSize = I.mToonAtlasSize || 2048,
            I.mToonAtlasSizeTransp = I.mToonAtlasSizeTransp || 1024,
            I.stdAtlasSize = I.stdAtlasSize || 2048,
            I.stdAtlasSizeTransp = I.stdAtlasSizeTransp || 1024,
            I.exportStdAtlas = I.exportStdAtlas || !1,
            I.exportMtoonAtlas = I.exportMtoonAtlas || !0,
            I.screenshotFaceDistance = I.screenshotFaceDistance || 1,
            I.screenshotFaceOffset = I.screenshotFaceOffset || [0, 0, 0],
            I.screenshotResolution = I.screenshotResolution || [512, 512],
            I.screenshotBackground = I.screenshotBackground || [.1, .1, .1],
            I.screenshotFOV = I.screenshotFOV || 75,
            !I.exportStdAtlas && !I.exportMtoonAtlas && (I.exportMtoonAtlas = !0)
        }
        )(),
        this.manifestRestrictions = new G0e(this),
        this.textureTraits = [],
        this.textureTraitsMap = null,
        this.createTextureTraits(x),
        this.decalTraits = [],
        this.decalTraitsMap = null,
        this.createDecalTraits(b),
        this.colorTraits = [],
        this.colorTraitsMap = null,
        this.createColorTraits(B),
        this.modelTraits = [],
        this.modelTraitsMap = null,
        this.createModelTraits(_),
        this.manifestRestrictions._init()
    }
    appendManifestData(e, t) {
        e.textureTraits.forEach(r => {
            const i = this.getTextureGroup(r.trait);
            i != null ? i.appendCollection(r, t) : (this.textureTraits.push(r),
            this.textureTraitsMap.set(r.trait, r))
        }
        ),
        e.colorTraits.forEach(r => {
            const i = this.getColorGroup(r.trait);
            i != null ? i.appendCollection(r, t) : (this.colorTraits.push(r),
            this.colorTraitsMap.set(r.trait, r))
        }
        ),
        e.modelTraits.forEach(r => {
            const i = this.getModelGroup(r.trait);
            i != null ? i.appendCollection(r, t) : (this.modelTraits.push(r),
            this.modelTraitsMap.set(r.trait, r))
        }
        ),
        console.log(e)
    }
    getExportOptions() {
        return this.downloadOptions
    }
    getGroupModelTraits() {
        return this.modelTraits
    }
    getInitialTraits() {
        return this.getRandomTraits(this.initialTraits)
    }
    getAllTraits() {
        return this.getRandomTraits(this.allTraits)
    }
    getTraitOptionById(e) {
        return this.getAllTraitOptions().find(t => t.id == e)
    }
    getTraitOptionsByType(e) {
        return this.getAllTraitOptions().filter(t => t.type == e)
    }
    getAllTraitOptions() {
        return this.modelTraits.map(e => e == null ? void 0 : e.getCollection()).flat()
    }
    getAllBlendShapeTraits() {
        return this.modelTraits.map(e => e.getCollection()).flat().map(e => e.blendshapeTraits).flat().map(e => e == null ? void 0 : e.collection).flat().filter(e => !!e)
    }
    isColliderRequired(e) {
        return this.colliderTraits.indexOf(e) != -1
    }
    isLipsyncTrait(e) {
        return this.lipSyncTraits.indexOf(e) != -1
    }
    async getNFTraitOptionsFromURL(e, t) {
        const r = await this._fetchJson(e);
        return this.getNFTraitOptionsFromObject(r, t)
    }
    getNFTraitOptionsFromObject(e, t) {
        const r = e.attributes;
        if (r) {
            t = ut(t);
            const i = [];
            return r.forEach(s => {
                if (t.indexOf(s.trait_type) == -1) {
                    const o = this.getTraitOption(s.trait_type, s.value);
                    o && i.push(o)
                }
            }
            ),
            i
        } else
            return console.warn("No attiributes parameter was found in ", e),
            null
    }
    getRandomTraits(e) {
        const t = [];
        return (e || this.randomTraits).forEach(i => {
            const s = this.getRandomTrait(i);
            s && t.push(s)
        }
        ),
        this._filterTraitOptions(t)
    }
    getRandomTrait(e) {
        var r, i;
        const t = this.getModelGroup(e);
        if (t) {
            const s = t.getRandomTrait();
            if (s) {
                const o = (r = s.targetTextureCollection) == null ? void 0 : r.getRandomTrait()
                  , a = (i = s.targetColorCollection) == null ? void 0 : i.getRandomTrait();
                return new oM(s,o,a)
            } else
                return null
        } else
            return console.warn("No trait group with name " + e + " was found."),
            null
    }
    async _fetchJson(e) {
        return await (await fetch(e)).json()
    }
    getTraitOption(e, t) {
        var i, s;
        const r = this.getModelTrait(e, t);
        if (r) {
            const o = (i = r.targetTextureCollection) == null ? void 0 : i.getRandomTrait()
              , a = (s = r.targetColorCollection) == null ? void 0 : s.getRandomTrait();
            return new oM(r,o,a)
        }
        return null
    }
    _filterTraitOptions(e) {
        const t = []
          , r = [];
        for (let i = 0; i < e.length; i++) {
            const s = e[i].traitModel;
            let o = !1;
            for (let a = 0; a < t.length; a++) {
                const l = t[a].traitModel;
                if (o = s.isRestricted(l),
                o)
                    break
            }
            o ? r.push(e[i]) : t.push(e[i])
        }
        return r.length > 0 && console.log("options were filtered to fullfill restrictions: ", r),
        t
    }
    getCustomTraitOption(e, t) {
        const r = this.getCustomModelTrait(e, t);
        return r ? new oM(r,null,null) : null
    }
    getCustomModelTrait(e, t) {
        var r;
        return (r = this.getModelGroup(e)) == null ? void 0 : r.getCustomTrait(t)
    }
    getModelTrait(e, t) {
        var r;
        return (r = this.getModelGroup(e)) == null ? void 0 : r.getTrait(t)
    }
    getModelTraits(e) {
        const t = this.getModelGroup(e);
        return t ? t.getCollection() : (console.warn("No model group with name " + e),
        null)
    }
    getModelGroup(e) {
        return this.modelTraitsMap.get(e)
    }
    getTextureTrait(e, t) {
        var r;
        return (r = this.getTextureGroup(e)) == null ? void 0 : r.getTrait(t)
    }
    getTextureGroup(e) {
        return this.textureTraitsMap.get(e)
    }
    getDecalTrait(e, t) {
        var r;
        return (r = this.getDecalGroup(e)) == null ? void 0 : r.getTrait(t)
    }
    getDecalGroup(e) {
        return this.decalTraitsMap.get(e)
    }
    getColorTrait(e, t) {
        var r;
        return (r = this.getColorGroup(e)) == null ? void 0 : r.getTrait(t)
    }
    getColorGroup(e) {
        return this.colorTraitsMap.get(e)
    }
    getTraitsDirectory() {
        let e = (this.assetsLocation || "") + (this.traitsDirectory || "");
        return !e.endsWith("/") && !e.endsWith("\\") && (e += "/"),
        e
    }
    getThumbnailsDirectory() {
        let e = (this.assetsLocation || "") + (this.thumbnailsDirectory || "");
        return !e.endsWith("/") && !e.endsWith("\\") && (e += "/"),
        e
    }
    getTraitIconsDirectorySvg() {
        let e = (this.assetsLocation || "") + (this.traitIconsDirectorySvg || "");
        return !e.endsWith("/") && !e.endsWith("\\") && (e += "/"),
        e
    }
    getAssetsDirectory() {
        let e = this.assetsLocation || "";
        return !e.endsWith("/") && !e.endsWith("\\") && (e += "/"),
        e
    }
    getDecalsDirectory() {
        let e = (this.assetsLocation || "") + (this.decalDirectory || "");
        return !e.endsWith("/") && !e.endsWith("\\") && (e += "/"),
        e
    }
    createModelTraits(e, t=!1) {
        t && (this.modelTraits = []);
        let r = !1;
        ut(e).forEach(i => {
            var o, a;
            const s = new j0e(this,i);
            this.modelTraits.push(s),
            r && ((o = s.getAllDecals()) != null && o.length) ? console.warn("Detected multiple traits with decals; only one trait with decals is supported at the moment") : (a = s.getAllDecals()) != null && a.length || (r = !0)
        }
        ),
        this.modelTraitsMap = new Map(this.modelTraits.map(i => [i.trait, i])),
        this.modelTraits.forEach(i => {
            this.manifestRestrictions.createTraitRestriction(i)
        }
        )
    }
    createTextureTraits(e, t=!1) {
        t && (this.textureTraits = []),
        ut(e).forEach(r => {
            this.textureTraits.push(new W0e(this,r))
        }
        ),
        this.textureTraitsMap = new Map(this.textureTraits.map(r => [r.trait, r]))
    }
    createDecalTraits(e, t=!1) {
        t && (this.decalTraits = []),
        ut(e).forEach(r => {
            this.decalTraits.push(new K0e(this,r))
        }
        ),
        this.decalTraitsMap = new Map(this.decalTraits.map(r => [r.trait, r]))
    }
    createColorTraits(e, t=!1) {
        t && (this.colorTraits = []),
        ut(e).forEach(r => {
            this.colorTraits.push(new X0e(this,r))
        }
        ),
        this.colorTraitsMap = new Map(this.colorTraits.map(r => [r.trait, r]))
    }
}
class j0e {
    constructor(e, t) {
        Ne(this, "collection");
        Ne(this, "manifestData");
        Ne(this, "restrictions");
        const {trait: r, name: i, iconSvg: s, cameraTarget: o={
            distance: 3,
            height: 1
        }, cullingDistance: a, cullingLayer: l, collection: c} = t;
        this.manifestData = e,
        this.isRequired = e.requiredTraits.indexOf(r) !== -1,
        this.trait = r,
        this.name = i,
        this.iconSvg = s,
        this.fullIconSvg = e.getTraitIconsDirectorySvg() + s,
        this.cameraTarget = o,
        this.cullingDistance = a,
        this.cullingLayer = l,
        this.collection = [],
        this.collectionMap = null,
        this.createCollection(c)
    }
    appendCollection(e, t) {
        e.collection.forEach(r => {
            const i = this.getTrait(r.id);
            if (i != null)
                if (t) {
                    console.log(`Model with id ${r.id} exists and will be replaced with new one`),
                    this.collectionMap.set(r.id, r);
                    const s = this.collection.indexOf(i);
                    this.collection[s] = r
                } else
                    console.log(`Model with id ${r.id} exists, skipping`);
            else
                this.collection.push(r),
                this.collectionMap.set(r.id, r)
        }
        )
    }
    createCollection(e, t=!1) {
        t && (this.collection = []),
        ut(e).forEach(r => {
            this.collection.push(new YO(this,r))
        }
        ),
        this.collectionMap = new Map(this.collection.map(r => [r.id, r]))
    }
    getCustomTrait(e) {
        return new YO(this,{
            directory: e,
            fullDirectory: e,
            id: "_custom",
            name: "Custom"
        })
    }
    getTrait(e) {
        return this.collectionMap.get(e)
    }
    getAllDecals() {
        return this.collection.map(t => t.targetDecalCollection).flat().map(t => t == null ? void 0 : t.collection).flat().filter(t => !!t)
    }
    getTraitByIndex(e) {
        return this.collection[e]
    }
    getRandomTrait() {
        return this.collection.length > 0 ? this.collection[Math.floor(Math.random() * this.collection.length)] : null
    }
    getCollection() {
        return this.collection
    }
}
class W0e {
    constructor(e, t) {
        const {trait: r, collection: i} = t;
        r ? this.trait = r : (console.warn("TraitTexturesGroup is missing property trait"),
        this.trait = "undefined" + Math.floor(Math.random() * 10)),
        this.manifestData = e,
        this.collection = [],
        this.collectionMap = null,
        this.createCollection(i)
    }
    appendCollection(e, t) {
        e.collection.forEach(r => {
            const i = this.getTrait(r.id);
            if (i != null)
                if (t) {
                    console.log(`Texture with id ${r.id} exists and will be replaced with new one`),
                    this.collectionMap.set(r.id, r);
                    const s = this.collection.indexOf(i);
                    this.collection[s] = r
                } else
                    console.log(`Texture with id ${r.id} exists, skipping`);
            else
                this.collection.push(r),
                this.collectionMap.set(r.id, r)
        }
        )
    }
    createCollection(e, t=!1) {
        t && (this.collection = []),
        ut(e).forEach(r => {
            this.collection.push(new lV(this,r))
        }
        ),
        this.collectionMap = new Map(this.collection.map(r => [r.id, r]))
    }
    getTrait(e) {
        return this.collectionMap.get(e)
    }
    getTraitByIndex(e) {
        return this.collection[e]
    }
    getRandomTrait() {
        return this.collection.length > 0 ? this.collection[Math.floor(Math.random() * this.collection.length)] : null
    }
}
class K0e {
    constructor(e, t) {
        Ne(this, "trait");
        Ne(this, "collection");
        Ne(this, "collectionMap");
        const {trait: r, collection: i} = t;
        this.manifestData = e,
        r ? this.trait = r : (console.warn("DecalTextureGroup is missing property trait"),
        this.trait = "undefined" + Math.floor(Math.random() * 10)),
        this.collection = [],
        this.collectionMap = null,
        this.createCollection(i)
    }
    appendCollection(e, t=!1) {
        e.collection.forEach(r => {
            const i = this.getTrait(r.id);
            if (i != null)
                if (t) {
                    console.log(`Texture with id ${r.id} exists and will be replaced with new one`),
                    this.collectionMap.set(r.id, r);
                    const s = this.collection.indexOf(i);
                    this.collection[s] = r
                } else
                    console.log(`Texture with id ${r.id} exists, skipping`);
            else
                this.collection.push(r),
                this.collectionMap.set(r.id, r)
        }
        )
    }
    createCollection(e, t=!1) {
        t && (this.collection = []),
        ut(e).forEach(r => {
            this.collection.push(new Z0e(this,r))
        }
        ),
        this.collectionMap = new Map(this.collection.map(r => [r.id, r]))
    }
    getTrait(e) {
        return this.collectionMap.get(e)
    }
    getTraitByIndex(e) {
        return this.collection[e]
    }
    getRandomTrait() {
        return this.collection.length > 0 ? this.collection[Math.floor(Math.random() * this.collection.length)] : null
    }
}
class X0e {
    constructor(e, t) {
        const {trait: r, collection: i} = t;
        this.manifestData = e,
        this.trait = r,
        this.collection = [],
        this.collectionMap = null,
        this.createCollection(i)
    }
    appendCollection(e, t) {
        e.collection.forEach(r => {
            const i = this.getTrait(r.id);
            if (i != null)
                if (t) {
                    console.log(`Color with id ${r.id} exists and will be replaced with new one`),
                    this.collectionMap.set(r.id, r);
                    const s = this.collection.indexOf(i);
                    this.collection[s] = r
                } else
                    console.log(`Color with id ${r.id} exists, skipping`);
            else
                this.collection.push(r),
                this.collectionMap.set(r.id, r)
        }
        )
    }
    createCollection(e, t=!1) {
        t && (this.collection = []),
        ut(e).forEach(r => {
            this.collection.push(new J0e(this,r))
        }
        ),
        this.collectionMap = new Map(this.collection.map(r => [r.id, r]))
    }
    getTrait(e) {
        return this.collectionMap.get(e)
    }
    getTraitByIndex(e) {
        return this.collection[e]
    }
    getRandomTrait() {
        return this.collection.length > 0 ? this.collection[Math.floor(Math.random() * this.collection.length)] : null
    }
}
class YO {
    constructor(e, t) {
        Ne(this, "type");
        Ne(this, "blendshapeTraits", []);
        Ne(this, "decalMeshNameTargets", []);
        Ne(this, "targetDecalCollection", null);
        Ne(this, "traitGroup");
        Ne(this, "blendshapeTraitsMap", new Map);
        Ne(this, "_restrictedItems", []);
        const {id: r, type: i="", directory: s, name: o, thumbnail: a, cullingDistance: l, cullingLayer: c, textureCollection: A, blendshapeTraits: u, colorCollection: f, decalCollection: h, decalMeshNameTargets: d, fullDirectory: m, fullThumbnail: g, restrictedItems: p} = t;
        if (this.manifestData = e.manifestData,
        this.traitGroup = e,
        this.decalMeshNameTargets = ut(d),
        this.id = r,
        this.directory = s,
        this._restrictedItems = p || [],
        m)
            this.fullDirectory = m;
        else if (Array.isArray(s)) {
            this.fullDirectory = [];
            for (let v = 0; v < s.length; v++)
                this.fullDirectory[v] = e.manifestData.getTraitsDirectory() + s[v]
        } else
            this.fullDirectory = e.manifestData.getTraitsDirectory() + s;
        this.name = o,
        this.thumbnail = a,
        this.fullThumbnail = g || e.manifestData.getThumbnailsDirectory() + a,
        this.cullHiddenMeshes = l || [0, 0],
        this.cullingLayer = c ?? e.cullingLayer ?? e.manifestData.defaultCullingLayer ?? 0,
        this.cullingDistance = l || e.cullingDistance || e.manifestData.defaultCullingDistance || [0, 0],
        this.type = i,
        this.targetTextureCollection = A ? e.manifestData.getTextureGroup(A) : null,
        this.targetColorCollection = f ? e.manifestData.getColorGroup(f) : null,
        this.targetDecalCollection = h ? e.manifestData.getDecalGroup(h) : null,
        u && Array.isArray(u) && (this.blendshapeTraits = u.map(v => new Y0e(this,v)),
        this.blendshapeTraitsMap = new Map(this.blendshapeTraits.map(v => [v.trait, v])))
    }
    isRestricted(e) {
        var t, r;
        return !(e == null || (t = this.traitGroup.restrictions) != null && t.isTraitAllowed(e.traitGroup.trait) || (r = this.traitGroup.restrictions) != null && r.isTypeAllowed(e.type))
    }
    getGroupBlendShapeTraits() {
        return this.blendshapeTraits
    }
    getBlendShapes(e) {
        var t, r;
        return (r = (t = this.blendshapeTraitsMap) == null ? void 0 : t.get(e)) == null ? void 0 : r.collection
    }
    getBlendShape(e, t) {
        var r, i;
        return (i = (r = this.blendshapeTraitsMap) == null ? void 0 : r.get(e)) == null ? void 0 : i.getTrait(t)
    }
}
class Y0e {
    constructor(e, t) {
        Ne(this, "trait");
        Ne(this, "name");
        Ne(this, "isBlendShapeGroup", !0);
        Ne(this, "collection", []);
        Ne(this, "cameraTarget", null);
        Ne(this, "collectionMap", null);
        const {trait: r, name: i, collection: s, cameraTarget: o=e.traitGroup.cameraTarget || {
            distance: 3,
            height: 1
        }} = t;
        this.modelTrait = e,
        this.trait = r,
        this.name = i,
        this.cameraTarget = o,
        this.createCollection(s)
    }
    createCollection(e, t=!1) {
        t && (this.collection = []),
        ut(e).forEach(r => {
            this.collection.push(new $0e(this,r))
        }
        ),
        this.collectionMap = new Map(this.collection.map(r => [r.id, r]))
    }
    getTrait(e) {
        return this.collectionMap.get(e)
    }
    getTraitByIndex(e) {
        return this.collection[e]
    }
    getRandomTrait() {
        return this.collection.length > 0 ? this.collection[Math.floor(Math.random() * this.collection.length)] : null
    }
}
class $0e {
    constructor(e, t) {
        Ne(this, "id");
        Ne(this, "name");
        Ne(this, "fullThumbnail");
        Ne(this, "isBlendShape", !0);
        const {id: r, name: i, fullThumbnail: s} = t;
        r || console.warn("BlendShapeTrait is missing id, parent trait: " + e.trait),
        i || console.warn("BlendShapeTrait is missing name, parent trait: " + e.trait),
        this.parentGroup = e,
        this.id = r,
        this.fullThumbnail = s,
        this.name = i
    }
    getGroupId() {
        return this.parentGroup.trait
    }
}
class lV {
    constructor(e, t) {
        const {id: r, directory: i, fullDirectory: s, name: o, thumbnail: a} = t;
        if (this.traitGroup = e,
        this.id = r,
        this.directory = i,
        s)
            this.fullDirectory = s;
        else if (Array.isArray(i)) {
            this.fullDirectory = [];
            for (let l = 0; l < i.length; l++)
                this.fullDirectory[l] = e.manifestData.getTraitsDirectory() + i[l]
        } else
            this.fullDirectory = e.manifestData.getTraitsDirectory() + a;
        this.name = o,
        this.thumbnail = a,
        this.fullThumbnail = e.manifestData.getThumbnailsDirectory() + a
    }
}
class Z0e extends lV {
    constructor(t, r) {
        super(t, r);
        Ne(this, "id");
        Ne(this, "directory");
        Ne(this, "fullDirectory");
        Ne(this, "name");
        Ne(this, "thumbnail");
        Ne(this, "fullThumbnail");
        Ne(this, "traitGroup");
        const {id: i, directory: s, fullDirectory: o, name: a, thumbnail: l} = r;
        if (this.traitGroup = t,
        this.id = i,
        this.directory = s,
        o)
            this.fullDirectory = o;
        else if (Array.isArray(s)) {
            this.fullDirectory = [];
            for (let c = 0; c < s.length; c++)
                this.fullDirectory[c] = t.manifestData.getTraitsDirectory() + s[c]
        } else
            this.fullDirectory = t.manifestData.getTraitsDirectory() + l;
        this.name = a,
        this.thumbnail = l,
        this.fullThumbnail = t.manifestData.getThumbnailsDirectory() + l
    }
}
class J0e {
    constructor(e, t) {
        const {id: r, value: i, name: s} = t;
        this.traitGroup = e,
        this.id = r,
        this.name = s,
        this.value = i
    }
}
class oM {
    constructor(e, t, r) {
        this.traitModel = e,
        this.traitTexture = t,
        this.traitColor = r
    }
}
const aM = new We
  , $O = new jz
  , xl = new $;
class q0e {
    constructor(e) {
        Ne(this, "emotionManager", null);
        Ne(this, "animationManager", null);
        Ne(this, "blinkManager");
        Ne(this, "screenshotManager");
        Ne(this, "toggleBinaryBlendShape", (e, t, r) => {
            e.traverse(i => {
                if (i.isMesh || i.isSkinnedMesh) {
                    const s = i;
                    if (!s.morphTargetDictionary || !s.morphTargetInfluences)
                        return;
                    const o = s.morphTargetDictionary[t.id];
                    o != null && (s.morphTargetInfluences[o] = r ? 1 : 0)
                }
            }
            )
        }
        );
        this._start(e)
    }
    async _start(e) {
        const {parentModel: t=null, renderCamera: r=null, manifestURL: i=null} = e;
        this.rootModel = new Lt,
        this.characterModel = new Lt,
        this.parentModel = t,
        t && t.add(this.rootModel),
        this.lipSync = null,
        this.lookAtManager = null,
        this.animationManager = new xge,
        this.screenshotManager = new Lge(this,t || this.rootModel),
        this.overlayedTextureManager = new z0e(this),
        this.blinkManager = new Nge(.1,.1,.5,5),
        this.emotionManager = new Oge,
        this.rootModel.add(this.characterModel),
        this.renderCamera = r,
        this.manifestData = null,
        this.manifest = null,
        i && (this.loadManifest(i),
        this.animationManager.setScale(this.manifestData.displayScale)),
        this.avatar = {},
        this.storedAvatar = {},
        this.traitLoadManager = new eve;
        const s = new ri;
        s.renderOrder = 1e4,
        this.rootModel.add(s),
        this.vrmHelperRoot = s
    }
    togglePauseSpringBoneAnimation(e) {
        for (const [t,r] of Object.entries(this.avatar))
            r.vrm.springBoneManager && (r.vrm.springBoneManager.paused = e)
    }
    update(e) {
        var t, r, i;
        if (this.lookAtManager != null && this.lookAtManager.update(),
        this.avatar) {
            for (const s in this.avatar)
                if (((t = this.avatar[s]) == null ? void 0 : t.vrm) != null) {
                    if ((r = this.avatar[s].vrm.springBoneManager) != null && r.paused)
                        return;
                    (i = this.avatar[s].vrm.springBoneManager) == null || i.update(e)
                }
        }
    }
    addLookAtMouse(e, t, r, i=!0) {
        var s;
        this.lookAtManager = new H0e(e,t,r),
        this.lookAtManager.enabled = !0;
        for (const o in this.avatar)
            ((s = this.avatar[o]) == null ? void 0 : s.vrm) != null && this.lookAtManager.addVRM(this.avatar[o].vrm)
    }
    toggleCharacterLookAtMouse(e) {
        this.lookAtManager != null ? (this.lookAtManager.setActive(e),
        this.animationManager && this.animationManager.enableMouseLook(e)) : console.warn("toggleCharacterLookAtMouse() was called, but no lookAtManager exist. Make sure to set it up first with addLookArMous()")
    }
    savePortraitScreenshot(e, t, r, i=1, s=0) {
        this.blinkManager.enableScreenshot(),
        this.characterModel.traverse(o => {
            o.isSkinnedMesh && o.skeleton.bones.filter(l => l.name === "head")[0].getWorldPosition(xl)
        }
        ),
        xl.z += .3,
        xl.y += s,
        this.screenshotManager.cameraFrameManager.setCamera(xl, i),
        this.screenshotManager.saveScreenshot(e, t, r),
        this.blinkManager.disableScreenshot()
    }
    cameraRaycastCulling(e, t, r=!0) {
        if (this.renderCamera == null) {
            console.warn("No camera was set in character manager. Please call setRenderCamera(camera) before calling this function");
            return
        }
        const i = () => {
            this.characterModel.traverse(c => {
                c.isMesh && c.userData.origIndexBuffer && (c.userData.clippedIndexGeometry = c.geometry.index.clone(),
                c.geometry.setIndex(c.userData.origIndexBuffer))
            }
            )
        }
          , s = () => {
            this.characterModel.traverse(c => {
                c.isMesh && c.userData.origIndexBuffer && c.geometry.setIndex(c.userData.clippedIndexGeometry)
            }
            )
        }
          , o = (c, A) => {
            for (let u = 0; u < c.length; u += 3)
                if (A[0] == c[u] && A[1] == c[u + 1] && A[2] == c[u + 2])
                    return u;
            return -1
        }
          , a = (c, A) => {
            var m, g;
            const u = c.object
              , f = c.face
              , h = [f.a, f.b, f.c]
              , d = (g = (m = u.userData) == null ? void 0 : m.clippedIndexGeometry) == null ? void 0 : g.array;
            if (d != null) {
                const p = o(d, h)
                  , v = Array.from(d);
                if (p == -1 && !A) {
                    const w = [...v, ...h];
                    u.userData.clippedIndexGeometry = new ct(new Uint32Array(w),1,!1)
                }
                p != 1 && A && (v.splice(p, 3),
                u.userData.clippedIndexGeometry = new ct(new Uint32Array(v),1,!1))
            }
        }
        ;
        aM.x = e,
        aM.y = t,
        i(),
        $O.setFromCamera(aM, this.renderCamera);
        const l = $O.intersectObjects(this.characterModel.children);
        if (l.length > 0) {
            const c = l[0];
            a(c, r)
        }
        s()
    }
    removeCurrentCharacter() {
        const e = [];
        for (const t in this.avatar)
            e.push(new Ow({
                traitGroupID: t,
                traitModel: null
            }));
        e.forEach(t => {
            this._addLoadedData(t)
        }
        ),
        this.avatar = {}
    }
    removeCurrentManifest() {
        this.removeCurrentCharacter(),
        this.manifest = null,
        this.manifestData = null,
        this.animationManager && this.animationManager.clearCurrentAnimations()
    }
    canDownload() {
        var e;
        return ((e = this.manifestData) == null ? void 0 : e.canDownload) || !0
    }
    downloadVRM(e, t=null) {
        return new Promise(async (r, i) => {
            if (this.canDownload())
                try {
                    t = t || {};
                    const o = {
                        ...this.manifestData.getExportOptions(),
                        ...t
                    };
                    o.screenshot = this._getPortaitScreenshotTexture(!1, o),
                    console.log(o),
                    await x0e(this.characterModel, this.avatar, e, o),
                    r()
                } catch (s) {
                    console.error("Error downloading VRM:", s.message),
                    i(new Error("Failed to download VRM."))
                }
            else {
                const s = "Download not supported.";
                console.error(s),
                i(new Error(s))
            }
        }
        )
    }
    downloadGLB(e, t=null) {
        if (console.log("XXX fix glb downloader"),
        this.canDownload()) {
            t = t || {};
            const r = {
                ...this.manifestData.getExportOptions(),
                ...t
            };
            E0e(this.characterModel, e, r)
        } else
            console.error("Download not supported")
    }
    getAvatarSelection() {
        var t;
        var e = {};
        for (const r in this.avatar)
            e[r] = {
                name: this.avatar[r].name,
                id: (t = this.avatar[r].traitInfo) == null ? void 0 : t.id
            };
        return e
    }
    getBoneTriangleCount() {
        let e = 0
          , t = new Set;
        for (const r in this.avatar)
            this.avatar[r].model.traverse(i => {
                i.isMesh && (e += i.geometry.index.array.length),
                i.isSkinnedMesh && i.skeleton.bones.forEach(s => {
                    t.add(s.name)
                }
                )
            }
            );
        return {
            triangles: e / 3,
            bones: t.size
        }
    }
    getGroupTraits() {
        if (this.manifestData)
            return this.manifestData.getGroupModelTraits()
    }
    getBlendShapeGroupTraits(e, t) {
        var r;
        return this.manifestData ? (r = this.manifestData.getModelTrait(e, t)) == null ? void 0 : r.getGroupBlendShapeTraits() : []
    }
    getCurrentCharacterModel() {
        return this.characterModel
    }
    isTraitGroupRequired(e) {
        const t = this.manifestData.getModelGroup(e);
        return !!(t != null && t.isRequired)
    }
    getTraits(e) {
        return this.manifestData ? this.manifestData.getModelTraits(e) : (console.warn("No manifest file has been loaded, please load it before trait models."),
        null)
    }
    getCurrentTraitID(e) {
        var t, r;
        return (r = (t = this.avatar[e]) == null ? void 0 : t.traitInfo) == null ? void 0 : r.id
    }
    getCurrentTraitData(e) {
        var t;
        return (t = this.avatar[e]) == null ? void 0 : t.traitInfo
    }
    getCurrentBlendShapeTraitData(e) {
        var t;
        return ((t = this.avatar[e]) == null ? void 0 : t.blendShapeTraitsInfo) || {}
    }
    getCurrentTraitVRM(e) {
        var t;
        return (t = this.avatar[e]) == null ? void 0 : t.vrm
    }
    setParentModel(e) {
        e.add(this.rootModel),
        this.parentModel = e,
        this.screenshotManager && this.screenshotManager.setScene(this.parentModel)
    }
    setRenderCamera(e) {
        this.renderCamera = e
    }
    loadRandomTraits() {
        return new Promise(async (e, t) => {
            if (this.manifestData) {
                const r = this.manifestData.getRandomTraits();
                await this._loadTraits(r),
                e()
            } else {
                const r = "No manifest was loaded, random traits cannot be loaded.";
                console.error(r),
                t(new Error(r))
            }
        }
        )
    }
    loadRandomTrait(e) {
        return new Promise(async (t, r) => {
            if (this.manifestData) {
                const i = this.manifestData.getRandomTrait(e);
                await this._loadTraits(ut(i)),
                t()
            } else {
                const i = "No manifest was loaded, random traits cannot be loaded.";
                console.error(i),
                r(new Error(i))
            }
        }
        )
    }
    loadTraitsFromNFT(e, t=!0, r=null) {
        return new Promise(async (i, s) => {
            try {
                if (this.manifestData) {
                    const o = this.manifestData.getNFTraitOptionsFromURL(e, r);
                    await this._loadTraits(o, t),
                    i()
                } else {
                    const o = "No manifest was loaded, NFT traits cannot be loaded.";
                    console.error(o),
                    s(new Error(o))
                }
            } catch (o) {
                s(o)
            }
        }
        )
    }
    loadTraitsFromNFTObject(e, t=!0, r=null) {
        return new Promise(async (i, s) => {
            if (this.manifestData)
                try {
                    const o = this.manifestData.getNFTraitOptionsFromObject(e, r);
                    await this._loadTraits(o, t),
                    i()
                } catch (o) {
                    console.error("Error loading traits from NFT object:", o.message),
                    s(new Error("Failed to load traits from NFT object."))
                }
            else {
                const o = "No manifest was loaded, NFT traits cannot be loaded.";
                console.error(o),
                s(new Error(o))
            }
        }
        )
    }
    loadInitialTraits() {
        return new Promise(async (e, t) => {
            if (this.manifestData)
                await this._loadTraits(this.manifestData.getInitialTraits()),
                e();
            else {
                const r = "No manifest was loaded, initial traits cannot be loaded.";
                console.error(r),
                t(new Error(r))
            }
        }
        )
    }
    loadAllTraits() {
        return console.log("load all"),
        new Promise(async (e, t) => {
            if (this.manifestData)
                await this._loadTraits(this.manifestData.getAllTraits()),
                e();
            else {
                const r = "No manifest was loaded, initial traits cannot be loaded.";
                console.error(r),
                t(new Error(r))
            }
        }
        )
    }
    loadBlendShapeTrait(e, t, r) {
        if (!this.avatar[e]) {
            console.warn(`Trait with name: ${e} was not found or not selected.`);
            return
        }
        if (!this.manifestData) {
            console.warn("No manifest data was found.");
            return
        }
        try {
            this._loadBlendShapeTrait(e, t, r)
        } catch {
            console.error("Error loading blendshape trait " + e, t, r)
        }
    }
    removeBlendShapeTrait(e, t) {
        this.avatar[e] ? this._loadBlendShapeTrait(e, t, null) : console.warn(`No trait with name: ${e} was found.`)
    }
    _getTraitAllowedRules(e, t) {
        var i;
        const r = [];
        for (const s in this.avatar) {
            const o = this.avatar[s]
              , a = (i = o.traitInfo.traitGroup.restrictions) == null ? void 0 : i.isReverseAllowed(o.traitInfo.type, e, o.traitInfo.id, t);
            a && !(a != null && a.allowed) && r.push(a)
        }
        return r.length ? r : [{
            allowed: !0,
            blocking: {}
        }]
    }
    _checkRestrictionsBeforeLoad(e, t) {
        const r = this._getTraitAllowedRules(e, t);
        if (!r[0].allowed)
            for (const i of r) {
                if (i.blocking.blockingTrait && this.removeTrait(i.blocking.blockingTrait),
                i.blocking.blockingItemId) {
                    const s = this.manifestData.getTraitOptionById(i.blocking.blockingItemId);
                    s && this.removeTrait(s.traitGroup.trait)
                }
                if (i.blocking.blockingType && this.manifestData.getTraitOptionsByType(i.blocking.blockingType).length)
                    for (const o in this.avatar)
                        this.avatar[o].traitInfo.type == i.blocking.blockingType && this.removeTrait(o)
            }
    }
    loadTrait(e, t, r=!1) {
        return new Promise(async (i, s) => {
            if (this.manifestData)
                try {
                    const o = this.manifestData.getTraitOption(e, t);
                    this._checkRestrictionsBeforeLoad(e, t),
                    o && (await this._loadTraits(ut(o), r),
                    i())
                } catch (o) {
                    console.error("Error loading specific trait:", o.message),
                    s(new Error("Failed to load specific trait."))
                }
            else {
                const o = "No manifest was loaded, specific trait cannot be loaded.";
                console.error(o),
                s(new Error(o))
            }
        }
        )
    }
    loadCustomTrait(e, t) {
        return new Promise(async (r, i) => {
            if (this.manifestData)
                try {
                    const s = this.manifestData.getCustomTraitOption(e, t);
                    s && (await this._loadTraits(ut(s)),
                    r())
                } catch (s) {
                    console.error("Error loading custom trait:", s.message),
                    i(new Error("Failed to load custom trait."))
                }
            else {
                const s = "No manifest was loaded, custom trait cannot be loaded.";
                console.error(s),
                i(new Error(s))
            }
        }
        )
    }
    loadCustomTexture(e, t) {
        return new Promise(async (r, i) => {
            var o;
            const s = (o = this.avatar[e]) == null ? void 0 : o.model;
            if (s)
                await Age(s, t),
                r();
            else {
                const a = "No Group Trait with name " + e + " was found.";
                console.warn(a),
                i(new Error(a))
            }
        }
        )
    }
    setTraitColor(e, t) {
        var i;
        const r = (i = this.avatar[e]) == null ? void 0 : i.model;
        if (r)
            try {
                const s = new Qe(t);
                r.traverse(o => {
                    o.isMesh && (o.material.type === "MeshStandardMaterial" ? Array.isArray(o.material) ? o.material.forEach(a => {
                        a.color = s
                    }
                    ) : o.material.color = s : (o.material[0].uniforms.litFactor.value = s,
                    o.material[0].uniforms.shadeColorFactor.value = new Qe(s.r * .8,s.g * .8,s.b * .8)))
                }
                )
            } catch (s) {
                throw console.error("Error setting trait color:", s.message),
                new Error("Failed to set trait color.")
            }
        else {
            const s = "No Group Trait with name " + e + " was found.";
            throw console.warn(s),
            new Error(s)
        }
    }
    removeTrait(e, t=!1) {
        if (this.isTraitGroupRequired(e) && !t) {
            console.warn(`No trait with name: ${e} is not removable.`);
            return
        }
        if (this.manifestData.getModelGroup(e)) {
            const i = new Ow({
                traitGroupID: e,
                traitModel: null
            });
            this._addLoadedData(i),
            qB(this.avatar)
        } else
            console.warn(`No trait with name: ${e} was found.`)
    }
    updateCullHiddenMeshes() {
        qB(this.avatar)
    }
    loadOptimizerManifest() {
        this.manifest = {
            colliderTraits: ["CUSTOM"],
            traits: [{
                name: "Custom",
                trait: "CUSTOM",
                collection: []
            }]
        },
        this.manifestData = new sM(this.manifest)
    }
    getCurrentOptimizerCharacterModel() {
        var e;
        return (e = this.avatar.CUSTOM) == null ? void 0 : e.vrm
    }
    loadOptimizerCharacter(e) {
        return this.loadCustomTrait("CUSTOM", e)
    }
    setManifest(e) {
        return this.removeCurrentCharacter(),
        new Promise(async (t, r) => {
            try {
                if (this.manifest = e,
                this.manifest) {
                    if (this.manifestData = new sM(this.manifest),
                    this.animationManager)
                        try {
                            await this._animationManagerSetup(this.manifest.animationPath, this.manifest.assetsLocation, this.manifestData.displayScale)
                        } catch (i) {
                            console.error("Error loading animations: " + i)
                        }
                    t()
                } else {
                    const i = "Failed to fetch or parse the manifest.";
                    console.error(i),
                    r(new Error(i))
                }
            } catch (i) {
                console.error("Error setting manifest:", i.message),
                r(new Error("Failed to set the manifest."))
            }
        }
        )
    }
    appendManifest(e, t) {
        return new Promise(async (r, i) => {
            try {
                t ? this.manifest = {
                    ...this.manifest || {},
                    manifest: e
                } : this.manifest = {
                    manifest: e,
                    ...this.manifest || {}
                };
                const s = new sM(e);
                this.manifestData.appendManifestData(s),
                r()
            } catch (s) {
                console.error("Error setting manifest:", s.message),
                i(new Error("Failed to set the manifest."))
            }
        }
        )
    }
    loadManifest(e) {
        return new Promise(async (t, r) => {
            try {
                const i = await this._fetchManifest(e);
                this.setManifest(i).then( () => {
                    t()
                }
                )
            } catch (i) {
                console.error("Error loading manifest:", i.message),
                r(new Error("Failed to load the manifest."))
            }
        }
        )
    }
    loadAppendManifest(e, t) {
        return new Promise(async (r, i) => {
            try {
                const s = await this._fetchManifest(e);
                this.appendManifest(s, t).then( () => {
                    r()
                }
                )
            } catch (s) {
                console.error("Error loading manifest:", s.message),
                i(new Error("Failed to load the manifest."))
            }
        }
        )
    }
    async soloTargetGroupTrait(e) {
        const t = ut(e)
          , r = [];
        for (const i in this.avatar)
            t.includes(i) && r.push(this.manifestData.getTraitOption(i, this.avatar[i].traitInfo.id));
        await this._loadTraits(r, !0)
    }
    storeCurrentAvatar() {
        this.storedAvatar = {
            ...this.avatar
        }
    }
    async loadStoredAvatar() {
        const e = [];
        for (const t in this.storedAvatar)
            e.push(this.manifestData.getTraitOption(t, this.storedAvatar[t].traitInfo.id));
        console.log(e),
        this._loadTraits(e, !0)
    }
    async _loadTraits(e, t=!1) {
        console.log("laoded traits:", e),
        await this.traitLoadManager.loadTraitOptions(ut(e)).then(r => {
            t && this.getGroupTraits().forEach(s => {
                r.some(a => {
                    var l;
                    return ((l = a.traitModel) == null ? void 0 : l.traitGroup.trait) === s.trait
                }
                ) || this.avatar[s.trait] != null && r.push(new Ow({
                    traitGroupID: s.trait,
                    traitModel: null
                }))
            }
            ),
            r.forEach(i => {
                this._addLoadedData(i)
            }
            ),
            qB(this.avatar)
        }
        )
    }
    async _loadBlendShapeTrait(e, t, r) {
        const i = this.avatar[e];
        if (!i) {
            console.warn(`Trait with name: ${e} was not found or not selected.`);
            return
        }
        if (i.blendShapeTraitsInfo || (i.blendShapeTraitsInfo = {}),
        i.blendShapeTraitsInfo[t] && this.toggleBinaryBlendShape(i.model, i.blendShapeTraitsInfo[t], !1),
        r == null) {
            delete this.avatar[e].blendShapeTraitsInfo[t];
            return
        }
        const s = i.traitInfo.getBlendShape(t, r);
        if (!s) {
            console.warn(`Blendshape with name: ${r} was not found.`);
            return
        }
        this.toggleBinaryBlendShape(i.model, s, !0),
        this.avatar[e].blendShapeTraitsInfo[s.getGroupId()] = s
    }
    async _animationManagerSetup(e, t, r) {
        const i = ut(e);
        this.animationManager && (this.animationManager.setScale(r),
        e.length > 0 && (this.animationManager.storeAnimationPaths(i, t || ""),
        await this.animationManager.loadAnimation(i, !1, 0, i[0].endsWith(".fbx"), t || "")))
    }
    async _fetchManifest(e) {
        return await (await fetch(e)).json()
    }
    _getPortaitScreenshotTexture(e, t) {
        this.blinkManager.enableScreenshot(),
        this.characterModel.traverse(u => {
            u.isSkinnedMesh && u.skeleton.bones.filter(h => h.name === "head")[0].getWorldPosition(xl)
        }
        );
        const {screenshotResolution: r, screenshotFaceDistance: i, screenshotFaceOffset: s, screenshotBackground: o, screenshotFOV: a} = t
          , l = r[0]
          , c = r[1];
        xl.x += s[0],
        xl.y += s[1],
        xl.z += s[2],
        this.screenshotManager.setBackground(o),
        this.screenshotManager.cameraFrameManager.setCamera(xl, i, a);
        const A = e ? this.screenshotManager.getScreenshotBlob(l, c) : this.screenshotManager.getScreenshotTexture(l, c);
        return this.blinkManager.disableScreenshot(),
        A
    }
    _setupWireframeMaterial(e) {
        e.origMat = e.material;
        const t = () => {
            const o = .1 + Math.random() * .9
              , a = .1 + Math.random() * (1 - .1)
              , l = .1 + Math.random() * (1 - .1);
            return new Qe(o,a,l)
        }
          , r = new qi({
            color: t(),
            wireframe: !0,
            wireframeLinewidth: .2
        })
          , i = e.material;
        e.setDebugMode = s => {
            s ? e.material.length ? (e.material[0] = r,
            e.material[1] = r) : e.material = r : e.material = i
        }
    }
    _VRMBaseSetup(e, t, r, i, s) {
        var a, l;
        let o = e.userData.vrm;
        if (e.userData.vrm == null)
            return console.error("No valid VRM was provided for " + r + " trait, skipping file."),
            null;
        if (NO(o, {
            isVRM0: ((a = o.meta) == null ? void 0 : a.metaVersion) === "0"
        }),
        this.manifestData.isColliderRequired(r) && N0e(e),
        this._applySpringBoneColliders(o),
        mge(o),
        D0e(e),
        this._unregisterMorphTargetsFromManifest(o),
        this.manifestData.isLipsyncTrait(r) && (this.lipSync = new ax(o)),
        this._modelBaseSetup(o, t, r, i, s),
        ((l = o.meta) == null ? void 0 : l.metaVersion) === "0") {
            if (o.humanoid.humanBones.hips.node.parent == o.scene) {
                const c = new Lt;
                c.name = "newRootNode",
                cge(o.scene, c),
                c.add(o.humanoid.humanBones.hips.node)
            }
            o.humanoid.humanBones.hips.node.parent.rotateY(3.14159),
            o.scene.traverse(c => {
                if (c.isSkinnedMesh) {
                    for (let A = 0; A < c.skeleton.bones.length; A++)
                        c.skeleton.bones[A].userData.vrm0RestPosition = {
                            ...c.skeleton.bones[A].position
                        };
                    c.userData.isVRM0 = !0
                }
            }
            ),
            console.log("Loaded VRM0 file ", o)
        } else
            console.log("Loaded VRM1 file ", o);
        return o
    }
    _applySpringBoneColliders(e) {
        function t(s) {
            e.springBoneManager.joints.forEach(o => {
                for (const a of s) {
                    const l = o.colliderGroups.find(c => c.name == a.name);
                    if (l) {
                        if (a.colliders.length != l.colliders.length) {
                            const c = a.colliders.filter(A => !l.colliders.find(u => u.name == A.name));
                            l.colliders.push(...c)
                        }
                    } else
                        o.colliderGroups.push(a)
                }
            }
            )
        }
        const i = ( () => {
            const s = [];
            return Object.entries(this.avatar).map( ([o,a]) => {
                const l = Q0e(a.vrm);
                l.length !== 0 && l.forEach(c => {
                    if (!e.springBoneManager)
                        return;
                    const A = {
                        colliders: [],
                        name: c.name
                    };
                    for (const u of c.children)
                        u instanceof Lw && A.colliders.indexOf(u) === -1 && A.colliders.push(u);
                    if (A.colliders.length) {
                        const u = s.find(f => f.name == A.name);
                        if (u && u.colliders.length != A.colliders.length) {
                            const f = A.colliders.filter(h => !u.colliders.find(d => d.name == h.name));
                            u.colliders.push(...f)
                        } else
                            u || s.push(A)
                    }
                }
                )
            }
            ),
            s
        }
        )();
        t(i)
    }
    _unregisterMorphTargetsFromManifest(e) {
        var s;
        const t = this.manifestData.getAllBlendShapeTraits()
          , r = (s = e.expressionManager) == null ? void 0 : s.expressions;
        if (t.length == 0 || !r)
            return;
        const i = [];
        for (const o of r)
            t.map(a => a.id).includes(o.expressionName) && i.push(o);
        for (const o of i)
            e.expressionManager.unregisterExpression(o)
    }
    _modelBaseSetup(e, t, r, i, s) {
        const o = []
          , a = ut(t.cullingIgnore)
          , l = [];
        t.meshTargets && ut(t.meshTargets).map(u => {
            const f = e.scene.getObjectByName(u);
            f != null && f.isMesh && o.push(f)
        }
        ),
        e.scene.traverse(u => {
            !t.meshTargets && u.isMesh && o.push(u),
            u.frustumCulled = !1,
            u.isMesh && (this._setupWireframeMaterial(u),
            a.indexOf(u.name) === -1 && l.push(u))
        }
        );
        const c = this.manifest
          , A = this.manifestData.getModelGroup(r);
        NO(e, {
            cullingLayer: t.cullingLayer != null ? t.cullingLayer : A.cullingLayer != null ? A.cullingLayer : c.defaultCullingLayer != null ? c.defaultCullingLayer : -1,
            cullingDistance: t.cullingDistance != null ? t.cullingDistance : A.cullingDistance != null ? A.cullingDistance : c.defaultCullingDistance != null ? c.defaultCullingDistance : null,
            maxCullingDistance: t.maxCullingDistance != null ? t.maxCullingDistance : A.maxCullingDistance != null ? A.maxCullingDistance : c.maxCullingDistance != null ? c.maxCullingDistance : 1 / 0,
            cullingMeshes: l
        }),
        o.map( (u, f) => {
            if (i) {
                const h = i[f] || i[0];
                h != null && ut(u.material).map(d => {
                    tve(d, h)
                }
                )
            }
            if (s) {
                const h = s[f] || s[0];
                h != null && (u.material[0].uniforms.litFactor.value = h,
                u.material[0].uniforms.shadeColorFactor.value = new Qe(h.r * .8,h.g * .8,h.b * .8))
            }
        }
        )
    }
    _applyManagers(e) {
        this.blinkManager.addVRM(e),
        this.emotionManager.addVRM(e),
        this.lookAtManager && this.lookAtManager.addVRM(e),
        this.animationManager && this.animationManager.addVRM(e)
    }
    _displayModel(e) {
        if (e) {
            const t = e.scene;
            this.characterModel.attach(t)
        }
    }
    _positionModel(e) {
        const t = this.manifestData.displayScale;
        e.scene.scale.set(t, t, t)
    }
    _disposeTrait(e) {
        this.blinkManager.removeVRM(e),
        this.emotionManager.removeVRM(e),
        this.lookAtManager && this.lookAtManager.removeVRM(e),
        this.animationManager && this.animationManager.removeVRM(e),
        pge(e)
    }
    _addLoadedData(e) {
        const {traitGroupID: t, traitModel: r, textureTrait: i, colorTrait: s, models: o, textures: a, colors: l} = e;
        if (r == null) {
            this.avatar[t] && this.avatar[t].vrm && (this._disposeTrait(this.avatar[t].vrm),
            delete this.avatar[t]);
            return
        }
        let c = null;
        o.map(A => {
            A != null && (c = this._VRMBaseSetup(A, r, t, a, l))
        }
        ),
        c != null && (this.avatar[t] && this.avatar[t].vrm && this._disposeTrait(this.avatar[t].vrm),
        this._positionModel(c),
        this._displayModel(c),
        this._applyManagers(c),
        this.overlayedTextureManager && r.targetDecalCollection && this.overlayedTextureManager.setTargetVRM(c, r.decalMeshNameTargets),
        this.avatar[t] = {
            traitInfo: r,
            blendShapeTraitsInfo: {},
            textureInfo: i,
            colorInfo: s,
            name: r.name,
            model: c && c.scene,
            vrm: c
        })
    }
}
class eve {
    constructor() {
        const e = new Hz;
        e.onProgress = (i, s, o) => {
            this.setLoadPercentage(Math.round(s / o * 100))
        }
        ;
        const t = new Xz(e);
        t.crossOrigin = "anonymous",
        t.register(i => new dpe(i,{
            autoUpdateHumanBones: !0
        }));
        const r = new PA(e);
        this.loadPercentager = 0,
        this.loadingManager = e,
        this.gltfLoader = t,
        this.textureLoader = r,
        this.isLoading = !1
    }
    setLoadPercentage(e) {
        this.loadPercentager = e
    }
    loadTraitOptions(e) {
        return new Promise(t => {
            this.isLoading = !0;
            const r = []
              , i = e.map(async (s, o) => {
                var A, u, f;
                if (s == null) {
                    r[o] = null;
                    return
                }
                const a = await Promise.all(ut((A = s == null ? void 0 : s.traitModel) == null ? void 0 : A.fullDirectory).map(async h => {
                    try {
                        return await this.gltfLoader.loadAsync(h)
                    } catch (d) {
                        return console.error(`Error loading modelsss ${h}:`, d),
                        null
                    }
                }
                ))
                  , l = await Promise.all(ut((u = s == null ? void 0 : s.traitTexture) == null ? void 0 : u.fullDirectory).map(h => new Promise(d => {
                    this.textureLoader.load(h, m => {
                        m.flipY = !1,
                        m.colorSpace = Ut,
                        d(m)
                    }
                    , null, m => {
                        console.error("error loading texture: ", m),
                        d(null)
                    }
                    )
                }
                )))
                  , c = ut((f = s == null ? void 0 : s.traitColor) == null ? void 0 : f.value).map(h => new Qe(h));
                r[o] = new Ow({
                    traitGroupID: s == null ? void 0 : s.traitModel.traitGroup.trait,
                    traitModel: s == null ? void 0 : s.traitModel,
                    textureTrait: s == null ? void 0 : s.traitTexture,
                    colorTrait: s == null ? void 0 : s.traitColor,
                    models: a,
                    textures: l,
                    colors: c
                })
            }
            );
            Promise.allSettled(i).then( () => {
                this.setLoadPercentage(100),
                t(r),
                this.isLoading = !1
            }
            ).catch(s => {
                this.setLoadPercentage(100),
                console.error("An error occurred:", s),
                t(r),
                this.isLoading = !1
            }
            )
        }
        )
    }
}
class Ow {
    constructor(e) {
        const {traitGroupID: t, traitModel: r, textureTrait: i, colorTrait: s, models: o, textures: a, colors: l} = e;
        this.traitGroupID = t,
        this.traitModel = r,
        this.textureTrait = i,
        this.colorTrait = s,
        this.models = o,
        this.textures = a,
        this.colors = l
    }
}
function tve(n, e) {
    if (n.type === "Shadermaterial" && !n.isMToonMaterial) {
        console.warn("XXX set material texture to shader material", n);
        return
    }
    n.map = e,
    n.needsUpdate = !0
}
class nve extends roe {
    constructor(e) {
        super(e),
        this.type = Ha
    }
    parse(e) {
        const o = function(S, I) {
            switch (S) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (I || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (I || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (I || ""));
            default:
            case 4:
                throw new Error("THREE.RGBELoader: Memory Error: " + (I || ""))
            }
        }
          , A = `
`
          , u = function(S, I, M) {
            I = I || 1024;
            let D = S.pos
              , T = -1
              , y = 0
              , E = ""
              , R = String.fromCharCode.apply(null, new Uint16Array(S.subarray(D, D + 128)));
            for (; 0 > (T = R.indexOf(A)) && y < I && D < S.byteLength; )
                E += R,
                y += R.length,
                D += 128,
                R += String.fromCharCode.apply(null, new Uint16Array(S.subarray(D, D + 128)));
            return -1 < T ? (M !== !1 && (S.pos += y + T + 1),
            E + R.slice(0, T)) : !1
        }
          , f = function(S) {
            const I = /^#\?(\S+)/
              , M = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , L = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , D = /^\s*FORMAT=(\S+)\s*$/
              , T = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , y = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let E, R;
            for ((S.pos >= S.byteLength || !(E = u(S))) && o(1, "no header found"),
            (R = E.match(I)) || o(3, "bad initial token"),
            y.valid |= 1,
            y.programtype = R[1],
            y.string += E + `
`; E = u(S),
            E !== !1; ) {
                if (y.string += E + `
`,
                E.charAt(0) === "#") {
                    y.comments += E + `
`;
                    continue
                }
                if ((R = E.match(M)) && (y.gamma = parseFloat(R[1])),
                (R = E.match(L)) && (y.exposure = parseFloat(R[1])),
                (R = E.match(D)) && (y.valid |= 2,
                y.format = R[1]),
                (R = E.match(T)) && (y.valid |= 4,
                y.height = parseInt(R[1], 10),
                y.width = parseInt(R[2], 10)),
                y.valid & 2 && y.valid & 4)
                    break
            }
            return y.valid & 2 || o(3, "missing format specifier"),
            y.valid & 4 || o(3, "missing image size specifier"),
            y
        }
          , h = function(S, I, M) {
            const L = I;
            if (L < 8 || L > 32767 || S[0] !== 2 || S[1] !== 2 || S[2] & 128)
                return new Uint8Array(S);
            L !== (S[2] << 8 | S[3]) && o(3, "wrong scanline width");
            const D = new Uint8Array(4 * I * M);
            D.length || o(4, "unable to allocate buffer space");
            let T = 0
              , y = 0;
            const E = 4 * L
              , R = new Uint8Array(4)
              , F = new Uint8Array(E);
            let O = M;
            for (; O > 0 && y < S.byteLength; ) {
                y + 4 > S.byteLength && o(1),
                R[0] = S[y++],
                R[1] = S[y++],
                R[2] = S[y++],
                R[3] = S[y++],
                (R[0] != 2 || R[1] != 2 || (R[2] << 8 | R[3]) != L) && o(3, "bad rgbe scanline format");
                let z = 0, j;
                for (; z < E && y < S.byteLength; ) {
                    j = S[y++];
                    const C = j > 128;
                    if (C && (j -= 128),
                    (j === 0 || z + j > E) && o(3, "bad scanline data"),
                    C) {
                        const W = S[y++];
                        for (let ee = 0; ee < j; ee++)
                            F[z++] = W
                    } else
                        F.set(S.subarray(y, y + j), z),
                        z += j,
                        y += j
                }
                const Q = L;
                for (let C = 0; C < Q; C++) {
                    let W = 0;
                    D[T] = F[C + W],
                    W += L,
                    D[T + 1] = F[C + W],
                    W += L,
                    D[T + 2] = F[C + W],
                    W += L,
                    D[T + 3] = F[C + W],
                    T += 4
                }
                O--
            }
            return D
        }
          , d = function(S, I, M, L) {
            const D = S[I + 3]
              , T = Math.pow(2, D - 128) / 255;
            M[L + 0] = S[I + 0] * T,
            M[L + 1] = S[I + 1] * T,
            M[L + 2] = S[I + 2] * T,
            M[L + 3] = 1
        }
          , m = function(S, I, M, L) {
            const D = S[I + 3]
              , T = Math.pow(2, D - 128) / 255;
            M[L + 0] = wv.toHalfFloat(Math.min(S[I + 0] * T, 65504)),
            M[L + 1] = wv.toHalfFloat(Math.min(S[I + 1] * T, 65504)),
            M[L + 2] = wv.toHalfFloat(Math.min(S[I + 2] * T, 65504)),
            M[L + 3] = wv.toHalfFloat(1)
        }
          , g = new Uint8Array(e);
        g.pos = 0;
        const p = f(g)
          , v = p.width
          , w = p.height
          , _ = h(g.subarray(g.pos), v, w);
        let x, b, B;
        switch (this.type) {
        case xi:
            B = _.length / 4;
            const S = new Float32Array(B * 4);
            for (let M = 0; M < B; M++)
                d(_, M * 4, S, M * 4);
            x = S,
            b = xi;
            break;
        case Ha:
            B = _.length / 4;
            const I = new Uint16Array(B * 4);
            for (let M = 0; M < B; M++)
                m(_, M * 4, I, M * 4);
            x = I,
            b = Ha;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: v,
            height: w,
            data: x,
            header: p.string,
            gamma: p.gamma,
            exposure: p.exposure,
            type: b
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, r, i) {
        function s(o, a) {
            switch (o.type) {
            case xi:
            case Ha:
                o.colorSpace = Sr,
                o.minFilter = Lr,
                o.magFilter = Lr,
                o.generateMipmaps = !1,
                o.flipY = !0;
                break
            }
            t && t(o, a)
        }
        return super.load(e, s, r, i)
    }
}
function rve(n) {
    const e = new Gg;
    new nve().load("./public/hdr/studio_small_09_2k.hdr", p => {
        p.mapping = kg,
        p.colorSpace = Sr,
        e.environment = p
    }
    ),
    e.environmentIntensity = .5;
    const t = new Vz(16777215,.8);
    e.add(t);
    const r = new WR(16777215,.8);
    r.position.set(0, 1, 1),
    e.add(r);
    const i = new Lt;
    e.add(i);
    const s = new Fr(30,window.innerWidth / window.innerHeight,.1,1e3);
    s.position.set(0, 1.3, 2);
    const o = new q0e({
        parentModel: e,
        createAnimationManager: !0,
        renderCamera: s
    });
    o.addLookAtMouse(80, n, s, !0);
    const a = document.getElementById(n)
      , l = new y0({
        canvas: a,
        antialias: !0,
        alpha: !0,
        preserveDrawingBuffer: !0
    })
      , c = new Eoe(s,l.domElement);
    c.minDistance = 1,
    c.maxDistance = 4,
    c.maxPolarAngle = Math.PI / 2,
    c.enablePan = !0,
    c.target = new $(0,1,0),
    c.enableDamping = !0,
    c.dampingFactor = .1;
    const A = new $(-.5,0,-.5)
      , u = new $(.5,1.7,.5)
      , f = () => {
        l.setSize(window.innerWidth, window.innerHeight),
        s.aspect = window.innerWidth / window.innerHeight,
        s.updateProjectionMatrix()
    }
    ;
    window.addEventListener("resize", f),
    l.setSize(window.innerWidth, window.innerHeight),
    l.setPixelRatio(window.devicePixelRatio),
    l.outputColorSpace = Ut;
    const h = new w1
      , d = () => {
        requestAnimationFrame(d);
        const p = h.getDelta();
        c.target.clamp(A, u),
        c == null || c.update(),
        o.update(p),
        l.render(e, s)
    }
    ;
    d();
    const m = p => {
        const v = p.ctrlKey
          , w = a.getBoundingClientRect()
          , _ = (p.clientX - w.left) / w.width * 2 - 1
          , x = -((p.clientY - w.top) / w.height) * 2 + 1;
        o.cameraRaycastCulling(_, x, v)
    }
    ;
    async function g() {}
    return g(),
    a.addEventListener("click", m),
    {
        scene: e,
        camera: s,
        controls: c,
        characterManager: o,
        sceneElements: i,
        clock: h
    }
}
function Ny(n) {
    throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var cV = {
    exports: {}
};
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, e) {
    (function(t) {
        n.exports = t()
    }
    )(function() {
        return function t(r, i, s) {
            function o(c, A) {
                if (!i[c]) {
                    if (!r[c]) {
                        var u = typeof Ny == "function" && Ny;
                        if (!A && u)
                            return u(c, !0);
                        if (a)
                            return a(c, !0);
                        var f = new Error("Cannot find module '" + c + "'");
                        throw f.code = "MODULE_NOT_FOUND",
                        f
                    }
                    var h = i[c] = {
                        exports: {}
                    };
                    r[c][0].call(h.exports, function(d) {
                        var m = r[c][1][d];
                        return o(m || d)
                    }, h, h.exports, t, r, i, s)
                }
                return i[c].exports
            }
            for (var a = typeof Ny == "function" && Ny, l = 0; l < s.length; l++)
                o(s[l]);
            return o
        }({
            1: [function(t, r, i) {
                var s = t("./utils")
                  , o = t("./support")
                  , a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                i.encode = function(l) {
                    for (var c, A, u, f, h, d, m, g = [], p = 0, v = l.length, w = v, _ = s.getTypeOf(l) !== "string"; p < l.length; )
                        w = v - p,
                        u = _ ? (c = l[p++],
                        A = p < v ? l[p++] : 0,
                        p < v ? l[p++] : 0) : (c = l.charCodeAt(p++),
                        A = p < v ? l.charCodeAt(p++) : 0,
                        p < v ? l.charCodeAt(p++) : 0),
                        f = c >> 2,
                        h = (3 & c) << 4 | A >> 4,
                        d = 1 < w ? (15 & A) << 2 | u >> 6 : 64,
                        m = 2 < w ? 63 & u : 64,
                        g.push(a.charAt(f) + a.charAt(h) + a.charAt(d) + a.charAt(m));
                    return g.join("")
                }
                ,
                i.decode = function(l) {
                    var c, A, u, f, h, d, m = 0, g = 0, p = "data:";
                    if (l.substr(0, p.length) === p)
                        throw new Error("Invalid base64 input, it looks like a data url.");
                    var v, w = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
                    if (l.charAt(l.length - 1) === a.charAt(64) && w--,
                    l.charAt(l.length - 2) === a.charAt(64) && w--,
                    w % 1 != 0)
                        throw new Error("Invalid base64 input, bad content length.");
                    for (v = o.uint8array ? new Uint8Array(0 | w) : new Array(0 | w); m < l.length; )
                        c = a.indexOf(l.charAt(m++)) << 2 | (f = a.indexOf(l.charAt(m++))) >> 4,
                        A = (15 & f) << 4 | (h = a.indexOf(l.charAt(m++))) >> 2,
                        u = (3 & h) << 6 | (d = a.indexOf(l.charAt(m++))),
                        v[g++] = c,
                        h !== 64 && (v[g++] = A),
                        d !== 64 && (v[g++] = u);
                    return v
                }
            }
            , {
                "./support": 30,
                "./utils": 32
            }],
            2: [function(t, r, i) {
                var s = t("./external")
                  , o = t("./stream/DataWorker")
                  , a = t("./stream/Crc32Probe")
                  , l = t("./stream/DataLengthProbe");
                function c(A, u, f, h, d) {
                    this.compressedSize = A,
                    this.uncompressedSize = u,
                    this.crc32 = f,
                    this.compression = h,
                    this.compressedContent = d
                }
                c.prototype = {
                    getContentWorker: function() {
                        var A = new o(s.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length"))
                          , u = this;
                        return A.on("end", function() {
                            if (this.streamInfo.data_length !== u.uncompressedSize)
                                throw new Error("Bug : uncompressed data size mismatch")
                        }),
                        A
                    },
                    getCompressedWorker: function() {
                        return new o(s.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression)
                    }
                },
                c.createWorkerFrom = function(A, u, f) {
                    return A.pipe(new a).pipe(new l("uncompressedSize")).pipe(u.compressWorker(f)).pipe(new l("compressedSize")).withStreamInfo("compression", u)
                }
                ,
                r.exports = c
            }
            , {
                "./external": 6,
                "./stream/Crc32Probe": 25,
                "./stream/DataLengthProbe": 26,
                "./stream/DataWorker": 27
            }],
            3: [function(t, r, i) {
                var s = t("./stream/GenericWorker");
                i.STORE = {
                    magic: "\0\0",
                    compressWorker: function() {
                        return new s("STORE compression")
                    },
                    uncompressWorker: function() {
                        return new s("STORE decompression")
                    }
                },
                i.DEFLATE = t("./flate")
            }
            , {
                "./flate": 7,
                "./stream/GenericWorker": 28
            }],
            4: [function(t, r, i) {
                var s = t("./utils")
                  , o = function() {
                    for (var a, l = [], c = 0; c < 256; c++) {
                        a = c;
                        for (var A = 0; A < 8; A++)
                            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
                        l[c] = a
                    }
                    return l
                }();
                r.exports = function(a, l) {
                    return a !== void 0 && a.length ? s.getTypeOf(a) !== "string" ? function(c, A, u, f) {
                        var h = o
                          , d = f + u;
                        c ^= -1;
                        for (var m = f; m < d; m++)
                            c = c >>> 8 ^ h[255 & (c ^ A[m])];
                        return -1 ^ c
                    }(0 | l, a, a.length, 0) : function(c, A, u, f) {
                        var h = o
                          , d = f + u;
                        c ^= -1;
                        for (var m = f; m < d; m++)
                            c = c >>> 8 ^ h[255 & (c ^ A.charCodeAt(m))];
                        return -1 ^ c
                    }(0 | l, a, a.length, 0) : 0
                }
            }
            , {
                "./utils": 32
            }],
            5: [function(t, r, i) {
                i.base64 = !1,
                i.binary = !1,
                i.dir = !1,
                i.createFolders = !0,
                i.date = null,
                i.compression = null,
                i.compressionOptions = null,
                i.comment = null,
                i.unixPermissions = null,
                i.dosPermissions = null
            }
            , {}],
            6: [function(t, r, i) {
                var s = null;
                s = typeof Promise < "u" ? Promise : t("lie"),
                r.exports = {
                    Promise: s
                }
            }
            , {
                lie: 37
            }],
            7: [function(t, r, i) {
                var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u"
                  , o = t("pako")
                  , a = t("./utils")
                  , l = t("./stream/GenericWorker")
                  , c = s ? "uint8array" : "array";
                function A(u, f) {
                    l.call(this, "FlateWorker/" + u),
                    this._pako = null,
                    this._pakoAction = u,
                    this._pakoOptions = f,
                    this.meta = {}
                }
                i.magic = "\b\0",
                a.inherits(A, l),
                A.prototype.processChunk = function(u) {
                    this.meta = u.meta,
                    this._pako === null && this._createPako(),
                    this._pako.push(a.transformTo(c, u.data), !1)
                }
                ,
                A.prototype.flush = function() {
                    l.prototype.flush.call(this),
                    this._pako === null && this._createPako(),
                    this._pako.push([], !0)
                }
                ,
                A.prototype.cleanUp = function() {
                    l.prototype.cleanUp.call(this),
                    this._pako = null
                }
                ,
                A.prototype._createPako = function() {
                    this._pako = new o[this._pakoAction]({
                        raw: !0,
                        level: this._pakoOptions.level || -1
                    });
                    var u = this;
                    this._pako.onData = function(f) {
                        u.push({
                            data: f,
                            meta: u.meta
                        })
                    }
                }
                ,
                i.compressWorker = function(u) {
                    return new A("Deflate",u)
                }
                ,
                i.uncompressWorker = function() {
                    return new A("Inflate",{})
                }
            }
            , {
                "./stream/GenericWorker": 28,
                "./utils": 32,
                pako: 38
            }],
            8: [function(t, r, i) {
                function s(h, d) {
                    var m, g = "";
                    for (m = 0; m < d; m++)
                        g += String.fromCharCode(255 & h),
                        h >>>= 8;
                    return g
                }
                function o(h, d, m, g, p, v) {
                    var w, _, x = h.file, b = h.compression, B = v !== c.utf8encode, S = a.transformTo("string", v(x.name)), I = a.transformTo("string", c.utf8encode(x.name)), M = x.comment, L = a.transformTo("string", v(M)), D = a.transformTo("string", c.utf8encode(M)), T = I.length !== x.name.length, y = D.length !== M.length, E = "", R = "", F = "", O = x.dir, z = x.date, j = {
                        crc32: 0,
                        compressedSize: 0,
                        uncompressedSize: 0
                    };
                    d && !m || (j.crc32 = h.crc32,
                    j.compressedSize = h.compressedSize,
                    j.uncompressedSize = h.uncompressedSize);
                    var Q = 0;
                    d && (Q |= 8),
                    B || !T && !y || (Q |= 2048);
                    var C = 0
                      , W = 0;
                    O && (C |= 16),
                    p === "UNIX" ? (W = 798,
                    C |= function(P, re) {
                        var ue = P;
                        return P || (ue = re ? 16893 : 33204),
                        (65535 & ue) << 16
                    }(x.unixPermissions, O)) : (W = 20,
                    C |= function(P) {
                        return 63 & (P || 0)
                    }(x.dosPermissions)),
                    w = z.getUTCHours(),
                    w <<= 6,
                    w |= z.getUTCMinutes(),
                    w <<= 5,
                    w |= z.getUTCSeconds() / 2,
                    _ = z.getUTCFullYear() - 1980,
                    _ <<= 4,
                    _ |= z.getUTCMonth() + 1,
                    _ <<= 5,
                    _ |= z.getUTCDate(),
                    T && (R = s(1, 1) + s(A(S), 4) + I,
                    E += "up" + s(R.length, 2) + R),
                    y && (F = s(1, 1) + s(A(L), 4) + D,
                    E += "uc" + s(F.length, 2) + F);
                    var ee = "";
                    return ee += `
\0`,
                    ee += s(Q, 2),
                    ee += b.magic,
                    ee += s(w, 2),
                    ee += s(_, 2),
                    ee += s(j.crc32, 4),
                    ee += s(j.compressedSize, 4),
                    ee += s(j.uncompressedSize, 4),
                    ee += s(S.length, 2),
                    ee += s(E.length, 2),
                    {
                        fileRecord: u.LOCAL_FILE_HEADER + ee + S + E,
                        dirRecord: u.CENTRAL_FILE_HEADER + s(W, 2) + ee + s(L.length, 2) + "\0\0\0\0" + s(C, 4) + s(g, 4) + S + E + L
                    }
                }
                var a = t("../utils")
                  , l = t("../stream/GenericWorker")
                  , c = t("../utf8")
                  , A = t("../crc32")
                  , u = t("../signature");
                function f(h, d, m, g) {
                    l.call(this, "ZipFileWorker"),
                    this.bytesWritten = 0,
                    this.zipComment = d,
                    this.zipPlatform = m,
                    this.encodeFileName = g,
                    this.streamFiles = h,
                    this.accumulate = !1,
                    this.contentBuffer = [],
                    this.dirRecords = [],
                    this.currentSourceOffset = 0,
                    this.entriesCount = 0,
                    this.currentFile = null,
                    this._sources = []
                }
                a.inherits(f, l),
                f.prototype.push = function(h) {
                    var d = h.meta.percent || 0
                      , m = this.entriesCount
                      , g = this._sources.length;
                    this.accumulate ? this.contentBuffer.push(h) : (this.bytesWritten += h.data.length,
                    l.prototype.push.call(this, {
                        data: h.data,
                        meta: {
                            currentFile: this.currentFile,
                            percent: m ? (d + 100 * (m - g - 1)) / m : 100
                        }
                    }))
                }
                ,
                f.prototype.openedSource = function(h) {
                    this.currentSourceOffset = this.bytesWritten,
                    this.currentFile = h.file.name;
                    var d = this.streamFiles && !h.file.dir;
                    if (d) {
                        var m = o(h, d, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                        this.push({
                            data: m.fileRecord,
                            meta: {
                                percent: 0
                            }
                        })
                    } else
                        this.accumulate = !0
                }
                ,
                f.prototype.closedSource = function(h) {
                    this.accumulate = !1;
                    var d = this.streamFiles && !h.file.dir
                      , m = o(h, d, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    if (this.dirRecords.push(m.dirRecord),
                    d)
                        this.push({
                            data: function(g) {
                                return u.DATA_DESCRIPTOR + s(g.crc32, 4) + s(g.compressedSize, 4) + s(g.uncompressedSize, 4)
                            }(h),
                            meta: {
                                percent: 100
                            }
                        });
                    else
                        for (this.push({
                            data: m.fileRecord,
                            meta: {
                                percent: 0
                            }
                        }); this.contentBuffer.length; )
                            this.push(this.contentBuffer.shift());
                    this.currentFile = null
                }
                ,
                f.prototype.flush = function() {
                    for (var h = this.bytesWritten, d = 0; d < this.dirRecords.length; d++)
                        this.push({
                            data: this.dirRecords[d],
                            meta: {
                                percent: 100
                            }
                        });
                    var m = this.bytesWritten - h
                      , g = function(p, v, w, _, x) {
                        var b = a.transformTo("string", x(_));
                        return u.CENTRAL_DIRECTORY_END + "\0\0\0\0" + s(p, 2) + s(p, 2) + s(v, 4) + s(w, 4) + s(b.length, 2) + b
                    }(this.dirRecords.length, m, h, this.zipComment, this.encodeFileName);
                    this.push({
                        data: g,
                        meta: {
                            percent: 100
                        }
                    })
                }
                ,
                f.prototype.prepareNextSource = function() {
                    this.previous = this._sources.shift(),
                    this.openedSource(this.previous.streamInfo),
                    this.isPaused ? this.previous.pause() : this.previous.resume()
                }
                ,
                f.prototype.registerPrevious = function(h) {
                    this._sources.push(h);
                    var d = this;
                    return h.on("data", function(m) {
                        d.processChunk(m)
                    }),
                    h.on("end", function() {
                        d.closedSource(d.previous.streamInfo),
                        d._sources.length ? d.prepareNextSource() : d.end()
                    }),
                    h.on("error", function(m) {
                        d.error(m)
                    }),
                    this
                }
                ,
                f.prototype.resume = function() {
                    return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(),
                    !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(),
                    !0))
                }
                ,
                f.prototype.error = function(h) {
                    var d = this._sources;
                    if (!l.prototype.error.call(this, h))
                        return !1;
                    for (var m = 0; m < d.length; m++)
                        try {
                            d[m].error(h)
                        } catch {}
                    return !0
                }
                ,
                f.prototype.lock = function() {
                    l.prototype.lock.call(this);
                    for (var h = this._sources, d = 0; d < h.length; d++)
                        h[d].lock()
                }
                ,
                r.exports = f
            }
            , {
                "../crc32": 4,
                "../signature": 23,
                "../stream/GenericWorker": 28,
                "../utf8": 31,
                "../utils": 32
            }],
            9: [function(t, r, i) {
                var s = t("../compressions")
                  , o = t("./ZipFileWorker");
                i.generateWorker = function(a, l, c) {
                    var A = new o(l.streamFiles,c,l.platform,l.encodeFileName)
                      , u = 0;
                    try {
                        a.forEach(function(f, h) {
                            u++;
                            var d = function(v, w) {
                                var _ = v || w
                                  , x = s[_];
                                if (!x)
                                    throw new Error(_ + " is not a valid compression method !");
                                return x
                            }(h.options.compression, l.compression)
                              , m = h.options.compressionOptions || l.compressionOptions || {}
                              , g = h.dir
                              , p = h.date;
                            h._compressWorker(d, m).withStreamInfo("file", {
                                name: f,
                                dir: g,
                                date: p,
                                comment: h.comment || "",
                                unixPermissions: h.unixPermissions,
                                dosPermissions: h.dosPermissions
                            }).pipe(A)
                        }),
                        A.entriesCount = u
                    } catch (f) {
                        A.error(f)
                    }
                    return A
                }
            }
            , {
                "../compressions": 3,
                "./ZipFileWorker": 8
            }],
            10: [function(t, r, i) {
                function s() {
                    if (!(this instanceof s))
                        return new s;
                    if (arguments.length)
                        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                    this.files = Object.create(null),
                    this.comment = null,
                    this.root = "",
                    this.clone = function() {
                        var o = new s;
                        for (var a in this)
                            typeof this[a] != "function" && (o[a] = this[a]);
                        return o
                    }
                }
                (s.prototype = t("./object")).loadAsync = t("./load"),
                s.support = t("./support"),
                s.defaults = t("./defaults"),
                s.version = "3.10.1",
                s.loadAsync = function(o, a) {
                    return new s().loadAsync(o, a)
                }
                ,
                s.external = t("./external"),
                r.exports = s
            }
            , {
                "./defaults": 5,
                "./external": 6,
                "./load": 11,
                "./object": 15,
                "./support": 30
            }],
            11: [function(t, r, i) {
                var s = t("./utils")
                  , o = t("./external")
                  , a = t("./utf8")
                  , l = t("./zipEntries")
                  , c = t("./stream/Crc32Probe")
                  , A = t("./nodejsUtils");
                function u(f) {
                    return new o.Promise(function(h, d) {
                        var m = f.decompressed.getContentWorker().pipe(new c);
                        m.on("error", function(g) {
                            d(g)
                        }).on("end", function() {
                            m.streamInfo.crc32 !== f.decompressed.crc32 ? d(new Error("Corrupted zip : CRC32 mismatch")) : h()
                        }).resume()
                    }
                    )
                }
                r.exports = function(f, h) {
                    var d = this;
                    return h = s.extend(h || {}, {
                        base64: !1,
                        checkCRC32: !1,
                        optimizedBinaryString: !1,
                        createFolders: !1,
                        decodeFileName: a.utf8decode
                    }),
                    A.isNode && A.isStream(f) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : s.prepareContent("the loaded zip file", f, !0, h.optimizedBinaryString, h.base64).then(function(m) {
                        var g = new l(h);
                        return g.load(m),
                        g
                    }).then(function(m) {
                        var g = [o.Promise.resolve(m)]
                          , p = m.files;
                        if (h.checkCRC32)
                            for (var v = 0; v < p.length; v++)
                                g.push(u(p[v]));
                        return o.Promise.all(g)
                    }).then(function(m) {
                        for (var g = m.shift(), p = g.files, v = 0; v < p.length; v++) {
                            var w = p[v]
                              , _ = w.fileNameStr
                              , x = s.resolve(w.fileNameStr);
                            d.file(x, w.decompressed, {
                                binary: !0,
                                optimizedBinaryString: !0,
                                date: w.date,
                                dir: w.dir,
                                comment: w.fileCommentStr.length ? w.fileCommentStr : null,
                                unixPermissions: w.unixPermissions,
                                dosPermissions: w.dosPermissions,
                                createFolders: h.createFolders
                            }),
                            w.dir || (d.file(x).unsafeOriginalName = _)
                        }
                        return g.zipComment.length && (d.comment = g.zipComment),
                        d
                    })
                }
            }
            , {
                "./external": 6,
                "./nodejsUtils": 14,
                "./stream/Crc32Probe": 25,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntries": 33
            }],
            12: [function(t, r, i) {
                var s = t("../utils")
                  , o = t("../stream/GenericWorker");
                function a(l, c) {
                    o.call(this, "Nodejs stream input adapter for " + l),
                    this._upstreamEnded = !1,
                    this._bindStream(c)
                }
                s.inherits(a, o),
                a.prototype._bindStream = function(l) {
                    var c = this;
                    (this._stream = l).pause(),
                    l.on("data", function(A) {
                        c.push({
                            data: A,
                            meta: {
                                percent: 0
                            }
                        })
                    }).on("error", function(A) {
                        c.isPaused ? this.generatedError = A : c.error(A)
                    }).on("end", function() {
                        c.isPaused ? c._upstreamEnded = !0 : c.end()
                    })
                }
                ,
                a.prototype.pause = function() {
                    return !!o.prototype.pause.call(this) && (this._stream.pause(),
                    !0)
                }
                ,
                a.prototype.resume = function() {
                    return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(),
                    !0)
                }
                ,
                r.exports = a
            }
            , {
                "../stream/GenericWorker": 28,
                "../utils": 32
            }],
            13: [function(t, r, i) {
                var s = t("readable-stream").Readable;
                function o(a, l, c) {
                    s.call(this, l),
                    this._helper = a;
                    var A = this;
                    a.on("data", function(u, f) {
                        A.push(u) || A._helper.pause(),
                        c && c(f)
                    }).on("error", function(u) {
                        A.emit("error", u)
                    }).on("end", function() {
                        A.push(null)
                    })
                }
                t("../utils").inherits(o, s),
                o.prototype._read = function() {
                    this._helper.resume()
                }
                ,
                r.exports = o
            }
            , {
                "../utils": 32,
                "readable-stream": 16
            }],
            14: [function(t, r, i) {
                r.exports = {
                    isNode: typeof Buffer < "u",
                    newBufferFrom: function(s, o) {
                        if (Buffer.from && Buffer.from !== Uint8Array.from)
                            return Buffer.from(s, o);
                        if (typeof s == "number")
                            throw new Error('The "data" argument must not be a number');
                        return new Buffer(s,o)
                    },
                    allocBuffer: function(s) {
                        if (Buffer.alloc)
                            return Buffer.alloc(s);
                        var o = new Buffer(s);
                        return o.fill(0),
                        o
                    },
                    isBuffer: function(s) {
                        return Buffer.isBuffer(s)
                    },
                    isStream: function(s) {
                        return s && typeof s.on == "function" && typeof s.pause == "function" && typeof s.resume == "function"
                    }
                }
            }
            , {}],
            15: [function(t, r, i) {
                function s(x, b, B) {
                    var S, I = a.getTypeOf(b), M = a.extend(B || {}, A);
                    M.date = M.date || new Date,
                    M.compression !== null && (M.compression = M.compression.toUpperCase()),
                    typeof M.unixPermissions == "string" && (M.unixPermissions = parseInt(M.unixPermissions, 8)),
                    M.unixPermissions && 16384 & M.unixPermissions && (M.dir = !0),
                    M.dosPermissions && 16 & M.dosPermissions && (M.dir = !0),
                    M.dir && (x = p(x)),
                    M.createFolders && (S = g(x)) && v.call(this, S, !0);
                    var L = I === "string" && M.binary === !1 && M.base64 === !1;
                    B && B.binary !== void 0 || (M.binary = !L),
                    (b instanceof u && b.uncompressedSize === 0 || M.dir || !b || b.length === 0) && (M.base64 = !1,
                    M.binary = !0,
                    b = "",
                    M.compression = "STORE",
                    I = "string");
                    var D = null;
                    D = b instanceof u || b instanceof l ? b : d.isNode && d.isStream(b) ? new m(x,b) : a.prepareContent(x, b, M.binary, M.optimizedBinaryString, M.base64);
                    var T = new f(x,D,M);
                    this.files[x] = T
                }
                var o = t("./utf8")
                  , a = t("./utils")
                  , l = t("./stream/GenericWorker")
                  , c = t("./stream/StreamHelper")
                  , A = t("./defaults")
                  , u = t("./compressedObject")
                  , f = t("./zipObject")
                  , h = t("./generate")
                  , d = t("./nodejsUtils")
                  , m = t("./nodejs/NodejsStreamInputAdapter")
                  , g = function(x) {
                    x.slice(-1) === "/" && (x = x.substring(0, x.length - 1));
                    var b = x.lastIndexOf("/");
                    return 0 < b ? x.substring(0, b) : ""
                }
                  , p = function(x) {
                    return x.slice(-1) !== "/" && (x += "/"),
                    x
                }
                  , v = function(x, b) {
                    return b = b !== void 0 ? b : A.createFolders,
                    x = p(x),
                    this.files[x] || s.call(this, x, null, {
                        dir: !0,
                        createFolders: b
                    }),
                    this.files[x]
                };
                function w(x) {
                    return Object.prototype.toString.call(x) === "[object RegExp]"
                }
                var _ = {
                    load: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                    },
                    forEach: function(x) {
                        var b, B, S;
                        for (b in this.files)
                            S = this.files[b],
                            (B = b.slice(this.root.length, b.length)) && b.slice(0, this.root.length) === this.root && x(B, S)
                    },
                    filter: function(x) {
                        var b = [];
                        return this.forEach(function(B, S) {
                            x(B, S) && b.push(S)
                        }),
                        b
                    },
                    file: function(x, b, B) {
                        if (arguments.length !== 1)
                            return x = this.root + x,
                            s.call(this, x, b, B),
                            this;
                        if (w(x)) {
                            var S = x;
                            return this.filter(function(M, L) {
                                return !L.dir && S.test(M)
                            })
                        }
                        var I = this.files[this.root + x];
                        return I && !I.dir ? I : null
                    },
                    folder: function(x) {
                        if (!x)
                            return this;
                        if (w(x))
                            return this.filter(function(I, M) {
                                return M.dir && x.test(I)
                            });
                        var b = this.root + x
                          , B = v.call(this, b)
                          , S = this.clone();
                        return S.root = B.name,
                        S
                    },
                    remove: function(x) {
                        x = this.root + x;
                        var b = this.files[x];
                        if (b || (x.slice(-1) !== "/" && (x += "/"),
                        b = this.files[x]),
                        b && !b.dir)
                            delete this.files[x];
                        else
                            for (var B = this.filter(function(I, M) {
                                return M.name.slice(0, x.length) === x
                            }), S = 0; S < B.length; S++)
                                delete this.files[B[S].name];
                        return this
                    },
                    generate: function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                    },
                    generateInternalStream: function(x) {
                        var b, B = {};
                        try {
                            if ((B = a.extend(x || {}, {
                                streamFiles: !1,
                                compression: "STORE",
                                compressionOptions: null,
                                type: "",
                                platform: "DOS",
                                comment: null,
                                mimeType: "application/zip",
                                encodeFileName: o.utf8encode
                            })).type = B.type.toLowerCase(),
                            B.compression = B.compression.toUpperCase(),
                            B.type === "binarystring" && (B.type = "string"),
                            !B.type)
                                throw new Error("No output type specified.");
                            a.checkSupport(B.type),
                            B.platform !== "darwin" && B.platform !== "freebsd" && B.platform !== "linux" && B.platform !== "sunos" || (B.platform = "UNIX"),
                            B.platform === "win32" && (B.platform = "DOS");
                            var S = B.comment || this.comment || "";
                            b = h.generateWorker(this, B, S)
                        } catch (I) {
                            (b = new l("error")).error(I)
                        }
                        return new c(b,B.type || "string",B.mimeType)
                    },
                    generateAsync: function(x, b) {
                        return this.generateInternalStream(x).accumulate(b)
                    },
                    generateNodeStream: function(x, b) {
                        return (x = x || {}).type || (x.type = "nodebuffer"),
                        this.generateInternalStream(x).toNodejsStream(b)
                    }
                };
                r.exports = _
            }
            , {
                "./compressedObject": 2,
                "./defaults": 5,
                "./generate": 9,
                "./nodejs/NodejsStreamInputAdapter": 12,
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
                "./utils": 32,
                "./zipObject": 35
            }],
            16: [function(t, r, i) {
                r.exports = t("stream")
            }
            , {
                stream: void 0
            }],
            17: [function(t, r, i) {
                var s = t("./DataReader");
                function o(a) {
                    s.call(this, a);
                    for (var l = 0; l < this.data.length; l++)
                        a[l] = 255 & a[l]
                }
                t("../utils").inherits(o, s),
                o.prototype.byteAt = function(a) {
                    return this.data[this.zero + a]
                }
                ,
                o.prototype.lastIndexOfSignature = function(a) {
                    for (var l = a.charCodeAt(0), c = a.charCodeAt(1), A = a.charCodeAt(2), u = a.charCodeAt(3), f = this.length - 4; 0 <= f; --f)
                        if (this.data[f] === l && this.data[f + 1] === c && this.data[f + 2] === A && this.data[f + 3] === u)
                            return f - this.zero;
                    return -1
                }
                ,
                o.prototype.readAndCheckSignature = function(a) {
                    var l = a.charCodeAt(0)
                      , c = a.charCodeAt(1)
                      , A = a.charCodeAt(2)
                      , u = a.charCodeAt(3)
                      , f = this.readData(4);
                    return l === f[0] && c === f[1] && A === f[2] && u === f[3]
                }
                ,
                o.prototype.readData = function(a) {
                    if (this.checkOffset(a),
                    a === 0)
                        return [];
                    var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
                    return this.index += a,
                    l
                }
                ,
                r.exports = o
            }
            , {
                "../utils": 32,
                "./DataReader": 18
            }],
            18: [function(t, r, i) {
                var s = t("../utils");
                function o(a) {
                    this.data = a,
                    this.length = a.length,
                    this.index = 0,
                    this.zero = 0
                }
                o.prototype = {
                    checkOffset: function(a) {
                        this.checkIndex(this.index + a)
                    },
                    checkIndex: function(a) {
                        if (this.length < this.zero + a || a < 0)
                            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?")
                    },
                    setIndex: function(a) {
                        this.checkIndex(a),
                        this.index = a
                    },
                    skip: function(a) {
                        this.setIndex(this.index + a)
                    },
                    byteAt: function() {},
                    readInt: function(a) {
                        var l, c = 0;
                        for (this.checkOffset(a),
                        l = this.index + a - 1; l >= this.index; l--)
                            c = (c << 8) + this.byteAt(l);
                        return this.index += a,
                        c
                    },
                    readString: function(a) {
                        return s.transformTo("string", this.readData(a))
                    },
                    readData: function() {},
                    lastIndexOfSignature: function() {},
                    readAndCheckSignature: function() {},
                    readDate: function() {
                        var a = this.readInt(4);
                        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1))
                    }
                },
                r.exports = o
            }
            , {
                "../utils": 32
            }],
            19: [function(t, r, i) {
                var s = t("./Uint8ArrayReader");
                function o(a) {
                    s.call(this, a)
                }
                t("../utils").inherits(o, s),
                o.prototype.readData = function(a) {
                    this.checkOffset(a);
                    var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
                    return this.index += a,
                    l
                }
                ,
                r.exports = o
            }
            , {
                "../utils": 32,
                "./Uint8ArrayReader": 21
            }],
            20: [function(t, r, i) {
                var s = t("./DataReader");
                function o(a) {
                    s.call(this, a)
                }
                t("../utils").inherits(o, s),
                o.prototype.byteAt = function(a) {
                    return this.data.charCodeAt(this.zero + a)
                }
                ,
                o.prototype.lastIndexOfSignature = function(a) {
                    return this.data.lastIndexOf(a) - this.zero
                }
                ,
                o.prototype.readAndCheckSignature = function(a) {
                    return a === this.readData(4)
                }
                ,
                o.prototype.readData = function(a) {
                    this.checkOffset(a);
                    var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
                    return this.index += a,
                    l
                }
                ,
                r.exports = o
            }
            , {
                "../utils": 32,
                "./DataReader": 18
            }],
            21: [function(t, r, i) {
                var s = t("./ArrayReader");
                function o(a) {
                    s.call(this, a)
                }
                t("../utils").inherits(o, s),
                o.prototype.readData = function(a) {
                    if (this.checkOffset(a),
                    a === 0)
                        return new Uint8Array(0);
                    var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
                    return this.index += a,
                    l
                }
                ,
                r.exports = o
            }
            , {
                "../utils": 32,
                "./ArrayReader": 17
            }],
            22: [function(t, r, i) {
                var s = t("../utils")
                  , o = t("../support")
                  , a = t("./ArrayReader")
                  , l = t("./StringReader")
                  , c = t("./NodeBufferReader")
                  , A = t("./Uint8ArrayReader");
                r.exports = function(u) {
                    var f = s.getTypeOf(u);
                    return s.checkSupport(f),
                    f !== "string" || o.uint8array ? f === "nodebuffer" ? new c(u) : o.uint8array ? new A(s.transformTo("uint8array", u)) : new a(s.transformTo("array", u)) : new l(u)
                }
            }
            , {
                "../support": 30,
                "../utils": 32,
                "./ArrayReader": 17,
                "./NodeBufferReader": 19,
                "./StringReader": 20,
                "./Uint8ArrayReader": 21
            }],
            23: [function(t, r, i) {
                i.LOCAL_FILE_HEADER = "PK",
                i.CENTRAL_FILE_HEADER = "PK",
                i.CENTRAL_DIRECTORY_END = "PK",
                i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07",
                i.ZIP64_CENTRAL_DIRECTORY_END = "PK",
                i.DATA_DESCRIPTOR = "PK\x07\b"
            }
            , {}],
            24: [function(t, r, i) {
                var s = t("./GenericWorker")
                  , o = t("../utils");
                function a(l) {
                    s.call(this, "ConvertWorker to " + l),
                    this.destType = l
                }
                o.inherits(a, s),
                a.prototype.processChunk = function(l) {
                    this.push({
                        data: o.transformTo(this.destType, l.data),
                        meta: l.meta
                    })
                }
                ,
                r.exports = a
            }
            , {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            25: [function(t, r, i) {
                var s = t("./GenericWorker")
                  , o = t("../crc32");
                function a() {
                    s.call(this, "Crc32Probe"),
                    this.withStreamInfo("crc32", 0)
                }
                t("../utils").inherits(a, s),
                a.prototype.processChunk = function(l) {
                    this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0),
                    this.push(l)
                }
                ,
                r.exports = a
            }
            , {
                "../crc32": 4,
                "../utils": 32,
                "./GenericWorker": 28
            }],
            26: [function(t, r, i) {
                var s = t("../utils")
                  , o = t("./GenericWorker");
                function a(l) {
                    o.call(this, "DataLengthProbe for " + l),
                    this.propName = l,
                    this.withStreamInfo(l, 0)
                }
                s.inherits(a, o),
                a.prototype.processChunk = function(l) {
                    if (l) {
                        var c = this.streamInfo[this.propName] || 0;
                        this.streamInfo[this.propName] = c + l.data.length
                    }
                    o.prototype.processChunk.call(this, l)
                }
                ,
                r.exports = a
            }
            , {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            27: [function(t, r, i) {
                var s = t("../utils")
                  , o = t("./GenericWorker");
                function a(l) {
                    o.call(this, "DataWorker");
                    var c = this;
                    this.dataIsReady = !1,
                    this.index = 0,
                    this.max = 0,
                    this.data = null,
                    this.type = "",
                    this._tickScheduled = !1,
                    l.then(function(A) {
                        c.dataIsReady = !0,
                        c.data = A,
                        c.max = A && A.length || 0,
                        c.type = s.getTypeOf(A),
                        c.isPaused || c._tickAndRepeat()
                    }, function(A) {
                        c.error(A)
                    })
                }
                s.inherits(a, o),
                a.prototype.cleanUp = function() {
                    o.prototype.cleanUp.call(this),
                    this.data = null
                }
                ,
                a.prototype.resume = function() {
                    return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0,
                    s.delay(this._tickAndRepeat, [], this)),
                    !0)
                }
                ,
                a.prototype._tickAndRepeat = function() {
                    this._tickScheduled = !1,
                    this.isPaused || this.isFinished || (this._tick(),
                    this.isFinished || (s.delay(this._tickAndRepeat, [], this),
                    this._tickScheduled = !0))
                }
                ,
                a.prototype._tick = function() {
                    if (this.isPaused || this.isFinished)
                        return !1;
                    var l = null
                      , c = Math.min(this.max, this.index + 16384);
                    if (this.index >= this.max)
                        return this.end();
                    switch (this.type) {
                    case "string":
                        l = this.data.substring(this.index, c);
                        break;
                    case "uint8array":
                        l = this.data.subarray(this.index, c);
                        break;
                    case "array":
                    case "nodebuffer":
                        l = this.data.slice(this.index, c)
                    }
                    return this.index = c,
                    this.push({
                        data: l,
                        meta: {
                            percent: this.max ? this.index / this.max * 100 : 0
                        }
                    })
                }
                ,
                r.exports = a
            }
            , {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            28: [function(t, r, i) {
                function s(o) {
                    this.name = o || "default",
                    this.streamInfo = {},
                    this.generatedError = null,
                    this.extraStreamInfo = {},
                    this.isPaused = !0,
                    this.isFinished = !1,
                    this.isLocked = !1,
                    this._listeners = {
                        data: [],
                        end: [],
                        error: []
                    },
                    this.previous = null
                }
                s.prototype = {
                    push: function(o) {
                        this.emit("data", o)
                    },
                    end: function() {
                        if (this.isFinished)
                            return !1;
                        this.flush();
                        try {
                            this.emit("end"),
                            this.cleanUp(),
                            this.isFinished = !0
                        } catch (o) {
                            this.emit("error", o)
                        }
                        return !0
                    },
                    error: function(o) {
                        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0,
                        this.emit("error", o),
                        this.previous && this.previous.error(o),
                        this.cleanUp()),
                        !0)
                    },
                    on: function(o, a) {
                        return this._listeners[o].push(a),
                        this
                    },
                    cleanUp: function() {
                        this.streamInfo = this.generatedError = this.extraStreamInfo = null,
                        this._listeners = []
                    },
                    emit: function(o, a) {
                        if (this._listeners[o])
                            for (var l = 0; l < this._listeners[o].length; l++)
                                this._listeners[o][l].call(this, a)
                    },
                    pipe: function(o) {
                        return o.registerPrevious(this)
                    },
                    registerPrevious: function(o) {
                        if (this.isLocked)
                            throw new Error("The stream '" + this + "' has already been used.");
                        this.streamInfo = o.streamInfo,
                        this.mergeStreamInfo(),
                        this.previous = o;
                        var a = this;
                        return o.on("data", function(l) {
                            a.processChunk(l)
                        }),
                        o.on("end", function() {
                            a.end()
                        }),
                        o.on("error", function(l) {
                            a.error(l)
                        }),
                        this
                    },
                    pause: function() {
                        return !this.isPaused && !this.isFinished && (this.isPaused = !0,
                        this.previous && this.previous.pause(),
                        !0)
                    },
                    resume: function() {
                        if (!this.isPaused || this.isFinished)
                            return !1;
                        var o = this.isPaused = !1;
                        return this.generatedError && (this.error(this.generatedError),
                        o = !0),
                        this.previous && this.previous.resume(),
                        !o
                    },
                    flush: function() {},
                    processChunk: function(o) {
                        this.push(o)
                    },
                    withStreamInfo: function(o, a) {
                        return this.extraStreamInfo[o] = a,
                        this.mergeStreamInfo(),
                        this
                    },
                    mergeStreamInfo: function() {
                        for (var o in this.extraStreamInfo)
                            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o])
                    },
                    lock: function() {
                        if (this.isLocked)
                            throw new Error("The stream '" + this + "' has already been used.");
                        this.isLocked = !0,
                        this.previous && this.previous.lock()
                    },
                    toString: function() {
                        var o = "Worker " + this.name;
                        return this.previous ? this.previous + " -> " + o : o
                    }
                },
                r.exports = s
            }
            , {}],
            29: [function(t, r, i) {
                var s = t("../utils")
                  , o = t("./ConvertWorker")
                  , a = t("./GenericWorker")
                  , l = t("../base64")
                  , c = t("../support")
                  , A = t("../external")
                  , u = null;
                if (c.nodestream)
                    try {
                        u = t("../nodejs/NodejsStreamOutputAdapter")
                    } catch {}
                function f(d, m) {
                    return new A.Promise(function(g, p) {
                        var v = []
                          , w = d._internalType
                          , _ = d._outputType
                          , x = d._mimeType;
                        d.on("data", function(b, B) {
                            v.push(b),
                            m && m(B)
                        }).on("error", function(b) {
                            v = [],
                            p(b)
                        }).on("end", function() {
                            try {
                                var b = function(B, S, I) {
                                    switch (B) {
                                    case "blob":
                                        return s.newBlob(s.transformTo("arraybuffer", S), I);
                                    case "base64":
                                        return l.encode(S);
                                    default:
                                        return s.transformTo(B, S)
                                    }
                                }(_, function(B, S) {
                                    var I, M = 0, L = null, D = 0;
                                    for (I = 0; I < S.length; I++)
                                        D += S[I].length;
                                    switch (B) {
                                    case "string":
                                        return S.join("");
                                    case "array":
                                        return Array.prototype.concat.apply([], S);
                                    case "uint8array":
                                        for (L = new Uint8Array(D),
                                        I = 0; I < S.length; I++)
                                            L.set(S[I], M),
                                            M += S[I].length;
                                        return L;
                                    case "nodebuffer":
                                        return Buffer.concat(S);
                                    default:
                                        throw new Error("concat : unsupported type '" + B + "'")
                                    }
                                }(w, v), x);
                                g(b)
                            } catch (B) {
                                p(B)
                            }
                            v = []
                        }).resume()
                    }
                    )
                }
                function h(d, m, g) {
                    var p = m;
                    switch (m) {
                    case "blob":
                    case "arraybuffer":
                        p = "uint8array";
                        break;
                    case "base64":
                        p = "string"
                    }
                    try {
                        this._internalType = p,
                        this._outputType = m,
                        this._mimeType = g,
                        s.checkSupport(p),
                        this._worker = d.pipe(new o(p)),
                        d.lock()
                    } catch (v) {
                        this._worker = new a("error"),
                        this._worker.error(v)
                    }
                }
                h.prototype = {
                    accumulate: function(d) {
                        return f(this, d)
                    },
                    on: function(d, m) {
                        var g = this;
                        return d === "data" ? this._worker.on(d, function(p) {
                            m.call(g, p.data, p.meta)
                        }) : this._worker.on(d, function() {
                            s.delay(m, arguments, g)
                        }),
                        this
                    },
                    resume: function() {
                        return s.delay(this._worker.resume, [], this._worker),
                        this
                    },
                    pause: function() {
                        return this._worker.pause(),
                        this
                    },
                    toNodejsStream: function(d) {
                        if (s.checkSupport("nodestream"),
                        this._outputType !== "nodebuffer")
                            throw new Error(this._outputType + " is not supported by this method");
                        return new u(this,{
                            objectMode: this._outputType !== "nodebuffer"
                        },d)
                    }
                },
                r.exports = h
            }
            , {
                "../base64": 1,
                "../external": 6,
                "../nodejs/NodejsStreamOutputAdapter": 13,
                "../support": 30,
                "../utils": 32,
                "./ConvertWorker": 24,
                "./GenericWorker": 28
            }],
            30: [function(t, r, i) {
                if (i.base64 = !0,
                i.array = !0,
                i.string = !0,
                i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u",
                i.nodebuffer = typeof Buffer < "u",
                i.uint8array = typeof Uint8Array < "u",
                typeof ArrayBuffer > "u")
                    i.blob = !1;
                else {
                    var s = new ArrayBuffer(0);
                    try {
                        i.blob = new Blob([s],{
                            type: "application/zip"
                        }).size === 0
                    } catch {
                        try {
                            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            o.append(s),
                            i.blob = o.getBlob("application/zip").size === 0
                        } catch {
                            i.blob = !1
                        }
                    }
                }
                try {
                    i.nodestream = !!t("readable-stream").Readable
                } catch {
                    i.nodestream = !1
                }
            }
            , {
                "readable-stream": 16
            }],
            31: [function(t, r, i) {
                for (var s = t("./utils"), o = t("./support"), a = t("./nodejsUtils"), l = t("./stream/GenericWorker"), c = new Array(256), A = 0; A < 256; A++)
                    c[A] = 252 <= A ? 6 : 248 <= A ? 5 : 240 <= A ? 4 : 224 <= A ? 3 : 192 <= A ? 2 : 1;
                c[254] = c[254] = 1;
                function u() {
                    l.call(this, "utf-8 decode"),
                    this.leftOver = null
                }
                function f() {
                    l.call(this, "utf-8 encode")
                }
                i.utf8encode = function(h) {
                    return o.nodebuffer ? a.newBufferFrom(h, "utf-8") : function(d) {
                        var m, g, p, v, w, _ = d.length, x = 0;
                        for (v = 0; v < _; v++)
                            (64512 & (g = d.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (p = d.charCodeAt(v + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (p - 56320),
                            v++),
                            x += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
                        for (m = o.uint8array ? new Uint8Array(x) : new Array(x),
                        v = w = 0; w < x; v++)
                            (64512 & (g = d.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (p = d.charCodeAt(v + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (p - 56320),
                            v++),
                            g < 128 ? m[w++] = g : (g < 2048 ? m[w++] = 192 | g >>> 6 : (g < 65536 ? m[w++] = 224 | g >>> 12 : (m[w++] = 240 | g >>> 18,
                            m[w++] = 128 | g >>> 12 & 63),
                            m[w++] = 128 | g >>> 6 & 63),
                            m[w++] = 128 | 63 & g);
                        return m
                    }(h)
                }
                ,
                i.utf8decode = function(h) {
                    return o.nodebuffer ? s.transformTo("nodebuffer", h).toString("utf-8") : function(d) {
                        var m, g, p, v, w = d.length, _ = new Array(2 * w);
                        for (m = g = 0; m < w; )
                            if ((p = d[m++]) < 128)
                                _[g++] = p;
                            else if (4 < (v = c[p]))
                                _[g++] = 65533,
                                m += v - 1;
                            else {
                                for (p &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && m < w; )
                                    p = p << 6 | 63 & d[m++],
                                    v--;
                                1 < v ? _[g++] = 65533 : p < 65536 ? _[g++] = p : (p -= 65536,
                                _[g++] = 55296 | p >> 10 & 1023,
                                _[g++] = 56320 | 1023 & p)
                            }
                        return _.length !== g && (_.subarray ? _ = _.subarray(0, g) : _.length = g),
                        s.applyFromCharCode(_)
                    }(h = s.transformTo(o.uint8array ? "uint8array" : "array", h))
                }
                ,
                s.inherits(u, l),
                u.prototype.processChunk = function(h) {
                    var d = s.transformTo(o.uint8array ? "uint8array" : "array", h.data);
                    if (this.leftOver && this.leftOver.length) {
                        if (o.uint8array) {
                            var m = d;
                            (d = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0),
                            d.set(m, this.leftOver.length)
                        } else
                            d = this.leftOver.concat(d);
                        this.leftOver = null
                    }
                    var g = function(v, w) {
                        var _;
                        for ((w = w || v.length) > v.length && (w = v.length),
                        _ = w - 1; 0 <= _ && (192 & v[_]) == 128; )
                            _--;
                        return _ < 0 || _ === 0 ? w : _ + c[v[_]] > w ? _ : w
                    }(d)
                      , p = d;
                    g !== d.length && (o.uint8array ? (p = d.subarray(0, g),
                    this.leftOver = d.subarray(g, d.length)) : (p = d.slice(0, g),
                    this.leftOver = d.slice(g, d.length))),
                    this.push({
                        data: i.utf8decode(p),
                        meta: h.meta
                    })
                }
                ,
                u.prototype.flush = function() {
                    this.leftOver && this.leftOver.length && (this.push({
                        data: i.utf8decode(this.leftOver),
                        meta: {}
                    }),
                    this.leftOver = null)
                }
                ,
                i.Utf8DecodeWorker = u,
                s.inherits(f, l),
                f.prototype.processChunk = function(h) {
                    this.push({
                        data: i.utf8encode(h.data),
                        meta: h.meta
                    })
                }
                ,
                i.Utf8EncodeWorker = f
            }
            , {
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./support": 30,
                "./utils": 32
            }],
            32: [function(t, r, i) {
                var s = t("./support")
                  , o = t("./base64")
                  , a = t("./nodejsUtils")
                  , l = t("./external");
                function c(m) {
                    return m
                }
                function A(m, g) {
                    for (var p = 0; p < m.length; ++p)
                        g[p] = 255 & m.charCodeAt(p);
                    return g
                }
                t("setimmediate"),
                i.newBlob = function(m, g) {
                    i.checkSupport("blob");
                    try {
                        return new Blob([m],{
                            type: g
                        })
                    } catch {
                        try {
                            var p = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder);
                            return p.append(m),
                            p.getBlob(g)
                        } catch {
                            throw new Error("Bug : can't construct the Blob.")
                        }
                    }
                }
                ;
                var u = {
                    stringifyByChunk: function(m, g, p) {
                        var v = []
                          , w = 0
                          , _ = m.length;
                        if (_ <= p)
                            return String.fromCharCode.apply(null, m);
                        for (; w < _; )
                            g === "array" || g === "nodebuffer" ? v.push(String.fromCharCode.apply(null, m.slice(w, Math.min(w + p, _)))) : v.push(String.fromCharCode.apply(null, m.subarray(w, Math.min(w + p, _)))),
                            w += p;
                        return v.join("")
                    },
                    stringifyByChar: function(m) {
                        for (var g = "", p = 0; p < m.length; p++)
                            g += String.fromCharCode(m[p]);
                        return g
                    },
                    applyCanBeUsed: {
                        uint8array: function() {
                            try {
                                return s.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1
                            } catch {
                                return !1
                            }
                        }(),
                        nodebuffer: function() {
                            try {
                                return s.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1
                            } catch {
                                return !1
                            }
                        }()
                    }
                };
                function f(m) {
                    var g = 65536
                      , p = i.getTypeOf(m)
                      , v = !0;
                    if (p === "uint8array" ? v = u.applyCanBeUsed.uint8array : p === "nodebuffer" && (v = u.applyCanBeUsed.nodebuffer),
                    v)
                        for (; 1 < g; )
                            try {
                                return u.stringifyByChunk(m, p, g)
                            } catch {
                                g = Math.floor(g / 2)
                            }
                    return u.stringifyByChar(m)
                }
                function h(m, g) {
                    for (var p = 0; p < m.length; p++)
                        g[p] = m[p];
                    return g
                }
                i.applyFromCharCode = f;
                var d = {};
                d.string = {
                    string: c,
                    array: function(m) {
                        return A(m, new Array(m.length))
                    },
                    arraybuffer: function(m) {
                        return d.string.uint8array(m).buffer
                    },
                    uint8array: function(m) {
                        return A(m, new Uint8Array(m.length))
                    },
                    nodebuffer: function(m) {
                        return A(m, a.allocBuffer(m.length))
                    }
                },
                d.array = {
                    string: f,
                    array: c,
                    arraybuffer: function(m) {
                        return new Uint8Array(m).buffer
                    },
                    uint8array: function(m) {
                        return new Uint8Array(m)
                    },
                    nodebuffer: function(m) {
                        return a.newBufferFrom(m)
                    }
                },
                d.arraybuffer = {
                    string: function(m) {
                        return f(new Uint8Array(m))
                    },
                    array: function(m) {
                        return h(new Uint8Array(m), new Array(m.byteLength))
                    },
                    arraybuffer: c,
                    uint8array: function(m) {
                        return new Uint8Array(m)
                    },
                    nodebuffer: function(m) {
                        return a.newBufferFrom(new Uint8Array(m))
                    }
                },
                d.uint8array = {
                    string: f,
                    array: function(m) {
                        return h(m, new Array(m.length))
                    },
                    arraybuffer: function(m) {
                        return m.buffer
                    },
                    uint8array: c,
                    nodebuffer: function(m) {
                        return a.newBufferFrom(m)
                    }
                },
                d.nodebuffer = {
                    string: f,
                    array: function(m) {
                        return h(m, new Array(m.length))
                    },
                    arraybuffer: function(m) {
                        return d.nodebuffer.uint8array(m).buffer
                    },
                    uint8array: function(m) {
                        return h(m, new Uint8Array(m.length))
                    },
                    nodebuffer: c
                },
                i.transformTo = function(m, g) {
                    if (g = g || "",
                    !m)
                        return g;
                    i.checkSupport(m);
                    var p = i.getTypeOf(g);
                    return d[p][m](g)
                }
                ,
                i.resolve = function(m) {
                    for (var g = m.split("/"), p = [], v = 0; v < g.length; v++) {
                        var w = g[v];
                        w === "." || w === "" && v !== 0 && v !== g.length - 1 || (w === ".." ? p.pop() : p.push(w))
                    }
                    return p.join("/")
                }
                ,
                i.getTypeOf = function(m) {
                    return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : s.nodebuffer && a.isBuffer(m) ? "nodebuffer" : s.uint8array && m instanceof Uint8Array ? "uint8array" : s.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0
                }
                ,
                i.checkSupport = function(m) {
                    if (!s[m.toLowerCase()])
                        throw new Error(m + " is not supported by this platform")
                }
                ,
                i.MAX_VALUE_16BITS = 65535,
                i.MAX_VALUE_32BITS = -1,
                i.pretty = function(m) {
                    var g, p, v = "";
                    for (p = 0; p < (m || "").length; p++)
                        v += "\\x" + ((g = m.charCodeAt(p)) < 16 ? "0" : "") + g.toString(16).toUpperCase();
                    return v
                }
                ,
                i.delay = function(m, g, p) {
                    setImmediate(function() {
                        m.apply(p || null, g || [])
                    })
                }
                ,
                i.inherits = function(m, g) {
                    function p() {}
                    p.prototype = g.prototype,
                    m.prototype = new p
                }
                ,
                i.extend = function() {
                    var m, g, p = {};
                    for (m = 0; m < arguments.length; m++)
                        for (g in arguments[m])
                            Object.prototype.hasOwnProperty.call(arguments[m], g) && p[g] === void 0 && (p[g] = arguments[m][g]);
                    return p
                }
                ,
                i.prepareContent = function(m, g, p, v, w) {
                    return l.Promise.resolve(g).then(function(_) {
                        return s.blob && (_ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(_)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(x, b) {
                            var B = new FileReader;
                            B.onload = function(S) {
                                x(S.target.result)
                            }
                            ,
                            B.onerror = function(S) {
                                b(S.target.error)
                            }
                            ,
                            B.readAsArrayBuffer(_)
                        }
                        ) : _
                    }).then(function(_) {
                        var x = i.getTypeOf(_);
                        return x ? (x === "arraybuffer" ? _ = i.transformTo("uint8array", _) : x === "string" && (w ? _ = o.decode(_) : p && v !== !0 && (_ = function(b) {
                            return A(b, s.uint8array ? new Uint8Array(b.length) : new Array(b.length))
                        }(_))),
                        _) : l.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))
                    })
                }
            }
            , {
                "./base64": 1,
                "./external": 6,
                "./nodejsUtils": 14,
                "./support": 30,
                setimmediate: 54
            }],
            33: [function(t, r, i) {
                var s = t("./reader/readerFor")
                  , o = t("./utils")
                  , a = t("./signature")
                  , l = t("./zipEntry")
                  , c = t("./support");
                function A(u) {
                    this.files = [],
                    this.loadOptions = u
                }
                A.prototype = {
                    checkSignature: function(u) {
                        if (!this.reader.readAndCheckSignature(u)) {
                            this.reader.index -= 4;
                            var f = this.reader.readString(4);
                            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(f) + ", expected " + o.pretty(u) + ")")
                        }
                    },
                    isSignature: function(u, f) {
                        var h = this.reader.index;
                        this.reader.setIndex(u);
                        var d = this.reader.readString(4) === f;
                        return this.reader.setIndex(h),
                        d
                    },
                    readBlockEndOfCentral: function() {
                        this.diskNumber = this.reader.readInt(2),
                        this.diskWithCentralDirStart = this.reader.readInt(2),
                        this.centralDirRecordsOnThisDisk = this.reader.readInt(2),
                        this.centralDirRecords = this.reader.readInt(2),
                        this.centralDirSize = this.reader.readInt(4),
                        this.centralDirOffset = this.reader.readInt(4),
                        this.zipCommentLength = this.reader.readInt(2);
                        var u = this.reader.readData(this.zipCommentLength)
                          , f = c.uint8array ? "uint8array" : "array"
                          , h = o.transformTo(f, u);
                        this.zipComment = this.loadOptions.decodeFileName(h)
                    },
                    readBlockZip64EndOfCentral: function() {
                        this.zip64EndOfCentralSize = this.reader.readInt(8),
                        this.reader.skip(4),
                        this.diskNumber = this.reader.readInt(4),
                        this.diskWithCentralDirStart = this.reader.readInt(4),
                        this.centralDirRecordsOnThisDisk = this.reader.readInt(8),
                        this.centralDirRecords = this.reader.readInt(8),
                        this.centralDirSize = this.reader.readInt(8),
                        this.centralDirOffset = this.reader.readInt(8),
                        this.zip64ExtensibleData = {};
                        for (var u, f, h, d = this.zip64EndOfCentralSize - 44; 0 < d; )
                            u = this.reader.readInt(2),
                            f = this.reader.readInt(4),
                            h = this.reader.readData(f),
                            this.zip64ExtensibleData[u] = {
                                id: u,
                                length: f,
                                value: h
                            }
                    },
                    readBlockZip64EndOfCentralLocator: function() {
                        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4),
                        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8),
                        this.disksCount = this.reader.readInt(4),
                        1 < this.disksCount)
                            throw new Error("Multi-volumes zip are not supported")
                    },
                    readLocalFiles: function() {
                        var u, f;
                        for (u = 0; u < this.files.length; u++)
                            f = this.files[u],
                            this.reader.setIndex(f.localHeaderOffset),
                            this.checkSignature(a.LOCAL_FILE_HEADER),
                            f.readLocalPart(this.reader),
                            f.handleUTF8(),
                            f.processAttributes()
                    },
                    readCentralDir: function() {
                        var u;
                        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
                            (u = new l({
                                zip64: this.zip64
                            },this.loadOptions)).readCentralPart(this.reader),
                            this.files.push(u);
                        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
                            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
                    },
                    readEndOfCentral: function() {
                        var u = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
                        if (u < 0)
                            throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
                        this.reader.setIndex(u);
                        var f = u;
                        if (this.checkSignature(a.CENTRAL_DIRECTORY_END),
                        this.readBlockEndOfCentral(),
                        this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
                            if (this.zip64 = !0,
                            (u = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
                                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                            if (this.reader.setIndex(u),
                            this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                            this.readBlockZip64EndOfCentralLocator(),
                            !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END),
                            this.relativeOffsetEndOfZip64CentralDir < 0))
                                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                            this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END),
                            this.readBlockZip64EndOfCentral()
                        }
                        var h = this.centralDirOffset + this.centralDirSize;
                        this.zip64 && (h += 20,
                        h += 12 + this.zip64EndOfCentralSize);
                        var d = f - h;
                        if (0 < d)
                            this.isSignature(f, a.CENTRAL_FILE_HEADER) || (this.reader.zero = d);
                        else if (d < 0)
                            throw new Error("Corrupted zip: missing " + Math.abs(d) + " bytes.")
                    },
                    prepareReader: function(u) {
                        this.reader = s(u)
                    },
                    load: function(u) {
                        this.prepareReader(u),
                        this.readEndOfCentral(),
                        this.readCentralDir(),
                        this.readLocalFiles()
                    }
                },
                r.exports = A
            }
            , {
                "./reader/readerFor": 22,
                "./signature": 23,
                "./support": 30,
                "./utils": 32,
                "./zipEntry": 34
            }],
            34: [function(t, r, i) {
                var s = t("./reader/readerFor")
                  , o = t("./utils")
                  , a = t("./compressedObject")
                  , l = t("./crc32")
                  , c = t("./utf8")
                  , A = t("./compressions")
                  , u = t("./support");
                function f(h, d) {
                    this.options = h,
                    this.loadOptions = d
                }
                f.prototype = {
                    isEncrypted: function() {
                        return (1 & this.bitFlag) == 1
                    },
                    useUTF8: function() {
                        return (2048 & this.bitFlag) == 2048
                    },
                    readLocalPart: function(h) {
                        var d, m;
                        if (h.skip(22),
                        this.fileNameLength = h.readInt(2),
                        m = h.readInt(2),
                        this.fileName = h.readData(this.fileNameLength),
                        h.skip(m),
                        this.compressedSize === -1 || this.uncompressedSize === -1)
                            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                        if ((d = function(g) {
                            for (var p in A)
                                if (Object.prototype.hasOwnProperty.call(A, p) && A[p].magic === g)
                                    return A[p];
                            return null
                        }(this.compressionMethod)) === null)
                            throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
                        this.decompressed = new a(this.compressedSize,this.uncompressedSize,this.crc32,d,h.readData(this.compressedSize))
                    },
                    readCentralPart: function(h) {
                        this.versionMadeBy = h.readInt(2),
                        h.skip(2),
                        this.bitFlag = h.readInt(2),
                        this.compressionMethod = h.readString(2),
                        this.date = h.readDate(),
                        this.crc32 = h.readInt(4),
                        this.compressedSize = h.readInt(4),
                        this.uncompressedSize = h.readInt(4);
                        var d = h.readInt(2);
                        if (this.extraFieldsLength = h.readInt(2),
                        this.fileCommentLength = h.readInt(2),
                        this.diskNumberStart = h.readInt(2),
                        this.internalFileAttributes = h.readInt(2),
                        this.externalFileAttributes = h.readInt(4),
                        this.localHeaderOffset = h.readInt(4),
                        this.isEncrypted())
                            throw new Error("Encrypted zip are not supported");
                        h.skip(d),
                        this.readExtraFields(h),
                        this.parseZIP64ExtraField(h),
                        this.fileComment = h.readData(this.fileCommentLength)
                    },
                    processAttributes: function() {
                        this.unixPermissions = null,
                        this.dosPermissions = null;
                        var h = this.versionMadeBy >> 8;
                        this.dir = !!(16 & this.externalFileAttributes),
                        h == 0 && (this.dosPermissions = 63 & this.externalFileAttributes),
                        h == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535),
                        this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0)
                    },
                    parseZIP64ExtraField: function() {
                        if (this.extraFields[1]) {
                            var h = s(this.extraFields[1].value);
                            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = h.readInt(8)),
                            this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = h.readInt(8)),
                            this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = h.readInt(8)),
                            this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = h.readInt(4))
                        }
                    },
                    readExtraFields: function(h) {
                        var d, m, g, p = h.index + this.extraFieldsLength;
                        for (this.extraFields || (this.extraFields = {}); h.index + 4 < p; )
                            d = h.readInt(2),
                            m = h.readInt(2),
                            g = h.readData(m),
                            this.extraFields[d] = {
                                id: d,
                                length: m,
                                value: g
                            };
                        h.setIndex(p)
                    },
                    handleUTF8: function() {
                        var h = u.uint8array ? "uint8array" : "array";
                        if (this.useUTF8())
                            this.fileNameStr = c.utf8decode(this.fileName),
                            this.fileCommentStr = c.utf8decode(this.fileComment);
                        else {
                            var d = this.findExtraFieldUnicodePath();
                            if (d !== null)
                                this.fileNameStr = d;
                            else {
                                var m = o.transformTo(h, this.fileName);
                                this.fileNameStr = this.loadOptions.decodeFileName(m)
                            }
                            var g = this.findExtraFieldUnicodeComment();
                            if (g !== null)
                                this.fileCommentStr = g;
                            else {
                                var p = o.transformTo(h, this.fileComment);
                                this.fileCommentStr = this.loadOptions.decodeFileName(p)
                            }
                        }
                    },
                    findExtraFieldUnicodePath: function() {
                        var h = this.extraFields[28789];
                        if (h) {
                            var d = s(h.value);
                            return d.readInt(1) !== 1 || l(this.fileName) !== d.readInt(4) ? null : c.utf8decode(d.readData(h.length - 5))
                        }
                        return null
                    },
                    findExtraFieldUnicodeComment: function() {
                        var h = this.extraFields[25461];
                        if (h) {
                            var d = s(h.value);
                            return d.readInt(1) !== 1 || l(this.fileComment) !== d.readInt(4) ? null : c.utf8decode(d.readData(h.length - 5))
                        }
                        return null
                    }
                },
                r.exports = f
            }
            , {
                "./compressedObject": 2,
                "./compressions": 3,
                "./crc32": 4,
                "./reader/readerFor": 22,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32
            }],
            35: [function(t, r, i) {
                function s(d, m, g) {
                    this.name = d,
                    this.dir = g.dir,
                    this.date = g.date,
                    this.comment = g.comment,
                    this.unixPermissions = g.unixPermissions,
                    this.dosPermissions = g.dosPermissions,
                    this._data = m,
                    this._dataBinary = g.binary,
                    this.options = {
                        compression: g.compression,
                        compressionOptions: g.compressionOptions
                    }
                }
                var o = t("./stream/StreamHelper")
                  , a = t("./stream/DataWorker")
                  , l = t("./utf8")
                  , c = t("./compressedObject")
                  , A = t("./stream/GenericWorker");
                s.prototype = {
                    internalStream: function(d) {
                        var m = null
                          , g = "string";
                        try {
                            if (!d)
                                throw new Error("No output type specified.");
                            var p = (g = d.toLowerCase()) === "string" || g === "text";
                            g !== "binarystring" && g !== "text" || (g = "string"),
                            m = this._decompressWorker();
                            var v = !this._dataBinary;
                            v && !p && (m = m.pipe(new l.Utf8EncodeWorker)),
                            !v && p && (m = m.pipe(new l.Utf8DecodeWorker))
                        } catch (w) {
                            (m = new A("error")).error(w)
                        }
                        return new o(m,g,"")
                    },
                    async: function(d, m) {
                        return this.internalStream(d).accumulate(m)
                    },
                    nodeStream: function(d, m) {
                        return this.internalStream(d || "nodebuffer").toNodejsStream(m)
                    },
                    _compressWorker: function(d, m) {
                        if (this._data instanceof c && this._data.compression.magic === d.magic)
                            return this._data.getCompressedWorker();
                        var g = this._decompressWorker();
                        return this._dataBinary || (g = g.pipe(new l.Utf8EncodeWorker)),
                        c.createWorkerFrom(g, d, m)
                    },
                    _decompressWorker: function() {
                        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof A ? this._data : new a(this._data)
                    }
                };
                for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                }, h = 0; h < u.length; h++)
                    s.prototype[u[h]] = f;
                r.exports = s
            }
            , {
                "./compressedObject": 2,
                "./stream/DataWorker": 27,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31
            }],
            36: [function(t, r, i) {
                (function(s) {
                    var o, a, l = s.MutationObserver || s.WebKitMutationObserver;
                    if (l) {
                        var c = 0
                          , A = new l(d)
                          , u = s.document.createTextNode("");
                        A.observe(u, {
                            characterData: !0
                        }),
                        o = function() {
                            u.data = c = ++c % 2
                        }
                    } else if (s.setImmediate || s.MessageChannel === void 0)
                        o = "document"in s && "onreadystatechange"in s.document.createElement("script") ? function() {
                            var m = s.document.createElement("script");
                            m.onreadystatechange = function() {
                                d(),
                                m.onreadystatechange = null,
                                m.parentNode.removeChild(m),
                                m = null
                            }
                            ,
                            s.document.documentElement.appendChild(m)
                        }
                        : function() {
                            setTimeout(d, 0)
                        }
                        ;
                    else {
                        var f = new s.MessageChannel;
                        f.port1.onmessage = d,
                        o = function() {
                            f.port2.postMessage(0)
                        }
                    }
                    var h = [];
                    function d() {
                        var m, g;
                        a = !0;
                        for (var p = h.length; p; ) {
                            for (g = h,
                            h = [],
                            m = -1; ++m < p; )
                                g[m]();
                            p = h.length
                        }
                        a = !1
                    }
                    r.exports = function(m) {
                        h.push(m) !== 1 || a || o()
                    }
                }
                ).call(this, typeof ka < "u" ? ka : typeof self < "u" ? self : typeof window < "u" ? window : {})
            }
            , {}],
            37: [function(t, r, i) {
                var s = t("immediate");
                function o() {}
                var a = {}
                  , l = ["REJECTED"]
                  , c = ["FULFILLED"]
                  , A = ["PENDING"];
                function u(p) {
                    if (typeof p != "function")
                        throw new TypeError("resolver must be a function");
                    this.state = A,
                    this.queue = [],
                    this.outcome = void 0,
                    p !== o && m(this, p)
                }
                function f(p, v, w) {
                    this.promise = p,
                    typeof v == "function" && (this.onFulfilled = v,
                    this.callFulfilled = this.otherCallFulfilled),
                    typeof w == "function" && (this.onRejected = w,
                    this.callRejected = this.otherCallRejected)
                }
                function h(p, v, w) {
                    s(function() {
                        var _;
                        try {
                            _ = v(w)
                        } catch (x) {
                            return a.reject(p, x)
                        }
                        _ === p ? a.reject(p, new TypeError("Cannot resolve promise with itself")) : a.resolve(p, _)
                    })
                }
                function d(p) {
                    var v = p && p.then;
                    if (p && (typeof p == "object" || typeof p == "function") && typeof v == "function")
                        return function() {
                            v.apply(p, arguments)
                        }
                }
                function m(p, v) {
                    var w = !1;
                    function _(B) {
                        w || (w = !0,
                        a.reject(p, B))
                    }
                    function x(B) {
                        w || (w = !0,
                        a.resolve(p, B))
                    }
                    var b = g(function() {
                        v(x, _)
                    });
                    b.status === "error" && _(b.value)
                }
                function g(p, v) {
                    var w = {};
                    try {
                        w.value = p(v),
                        w.status = "success"
                    } catch (_) {
                        w.status = "error",
                        w.value = _
                    }
                    return w
                }
                (r.exports = u).prototype.finally = function(p) {
                    if (typeof p != "function")
                        return this;
                    var v = this.constructor;
                    return this.then(function(w) {
                        return v.resolve(p()).then(function() {
                            return w
                        })
                    }, function(w) {
                        return v.resolve(p()).then(function() {
                            throw w
                        })
                    })
                }
                ,
                u.prototype.catch = function(p) {
                    return this.then(null, p)
                }
                ,
                u.prototype.then = function(p, v) {
                    if (typeof p != "function" && this.state === c || typeof v != "function" && this.state === l)
                        return this;
                    var w = new this.constructor(o);
                    return this.state !== A ? h(w, this.state === c ? p : v, this.outcome) : this.queue.push(new f(w,p,v)),
                    w
                }
                ,
                f.prototype.callFulfilled = function(p) {
                    a.resolve(this.promise, p)
                }
                ,
                f.prototype.otherCallFulfilled = function(p) {
                    h(this.promise, this.onFulfilled, p)
                }
                ,
                f.prototype.callRejected = function(p) {
                    a.reject(this.promise, p)
                }
                ,
                f.prototype.otherCallRejected = function(p) {
                    h(this.promise, this.onRejected, p)
                }
                ,
                a.resolve = function(p, v) {
                    var w = g(d, v);
                    if (w.status === "error")
                        return a.reject(p, w.value);
                    var _ = w.value;
                    if (_)
                        m(p, _);
                    else {
                        p.state = c,
                        p.outcome = v;
                        for (var x = -1, b = p.queue.length; ++x < b; )
                            p.queue[x].callFulfilled(v)
                    }
                    return p
                }
                ,
                a.reject = function(p, v) {
                    p.state = l,
                    p.outcome = v;
                    for (var w = -1, _ = p.queue.length; ++w < _; )
                        p.queue[w].callRejected(v);
                    return p
                }
                ,
                u.resolve = function(p) {
                    return p instanceof this ? p : a.resolve(new this(o), p)
                }
                ,
                u.reject = function(p) {
                    var v = new this(o);
                    return a.reject(v, p)
                }
                ,
                u.all = function(p) {
                    var v = this;
                    if (Object.prototype.toString.call(p) !== "[object Array]")
                        return this.reject(new TypeError("must be an array"));
                    var w = p.length
                      , _ = !1;
                    if (!w)
                        return this.resolve([]);
                    for (var x = new Array(w), b = 0, B = -1, S = new this(o); ++B < w; )
                        I(p[B], B);
                    return S;
                    function I(M, L) {
                        v.resolve(M).then(function(D) {
                            x[L] = D,
                            ++b !== w || _ || (_ = !0,
                            a.resolve(S, x))
                        }, function(D) {
                            _ || (_ = !0,
                            a.reject(S, D))
                        })
                    }
                }
                ,
                u.race = function(p) {
                    var v = this;
                    if (Object.prototype.toString.call(p) !== "[object Array]")
                        return this.reject(new TypeError("must be an array"));
                    var w = p.length
                      , _ = !1;
                    if (!w)
                        return this.resolve([]);
                    for (var x = -1, b = new this(o); ++x < w; )
                        B = p[x],
                        v.resolve(B).then(function(S) {
                            _ || (_ = !0,
                            a.resolve(b, S))
                        }, function(S) {
                            _ || (_ = !0,
                            a.reject(b, S))
                        });
                    var B;
                    return b
                }
            }
            , {
                immediate: 36
            }],
            38: [function(t, r, i) {
                var s = {};
                (0,
                t("./lib/utils/common").assign)(s, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")),
                r.exports = s
            }
            , {
                "./lib/deflate": 39,
                "./lib/inflate": 40,
                "./lib/utils/common": 41,
                "./lib/zlib/constants": 44
            }],
            39: [function(t, r, i) {
                var s = t("./zlib/deflate")
                  , o = t("./utils/common")
                  , a = t("./utils/strings")
                  , l = t("./zlib/messages")
                  , c = t("./zlib/zstream")
                  , A = Object.prototype.toString
                  , u = 0
                  , f = -1
                  , h = 0
                  , d = 8;
                function m(p) {
                    if (!(this instanceof m))
                        return new m(p);
                    this.options = o.assign({
                        level: f,
                        method: d,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: h,
                        to: ""
                    }, p || {});
                    var v = this.options;
                    v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16),
                    this.err = 0,
                    this.msg = "",
                    this.ended = !1,
                    this.chunks = [],
                    this.strm = new c,
                    this.strm.avail_out = 0;
                    var w = s.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
                    if (w !== u)
                        throw new Error(l[w]);
                    if (v.header && s.deflateSetHeader(this.strm, v.header),
                    v.dictionary) {
                        var _;
                        if (_ = typeof v.dictionary == "string" ? a.string2buf(v.dictionary) : A.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary,
                        (w = s.deflateSetDictionary(this.strm, _)) !== u)
                            throw new Error(l[w]);
                        this._dict_set = !0
                    }
                }
                function g(p, v) {
                    var w = new m(v);
                    if (w.push(p, !0),
                    w.err)
                        throw w.msg || l[w.err];
                    return w.result
                }
                m.prototype.push = function(p, v) {
                    var w, _, x = this.strm, b = this.options.chunkSize;
                    if (this.ended)
                        return !1;
                    _ = v === ~~v ? v : v === !0 ? 4 : 0,
                    typeof p == "string" ? x.input = a.string2buf(p) : A.call(p) === "[object ArrayBuffer]" ? x.input = new Uint8Array(p) : x.input = p,
                    x.next_in = 0,
                    x.avail_in = x.input.length;
                    do {
                        if (x.avail_out === 0 && (x.output = new o.Buf8(b),
                        x.next_out = 0,
                        x.avail_out = b),
                        (w = s.deflate(x, _)) !== 1 && w !== u)
                            return this.onEnd(w),
                            !(this.ended = !0);
                        x.avail_out !== 0 && (x.avail_in !== 0 || _ !== 4 && _ !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(x.output, x.next_out))) : this.onData(o.shrinkBuf(x.output, x.next_out)))
                    } while ((0 < x.avail_in || x.avail_out === 0) && w !== 1);
                    return _ === 4 ? (w = s.deflateEnd(this.strm),
                    this.onEnd(w),
                    this.ended = !0,
                    w === u) : _ !== 2 || (this.onEnd(u),
                    !(x.avail_out = 0))
                }
                ,
                m.prototype.onData = function(p) {
                    this.chunks.push(p)
                }
                ,
                m.prototype.onEnd = function(p) {
                    p === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)),
                    this.chunks = [],
                    this.err = p,
                    this.msg = this.strm.msg
                }
                ,
                i.Deflate = m,
                i.deflate = g,
                i.deflateRaw = function(p, v) {
                    return (v = v || {}).raw = !0,
                    g(p, v)
                }
                ,
                i.gzip = function(p, v) {
                    return (v = v || {}).gzip = !0,
                    g(p, v)
                }
            }
            , {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/deflate": 46,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }],
            40: [function(t, r, i) {
                var s = t("./zlib/inflate")
                  , o = t("./utils/common")
                  , a = t("./utils/strings")
                  , l = t("./zlib/constants")
                  , c = t("./zlib/messages")
                  , A = t("./zlib/zstream")
                  , u = t("./zlib/gzheader")
                  , f = Object.prototype.toString;
                function h(m) {
                    if (!(this instanceof h))
                        return new h(m);
                    this.options = o.assign({
                        chunkSize: 16384,
                        windowBits: 0,
                        to: ""
                    }, m || {});
                    var g = this.options;
                    g.raw && 0 <= g.windowBits && g.windowBits < 16 && (g.windowBits = -g.windowBits,
                    g.windowBits === 0 && (g.windowBits = -15)),
                    !(0 <= g.windowBits && g.windowBits < 16) || m && m.windowBits || (g.windowBits += 32),
                    15 < g.windowBits && g.windowBits < 48 && !(15 & g.windowBits) && (g.windowBits |= 15),
                    this.err = 0,
                    this.msg = "",
                    this.ended = !1,
                    this.chunks = [],
                    this.strm = new A,
                    this.strm.avail_out = 0;
                    var p = s.inflateInit2(this.strm, g.windowBits);
                    if (p !== l.Z_OK)
                        throw new Error(c[p]);
                    this.header = new u,
                    s.inflateGetHeader(this.strm, this.header)
                }
                function d(m, g) {
                    var p = new h(g);
                    if (p.push(m, !0),
                    p.err)
                        throw p.msg || c[p.err];
                    return p.result
                }
                h.prototype.push = function(m, g) {
                    var p, v, w, _, x, b, B = this.strm, S = this.options.chunkSize, I = this.options.dictionary, M = !1;
                    if (this.ended)
                        return !1;
                    v = g === ~~g ? g : g === !0 ? l.Z_FINISH : l.Z_NO_FLUSH,
                    typeof m == "string" ? B.input = a.binstring2buf(m) : f.call(m) === "[object ArrayBuffer]" ? B.input = new Uint8Array(m) : B.input = m,
                    B.next_in = 0,
                    B.avail_in = B.input.length;
                    do {
                        if (B.avail_out === 0 && (B.output = new o.Buf8(S),
                        B.next_out = 0,
                        B.avail_out = S),
                        (p = s.inflate(B, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && I && (b = typeof I == "string" ? a.string2buf(I) : f.call(I) === "[object ArrayBuffer]" ? new Uint8Array(I) : I,
                        p = s.inflateSetDictionary(this.strm, b)),
                        p === l.Z_BUF_ERROR && M === !0 && (p = l.Z_OK,
                        M = !1),
                        p !== l.Z_STREAM_END && p !== l.Z_OK)
                            return this.onEnd(p),
                            !(this.ended = !0);
                        B.next_out && (B.avail_out !== 0 && p !== l.Z_STREAM_END && (B.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = a.utf8border(B.output, B.next_out),
                        _ = B.next_out - w,
                        x = a.buf2string(B.output, w),
                        B.next_out = _,
                        B.avail_out = S - _,
                        _ && o.arraySet(B.output, B.output, w, _, 0),
                        this.onData(x)) : this.onData(o.shrinkBuf(B.output, B.next_out)))),
                        B.avail_in === 0 && B.avail_out === 0 && (M = !0)
                    } while ((0 < B.avail_in || B.avail_out === 0) && p !== l.Z_STREAM_END);
                    return p === l.Z_STREAM_END && (v = l.Z_FINISH),
                    v === l.Z_FINISH ? (p = s.inflateEnd(this.strm),
                    this.onEnd(p),
                    this.ended = !0,
                    p === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK),
                    !(B.avail_out = 0))
                }
                ,
                h.prototype.onData = function(m) {
                    this.chunks.push(m)
                }
                ,
                h.prototype.onEnd = function(m) {
                    m === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)),
                    this.chunks = [],
                    this.err = m,
                    this.msg = this.strm.msg
                }
                ,
                i.Inflate = h,
                i.inflate = d,
                i.inflateRaw = function(m, g) {
                    return (g = g || {}).raw = !0,
                    d(m, g)
                }
                ,
                i.ungzip = d
            }
            , {
                "./utils/common": 41,
                "./utils/strings": 42,
                "./zlib/constants": 44,
                "./zlib/gzheader": 47,
                "./zlib/inflate": 49,
                "./zlib/messages": 51,
                "./zlib/zstream": 53
            }],
            41: [function(t, r, i) {
                var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
                i.assign = function(l) {
                    for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
                        var A = c.shift();
                        if (A) {
                            if (typeof A != "object")
                                throw new TypeError(A + "must be non-object");
                            for (var u in A)
                                A.hasOwnProperty(u) && (l[u] = A[u])
                        }
                    }
                    return l
                }
                ,
                i.shrinkBuf = function(l, c) {
                    return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c,
                    l)
                }
                ;
                var o = {
                    arraySet: function(l, c, A, u, f) {
                        if (c.subarray && l.subarray)
                            l.set(c.subarray(A, A + u), f);
                        else
                            for (var h = 0; h < u; h++)
                                l[f + h] = c[A + h]
                    },
                    flattenChunks: function(l) {
                        var c, A, u, f, h, d;
                        for (c = u = 0,
                        A = l.length; c < A; c++)
                            u += l[c].length;
                        for (d = new Uint8Array(u),
                        c = f = 0,
                        A = l.length; c < A; c++)
                            h = l[c],
                            d.set(h, f),
                            f += h.length;
                        return d
                    }
                }
                  , a = {
                    arraySet: function(l, c, A, u, f) {
                        for (var h = 0; h < u; h++)
                            l[f + h] = c[A + h]
                    },
                    flattenChunks: function(l) {
                        return [].concat.apply([], l)
                    }
                };
                i.setTyped = function(l) {
                    l ? (i.Buf8 = Uint8Array,
                    i.Buf16 = Uint16Array,
                    i.Buf32 = Int32Array,
                    i.assign(i, o)) : (i.Buf8 = Array,
                    i.Buf16 = Array,
                    i.Buf32 = Array,
                    i.assign(i, a))
                }
                ,
                i.setTyped(s)
            }
            , {}],
            42: [function(t, r, i) {
                var s = t("./common")
                  , o = !0
                  , a = !0;
                try {
                    String.fromCharCode.apply(null, [0])
                } catch {
                    o = !1
                }
                try {
                    String.fromCharCode.apply(null, new Uint8Array(1))
                } catch {
                    a = !1
                }
                for (var l = new s.Buf8(256), c = 0; c < 256; c++)
                    l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
                function A(u, f) {
                    if (f < 65537 && (u.subarray && a || !u.subarray && o))
                        return String.fromCharCode.apply(null, s.shrinkBuf(u, f));
                    for (var h = "", d = 0; d < f; d++)
                        h += String.fromCharCode(u[d]);
                    return h
                }
                l[254] = l[254] = 1,
                i.string2buf = function(u) {
                    var f, h, d, m, g, p = u.length, v = 0;
                    for (m = 0; m < p; m++)
                        (64512 & (h = u.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (d = u.charCodeAt(m + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (d - 56320),
                        m++),
                        v += h < 128 ? 1 : h < 2048 ? 2 : h < 65536 ? 3 : 4;
                    for (f = new s.Buf8(v),
                    m = g = 0; g < v; m++)
                        (64512 & (h = u.charCodeAt(m))) == 55296 && m + 1 < p && (64512 & (d = u.charCodeAt(m + 1))) == 56320 && (h = 65536 + (h - 55296 << 10) + (d - 56320),
                        m++),
                        h < 128 ? f[g++] = h : (h < 2048 ? f[g++] = 192 | h >>> 6 : (h < 65536 ? f[g++] = 224 | h >>> 12 : (f[g++] = 240 | h >>> 18,
                        f[g++] = 128 | h >>> 12 & 63),
                        f[g++] = 128 | h >>> 6 & 63),
                        f[g++] = 128 | 63 & h);
                    return f
                }
                ,
                i.buf2binstring = function(u) {
                    return A(u, u.length)
                }
                ,
                i.binstring2buf = function(u) {
                    for (var f = new s.Buf8(u.length), h = 0, d = f.length; h < d; h++)
                        f[h] = u.charCodeAt(h);
                    return f
                }
                ,
                i.buf2string = function(u, f) {
                    var h, d, m, g, p = f || u.length, v = new Array(2 * p);
                    for (h = d = 0; h < p; )
                        if ((m = u[h++]) < 128)
                            v[d++] = m;
                        else if (4 < (g = l[m]))
                            v[d++] = 65533,
                            h += g - 1;
                        else {
                            for (m &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && h < p; )
                                m = m << 6 | 63 & u[h++],
                                g--;
                            1 < g ? v[d++] = 65533 : m < 65536 ? v[d++] = m : (m -= 65536,
                            v[d++] = 55296 | m >> 10 & 1023,
                            v[d++] = 56320 | 1023 & m)
                        }
                    return A(v, d)
                }
                ,
                i.utf8border = function(u, f) {
                    var h;
                    for ((f = f || u.length) > u.length && (f = u.length),
                    h = f - 1; 0 <= h && (192 & u[h]) == 128; )
                        h--;
                    return h < 0 || h === 0 ? f : h + l[u[h]] > f ? h : f
                }
            }
            , {
                "./common": 41
            }],
            43: [function(t, r, i) {
                r.exports = function(s, o, a, l) {
                    for (var c = 65535 & s | 0, A = s >>> 16 & 65535 | 0, u = 0; a !== 0; ) {
                        for (a -= u = 2e3 < a ? 2e3 : a; A = A + (c = c + o[l++] | 0) | 0,
                        --u; )
                            ;
                        c %= 65521,
                        A %= 65521
                    }
                    return c | A << 16 | 0
                }
            }
            , {}],
            44: [function(t, r, i) {
                r.exports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                }
            }
            , {}],
            45: [function(t, r, i) {
                var s = function() {
                    for (var o, a = [], l = 0; l < 256; l++) {
                        o = l;
                        for (var c = 0; c < 8; c++)
                            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
                        a[l] = o
                    }
                    return a
                }();
                r.exports = function(o, a, l, c) {
                    var A = s
                      , u = c + l;
                    o ^= -1;
                    for (var f = c; f < u; f++)
                        o = o >>> 8 ^ A[255 & (o ^ a[f])];
                    return -1 ^ o
                }
            }
            , {}],
            46: [function(t, r, i) {
                var s, o = t("../utils/common"), a = t("./trees"), l = t("./adler32"), c = t("./crc32"), A = t("./messages"), u = 0, f = 4, h = 0, d = -2, m = -1, g = 4, p = 2, v = 8, w = 9, _ = 286, x = 30, b = 19, B = 2 * _ + 1, S = 15, I = 3, M = 258, L = M + I + 1, D = 42, T = 113, y = 1, E = 2, R = 3, F = 4;
                function O(H, fe) {
                    return H.msg = A[fe],
                    fe
                }
                function z(H) {
                    return (H << 1) - (4 < H ? 9 : 0)
                }
                function j(H) {
                    for (var fe = H.length; 0 <= --fe; )
                        H[fe] = 0
                }
                function Q(H) {
                    var fe = H.state
                      , Ae = fe.pending;
                    Ae > H.avail_out && (Ae = H.avail_out),
                    Ae !== 0 && (o.arraySet(H.output, fe.pending_buf, fe.pending_out, Ae, H.next_out),
                    H.next_out += Ae,
                    fe.pending_out += Ae,
                    H.total_out += Ae,
                    H.avail_out -= Ae,
                    fe.pending -= Ae,
                    fe.pending === 0 && (fe.pending_out = 0))
                }
                function C(H, fe) {
                    a._tr_flush_block(H, 0 <= H.block_start ? H.block_start : -1, H.strstart - H.block_start, fe),
                    H.block_start = H.strstart,
                    Q(H.strm)
                }
                function W(H, fe) {
                    H.pending_buf[H.pending++] = fe
                }
                function ee(H, fe) {
                    H.pending_buf[H.pending++] = fe >>> 8 & 255,
                    H.pending_buf[H.pending++] = 255 & fe
                }
                function P(H, fe) {
                    var Ae, J, q = H.max_chain_length, he = H.strstart, X = H.prev_length, G = H.nice_match, ne = H.strstart > H.w_size - L ? H.strstart - (H.w_size - L) : 0, Y = H.window, de = H.w_mask, ae = H.prev, Ee = H.strstart + M, V = Y[he + X - 1], U = Y[he + X];
                    H.prev_length >= H.good_match && (q >>= 2),
                    G > H.lookahead && (G = H.lookahead);
                    do
                        if (Y[(Ae = fe) + X] === U && Y[Ae + X - 1] === V && Y[Ae] === Y[he] && Y[++Ae] === Y[he + 1]) {
                            he += 2,
                            Ae++;
                            do
                                ;
                            while (Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && Y[++he] === Y[++Ae] && he < Ee);
                            if (J = M - (Ee - he),
                            he = Ee - M,
                            X < J) {
                                if (H.match_start = fe,
                                G <= (X = J))
                                    break;
                                V = Y[he + X - 1],
                                U = Y[he + X]
                            }
                        }
                    while ((fe = ae[fe & de]) > ne && --q != 0);
                    return X <= H.lookahead ? X : H.lookahead
                }
                function re(H) {
                    var fe, Ae, J, q, he, X, G, ne, Y, de, ae = H.w_size;
                    do {
                        if (q = H.window_size - H.lookahead - H.strstart,
                        H.strstart >= ae + (ae - L)) {
                            for (o.arraySet(H.window, H.window, ae, ae, 0),
                            H.match_start -= ae,
                            H.strstart -= ae,
                            H.block_start -= ae,
                            fe = Ae = H.hash_size; J = H.head[--fe],
                            H.head[fe] = ae <= J ? J - ae : 0,
                            --Ae; )
                                ;
                            for (fe = Ae = ae; J = H.prev[--fe],
                            H.prev[fe] = ae <= J ? J - ae : 0,
                            --Ae; )
                                ;
                            q += ae
                        }
                        if (H.strm.avail_in === 0)
                            break;
                        if (X = H.strm,
                        G = H.window,
                        ne = H.strstart + H.lookahead,
                        Y = q,
                        de = void 0,
                        de = X.avail_in,
                        Y < de && (de = Y),
                        Ae = de === 0 ? 0 : (X.avail_in -= de,
                        o.arraySet(G, X.input, X.next_in, de, ne),
                        X.state.wrap === 1 ? X.adler = l(X.adler, G, de, ne) : X.state.wrap === 2 && (X.adler = c(X.adler, G, de, ne)),
                        X.next_in += de,
                        X.total_in += de,
                        de),
                        H.lookahead += Ae,
                        H.lookahead + H.insert >= I)
                            for (he = H.strstart - H.insert,
                            H.ins_h = H.window[he],
                            H.ins_h = (H.ins_h << H.hash_shift ^ H.window[he + 1]) & H.hash_mask; H.insert && (H.ins_h = (H.ins_h << H.hash_shift ^ H.window[he + I - 1]) & H.hash_mask,
                            H.prev[he & H.w_mask] = H.head[H.ins_h],
                            H.head[H.ins_h] = he,
                            he++,
                            H.insert--,
                            !(H.lookahead + H.insert < I)); )
                                ;
                    } while (H.lookahead < L && H.strm.avail_in !== 0)
                }
                function ue(H, fe) {
                    for (var Ae, J; ; ) {
                        if (H.lookahead < L) {
                            if (re(H),
                            H.lookahead < L && fe === u)
                                return y;
                            if (H.lookahead === 0)
                                break
                        }
                        if (Ae = 0,
                        H.lookahead >= I && (H.ins_h = (H.ins_h << H.hash_shift ^ H.window[H.strstart + I - 1]) & H.hash_mask,
                        Ae = H.prev[H.strstart & H.w_mask] = H.head[H.ins_h],
                        H.head[H.ins_h] = H.strstart),
                        Ae !== 0 && H.strstart - Ae <= H.w_size - L && (H.match_length = P(H, Ae)),
                        H.match_length >= I)
                            if (J = a._tr_tally(H, H.strstart - H.match_start, H.match_length - I),
                            H.lookahead -= H.match_length,
                            H.match_length <= H.max_lazy_match && H.lookahead >= I) {
                                for (H.match_length--; H.strstart++,
                                H.ins_h = (H.ins_h << H.hash_shift ^ H.window[H.strstart + I - 1]) & H.hash_mask,
                                Ae = H.prev[H.strstart & H.w_mask] = H.head[H.ins_h],
                                H.head[H.ins_h] = H.strstart,
                                --H.match_length != 0; )
                                    ;
                                H.strstart++
                            } else
                                H.strstart += H.match_length,
                                H.match_length = 0,
                                H.ins_h = H.window[H.strstart],
                                H.ins_h = (H.ins_h << H.hash_shift ^ H.window[H.strstart + 1]) & H.hash_mask;
                        else
                            J = a._tr_tally(H, 0, H.window[H.strstart]),
                            H.lookahead--,
                            H.strstart++;
                        if (J && (C(H, !1),
                        H.strm.avail_out === 0))
                            return y
                    }
                    return H.insert = H.strstart < I - 1 ? H.strstart : I - 1,
                    fe === f ? (C(H, !0),
                    H.strm.avail_out === 0 ? R : F) : H.last_lit && (C(H, !1),
                    H.strm.avail_out === 0) ? y : E
                }
                function le(H, fe) {
                    for (var Ae, J, q; ; ) {
                        if (H.lookahead < L) {
                            if (re(H),
                            H.lookahead < L && fe === u)
                                return y;
                            if (H.lookahead === 0)
                                break
                        }
                        if (Ae = 0,
                        H.lookahead >= I && (H.ins_h = (H.ins_h << H.hash_shift ^ H.window[H.strstart + I - 1]) & H.hash_mask,
                        Ae = H.prev[H.strstart & H.w_mask] = H.head[H.ins_h],
                        H.head[H.ins_h] = H.strstart),
                        H.prev_length = H.match_length,
                        H.prev_match = H.match_start,
                        H.match_length = I - 1,
                        Ae !== 0 && H.prev_length < H.max_lazy_match && H.strstart - Ae <= H.w_size - L && (H.match_length = P(H, Ae),
                        H.match_length <= 5 && (H.strategy === 1 || H.match_length === I && 4096 < H.strstart - H.match_start) && (H.match_length = I - 1)),
                        H.prev_length >= I && H.match_length <= H.prev_length) {
                            for (q = H.strstart + H.lookahead - I,
                            J = a._tr_tally(H, H.strstart - 1 - H.prev_match, H.prev_length - I),
                            H.lookahead -= H.prev_length - 1,
                            H.prev_length -= 2; ++H.strstart <= q && (H.ins_h = (H.ins_h << H.hash_shift ^ H.window[H.strstart + I - 1]) & H.hash_mask,
                            Ae = H.prev[H.strstart & H.w_mask] = H.head[H.ins_h],
                            H.head[H.ins_h] = H.strstart),
                            --H.prev_length != 0; )
                                ;
                            if (H.match_available = 0,
                            H.match_length = I - 1,
                            H.strstart++,
                            J && (C(H, !1),
                            H.strm.avail_out === 0))
                                return y
                        } else if (H.match_available) {
                            if ((J = a._tr_tally(H, 0, H.window[H.strstart - 1])) && C(H, !1),
                            H.strstart++,
                            H.lookahead--,
                            H.strm.avail_out === 0)
                                return y
                        } else
                            H.match_available = 1,
                            H.strstart++,
                            H.lookahead--
                    }
                    return H.match_available && (J = a._tr_tally(H, 0, H.window[H.strstart - 1]),
                    H.match_available = 0),
                    H.insert = H.strstart < I - 1 ? H.strstart : I - 1,
                    fe === f ? (C(H, !0),
                    H.strm.avail_out === 0 ? R : F) : H.last_lit && (C(H, !1),
                    H.strm.avail_out === 0) ? y : E
                }
                function me(H, fe, Ae, J, q) {
                    this.good_length = H,
                    this.max_lazy = fe,
                    this.nice_length = Ae,
                    this.max_chain = J,
                    this.func = q
                }
                function ie() {
                    this.strm = null,
                    this.status = 0,
                    this.pending_buf = null,
                    this.pending_buf_size = 0,
                    this.pending_out = 0,
                    this.pending = 0,
                    this.wrap = 0,
                    this.gzhead = null,
                    this.gzindex = 0,
                    this.method = v,
                    this.last_flush = -1,
                    this.w_size = 0,
                    this.w_bits = 0,
                    this.w_mask = 0,
                    this.window = null,
                    this.window_size = 0,
                    this.prev = null,
                    this.head = null,
                    this.ins_h = 0,
                    this.hash_size = 0,
                    this.hash_bits = 0,
                    this.hash_mask = 0,
                    this.hash_shift = 0,
                    this.block_start = 0,
                    this.match_length = 0,
                    this.prev_match = 0,
                    this.match_available = 0,
                    this.strstart = 0,
                    this.match_start = 0,
                    this.lookahead = 0,
                    this.prev_length = 0,
                    this.max_chain_length = 0,
                    this.max_lazy_match = 0,
                    this.level = 0,
                    this.strategy = 0,
                    this.good_match = 0,
                    this.nice_match = 0,
                    this.dyn_ltree = new o.Buf16(2 * B),
                    this.dyn_dtree = new o.Buf16(2 * (2 * x + 1)),
                    this.bl_tree = new o.Buf16(2 * (2 * b + 1)),
                    j(this.dyn_ltree),
                    j(this.dyn_dtree),
                    j(this.bl_tree),
                    this.l_desc = null,
                    this.d_desc = null,
                    this.bl_desc = null,
                    this.bl_count = new o.Buf16(S + 1),
                    this.heap = new o.Buf16(2 * _ + 1),
                    j(this.heap),
                    this.heap_len = 0,
                    this.heap_max = 0,
                    this.depth = new o.Buf16(2 * _ + 1),
                    j(this.depth),
                    this.l_buf = 0,
                    this.lit_bufsize = 0,
                    this.last_lit = 0,
                    this.d_buf = 0,
                    this.opt_len = 0,
                    this.static_len = 0,
                    this.matches = 0,
                    this.insert = 0,
                    this.bi_buf = 0,
                    this.bi_valid = 0
                }
                function ge(H) {
                    var fe;
                    return H && H.state ? (H.total_in = H.total_out = 0,
                    H.data_type = p,
                    (fe = H.state).pending = 0,
                    fe.pending_out = 0,
                    fe.wrap < 0 && (fe.wrap = -fe.wrap),
                    fe.status = fe.wrap ? D : T,
                    H.adler = fe.wrap === 2 ? 0 : 1,
                    fe.last_flush = u,
                    a._tr_init(fe),
                    h) : O(H, d)
                }
                function _e(H) {
                    var fe = ge(H);
                    return fe === h && function(Ae) {
                        Ae.window_size = 2 * Ae.w_size,
                        j(Ae.head),
                        Ae.max_lazy_match = s[Ae.level].max_lazy,
                        Ae.good_match = s[Ae.level].good_length,
                        Ae.nice_match = s[Ae.level].nice_length,
                        Ae.max_chain_length = s[Ae.level].max_chain,
                        Ae.strstart = 0,
                        Ae.block_start = 0,
                        Ae.lookahead = 0,
                        Ae.insert = 0,
                        Ae.match_length = Ae.prev_length = I - 1,
                        Ae.match_available = 0,
                        Ae.ins_h = 0
                    }(H.state),
                    fe
                }
                function se(H, fe, Ae, J, q, he) {
                    if (!H)
                        return d;
                    var X = 1;
                    if (fe === m && (fe = 6),
                    J < 0 ? (X = 0,
                    J = -J) : 15 < J && (X = 2,
                    J -= 16),
                    q < 1 || w < q || Ae !== v || J < 8 || 15 < J || fe < 0 || 9 < fe || he < 0 || g < he)
                        return O(H, d);
                    J === 8 && (J = 9);
                    var G = new ie;
                    return (H.state = G).strm = H,
                    G.wrap = X,
                    G.gzhead = null,
                    G.w_bits = J,
                    G.w_size = 1 << G.w_bits,
                    G.w_mask = G.w_size - 1,
                    G.hash_bits = q + 7,
                    G.hash_size = 1 << G.hash_bits,
                    G.hash_mask = G.hash_size - 1,
                    G.hash_shift = ~~((G.hash_bits + I - 1) / I),
                    G.window = new o.Buf8(2 * G.w_size),
                    G.head = new o.Buf16(G.hash_size),
                    G.prev = new o.Buf16(G.w_size),
                    G.lit_bufsize = 1 << q + 6,
                    G.pending_buf_size = 4 * G.lit_bufsize,
                    G.pending_buf = new o.Buf8(G.pending_buf_size),
                    G.d_buf = 1 * G.lit_bufsize,
                    G.l_buf = 3 * G.lit_bufsize,
                    G.level = fe,
                    G.strategy = he,
                    G.method = Ae,
                    _e(H)
                }
                s = [new me(0,0,0,0,function(H, fe) {
                    var Ae = 65535;
                    for (Ae > H.pending_buf_size - 5 && (Ae = H.pending_buf_size - 5); ; ) {
                        if (H.lookahead <= 1) {
                            if (re(H),
                            H.lookahead === 0 && fe === u)
                                return y;
                            if (H.lookahead === 0)
                                break
                        }
                        H.strstart += H.lookahead,
                        H.lookahead = 0;
                        var J = H.block_start + Ae;
                        if ((H.strstart === 0 || H.strstart >= J) && (H.lookahead = H.strstart - J,
                        H.strstart = J,
                        C(H, !1),
                        H.strm.avail_out === 0) || H.strstart - H.block_start >= H.w_size - L && (C(H, !1),
                        H.strm.avail_out === 0))
                            return y
                    }
                    return H.insert = 0,
                    fe === f ? (C(H, !0),
                    H.strm.avail_out === 0 ? R : F) : (H.strstart > H.block_start && (C(H, !1),
                    H.strm.avail_out),
                    y)
                }
                ), new me(4,4,8,4,ue), new me(4,5,16,8,ue), new me(4,6,32,32,ue), new me(4,4,16,16,le), new me(8,16,32,32,le), new me(8,16,128,128,le), new me(8,32,128,256,le), new me(32,128,258,1024,le), new me(32,258,258,4096,le)],
                i.deflateInit = function(H, fe) {
                    return se(H, fe, v, 15, 8, 0)
                }
                ,
                i.deflateInit2 = se,
                i.deflateReset = _e,
                i.deflateResetKeep = ge,
                i.deflateSetHeader = function(H, fe) {
                    return H && H.state ? H.state.wrap !== 2 ? d : (H.state.gzhead = fe,
                    h) : d
                }
                ,
                i.deflate = function(H, fe) {
                    var Ae, J, q, he;
                    if (!H || !H.state || 5 < fe || fe < 0)
                        return H ? O(H, d) : d;
                    if (J = H.state,
                    !H.output || !H.input && H.avail_in !== 0 || J.status === 666 && fe !== f)
                        return O(H, H.avail_out === 0 ? -5 : d);
                    if (J.strm = H,
                    Ae = J.last_flush,
                    J.last_flush = fe,
                    J.status === D)
                        if (J.wrap === 2)
                            H.adler = 0,
                            W(J, 31),
                            W(J, 139),
                            W(J, 8),
                            J.gzhead ? (W(J, (J.gzhead.text ? 1 : 0) + (J.gzhead.hcrc ? 2 : 0) + (J.gzhead.extra ? 4 : 0) + (J.gzhead.name ? 8 : 0) + (J.gzhead.comment ? 16 : 0)),
                            W(J, 255 & J.gzhead.time),
                            W(J, J.gzhead.time >> 8 & 255),
                            W(J, J.gzhead.time >> 16 & 255),
                            W(J, J.gzhead.time >> 24 & 255),
                            W(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0),
                            W(J, 255 & J.gzhead.os),
                            J.gzhead.extra && J.gzhead.extra.length && (W(J, 255 & J.gzhead.extra.length),
                            W(J, J.gzhead.extra.length >> 8 & 255)),
                            J.gzhead.hcrc && (H.adler = c(H.adler, J.pending_buf, J.pending, 0)),
                            J.gzindex = 0,
                            J.status = 69) : (W(J, 0),
                            W(J, 0),
                            W(J, 0),
                            W(J, 0),
                            W(J, 0),
                            W(J, J.level === 9 ? 2 : 2 <= J.strategy || J.level < 2 ? 4 : 0),
                            W(J, 3),
                            J.status = T);
                        else {
                            var X = v + (J.w_bits - 8 << 4) << 8;
                            X |= (2 <= J.strategy || J.level < 2 ? 0 : J.level < 6 ? 1 : J.level === 6 ? 2 : 3) << 6,
                            J.strstart !== 0 && (X |= 32),
                            X += 31 - X % 31,
                            J.status = T,
                            ee(J, X),
                            J.strstart !== 0 && (ee(J, H.adler >>> 16),
                            ee(J, 65535 & H.adler)),
                            H.adler = 1
                        }
                    if (J.status === 69)
                        if (J.gzhead.extra) {
                            for (q = J.pending; J.gzindex < (65535 & J.gzhead.extra.length) && (J.pending !== J.pending_buf_size || (J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                            Q(H),
                            q = J.pending,
                            J.pending !== J.pending_buf_size)); )
                                W(J, 255 & J.gzhead.extra[J.gzindex]),
                                J.gzindex++;
                            J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                            J.gzindex === J.gzhead.extra.length && (J.gzindex = 0,
                            J.status = 73)
                        } else
                            J.status = 73;
                    if (J.status === 73)
                        if (J.gzhead.name) {
                            q = J.pending;
                            do {
                                if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                                Q(H),
                                q = J.pending,
                                J.pending === J.pending_buf_size)) {
                                    he = 1;
                                    break
                                }
                                he = J.gzindex < J.gzhead.name.length ? 255 & J.gzhead.name.charCodeAt(J.gzindex++) : 0,
                                W(J, he)
                            } while (he !== 0);
                            J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                            he === 0 && (J.gzindex = 0,
                            J.status = 91)
                        } else
                            J.status = 91;
                    if (J.status === 91)
                        if (J.gzhead.comment) {
                            q = J.pending;
                            do {
                                if (J.pending === J.pending_buf_size && (J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                                Q(H),
                                q = J.pending,
                                J.pending === J.pending_buf_size)) {
                                    he = 1;
                                    break
                                }
                                he = J.gzindex < J.gzhead.comment.length ? 255 & J.gzhead.comment.charCodeAt(J.gzindex++) : 0,
                                W(J, he)
                            } while (he !== 0);
                            J.gzhead.hcrc && J.pending > q && (H.adler = c(H.adler, J.pending_buf, J.pending - q, q)),
                            he === 0 && (J.status = 103)
                        } else
                            J.status = 103;
                    if (J.status === 103 && (J.gzhead.hcrc ? (J.pending + 2 > J.pending_buf_size && Q(H),
                    J.pending + 2 <= J.pending_buf_size && (W(J, 255 & H.adler),
                    W(J, H.adler >> 8 & 255),
                    H.adler = 0,
                    J.status = T)) : J.status = T),
                    J.pending !== 0) {
                        if (Q(H),
                        H.avail_out === 0)
                            return J.last_flush = -1,
                            h
                    } else if (H.avail_in === 0 && z(fe) <= z(Ae) && fe !== f)
                        return O(H, -5);
                    if (J.status === 666 && H.avail_in !== 0)
                        return O(H, -5);
                    if (H.avail_in !== 0 || J.lookahead !== 0 || fe !== u && J.status !== 666) {
                        var G = J.strategy === 2 ? function(ne, Y) {
                            for (var de; ; ) {
                                if (ne.lookahead === 0 && (re(ne),
                                ne.lookahead === 0)) {
                                    if (Y === u)
                                        return y;
                                    break
                                }
                                if (ne.match_length = 0,
                                de = a._tr_tally(ne, 0, ne.window[ne.strstart]),
                                ne.lookahead--,
                                ne.strstart++,
                                de && (C(ne, !1),
                                ne.strm.avail_out === 0))
                                    return y
                            }
                            return ne.insert = 0,
                            Y === f ? (C(ne, !0),
                            ne.strm.avail_out === 0 ? R : F) : ne.last_lit && (C(ne, !1),
                            ne.strm.avail_out === 0) ? y : E
                        }(J, fe) : J.strategy === 3 ? function(ne, Y) {
                            for (var de, ae, Ee, V, U = ne.window; ; ) {
                                if (ne.lookahead <= M) {
                                    if (re(ne),
                                    ne.lookahead <= M && Y === u)
                                        return y;
                                    if (ne.lookahead === 0)
                                        break
                                }
                                if (ne.match_length = 0,
                                ne.lookahead >= I && 0 < ne.strstart && (ae = U[Ee = ne.strstart - 1]) === U[++Ee] && ae === U[++Ee] && ae === U[++Ee]) {
                                    V = ne.strstart + M;
                                    do
                                        ;
                                    while (ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && ae === U[++Ee] && Ee < V);
                                    ne.match_length = M - (V - Ee),
                                    ne.match_length > ne.lookahead && (ne.match_length = ne.lookahead)
                                }
                                if (ne.match_length >= I ? (de = a._tr_tally(ne, 1, ne.match_length - I),
                                ne.lookahead -= ne.match_length,
                                ne.strstart += ne.match_length,
                                ne.match_length = 0) : (de = a._tr_tally(ne, 0, ne.window[ne.strstart]),
                                ne.lookahead--,
                                ne.strstart++),
                                de && (C(ne, !1),
                                ne.strm.avail_out === 0))
                                    return y
                            }
                            return ne.insert = 0,
                            Y === f ? (C(ne, !0),
                            ne.strm.avail_out === 0 ? R : F) : ne.last_lit && (C(ne, !1),
                            ne.strm.avail_out === 0) ? y : E
                        }(J, fe) : s[J.level].func(J, fe);
                        if (G !== R && G !== F || (J.status = 666),
                        G === y || G === R)
                            return H.avail_out === 0 && (J.last_flush = -1),
                            h;
                        if (G === E && (fe === 1 ? a._tr_align(J) : fe !== 5 && (a._tr_stored_block(J, 0, 0, !1),
                        fe === 3 && (j(J.head),
                        J.lookahead === 0 && (J.strstart = 0,
                        J.block_start = 0,
                        J.insert = 0))),
                        Q(H),
                        H.avail_out === 0))
                            return J.last_flush = -1,
                            h
                    }
                    return fe !== f ? h : J.wrap <= 0 ? 1 : (J.wrap === 2 ? (W(J, 255 & H.adler),
                    W(J, H.adler >> 8 & 255),
                    W(J, H.adler >> 16 & 255),
                    W(J, H.adler >> 24 & 255),
                    W(J, 255 & H.total_in),
                    W(J, H.total_in >> 8 & 255),
                    W(J, H.total_in >> 16 & 255),
                    W(J, H.total_in >> 24 & 255)) : (ee(J, H.adler >>> 16),
                    ee(J, 65535 & H.adler)),
                    Q(H),
                    0 < J.wrap && (J.wrap = -J.wrap),
                    J.pending !== 0 ? h : 1)
                }
                ,
                i.deflateEnd = function(H) {
                    var fe;
                    return H && H.state ? (fe = H.state.status) !== D && fe !== 69 && fe !== 73 && fe !== 91 && fe !== 103 && fe !== T && fe !== 666 ? O(H, d) : (H.state = null,
                    fe === T ? O(H, -3) : h) : d
                }
                ,
                i.deflateSetDictionary = function(H, fe) {
                    var Ae, J, q, he, X, G, ne, Y, de = fe.length;
                    if (!H || !H.state || (he = (Ae = H.state).wrap) === 2 || he === 1 && Ae.status !== D || Ae.lookahead)
                        return d;
                    for (he === 1 && (H.adler = l(H.adler, fe, de, 0)),
                    Ae.wrap = 0,
                    de >= Ae.w_size && (he === 0 && (j(Ae.head),
                    Ae.strstart = 0,
                    Ae.block_start = 0,
                    Ae.insert = 0),
                    Y = new o.Buf8(Ae.w_size),
                    o.arraySet(Y, fe, de - Ae.w_size, Ae.w_size, 0),
                    fe = Y,
                    de = Ae.w_size),
                    X = H.avail_in,
                    G = H.next_in,
                    ne = H.input,
                    H.avail_in = de,
                    H.next_in = 0,
                    H.input = fe,
                    re(Ae); Ae.lookahead >= I; ) {
                        for (J = Ae.strstart,
                        q = Ae.lookahead - (I - 1); Ae.ins_h = (Ae.ins_h << Ae.hash_shift ^ Ae.window[J + I - 1]) & Ae.hash_mask,
                        Ae.prev[J & Ae.w_mask] = Ae.head[Ae.ins_h],
                        Ae.head[Ae.ins_h] = J,
                        J++,
                        --q; )
                            ;
                        Ae.strstart = J,
                        Ae.lookahead = I - 1,
                        re(Ae)
                    }
                    return Ae.strstart += Ae.lookahead,
                    Ae.block_start = Ae.strstart,
                    Ae.insert = Ae.lookahead,
                    Ae.lookahead = 0,
                    Ae.match_length = Ae.prev_length = I - 1,
                    Ae.match_available = 0,
                    H.next_in = G,
                    H.input = ne,
                    H.avail_in = X,
                    Ae.wrap = he,
                    h
                }
                ,
                i.deflateInfo = "pako deflate (from Nodeca project)"
            }
            , {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./messages": 51,
                "./trees": 52
            }],
            47: [function(t, r, i) {
                r.exports = function() {
                    this.text = 0,
                    this.time = 0,
                    this.xflags = 0,
                    this.os = 0,
                    this.extra = null,
                    this.extra_len = 0,
                    this.name = "",
                    this.comment = "",
                    this.hcrc = 0,
                    this.done = !1
                }
            }
            , {}],
            48: [function(t, r, i) {
                r.exports = function(s, o) {
                    var a, l, c, A, u, f, h, d, m, g, p, v, w, _, x, b, B, S, I, M, L, D, T, y, E;
                    a = s.state,
                    l = s.next_in,
                    y = s.input,
                    c = l + (s.avail_in - 5),
                    A = s.next_out,
                    E = s.output,
                    u = A - (o - s.avail_out),
                    f = A + (s.avail_out - 257),
                    h = a.dmax,
                    d = a.wsize,
                    m = a.whave,
                    g = a.wnext,
                    p = a.window,
                    v = a.hold,
                    w = a.bits,
                    _ = a.lencode,
                    x = a.distcode,
                    b = (1 << a.lenbits) - 1,
                    B = (1 << a.distbits) - 1;
                    e: do {
                        w < 15 && (v += y[l++] << w,
                        w += 8,
                        v += y[l++] << w,
                        w += 8),
                        S = _[v & b];
                        t: for (; ; ) {
                            if (v >>>= I = S >>> 24,
                            w -= I,
                            (I = S >>> 16 & 255) === 0)
                                E[A++] = 65535 & S;
                            else {
                                if (!(16 & I)) {
                                    if (!(64 & I)) {
                                        S = _[(65535 & S) + (v & (1 << I) - 1)];
                                        continue t
                                    }
                                    if (32 & I) {
                                        a.mode = 12;
                                        break e
                                    }
                                    s.msg = "invalid literal/length code",
                                    a.mode = 30;
                                    break e
                                }
                                M = 65535 & S,
                                (I &= 15) && (w < I && (v += y[l++] << w,
                                w += 8),
                                M += v & (1 << I) - 1,
                                v >>>= I,
                                w -= I),
                                w < 15 && (v += y[l++] << w,
                                w += 8,
                                v += y[l++] << w,
                                w += 8),
                                S = x[v & B];
                                n: for (; ; ) {
                                    if (v >>>= I = S >>> 24,
                                    w -= I,
                                    !(16 & (I = S >>> 16 & 255))) {
                                        if (!(64 & I)) {
                                            S = x[(65535 & S) + (v & (1 << I) - 1)];
                                            continue n
                                        }
                                        s.msg = "invalid distance code",
                                        a.mode = 30;
                                        break e
                                    }
                                    if (L = 65535 & S,
                                    w < (I &= 15) && (v += y[l++] << w,
                                    (w += 8) < I && (v += y[l++] << w,
                                    w += 8)),
                                    h < (L += v & (1 << I) - 1)) {
                                        s.msg = "invalid distance too far back",
                                        a.mode = 30;
                                        break e
                                    }
                                    if (v >>>= I,
                                    w -= I,
                                    (I = A - u) < L) {
                                        if (m < (I = L - I) && a.sane) {
                                            s.msg = "invalid distance too far back",
                                            a.mode = 30;
                                            break e
                                        }
                                        if (T = p,
                                        (D = 0) === g) {
                                            if (D += d - I,
                                            I < M) {
                                                for (M -= I; E[A++] = p[D++],
                                                --I; )
                                                    ;
                                                D = A - L,
                                                T = E
                                            }
                                        } else if (g < I) {
                                            if (D += d + g - I,
                                            (I -= g) < M) {
                                                for (M -= I; E[A++] = p[D++],
                                                --I; )
                                                    ;
                                                if (D = 0,
                                                g < M) {
                                                    for (M -= I = g; E[A++] = p[D++],
                                                    --I; )
                                                        ;
                                                    D = A - L,
                                                    T = E
                                                }
                                            }
                                        } else if (D += g - I,
                                        I < M) {
                                            for (M -= I; E[A++] = p[D++],
                                            --I; )
                                                ;
                                            D = A - L,
                                            T = E
                                        }
                                        for (; 2 < M; )
                                            E[A++] = T[D++],
                                            E[A++] = T[D++],
                                            E[A++] = T[D++],
                                            M -= 3;
                                        M && (E[A++] = T[D++],
                                        1 < M && (E[A++] = T[D++]))
                                    } else {
                                        for (D = A - L; E[A++] = E[D++],
                                        E[A++] = E[D++],
                                        E[A++] = E[D++],
                                        2 < (M -= 3); )
                                            ;
                                        M && (E[A++] = E[D++],
                                        1 < M && (E[A++] = E[D++]))
                                    }
                                    break
                                }
                            }
                            break
                        }
                    } while (l < c && A < f);
                    l -= M = w >> 3,
                    v &= (1 << (w -= M << 3)) - 1,
                    s.next_in = l,
                    s.next_out = A,
                    s.avail_in = l < c ? c - l + 5 : 5 - (l - c),
                    s.avail_out = A < f ? f - A + 257 : 257 - (A - f),
                    a.hold = v,
                    a.bits = w
                }
            }
            , {}],
            49: [function(t, r, i) {
                var s = t("../utils/common")
                  , o = t("./adler32")
                  , a = t("./crc32")
                  , l = t("./inffast")
                  , c = t("./inftrees")
                  , A = 1
                  , u = 2
                  , f = 0
                  , h = -2
                  , d = 1
                  , m = 852
                  , g = 592;
                function p(D) {
                    return (D >>> 24 & 255) + (D >>> 8 & 65280) + ((65280 & D) << 8) + ((255 & D) << 24)
                }
                function v() {
                    this.mode = 0,
                    this.last = !1,
                    this.wrap = 0,
                    this.havedict = !1,
                    this.flags = 0,
                    this.dmax = 0,
                    this.check = 0,
                    this.total = 0,
                    this.head = null,
                    this.wbits = 0,
                    this.wsize = 0,
                    this.whave = 0,
                    this.wnext = 0,
                    this.window = null,
                    this.hold = 0,
                    this.bits = 0,
                    this.length = 0,
                    this.offset = 0,
                    this.extra = 0,
                    this.lencode = null,
                    this.distcode = null,
                    this.lenbits = 0,
                    this.distbits = 0,
                    this.ncode = 0,
                    this.nlen = 0,
                    this.ndist = 0,
                    this.have = 0,
                    this.next = null,
                    this.lens = new s.Buf16(320),
                    this.work = new s.Buf16(288),
                    this.lendyn = null,
                    this.distdyn = null,
                    this.sane = 0,
                    this.back = 0,
                    this.was = 0
                }
                function w(D) {
                    var T;
                    return D && D.state ? (T = D.state,
                    D.total_in = D.total_out = T.total = 0,
                    D.msg = "",
                    T.wrap && (D.adler = 1 & T.wrap),
                    T.mode = d,
                    T.last = 0,
                    T.havedict = 0,
                    T.dmax = 32768,
                    T.head = null,
                    T.hold = 0,
                    T.bits = 0,
                    T.lencode = T.lendyn = new s.Buf32(m),
                    T.distcode = T.distdyn = new s.Buf32(g),
                    T.sane = 1,
                    T.back = -1,
                    f) : h
                }
                function _(D) {
                    var T;
                    return D && D.state ? ((T = D.state).wsize = 0,
                    T.whave = 0,
                    T.wnext = 0,
                    w(D)) : h
                }
                function x(D, T) {
                    var y, E;
                    return D && D.state ? (E = D.state,
                    T < 0 ? (y = 0,
                    T = -T) : (y = 1 + (T >> 4),
                    T < 48 && (T &= 15)),
                    T && (T < 8 || 15 < T) ? h : (E.window !== null && E.wbits !== T && (E.window = null),
                    E.wrap = y,
                    E.wbits = T,
                    _(D))) : h
                }
                function b(D, T) {
                    var y, E;
                    return D ? (E = new v,
                    (D.state = E).window = null,
                    (y = x(D, T)) !== f && (D.state = null),
                    y) : h
                }
                var B, S, I = !0;
                function M(D) {
                    if (I) {
                        var T;
                        for (B = new s.Buf32(512),
                        S = new s.Buf32(32),
                        T = 0; T < 144; )
                            D.lens[T++] = 8;
                        for (; T < 256; )
                            D.lens[T++] = 9;
                        for (; T < 280; )
                            D.lens[T++] = 7;
                        for (; T < 288; )
                            D.lens[T++] = 8;
                        for (c(A, D.lens, 0, 288, B, 0, D.work, {
                            bits: 9
                        }),
                        T = 0; T < 32; )
                            D.lens[T++] = 5;
                        c(u, D.lens, 0, 32, S, 0, D.work, {
                            bits: 5
                        }),
                        I = !1
                    }
                    D.lencode = B,
                    D.lenbits = 9,
                    D.distcode = S,
                    D.distbits = 5
                }
                function L(D, T, y, E) {
                    var R, F = D.state;
                    return F.window === null && (F.wsize = 1 << F.wbits,
                    F.wnext = 0,
                    F.whave = 0,
                    F.window = new s.Buf8(F.wsize)),
                    E >= F.wsize ? (s.arraySet(F.window, T, y - F.wsize, F.wsize, 0),
                    F.wnext = 0,
                    F.whave = F.wsize) : (E < (R = F.wsize - F.wnext) && (R = E),
                    s.arraySet(F.window, T, y - E, R, F.wnext),
                    (E -= R) ? (s.arraySet(F.window, T, y - E, E, 0),
                    F.wnext = E,
                    F.whave = F.wsize) : (F.wnext += R,
                    F.wnext === F.wsize && (F.wnext = 0),
                    F.whave < F.wsize && (F.whave += R))),
                    0
                }
                i.inflateReset = _,
                i.inflateReset2 = x,
                i.inflateResetKeep = w,
                i.inflateInit = function(D) {
                    return b(D, 15)
                }
                ,
                i.inflateInit2 = b,
                i.inflate = function(D, T) {
                    var y, E, R, F, O, z, j, Q, C, W, ee, P, re, ue, le, me, ie, ge, _e, se, H, fe, Ae, J, q = 0, he = new s.Buf8(4), X = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                    if (!D || !D.state || !D.output || !D.input && D.avail_in !== 0)
                        return h;
                    (y = D.state).mode === 12 && (y.mode = 13),
                    O = D.next_out,
                    R = D.output,
                    j = D.avail_out,
                    F = D.next_in,
                    E = D.input,
                    z = D.avail_in,
                    Q = y.hold,
                    C = y.bits,
                    W = z,
                    ee = j,
                    fe = f;
                    e: for (; ; )
                        switch (y.mode) {
                        case d:
                            if (y.wrap === 0) {
                                y.mode = 13;
                                break
                            }
                            for (; C < 16; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if (2 & y.wrap && Q === 35615) {
                                he[y.check = 0] = 255 & Q,
                                he[1] = Q >>> 8 & 255,
                                y.check = a(y.check, he, 2, 0),
                                C = Q = 0,
                                y.mode = 2;
                                break
                            }
                            if (y.flags = 0,
                            y.head && (y.head.done = !1),
                            !(1 & y.wrap) || (((255 & Q) << 8) + (Q >> 8)) % 31) {
                                D.msg = "incorrect header check",
                                y.mode = 30;
                                break
                            }
                            if ((15 & Q) != 8) {
                                D.msg = "unknown compression method",
                                y.mode = 30;
                                break
                            }
                            if (C -= 4,
                            H = 8 + (15 & (Q >>>= 4)),
                            y.wbits === 0)
                                y.wbits = H;
                            else if (H > y.wbits) {
                                D.msg = "invalid window size",
                                y.mode = 30;
                                break
                            }
                            y.dmax = 1 << H,
                            D.adler = y.check = 1,
                            y.mode = 512 & Q ? 10 : 12,
                            C = Q = 0;
                            break;
                        case 2:
                            for (; C < 16; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if (y.flags = Q,
                            (255 & y.flags) != 8) {
                                D.msg = "unknown compression method",
                                y.mode = 30;
                                break
                            }
                            if (57344 & y.flags) {
                                D.msg = "unknown header flags set",
                                y.mode = 30;
                                break
                            }
                            y.head && (y.head.text = Q >> 8 & 1),
                            512 & y.flags && (he[0] = 255 & Q,
                            he[1] = Q >>> 8 & 255,
                            y.check = a(y.check, he, 2, 0)),
                            C = Q = 0,
                            y.mode = 3;
                        case 3:
                            for (; C < 32; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            y.head && (y.head.time = Q),
                            512 & y.flags && (he[0] = 255 & Q,
                            he[1] = Q >>> 8 & 255,
                            he[2] = Q >>> 16 & 255,
                            he[3] = Q >>> 24 & 255,
                            y.check = a(y.check, he, 4, 0)),
                            C = Q = 0,
                            y.mode = 4;
                        case 4:
                            for (; C < 16; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            y.head && (y.head.xflags = 255 & Q,
                            y.head.os = Q >> 8),
                            512 & y.flags && (he[0] = 255 & Q,
                            he[1] = Q >>> 8 & 255,
                            y.check = a(y.check, he, 2, 0)),
                            C = Q = 0,
                            y.mode = 5;
                        case 5:
                            if (1024 & y.flags) {
                                for (; C < 16; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                y.length = Q,
                                y.head && (y.head.extra_len = Q),
                                512 & y.flags && (he[0] = 255 & Q,
                                he[1] = Q >>> 8 & 255,
                                y.check = a(y.check, he, 2, 0)),
                                C = Q = 0
                            } else
                                y.head && (y.head.extra = null);
                            y.mode = 6;
                        case 6:
                            if (1024 & y.flags && (z < (P = y.length) && (P = z),
                            P && (y.head && (H = y.head.extra_len - y.length,
                            y.head.extra || (y.head.extra = new Array(y.head.extra_len)),
                            s.arraySet(y.head.extra, E, F, P, H)),
                            512 & y.flags && (y.check = a(y.check, E, P, F)),
                            z -= P,
                            F += P,
                            y.length -= P),
                            y.length))
                                break e;
                            y.length = 0,
                            y.mode = 7;
                        case 7:
                            if (2048 & y.flags) {
                                if (z === 0)
                                    break e;
                                for (P = 0; H = E[F + P++],
                                y.head && H && y.length < 65536 && (y.head.name += String.fromCharCode(H)),
                                H && P < z; )
                                    ;
                                if (512 & y.flags && (y.check = a(y.check, E, P, F)),
                                z -= P,
                                F += P,
                                H)
                                    break e
                            } else
                                y.head && (y.head.name = null);
                            y.length = 0,
                            y.mode = 8;
                        case 8:
                            if (4096 & y.flags) {
                                if (z === 0)
                                    break e;
                                for (P = 0; H = E[F + P++],
                                y.head && H && y.length < 65536 && (y.head.comment += String.fromCharCode(H)),
                                H && P < z; )
                                    ;
                                if (512 & y.flags && (y.check = a(y.check, E, P, F)),
                                z -= P,
                                F += P,
                                H)
                                    break e
                            } else
                                y.head && (y.head.comment = null);
                            y.mode = 9;
                        case 9:
                            if (512 & y.flags) {
                                for (; C < 16; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                if (Q !== (65535 & y.check)) {
                                    D.msg = "header crc mismatch",
                                    y.mode = 30;
                                    break
                                }
                                C = Q = 0
                            }
                            y.head && (y.head.hcrc = y.flags >> 9 & 1,
                            y.head.done = !0),
                            D.adler = y.check = 0,
                            y.mode = 12;
                            break;
                        case 10:
                            for (; C < 32; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            D.adler = y.check = p(Q),
                            C = Q = 0,
                            y.mode = 11;
                        case 11:
                            if (y.havedict === 0)
                                return D.next_out = O,
                                D.avail_out = j,
                                D.next_in = F,
                                D.avail_in = z,
                                y.hold = Q,
                                y.bits = C,
                                2;
                            D.adler = y.check = 1,
                            y.mode = 12;
                        case 12:
                            if (T === 5 || T === 6)
                                break e;
                        case 13:
                            if (y.last) {
                                Q >>>= 7 & C,
                                C -= 7 & C,
                                y.mode = 27;
                                break
                            }
                            for (; C < 3; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            switch (y.last = 1 & Q,
                            C -= 1,
                            3 & (Q >>>= 1)) {
                            case 0:
                                y.mode = 14;
                                break;
                            case 1:
                                if (M(y),
                                y.mode = 20,
                                T !== 6)
                                    break;
                                Q >>>= 2,
                                C -= 2;
                                break e;
                            case 2:
                                y.mode = 17;
                                break;
                            case 3:
                                D.msg = "invalid block type",
                                y.mode = 30
                            }
                            Q >>>= 2,
                            C -= 2;
                            break;
                        case 14:
                            for (Q >>>= 7 & C,
                            C -= 7 & C; C < 32; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if ((65535 & Q) != (Q >>> 16 ^ 65535)) {
                                D.msg = "invalid stored block lengths",
                                y.mode = 30;
                                break
                            }
                            if (y.length = 65535 & Q,
                            C = Q = 0,
                            y.mode = 15,
                            T === 6)
                                break e;
                        case 15:
                            y.mode = 16;
                        case 16:
                            if (P = y.length) {
                                if (z < P && (P = z),
                                j < P && (P = j),
                                P === 0)
                                    break e;
                                s.arraySet(R, E, F, P, O),
                                z -= P,
                                F += P,
                                j -= P,
                                O += P,
                                y.length -= P;
                                break
                            }
                            y.mode = 12;
                            break;
                        case 17:
                            for (; C < 14; ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if (y.nlen = 257 + (31 & Q),
                            Q >>>= 5,
                            C -= 5,
                            y.ndist = 1 + (31 & Q),
                            Q >>>= 5,
                            C -= 5,
                            y.ncode = 4 + (15 & Q),
                            Q >>>= 4,
                            C -= 4,
                            286 < y.nlen || 30 < y.ndist) {
                                D.msg = "too many length or distance symbols",
                                y.mode = 30;
                                break
                            }
                            y.have = 0,
                            y.mode = 18;
                        case 18:
                            for (; y.have < y.ncode; ) {
                                for (; C < 3; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                y.lens[X[y.have++]] = 7 & Q,
                                Q >>>= 3,
                                C -= 3
                            }
                            for (; y.have < 19; )
                                y.lens[X[y.have++]] = 0;
                            if (y.lencode = y.lendyn,
                            y.lenbits = 7,
                            Ae = {
                                bits: y.lenbits
                            },
                            fe = c(0, y.lens, 0, 19, y.lencode, 0, y.work, Ae),
                            y.lenbits = Ae.bits,
                            fe) {
                                D.msg = "invalid code lengths set",
                                y.mode = 30;
                                break
                            }
                            y.have = 0,
                            y.mode = 19;
                        case 19:
                            for (; y.have < y.nlen + y.ndist; ) {
                                for (; me = (q = y.lencode[Q & (1 << y.lenbits) - 1]) >>> 16 & 255,
                                ie = 65535 & q,
                                !((le = q >>> 24) <= C); ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                if (ie < 16)
                                    Q >>>= le,
                                    C -= le,
                                    y.lens[y.have++] = ie;
                                else {
                                    if (ie === 16) {
                                        for (J = le + 2; C < J; ) {
                                            if (z === 0)
                                                break e;
                                            z--,
                                            Q += E[F++] << C,
                                            C += 8
                                        }
                                        if (Q >>>= le,
                                        C -= le,
                                        y.have === 0) {
                                            D.msg = "invalid bit length repeat",
                                            y.mode = 30;
                                            break
                                        }
                                        H = y.lens[y.have - 1],
                                        P = 3 + (3 & Q),
                                        Q >>>= 2,
                                        C -= 2
                                    } else if (ie === 17) {
                                        for (J = le + 3; C < J; ) {
                                            if (z === 0)
                                                break e;
                                            z--,
                                            Q += E[F++] << C,
                                            C += 8
                                        }
                                        C -= le,
                                        H = 0,
                                        P = 3 + (7 & (Q >>>= le)),
                                        Q >>>= 3,
                                        C -= 3
                                    } else {
                                        for (J = le + 7; C < J; ) {
                                            if (z === 0)
                                                break e;
                                            z--,
                                            Q += E[F++] << C,
                                            C += 8
                                        }
                                        C -= le,
                                        H = 0,
                                        P = 11 + (127 & (Q >>>= le)),
                                        Q >>>= 7,
                                        C -= 7
                                    }
                                    if (y.have + P > y.nlen + y.ndist) {
                                        D.msg = "invalid bit length repeat",
                                        y.mode = 30;
                                        break
                                    }
                                    for (; P--; )
                                        y.lens[y.have++] = H
                                }
                            }
                            if (y.mode === 30)
                                break;
                            if (y.lens[256] === 0) {
                                D.msg = "invalid code -- missing end-of-block",
                                y.mode = 30;
                                break
                            }
                            if (y.lenbits = 9,
                            Ae = {
                                bits: y.lenbits
                            },
                            fe = c(A, y.lens, 0, y.nlen, y.lencode, 0, y.work, Ae),
                            y.lenbits = Ae.bits,
                            fe) {
                                D.msg = "invalid literal/lengths set",
                                y.mode = 30;
                                break
                            }
                            if (y.distbits = 6,
                            y.distcode = y.distdyn,
                            Ae = {
                                bits: y.distbits
                            },
                            fe = c(u, y.lens, y.nlen, y.ndist, y.distcode, 0, y.work, Ae),
                            y.distbits = Ae.bits,
                            fe) {
                                D.msg = "invalid distances set",
                                y.mode = 30;
                                break
                            }
                            if (y.mode = 20,
                            T === 6)
                                break e;
                        case 20:
                            y.mode = 21;
                        case 21:
                            if (6 <= z && 258 <= j) {
                                D.next_out = O,
                                D.avail_out = j,
                                D.next_in = F,
                                D.avail_in = z,
                                y.hold = Q,
                                y.bits = C,
                                l(D, ee),
                                O = D.next_out,
                                R = D.output,
                                j = D.avail_out,
                                F = D.next_in,
                                E = D.input,
                                z = D.avail_in,
                                Q = y.hold,
                                C = y.bits,
                                y.mode === 12 && (y.back = -1);
                                break
                            }
                            for (y.back = 0; me = (q = y.lencode[Q & (1 << y.lenbits) - 1]) >>> 16 & 255,
                            ie = 65535 & q,
                            !((le = q >>> 24) <= C); ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if (me && !(240 & me)) {
                                for (ge = le,
                                _e = me,
                                se = ie; me = (q = y.lencode[se + ((Q & (1 << ge + _e) - 1) >> ge)]) >>> 16 & 255,
                                ie = 65535 & q,
                                !(ge + (le = q >>> 24) <= C); ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                Q >>>= ge,
                                C -= ge,
                                y.back += ge
                            }
                            if (Q >>>= le,
                            C -= le,
                            y.back += le,
                            y.length = ie,
                            me === 0) {
                                y.mode = 26;
                                break
                            }
                            if (32 & me) {
                                y.back = -1,
                                y.mode = 12;
                                break
                            }
                            if (64 & me) {
                                D.msg = "invalid literal/length code",
                                y.mode = 30;
                                break
                            }
                            y.extra = 15 & me,
                            y.mode = 22;
                        case 22:
                            if (y.extra) {
                                for (J = y.extra; C < J; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                y.length += Q & (1 << y.extra) - 1,
                                Q >>>= y.extra,
                                C -= y.extra,
                                y.back += y.extra
                            }
                            y.was = y.length,
                            y.mode = 23;
                        case 23:
                            for (; me = (q = y.distcode[Q & (1 << y.distbits) - 1]) >>> 16 & 255,
                            ie = 65535 & q,
                            !((le = q >>> 24) <= C); ) {
                                if (z === 0)
                                    break e;
                                z--,
                                Q += E[F++] << C,
                                C += 8
                            }
                            if (!(240 & me)) {
                                for (ge = le,
                                _e = me,
                                se = ie; me = (q = y.distcode[se + ((Q & (1 << ge + _e) - 1) >> ge)]) >>> 16 & 255,
                                ie = 65535 & q,
                                !(ge + (le = q >>> 24) <= C); ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                Q >>>= ge,
                                C -= ge,
                                y.back += ge
                            }
                            if (Q >>>= le,
                            C -= le,
                            y.back += le,
                            64 & me) {
                                D.msg = "invalid distance code",
                                y.mode = 30;
                                break
                            }
                            y.offset = ie,
                            y.extra = 15 & me,
                            y.mode = 24;
                        case 24:
                            if (y.extra) {
                                for (J = y.extra; C < J; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                y.offset += Q & (1 << y.extra) - 1,
                                Q >>>= y.extra,
                                C -= y.extra,
                                y.back += y.extra
                            }
                            if (y.offset > y.dmax) {
                                D.msg = "invalid distance too far back",
                                y.mode = 30;
                                break
                            }
                            y.mode = 25;
                        case 25:
                            if (j === 0)
                                break e;
                            if (P = ee - j,
                            y.offset > P) {
                                if ((P = y.offset - P) > y.whave && y.sane) {
                                    D.msg = "invalid distance too far back",
                                    y.mode = 30;
                                    break
                                }
                                re = P > y.wnext ? (P -= y.wnext,
                                y.wsize - P) : y.wnext - P,
                                P > y.length && (P = y.length),
                                ue = y.window
                            } else
                                ue = R,
                                re = O - y.offset,
                                P = y.length;
                            for (j < P && (P = j),
                            j -= P,
                            y.length -= P; R[O++] = ue[re++],
                            --P; )
                                ;
                            y.length === 0 && (y.mode = 21);
                            break;
                        case 26:
                            if (j === 0)
                                break e;
                            R[O++] = y.length,
                            j--,
                            y.mode = 21;
                            break;
                        case 27:
                            if (y.wrap) {
                                for (; C < 32; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q |= E[F++] << C,
                                    C += 8
                                }
                                if (ee -= j,
                                D.total_out += ee,
                                y.total += ee,
                                ee && (D.adler = y.check = y.flags ? a(y.check, R, ee, O - ee) : o(y.check, R, ee, O - ee)),
                                ee = j,
                                (y.flags ? Q : p(Q)) !== y.check) {
                                    D.msg = "incorrect data check",
                                    y.mode = 30;
                                    break
                                }
                                C = Q = 0
                            }
                            y.mode = 28;
                        case 28:
                            if (y.wrap && y.flags) {
                                for (; C < 32; ) {
                                    if (z === 0)
                                        break e;
                                    z--,
                                    Q += E[F++] << C,
                                    C += 8
                                }
                                if (Q !== (4294967295 & y.total)) {
                                    D.msg = "incorrect length check",
                                    y.mode = 30;
                                    break
                                }
                                C = Q = 0
                            }
                            y.mode = 29;
                        case 29:
                            fe = 1;
                            break e;
                        case 30:
                            fe = -3;
                            break e;
                        case 31:
                            return -4;
                        case 32:
                        default:
                            return h
                        }
                    return D.next_out = O,
                    D.avail_out = j,
                    D.next_in = F,
                    D.avail_in = z,
                    y.hold = Q,
                    y.bits = C,
                    (y.wsize || ee !== D.avail_out && y.mode < 30 && (y.mode < 27 || T !== 4)) && L(D, D.output, D.next_out, ee - D.avail_out) ? (y.mode = 31,
                    -4) : (W -= D.avail_in,
                    ee -= D.avail_out,
                    D.total_in += W,
                    D.total_out += ee,
                    y.total += ee,
                    y.wrap && ee && (D.adler = y.check = y.flags ? a(y.check, R, ee, D.next_out - ee) : o(y.check, R, ee, D.next_out - ee)),
                    D.data_type = y.bits + (y.last ? 64 : 0) + (y.mode === 12 ? 128 : 0) + (y.mode === 20 || y.mode === 15 ? 256 : 0),
                    (W == 0 && ee === 0 || T === 4) && fe === f && (fe = -5),
                    fe)
                }
                ,
                i.inflateEnd = function(D) {
                    if (!D || !D.state)
                        return h;
                    var T = D.state;
                    return T.window && (T.window = null),
                    D.state = null,
                    f
                }
                ,
                i.inflateGetHeader = function(D, T) {
                    var y;
                    return D && D.state && 2 & (y = D.state).wrap ? ((y.head = T).done = !1,
                    f) : h
                }
                ,
                i.inflateSetDictionary = function(D, T) {
                    var y, E = T.length;
                    return D && D.state ? (y = D.state).wrap !== 0 && y.mode !== 11 ? h : y.mode === 11 && o(1, T, E, 0) !== y.check ? -3 : L(D, T, E, E) ? (y.mode = 31,
                    -4) : (y.havedict = 1,
                    f) : h
                }
                ,
                i.inflateInfo = "pako inflate (from Nodeca project)"
            }
            , {
                "../utils/common": 41,
                "./adler32": 43,
                "./crc32": 45,
                "./inffast": 48,
                "./inftrees": 50
            }],
            50: [function(t, r, i) {
                var s = t("../utils/common")
                  , o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]
                  , a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]
                  , l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]
                  , c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                r.exports = function(A, u, f, h, d, m, g, p) {
                    var v, w, _, x, b, B, S, I, M, L = p.bits, D = 0, T = 0, y = 0, E = 0, R = 0, F = 0, O = 0, z = 0, j = 0, Q = 0, C = null, W = 0, ee = new s.Buf16(16), P = new s.Buf16(16), re = null, ue = 0;
                    for (D = 0; D <= 15; D++)
                        ee[D] = 0;
                    for (T = 0; T < h; T++)
                        ee[u[f + T]]++;
                    for (R = L,
                    E = 15; 1 <= E && ee[E] === 0; E--)
                        ;
                    if (E < R && (R = E),
                    E === 0)
                        return d[m++] = 20971520,
                        d[m++] = 20971520,
                        p.bits = 1,
                        0;
                    for (y = 1; y < E && ee[y] === 0; y++)
                        ;
                    for (R < y && (R = y),
                    D = z = 1; D <= 15; D++)
                        if (z <<= 1,
                        (z -= ee[D]) < 0)
                            return -1;
                    if (0 < z && (A === 0 || E !== 1))
                        return -1;
                    for (P[1] = 0,
                    D = 1; D < 15; D++)
                        P[D + 1] = P[D] + ee[D];
                    for (T = 0; T < h; T++)
                        u[f + T] !== 0 && (g[P[u[f + T]]++] = T);
                    if (B = A === 0 ? (C = re = g,
                    19) : A === 1 ? (C = o,
                    W -= 257,
                    re = a,
                    ue -= 257,
                    256) : (C = l,
                    re = c,
                    -1),
                    D = y,
                    b = m,
                    O = T = Q = 0,
                    _ = -1,
                    x = (j = 1 << (F = R)) - 1,
                    A === 1 && 852 < j || A === 2 && 592 < j)
                        return 1;
                    for (; ; ) {
                        for (S = D - O,
                        M = g[T] < B ? (I = 0,
                        g[T]) : g[T] > B ? (I = re[ue + g[T]],
                        C[W + g[T]]) : (I = 96,
                        0),
                        v = 1 << D - O,
                        y = w = 1 << F; d[b + (Q >> O) + (w -= v)] = S << 24 | I << 16 | M | 0,
                        w !== 0; )
                            ;
                        for (v = 1 << D - 1; Q & v; )
                            v >>= 1;
                        if (v !== 0 ? (Q &= v - 1,
                        Q += v) : Q = 0,
                        T++,
                        --ee[D] == 0) {
                            if (D === E)
                                break;
                            D = u[f + g[T]]
                        }
                        if (R < D && (Q & x) !== _) {
                            for (O === 0 && (O = R),
                            b += y,
                            z = 1 << (F = D - O); F + O < E && !((z -= ee[F + O]) <= 0); )
                                F++,
                                z <<= 1;
                            if (j += 1 << F,
                            A === 1 && 852 < j || A === 2 && 592 < j)
                                return 1;
                            d[_ = Q & x] = R << 24 | F << 16 | b - m | 0
                        }
                    }
                    return Q !== 0 && (d[b + Q] = D - O << 24 | 64 << 16 | 0),
                    p.bits = R,
                    0
                }
            }
            , {
                "../utils/common": 41
            }],
            51: [function(t, r, i) {
                r.exports = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                }
            }
            , {}],
            52: [function(t, r, i) {
                var s = t("../utils/common")
                  , o = 0
                  , a = 1;
                function l(q) {
                    for (var he = q.length; 0 <= --he; )
                        q[he] = 0
                }
                var c = 0
                  , A = 29
                  , u = 256
                  , f = u + 1 + A
                  , h = 30
                  , d = 19
                  , m = 2 * f + 1
                  , g = 15
                  , p = 16
                  , v = 7
                  , w = 256
                  , _ = 16
                  , x = 17
                  , b = 18
                  , B = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
                  , S = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
                  , I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
                  , M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
                  , L = new Array(2 * (f + 2));
                l(L);
                var D = new Array(2 * h);
                l(D);
                var T = new Array(512);
                l(T);
                var y = new Array(256);
                l(y);
                var E = new Array(A);
                l(E);
                var R, F, O, z = new Array(h);
                function j(q, he, X, G, ne) {
                    this.static_tree = q,
                    this.extra_bits = he,
                    this.extra_base = X,
                    this.elems = G,
                    this.max_length = ne,
                    this.has_stree = q && q.length
                }
                function Q(q, he) {
                    this.dyn_tree = q,
                    this.max_code = 0,
                    this.stat_desc = he
                }
                function C(q) {
                    return q < 256 ? T[q] : T[256 + (q >>> 7)]
                }
                function W(q, he) {
                    q.pending_buf[q.pending++] = 255 & he,
                    q.pending_buf[q.pending++] = he >>> 8 & 255
                }
                function ee(q, he, X) {
                    q.bi_valid > p - X ? (q.bi_buf |= he << q.bi_valid & 65535,
                    W(q, q.bi_buf),
                    q.bi_buf = he >> p - q.bi_valid,
                    q.bi_valid += X - p) : (q.bi_buf |= he << q.bi_valid & 65535,
                    q.bi_valid += X)
                }
                function P(q, he, X) {
                    ee(q, X[2 * he], X[2 * he + 1])
                }
                function re(q, he) {
                    for (var X = 0; X |= 1 & q,
                    q >>>= 1,
                    X <<= 1,
                    0 < --he; )
                        ;
                    return X >>> 1
                }
                function ue(q, he, X) {
                    var G, ne, Y = new Array(g + 1), de = 0;
                    for (G = 1; G <= g; G++)
                        Y[G] = de = de + X[G - 1] << 1;
                    for (ne = 0; ne <= he; ne++) {
                        var ae = q[2 * ne + 1];
                        ae !== 0 && (q[2 * ne] = re(Y[ae]++, ae))
                    }
                }
                function le(q) {
                    var he;
                    for (he = 0; he < f; he++)
                        q.dyn_ltree[2 * he] = 0;
                    for (he = 0; he < h; he++)
                        q.dyn_dtree[2 * he] = 0;
                    for (he = 0; he < d; he++)
                        q.bl_tree[2 * he] = 0;
                    q.dyn_ltree[2 * w] = 1,
                    q.opt_len = q.static_len = 0,
                    q.last_lit = q.matches = 0
                }
                function me(q) {
                    8 < q.bi_valid ? W(q, q.bi_buf) : 0 < q.bi_valid && (q.pending_buf[q.pending++] = q.bi_buf),
                    q.bi_buf = 0,
                    q.bi_valid = 0
                }
                function ie(q, he, X, G) {
                    var ne = 2 * he
                      , Y = 2 * X;
                    return q[ne] < q[Y] || q[ne] === q[Y] && G[he] <= G[X]
                }
                function ge(q, he, X) {
                    for (var G = q.heap[X], ne = X << 1; ne <= q.heap_len && (ne < q.heap_len && ie(he, q.heap[ne + 1], q.heap[ne], q.depth) && ne++,
                    !ie(he, G, q.heap[ne], q.depth)); )
                        q.heap[X] = q.heap[ne],
                        X = ne,
                        ne <<= 1;
                    q.heap[X] = G
                }
                function _e(q, he, X) {
                    var G, ne, Y, de, ae = 0;
                    if (q.last_lit !== 0)
                        for (; G = q.pending_buf[q.d_buf + 2 * ae] << 8 | q.pending_buf[q.d_buf + 2 * ae + 1],
                        ne = q.pending_buf[q.l_buf + ae],
                        ae++,
                        G === 0 ? P(q, ne, he) : (P(q, (Y = y[ne]) + u + 1, he),
                        (de = B[Y]) !== 0 && ee(q, ne -= E[Y], de),
                        P(q, Y = C(--G), X),
                        (de = S[Y]) !== 0 && ee(q, G -= z[Y], de)),
                        ae < q.last_lit; )
                            ;
                    P(q, w, he)
                }
                function se(q, he) {
                    var X, G, ne, Y = he.dyn_tree, de = he.stat_desc.static_tree, ae = he.stat_desc.has_stree, Ee = he.stat_desc.elems, V = -1;
                    for (q.heap_len = 0,
                    q.heap_max = m,
                    X = 0; X < Ee; X++)
                        Y[2 * X] !== 0 ? (q.heap[++q.heap_len] = V = X,
                        q.depth[X] = 0) : Y[2 * X + 1] = 0;
                    for (; q.heap_len < 2; )
                        Y[2 * (ne = q.heap[++q.heap_len] = V < 2 ? ++V : 0)] = 1,
                        q.depth[ne] = 0,
                        q.opt_len--,
                        ae && (q.static_len -= de[2 * ne + 1]);
                    for (he.max_code = V,
                    X = q.heap_len >> 1; 1 <= X; X--)
                        ge(q, Y, X);
                    for (ne = Ee; X = q.heap[1],
                    q.heap[1] = q.heap[q.heap_len--],
                    ge(q, Y, 1),
                    G = q.heap[1],
                    q.heap[--q.heap_max] = X,
                    q.heap[--q.heap_max] = G,
                    Y[2 * ne] = Y[2 * X] + Y[2 * G],
                    q.depth[ne] = (q.depth[X] >= q.depth[G] ? q.depth[X] : q.depth[G]) + 1,
                    Y[2 * X + 1] = Y[2 * G + 1] = ne,
                    q.heap[1] = ne++,
                    ge(q, Y, 1),
                    2 <= q.heap_len; )
                        ;
                    q.heap[--q.heap_max] = q.heap[1],
                    function(U, N) {
                        var K, oe, pe, ve, Ce, Le, Re = N.dyn_tree, $e = N.max_code, ce = N.stat_desc.static_tree, Pe = N.stat_desc.has_stree, Se = N.stat_desc.extra_bits, Te = N.stat_desc.extra_base, Fe = N.stat_desc.max_length, De = 0;
                        for (ve = 0; ve <= g; ve++)
                            U.bl_count[ve] = 0;
                        for (Re[2 * U.heap[U.heap_max] + 1] = 0,
                        K = U.heap_max + 1; K < m; K++)
                            Fe < (ve = Re[2 * Re[2 * (oe = U.heap[K]) + 1] + 1] + 1) && (ve = Fe,
                            De++),
                            Re[2 * oe + 1] = ve,
                            $e < oe || (U.bl_count[ve]++,
                            Ce = 0,
                            Te <= oe && (Ce = Se[oe - Te]),
                            Le = Re[2 * oe],
                            U.opt_len += Le * (ve + Ce),
                            Pe && (U.static_len += Le * (ce[2 * oe + 1] + Ce)));
                        if (De !== 0) {
                            do {
                                for (ve = Fe - 1; U.bl_count[ve] === 0; )
                                    ve--;
                                U.bl_count[ve]--,
                                U.bl_count[ve + 1] += 2,
                                U.bl_count[Fe]--,
                                De -= 2
                            } while (0 < De);
                            for (ve = Fe; ve !== 0; ve--)
                                for (oe = U.bl_count[ve]; oe !== 0; )
                                    $e < (pe = U.heap[--K]) || (Re[2 * pe + 1] !== ve && (U.opt_len += (ve - Re[2 * pe + 1]) * Re[2 * pe],
                                    Re[2 * pe + 1] = ve),
                                    oe--)
                        }
                    }(q, he),
                    ue(Y, V, q.bl_count)
                }
                function H(q, he, X) {
                    var G, ne, Y = -1, de = he[1], ae = 0, Ee = 7, V = 4;
                    for (de === 0 && (Ee = 138,
                    V = 3),
                    he[2 * (X + 1) + 1] = 65535,
                    G = 0; G <= X; G++)
                        ne = de,
                        de = he[2 * (G + 1) + 1],
                        ++ae < Ee && ne === de || (ae < V ? q.bl_tree[2 * ne] += ae : ne !== 0 ? (ne !== Y && q.bl_tree[2 * ne]++,
                        q.bl_tree[2 * _]++) : ae <= 10 ? q.bl_tree[2 * x]++ : q.bl_tree[2 * b]++,
                        Y = ne,
                        V = (ae = 0) === de ? (Ee = 138,
                        3) : ne === de ? (Ee = 6,
                        3) : (Ee = 7,
                        4))
                }
                function fe(q, he, X) {
                    var G, ne, Y = -1, de = he[1], ae = 0, Ee = 7, V = 4;
                    for (de === 0 && (Ee = 138,
                    V = 3),
                    G = 0; G <= X; G++)
                        if (ne = de,
                        de = he[2 * (G + 1) + 1],
                        !(++ae < Ee && ne === de)) {
                            if (ae < V)
                                for (; P(q, ne, q.bl_tree),
                                --ae != 0; )
                                    ;
                            else
                                ne !== 0 ? (ne !== Y && (P(q, ne, q.bl_tree),
                                ae--),
                                P(q, _, q.bl_tree),
                                ee(q, ae - 3, 2)) : ae <= 10 ? (P(q, x, q.bl_tree),
                                ee(q, ae - 3, 3)) : (P(q, b, q.bl_tree),
                                ee(q, ae - 11, 7));
                            Y = ne,
                            V = (ae = 0) === de ? (Ee = 138,
                            3) : ne === de ? (Ee = 6,
                            3) : (Ee = 7,
                            4)
                        }
                }
                l(z);
                var Ae = !1;
                function J(q, he, X, G) {
                    ee(q, (c << 1) + (G ? 1 : 0), 3),
                    function(ne, Y, de, ae) {
                        me(ne),
                        ae && (W(ne, de),
                        W(ne, ~de)),
                        s.arraySet(ne.pending_buf, ne.window, Y, de, ne.pending),
                        ne.pending += de
                    }(q, he, X, !0)
                }
                i._tr_init = function(q) {
                    Ae || (function() {
                        var he, X, G, ne, Y, de = new Array(g + 1);
                        for (ne = G = 0; ne < A - 1; ne++)
                            for (E[ne] = G,
                            he = 0; he < 1 << B[ne]; he++)
                                y[G++] = ne;
                        for (y[G - 1] = ne,
                        ne = Y = 0; ne < 16; ne++)
                            for (z[ne] = Y,
                            he = 0; he < 1 << S[ne]; he++)
                                T[Y++] = ne;
                        for (Y >>= 7; ne < h; ne++)
                            for (z[ne] = Y << 7,
                            he = 0; he < 1 << S[ne] - 7; he++)
                                T[256 + Y++] = ne;
                        for (X = 0; X <= g; X++)
                            de[X] = 0;
                        for (he = 0; he <= 143; )
                            L[2 * he + 1] = 8,
                            he++,
                            de[8]++;
                        for (; he <= 255; )
                            L[2 * he + 1] = 9,
                            he++,
                            de[9]++;
                        for (; he <= 279; )
                            L[2 * he + 1] = 7,
                            he++,
                            de[7]++;
                        for (; he <= 287; )
                            L[2 * he + 1] = 8,
                            he++,
                            de[8]++;
                        for (ue(L, f + 1, de),
                        he = 0; he < h; he++)
                            D[2 * he + 1] = 5,
                            D[2 * he] = re(he, 5);
                        R = new j(L,B,u + 1,f,g),
                        F = new j(D,S,0,h,g),
                        O = new j(new Array(0),I,0,d,v)
                    }(),
                    Ae = !0),
                    q.l_desc = new Q(q.dyn_ltree,R),
                    q.d_desc = new Q(q.dyn_dtree,F),
                    q.bl_desc = new Q(q.bl_tree,O),
                    q.bi_buf = 0,
                    q.bi_valid = 0,
                    le(q)
                }
                ,
                i._tr_stored_block = J,
                i._tr_flush_block = function(q, he, X, G) {
                    var ne, Y, de = 0;
                    0 < q.level ? (q.strm.data_type === 2 && (q.strm.data_type = function(ae) {
                        var Ee, V = 4093624447;
                        for (Ee = 0; Ee <= 31; Ee++,
                        V >>>= 1)
                            if (1 & V && ae.dyn_ltree[2 * Ee] !== 0)
                                return o;
                        if (ae.dyn_ltree[18] !== 0 || ae.dyn_ltree[20] !== 0 || ae.dyn_ltree[26] !== 0)
                            return a;
                        for (Ee = 32; Ee < u; Ee++)
                            if (ae.dyn_ltree[2 * Ee] !== 0)
                                return a;
                        return o
                    }(q)),
                    se(q, q.l_desc),
                    se(q, q.d_desc),
                    de = function(ae) {
                        var Ee;
                        for (H(ae, ae.dyn_ltree, ae.l_desc.max_code),
                        H(ae, ae.dyn_dtree, ae.d_desc.max_code),
                        se(ae, ae.bl_desc),
                        Ee = d - 1; 3 <= Ee && ae.bl_tree[2 * M[Ee] + 1] === 0; Ee--)
                            ;
                        return ae.opt_len += 3 * (Ee + 1) + 5 + 5 + 4,
                        Ee
                    }(q),
                    ne = q.opt_len + 3 + 7 >>> 3,
                    (Y = q.static_len + 3 + 7 >>> 3) <= ne && (ne = Y)) : ne = Y = X + 5,
                    X + 4 <= ne && he !== -1 ? J(q, he, X, G) : q.strategy === 4 || Y === ne ? (ee(q, 2 + (G ? 1 : 0), 3),
                    _e(q, L, D)) : (ee(q, 4 + (G ? 1 : 0), 3),
                    function(ae, Ee, V, U) {
                        var N;
                        for (ee(ae, Ee - 257, 5),
                        ee(ae, V - 1, 5),
                        ee(ae, U - 4, 4),
                        N = 0; N < U; N++)
                            ee(ae, ae.bl_tree[2 * M[N] + 1], 3);
                        fe(ae, ae.dyn_ltree, Ee - 1),
                        fe(ae, ae.dyn_dtree, V - 1)
                    }(q, q.l_desc.max_code + 1, q.d_desc.max_code + 1, de + 1),
                    _e(q, q.dyn_ltree, q.dyn_dtree)),
                    le(q),
                    G && me(q)
                }
                ,
                i._tr_tally = function(q, he, X) {
                    return q.pending_buf[q.d_buf + 2 * q.last_lit] = he >>> 8 & 255,
                    q.pending_buf[q.d_buf + 2 * q.last_lit + 1] = 255 & he,
                    q.pending_buf[q.l_buf + q.last_lit] = 255 & X,
                    q.last_lit++,
                    he === 0 ? q.dyn_ltree[2 * X]++ : (q.matches++,
                    he--,
                    q.dyn_ltree[2 * (y[X] + u + 1)]++,
                    q.dyn_dtree[2 * C(he)]++),
                    q.last_lit === q.lit_bufsize - 1
                }
                ,
                i._tr_align = function(q) {
                    ee(q, 2, 3),
                    P(q, w, L),
                    function(he) {
                        he.bi_valid === 16 ? (W(he, he.bi_buf),
                        he.bi_buf = 0,
                        he.bi_valid = 0) : 8 <= he.bi_valid && (he.pending_buf[he.pending++] = 255 & he.bi_buf,
                        he.bi_buf >>= 8,
                        he.bi_valid -= 8)
                    }(q)
                }
            }
            , {
                "../utils/common": 41
            }],
            53: [function(t, r, i) {
                r.exports = function() {
                    this.input = null,
                    this.next_in = 0,
                    this.avail_in = 0,
                    this.total_in = 0,
                    this.output = null,
                    this.next_out = 0,
                    this.avail_out = 0,
                    this.total_out = 0,
                    this.msg = "",
                    this.state = null,
                    this.data_type = 2,
                    this.adler = 0
                }
            }
            , {}],
            54: [function(t, r, i) {
                (function(s) {
                    (function(o, a) {
                        if (!o.setImmediate) {
                            var l, c, A, u, f = 1, h = {}, d = !1, m = o.document, g = Object.getPrototypeOf && Object.getPrototypeOf(o);
                            g = g && g.setTimeout ? g : o,
                            l = {}.toString.call(o.process) === "[object process]" ? function(_) {
                                process.nextTick(function() {
                                    v(_)
                                })
                            }
                            : function() {
                                if (o.postMessage && !o.importScripts) {
                                    var _ = !0
                                      , x = o.onmessage;
                                    return o.onmessage = function() {
                                        _ = !1
                                    }
                                    ,
                                    o.postMessage("", "*"),
                                    o.onmessage = x,
                                    _
                                }
                            }() ? (u = "setImmediate$" + Math.random() + "$",
                            o.addEventListener ? o.addEventListener("message", w, !1) : o.attachEvent("onmessage", w),
                            function(_) {
                                o.postMessage(u + _, "*")
                            }
                            ) : o.MessageChannel ? ((A = new MessageChannel).port1.onmessage = function(_) {
                                v(_.data)
                            }
                            ,
                            function(_) {
                                A.port2.postMessage(_)
                            }
                            ) : m && "onreadystatechange"in m.createElement("script") ? (c = m.documentElement,
                            function(_) {
                                var x = m.createElement("script");
                                x.onreadystatechange = function() {
                                    v(_),
                                    x.onreadystatechange = null,
                                    c.removeChild(x),
                                    x = null
                                }
                                ,
                                c.appendChild(x)
                            }
                            ) : function(_) {
                                setTimeout(v, 0, _)
                            }
                            ,
                            g.setImmediate = function(_) {
                                typeof _ != "function" && (_ = new Function("" + _));
                                for (var x = new Array(arguments.length - 1), b = 0; b < x.length; b++)
                                    x[b] = arguments[b + 1];
                                var B = {
                                    callback: _,
                                    args: x
                                };
                                return h[f] = B,
                                l(f),
                                f++
                            }
                            ,
                            g.clearImmediate = p
                        }
                        function p(_) {
                            delete h[_]
                        }
                        function v(_) {
                            if (d)
                                setTimeout(v, 0, _);
                            else {
                                var x = h[_];
                                if (x) {
                                    d = !0;
                                    try {
                                        (function(b) {
                                            var B = b.callback
                                              , S = b.args;
                                            switch (S.length) {
                                            case 0:
                                                B();
                                                break;
                                            case 1:
                                                B(S[0]);
                                                break;
                                            case 2:
                                                B(S[0], S[1]);
                                                break;
                                            case 3:
                                                B(S[0], S[1], S[2]);
                                                break;
                                            default:
                                                B.apply(a, S)
                                            }
                                        }
                                        )(x)
                                    } finally {
                                        p(_),
                                        d = !1
                                    }
                                }
                            }
                        }
                        function w(_) {
                            _.source === o && typeof _.data == "string" && _.data.indexOf(u) === 0 && v(+_.data.slice(u.length))
                        }
                    }
                    )(typeof self > "u" ? s === void 0 ? this : s : self)
                }
                ).call(this, typeof ka < "u" ? ka : typeof self < "u" ? self : typeof window < "u" ? window : {})
            }
            , {}]
        }, {}, [10])(10)
    })
}
)(cV);
var ive = cV.exports;
const sve = oc(ive);
class ep {
    constructor() {
        this.zipContainer = {}
    }
    addData(e, t, r, i="") {
        i == "" && (i = "_"),
        this.zipContainer[i] == null && (this.zipContainer[i] = []),
        this.zipContainer[i].push({
            data: e,
            name: t,
            extension: r
        })
    }
    saveZip(e, t=!0) {
        const r = this.zipContainer
          , i = new sve;
        for (const s in r)
            if (s == "_")
                r[s].forEach( (o, a) => {
                    i.file(o.name + "." + o.extension, o.data, {
                        base64: !0
                    })
                }
                );
            else {
                const o = i.folder(s);
                r[s].forEach( (a, l) => {
                    const c = a.extension != "txt";
                    o.file(a.name + "." + a.extension, a.data, {
                        base64: c
                    })
                }
                )
            }
        i.generateAsync({
            type: "blob"
        }).then(s => {
            this._saveZipFile(s, e + ".zip")
        }
        ),
        t && (this.zipContainer = {})
    }
    _saveZipFile(e, t) {
        const r = new Blob([e],{
            type: "application/zip"
        });
        if (typeof window.navigator.msSaveBlob < "u")
            window.navigator.msSaveBlob(r, t);
        else {
            const i = document.createElement("a");
            typeof i.download == "string" ? (document.body.appendChild(i),
            i.download = t,
            i.href = URL.createObjectURL(r),
            i.click(),
            document.body.removeChild(i)) : window.open(e, "_blank").document.write("<title>" + t + "</title><img src='" + e + "'/>")
        }
    }
}
class ove {
    constructor(e) {
        Ne(this, "screenshotManager");
        this.characterManager = e,
        this.screenshotManager = e.screenshotManager,
        this.blinkManager = e.blinkManager,
        this.animationManager = this.characterManager.animationManager,
        this.temptime = 0
    }
    get vrms() {
        return Object.values(this.characterManager.avatar).map(e => e.vrm)
    }
    async createLoraData(e, t=null, r="") {
        const i = e.manifest
          , s = e.name ? "loraData/" + e.name : "loraData"
          , o = await this._fetchManifest(i)
          , {assetsLocation: a="", animationsDirectory: l="", backgroundGrayscale: c=1, backgroundDescription: A="", width: u=512, height: f=512, dataCollection: h} = o
          , d = a + l + "/";
        this.screenshotManager.setBackground([c, c, c]),
        this.blinkManager.enableScreenshot(),
        await this.screenshotManager.cameraFrameManager.calculateBoneOffsets(this.characterManager.characterModel, .2);
        let m = 0;
        const g = this;
        if (Array.isArray(h)) {
            const p = t ?? new ep;
            await (async () => {
                if (Array.isArray(h))
                    for (let w = 0; w < h.length; w++) {
                        const {animationPath: _, animationTime: x=0, animationFrame: b, cameraPosition: B, cameraFrame: S, description: I} = h[w];
                        m++;
                        const M = m.toString().padStart(4, "0")
                          , L = b ? b / 30 : x;
                        await g.animationManager.loadAnimation(d + _, !0, L),
                        this.vrms.forEach(y => {
                            var E;
                            (E = y.springBoneManager) == null || E.reset()
                        }
                        );
                        const D = h2(B);
                        g.screenshotManager.cameraFrameManager.setCameraFrameWithName(S, D);
                        const T = g.screenshotManager.getImageData(u, f, !1);
                        p.addData(T, M, "png", s),
                        p.addData("anata " + I + " " + A, M, "txt", s)
                    }
            }
            )(),
            t == null && (r == "" && (r = "lora_zip"),
            p.saveZip(r))
        }
        this.blinkManager.disableScreenshot()
    }
    async _fetchManifest(e) {
        return await (await fetch(e)).json()
    }
}
class ave {
    constructor(e) {
        Ne(this, "screenshotManager");
        this.characterManager = e,
        this.screenshotManager = e.screenshotManager,
        this.blinkManager = e.blinkManager,
        this.animationManager = this.characterManager.animationManager
    }
    async createSpriteAtlas(e, t=null, r="") {
        const i = e.manifest
          , s = e.name ? "spriteData/" + e.name : "spriteData"
          , o = await this._fetchManifest(i)
          , {assetsLocation: a="", animationsDirectory: l="", backgroundColor: c=[1, 1, 1, 1], screenshotOffset: A, topFrameOffset: u=.1, bottomFrameOffset: f=.1, pixelStyleSize: h, atlasWidth: d=512, atlasHeight: m=512, spritesCollection: g} = o
          , p = a + l + "/";
        this.screenshotManager.cameraFrameManager.setBottomFrameOffset(f),
        this.screenshotManager.cameraFrameManager.setTopFrameOffset(u),
        this.screenshotManager.setBackground(c),
        this.blinkManager.enableScreenshot(),
        await this.screenshotManager.cameraFrameManager.calculateBoneOffsets(this.characterManager.characterModel, .2);
        let v = 0;
        const w = this;
        if (Array.isArray(g)) {
            const _ = t ?? new ep;
            await (async () => {
                if (Array.isArray(g))
                    for (const b of g) {
                        const {animationName: B, animationPath: S, framesNumber: I, lookAtCamera: M, expression: L, cameraPosition: D, cameraFrame: T} = b;
                        v++;
                        const y = s + "/" + (B || v.toString().padStart(2, "0"));
                        await w.animationManager.loadAnimation(p + S, !0, 0);
                        const E = h2(D);
                        w.screenshotManager.cameraFrameManager.setCameraFrameWithName(T, E);
                        const F = w.animationManager.getCurrentClipDuration() / I;
                        for (let O = 0; O < I; O++) {
                            w.animationManager.setTime(O * F);
                            const z = w.screenshotManager.getImageData(d, m, h);
                            _.addData(z, O.toString().padStart(2, "0"), "png", y)
                        }
                    }
            }
            )(),
            t == null && (r == "" && (r = "sprites_zip"),
            _.saveZip(r))
        }
        this.blinkManager.disableScreenshot()
    }
    async _fetchManifest(e) {
        return await (await fetch(e)).json()
    }
}
class lve {
    constructor(e) {
        Ne(this, "screenshotManager");
        this.characterManager = e,
        this.screenshotManager = e.screenshotManager,
        this.blinkManager = e.blinkManager,
        this.animationManager = this.characterManager.animationManager
    }
    async createThumbnailsWithObjectData(e, t=!0, r=null, i="") {
        const {assetsLocation: s="", poseAnimation: o="", animationFrame: a, animationTime: l, backgroundColor: c=[1, 1, 1, 0], screenshotOffset: A, topFrameOffset: u=.1, bottomFrameOffset: f=.1, thumbnailsWidth: h=128, thumbnailsHeight: d=128, thumbnailsCollection: m} = e
          , g = s + "/";
        let p = a || 0;
        l != null && (p = l * 30),
        t && await this.animationManager.loadAnimation(g + o, !0, p),
        this.screenshotManager.cameraFrameManager.setBottomFrameOffset(f),
        this.screenshotManager.cameraFrameManager.setTopFrameOffset(u),
        this.screenshotManager.setBackground(c),
        this.blinkManager.enableScreenshot(),
        await this.screenshotManager.cameraFrameManager.calculateBoneOffsets(this.characterManager.characterModel, .2);
        const v = this;
        if (Array.isArray(m)) {
            const w = r ?? new ep;
            let _ = !1;
            await (async () => {
                for (const b of m) {
                    const {traitGroup: B, cameraPosition: S="front", bottomBoneName: I, bottomBoneMaxVertex: M=!1, topBoneName: L, topBoneMaxVertex: D=!0, groupTopOffset: T, groupBotomOffset: y, cameraFrame: E, saveOnlyIDs: R} = b;
                    if ((!I || !L) && (E || console.warn("missing bonename info or camera frame. Skipping")),
                    !B) {
                        console.warn("missing trait group for thumbnail info. Skipping");
                        continue
                    }
                    const F = () => {
                        const j = [];
                        return ut(R).forEach(C => {
                            j.push({
                                id: C
                            })
                        }
                        ),
                        j
                    }
                      , O = R == null ? v.characterManager.getTraits(B) : F();
                    if (O == null) {
                        console.log("SKipping Thumbnail Generation for trait group " + B + ", its not present in the character manifest.");
                        continue
                    }
                    const z = h2(S);
                    E ? v.screenshotManager.cameraFrameManager.setCameraFrameWithName(E, z) : v.screenshotManager.cameraFrameManager.frameShot(I, L, z, M, D);
                    for (let j = 0; j < O.length; j++) {
                        const Q = O[j].id;
                        let C = Q;
                        if (O[j].fullDirectory != null) {
                            const W = O[j].fullDirectory.split("/");
                            C = W[W.length - 1].split(".")[0]
                        }
                        if (await v.characterManager.loadTrait(B, Q, !0),
                        m.length == 1 && O.length == 1)
                            _ = !0,
                            v.screenshotManager.saveScreenshot(C, h, d);
                        else {
                            const W = v.screenshotManager.getImageData(h, d);
                            w.addData(W, C, "png", B)
                        }
                    }
                }
            }
            )(),
            r == null && _ == !1 && (i == "" && (i = "thumbnails_zip"),
            w.saveZip(i))
        }
        this.blinkManager.disableScreenshot()
    }
    async createThumbnails(e, t=null, r="") {
        const i = e.manifest
          , s = await this._fetchManifest(i);
        await this.createThumbnailsWithObjectData(s, !0, t, r)
    }
    async _fetchManifest(e) {
        return await (await fetch(e)).json()
    }
}
const $n = be.createContext({
    characterManager: null,
    moveCamera: n => {}
})
  , cve = n => {
    const [e,t] = be.useState(null)
      , [r,i] = be.useState(null)
      , [s,o] = be.useState(null)
      , [a,l] = be.useState(null)
      , [c,A] = be.useState(null)
      , [u,f] = be.useState(null)
      , [h,d] = be.useState(null)
      , [m,g] = be.useState(null)
      , [p,v] = be.useState(null)
      , [w,_] = be.useState(null)
      , [x,b] = be.useState(null)
      , [B,S] = be.useState(null)
      , [I,M] = be.useState(!1);
    let L = !1
      , [D,T] = be.useState(!1);
    be.useEffect( () => {
        if (L || D)
            return;
        T(!0),
        L = !0;
        const {scene: F, camera: O, controls: z, characterManager: j, sceneElements: Q} = rve("editor-scene");
        _(O),
        v(F),
        t(j),
        f(Q),
        d(j.animationManager),
        g(j.lookAtManager),
        l(j.overlayedTextureManager),
        b(z),
        i(new ove(j)),
        o(new ave(j)),
        A(new lve(j))
    }
    , []);
    const y = F => {
        F == null && (F = !I),
        M(F),
        p.traverse(O => {
            O.isMesh && O.setDebugMode && O.setDebugMode(F)
        }
        )
    }
    ;
    be.useEffect( () => {
        if (B != null && B.defaultAnimations) {
            const F = B.defaultAnimations.map(O => O.location);
            h.storeDefaultAnimationPaths(F, "")
        }
    }
    , [B]);
    const E = F => {
        F ? p.add(u) : p.remove(u)
    }
      , R = F => {
        x && (XS.to(x.target, {
            x: F.targetX ?? 0,
            y: F.targetY ?? 0,
            z: F.targetZ ?? 0,
            duration: 1
        }),
        XS.fromTo(x, {
            maxDistance: x.getDistance(),
            minDistance: x.getDistance(),
            minPolarAngle: x.getPolarAngle(),
            maxPolarAngle: x.getPolarAngle(),
            minAzimuthAngle: x.getAzimuthalAngle(),
            maxAzimuthAngle: x.getAzimuthalAngle()
        }, {
            maxDistance: F.distance,
            minDistance: F.distance,
            minPolarAngle: Math.PI / 2 - .11,
            maxPolarAngle: Math.PI / 2 - .11,
            minAzimuthAngle: -.78,
            maxAzimuthAngle: -.78,
            duration: 1
        }).then( () => {
            x.minPolarAngle = 0,
            x.maxPolarAngle = 3.1415,
            x.minDistance = .5,
            x.maxDistance = 10,
            x.minAzimuthAngle = 1 / 0,
            x.maxAzimuthAngle = 1 / 0
        }
        ))
    }
    ;
    return k.jsx($n.Provider, {
        value: {
            manifest: B,
            setManifest: S,
            scene: p,
            decalManager: a,
            characterManager: e,
            loraDataGenerator: r,
            spriteAtlasGenerator: s,
            thumbnailsGenerator: c,
            showEnvironmentModels: E,
            debugMode: I,
            toggleDebugMode: y,
            animationManager: h,
            lookAtManager: m,
            camera: w,
            moveCamera: R,
            controls: x,
            sceneElements: u
        },
        children: n.children
    })
}
  , Ave = {
    NORMAL: "NORMAL",
    AR: "AR",
    AR_FRONT: "AR_FRONT",
    VR: "VR"
}
  , wt = {
    LANDING: "LANDING",
    CREATE: "CREATE",
    CLAIM: "CLAIM",
    LOAD: "LOAD",
    APPEARANCE: "APPEARANCE",
    BATCHDOWNLOAD: "BATCHDOWNLOAD",
    SAVE: "SAVE",
    MINT: "MINT",
    OPTIMIZER: "OPTIMIZER",
    BATCHMANIFEST: "BATCHMANIFEST",
    WALLET: "WALLET"
}
  , us = Z.createContext()
  , uve = n => {
    const [e,t] = Z.useState(Ave.NORMAL)
      , [r,i] = Z.useState(wt.LANDING)
      , [s,o] = Z.useState(!1)
      , [a,l] = Z.useState(!1);
    return k.jsx(us.Provider, {
        value: {
            viewMode: r,
            setViewMode: i,
            isLoading: s,
            setIsLoading: o,
            mouseIsOverUI: a,
            setMouseIsOverUI: l,
            currentCameraMode: e,
            setCurrentCameraMode: t
        },
        children: n.children
    })
}
  , fve = "modulepreload"
  , hve = function(n) {
    return "/" + n
}
  , ZO = {}
  , dve = function(e, t, r) {
    if (!t || t.length === 0)
        return e();
    const i = document.getElementsByTagName("link");
    return Promise.all(t.map(s => {
        if (s = hve(s),
        s in ZO)
            return;
        ZO[s] = !0;
        const o = s.endsWith(".css")
          , a = o ? '[rel="stylesheet"]' : "";
        if (!!r)
            for (let A = i.length - 1; A >= 0; A--) {
                const u = i[A];
                if (u.href === s && (!o || u.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${s}"]${a}`))
            return;
        const c = document.createElement("link");
        if (c.rel = o ? "stylesheet" : fve,
        o || (c.as = "script",
        c.crossOrigin = ""),
        c.href = s,
        document.head.appendChild(c),
        o)
            return new Promise( (A, u) => {
                c.addEventListener("load", A),
                c.addEventListener("error", () => u(new Error(`Unable to preload CSS for ${s}`)))
            }
            )
    }
    )).then( () => e()).catch(s => {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = s,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw s
    }
    )
};
function lx() {
    return lx = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                ({}).hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ,
    lx.apply(null, arguments)
}
function pve(n, e) {
    if (n == null)
        return {};
    var t = {};
    for (var r in n)
        if ({}.hasOwnProperty.call(n, r)) {
            if (e.indexOf(r) >= 0)
                continue;
            t[r] = n[r]
        }
    return t
}
function mve(n) {
    be.useEffect(n, [])
}
var gve = ["id", "volume", "playbackRate", "soundEnabled", "interrupt", "onload"];
function vve(n, e) {
    var t = e === void 0 ? {} : e
      , r = t.volume
      , i = r === void 0 ? 1 : r
      , s = t.playbackRate
      , o = s === void 0 ? 1 : s
      , a = t.soundEnabled
      , l = a === void 0 ? !0 : a
      , c = t.interrupt
      , A = c === void 0 ? !1 : c
      , u = t.onload
      , f = pve(t, gve)
      , h = Z.useRef(null)
      , d = Z.useRef(!1)
      , m = Z.useState(null)
      , g = m[0]
      , p = m[1]
      , v = Z.useState(null)
      , w = v[0]
      , _ = v[1]
      , x = function() {
        typeof u == "function" && u.call(this),
        d.current && p(this.duration() * 1e3),
        _(this)
    };
    mve(function() {
        return dve( () => import("./howler-f7e5c2d9.js").then(M => M.h), []).then(function(M) {
            if (!d.current) {
                var L;
                h.current = (L = M.Howl) !== null && L !== void 0 ? L : M.default.Howl,
                d.current = !0,
                new h.current(lx({
                    src: Array.isArray(n) ? n : [n],
                    volume: i,
                    rate: o,
                    onload: x
                }, f))
            }
        }),
        function() {
            d.current = !1
        }
    }),
    Z.useEffect(function() {
        h.current && w && _(new h.current(lx({
            src: Array.isArray(n) ? n : [n],
            volume: i,
            onload: x
        }, f)))
    }, [JSON.stringify(n)]),
    Z.useEffect(function() {
        w && (w.volume(i),
        w.rate(o))
    }, [i, o]);
    var b = Z.useCallback(function(M) {
        typeof M > "u" && (M = {}),
        !(!w || !l && !M.forceSoundEnabled) && (A && w.stop(),
        M.playbackRate && w.rate(M.playbackRate),
        w.play(M.id))
    }, [w, l, A])
      , B = Z.useCallback(function(M) {
        w && w.stop(M)
    }, [w])
      , S = Z.useCallback(function(M) {
        w && w.pause(M)
    }, [w])
      , I = [b, {
        sound: w,
        stop: B,
        pause: S,
        duration: g
    }];
    return I
}
const yve = [{
    name: "background/cc_bgm.wav",
    offset: 0,
    duration: 123458.58333333334
}, {
    name: "background/cc_bgm_balanced.wav",
    offset: 123458.58333333334,
    duration: 123458.60416666666
}, {
    name: "effect/character-load.wav",
    offset: 246917.1875,
    duration: 3030
}, {
    name: "effect/class-select.wav",
    offset: 249947.1875,
    duration: 2780
}, {
    name: "effect/switchingItem.wav",
    offset: 252727.1875,
    duration: 623.75
}, {
    name: "ui/back-next-button.wav",
    offset: 253350.9375,
    duration: 155.02083333333334
}, {
    name: "ui/class-mouse-over.wav",
    offset: 253505.95833333334,
    duration: 217.52083333333334
}, {
    name: "ui/class_click.wav",
    offset: 253723.4791666667,
    duration: 3123.75
}, {
    name: "ui/class_pass.wav",
    offset: 256847.2291666667,
    duration: 155
}, {
    name: "ui/option_click.wav",
    offset: 257002.2291666667,
    duration: 155.02083333333334
}, {
    name: "ui/randomize-button.wav",
    offset: 257157.25000000003,
    duration: 342.5208333333333
}, {
    name: "ui/section_click.wav",
    offset: 257499.77083333337,
    duration: 155
}]
  , wve = "/public/assets/sounds.mp3"
  , Co = be.createContext()
  , _ve = n => {
    const e = i => yve.find(s => i.test(s.name))
      , [t] = vve(wve, {
        sprite: {
            switchItem: [e(/switchingItem/).offset, e(/switchingItem/).duration],
            classSelect: [e(/class-select/).offset, e(/class-select/).duration],
            characterLoad: [e(/character-load/).offset, e(/character-load/).duration],
            randomizeButton: [e(/randomize-button/).offset, e(/randomize-button/).duration],
            classMouseOver: [e(/class-mouse-over/).offset, e(/class-mouse-over/).duration],
            backNextButton: [e(/back-next-button/).offset, e(/back-next-button/).duration]
        }
    })
      , r = (i, s=0) => {
        s === 0 ? t({
            id: i
        }) : setTimeout( () => {
            t({
                id: i
            })
        }
        , s)
    }
    ;
    return k.jsx(Co.Provider, {
        value: {
            playSound: r
        },
        children: n.children
    })
}
;
function Ns(n) {
    "@babel/helpers - typeof";
    return Ns = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Ns(n)
}
function To(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function xve(n, e) {
    if (Ns(n) != "object" || !n)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var r = t.call(n, e || "default");
        if (Ns(r) != "object")
            return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function AV(n) {
    var e = xve(n, "string");
    return Ns(e) == "symbol" ? e : e + ""
}
function JO(n, e) {
    for (var t = 0; t < e.length; t++) {
        var r = e[t];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value"in r && (r.writable = !0),
        Object.defineProperty(n, AV(r.key), r)
    }
}
function Io(n, e, t) {
    return e && JO(n.prototype, e),
    t && JO(n, t),
    Object.defineProperty(n, "prototype", {
        writable: !1
    }),
    n
}
function dA(n) {
    if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return n
}
function TT(n, e) {
    return TT = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, r) {
        return t.__proto__ = r,
        t
    }
    ,
    TT(n, e)
}
function N1(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function");
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(n, "prototype", {
        writable: !1
    }),
    e && TT(n, e)
}
function M0(n, e) {
    if (e && (Ns(e) == "object" || typeof e == "function"))
        return e;
    if (e !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
    return dA(n)
}
function il(n) {
    return il = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e)
    }
    ,
    il(n)
}
function Al(n, e, t) {
    return (e = AV(e))in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function uV(n) {
    if (Array.isArray(n))
        return n
}
function bve(n) {
    if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
        return Array.from(n)
}
function qO(n, e) {
    (e == null || e > n.length) && (e = n.length);
    for (var t = 0, r = Array(e); t < e; t++)
        r[t] = n[t];
    return r
}
function fV(n, e) {
    if (n) {
        if (typeof n == "string")
            return qO(n, e);
        var t = {}.toString.call(n).slice(8, -1);
        return t === "Object" && n.constructor && (t = n.constructor.name),
        t === "Map" || t === "Set" ? Array.from(n) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? qO(n, e) : void 0
    }
}
function hV() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Eve(n) {
    return uV(n) || bve(n) || fV(n) || hV()
}
function e3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function t3(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? e3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : e3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
var Bve = {
    type: "logger",
    log: function(e) {
        this.output("log", e)
    },
    warn: function(e) {
        this.output("warn", e)
    },
    error: function(e) {
        this.output("error", e)
    },
    output: function(e, t) {
        console && console[e] && console[e].apply(console, t)
    }
}
  , Mve = function() {
    function n(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        To(this, n),
        this.init(e, t)
    }
    return Io(n, [{
        key: "init",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.prefix = r.prefix || "i18next:",
            this.logger = t || Bve,
            this.options = r,
            this.debug = r.debug
        }
    }, {
        key: "setDebug",
        value: function(t) {
            this.debug = t
        }
    }, {
        key: "log",
        value: function() {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return this.forward(r, "log", "", !0)
        }
    }, {
        key: "warn",
        value: function() {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return this.forward(r, "warn", "", !0)
        }
    }, {
        key: "error",
        value: function() {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return this.forward(r, "error", "")
        }
    }, {
        key: "deprecate",
        value: function() {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
                r[i] = arguments[i];
            return this.forward(r, "warn", "WARNING DEPRECATED: ", !0)
        }
    }, {
        key: "forward",
        value: function(t, r, i, s) {
            return s && !this.debug ? null : (typeof t[0] == "string" && (t[0] = "".concat(i).concat(this.prefix, " ").concat(t[0])),
            this.logger[r](t))
        }
    }, {
        key: "create",
        value: function(t) {
            return new n(this.logger,t3(t3({}, {
                prefix: "".concat(this.prefix, ":").concat(t, ":")
            }), this.options))
        }
    }, {
        key: "clone",
        value: function(t) {
            return t = t || this.options,
            t.prefix = t.prefix || this.prefix,
            new n(this.logger,t)
        }
    }]),
    n
}()
  , za = new Mve
  , bA = function() {
    function n() {
        To(this, n),
        this.observers = {}
    }
    return Io(n, [{
        key: "on",
        value: function(t, r) {
            var i = this;
            return t.split(" ").forEach(function(s) {
                i.observers[s] = i.observers[s] || [],
                i.observers[s].push(r)
            }),
            this
        }
    }, {
        key: "off",
        value: function(t, r) {
            if (this.observers[t]) {
                if (!r) {
                    delete this.observers[t];
                    return
                }
                this.observers[t] = this.observers[t].filter(function(i) {
                    return i !== r
                })
            }
        }
    }, {
        key: "emit",
        value: function(t) {
            for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
                i[s - 1] = arguments[s];
            if (this.observers[t]) {
                var o = [].concat(this.observers[t]);
                o.forEach(function(l) {
                    l.apply(void 0, i)
                })
            }
            if (this.observers["*"]) {
                var a = [].concat(this.observers["*"]);
                a.forEach(function(l) {
                    l.apply(l, [t].concat(i))
                })
            }
        }
    }]),
    n
}();
function om() {
    var n, e, t = new Promise(function(r, i) {
        n = r,
        e = i
    }
    );
    return t.resolve = n,
    t.reject = e,
    t
}
function n3(n) {
    return n == null ? "" : "" + n
}
function Sve(n, e, t) {
    n.forEach(function(r) {
        e[r] && (t[r] = e[r])
    })
}
function v2(n, e, t) {
    function r(a) {
        return a && a.indexOf("###") > -1 ? a.replace(/###/g, ".") : a
    }
    function i() {
        return !n || typeof n == "string"
    }
    for (var s = typeof e != "string" ? [].concat(e) : e.split("."); s.length > 1; ) {
        if (i())
            return {};
        var o = r(s.shift());
        !n[o] && t && (n[o] = new t),
        Object.prototype.hasOwnProperty.call(n, o) ? n = n[o] : n = {}
    }
    return i() ? {} : {
        obj: n,
        k: r(s.shift())
    }
}
function r3(n, e, t) {
    var r = v2(n, e, Object)
      , i = r.obj
      , s = r.k;
    i[s] = t
}
function Cve(n, e, t, r) {
    var i = v2(n, e, Object)
      , s = i.obj
      , o = i.k;
    s[o] = s[o] || [],
    r && (s[o] = s[o].concat(t)),
    r || s[o].push(t)
}
function cx(n, e) {
    var t = v2(n, e)
      , r = t.obj
      , i = t.k;
    if (r)
        return r[i]
}
function Tve(n, e, t) {
    var r = cx(n, t);
    return r !== void 0 ? r : cx(e, t)
}
function dV(n, e, t) {
    for (var r in e)
        r !== "__proto__" && r !== "constructor" && (r in n ? typeof n[r] == "string" || n[r]instanceof String || typeof e[r] == "string" || e[r]instanceof String ? t && (n[r] = e[r]) : dV(n[r], e[r], t) : n[r] = e[r]);
    return n
}
function Vf(n) {
    return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
}
var Ive = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};
function Rve(n) {
    return typeof n == "string" ? n.replace(/[&<>"'\/]/g, function(e) {
        return Ive[e]
    }) : n
}
var O1 = typeof window < "u" && window.navigator && typeof window.navigator.userAgentData > "u" && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1
  , Uve = [" ", ",", "?", "!", ";"];
function Fve(n, e, t) {
    e = e || "",
    t = t || "";
    var r = Uve.filter(function(a) {
        return e.indexOf(a) < 0 && t.indexOf(a) < 0
    });
    if (r.length === 0)
        return !0;
    var i = new RegExp("(".concat(r.map(function(a) {
        return a === "?" ? "\\?" : a
    }).join("|"), ")"))
      , s = !i.test(n);
    if (!s) {
        var o = n.indexOf(t);
        o > 0 && !i.test(n.substring(0, o)) && (s = !0)
    }
    return s
}
function Ax(n, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (n) {
        if (n[e])
            return n[e];
        for (var r = e.split(t), i = n, s = 0; s < r.length; ++s) {
            if (!i || typeof i[r[s]] == "string" && s + 1 < r.length)
                return;
            if (i[r[s]] === void 0) {
                for (var o = 2, a = r.slice(s, s + o).join(t), l = i[a]; l === void 0 && r.length > s + o; )
                    o++,
                    a = r.slice(s, s + o).join(t),
                    l = i[a];
                if (l === void 0)
                    return;
                if (l === null)
                    return null;
                if (e.endsWith(a)) {
                    if (typeof l == "string")
                        return l;
                    if (a && typeof l[a] == "string")
                        return l[a]
                }
                var c = r.slice(s + o).join(t);
                return c ? Ax(l, c, t) : void 0
            }
            i = i[r[s]]
        }
        return i
    }
}
function i3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function Oy(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? i3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : i3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function Pve(n) {
    var e = Lve();
    return function() {
        var r = il(n), i;
        if (e) {
            var s = il(this).constructor;
            i = Reflect.construct(r, arguments, s)
        } else
            i = r.apply(this, arguments);
        return M0(this, i)
    }
}
function Lve() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
var Dve = function(n) {
    N1(t, n);
    var e = Pve(t);
    function t(r) {
        var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            ns: ["translation"],
            defaultNS: "translation"
        };
        return To(this, t),
        i = e.call(this),
        O1 && bA.call(dA(i)),
        i.data = r || {},
        i.options = s,
        i.options.keySeparator === void 0 && (i.options.keySeparator = "."),
        i.options.ignoreJSONStructure === void 0 && (i.options.ignoreJSONStructure = !0),
        i
    }
    return Io(t, [{
        key: "addNamespaces",
        value: function(i) {
            this.options.ns.indexOf(i) < 0 && this.options.ns.push(i)
        }
    }, {
        key: "removeNamespaces",
        value: function(i) {
            var s = this.options.ns.indexOf(i);
            s > -1 && this.options.ns.splice(s, 1)
        }
    }, {
        key: "getResource",
        value: function(i, s, o) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
              , l = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator
              , c = a.ignoreJSONStructure !== void 0 ? a.ignoreJSONStructure : this.options.ignoreJSONStructure
              , A = [i, s];
            o && typeof o != "string" && (A = A.concat(o)),
            o && typeof o == "string" && (A = A.concat(l ? o.split(l) : o)),
            i.indexOf(".") > -1 && (A = i.split("."));
            var u = cx(this.data, A);
            return u || !c || typeof o != "string" ? u : Ax(this.data && this.data[i] && this.data[i][s], o, l)
        }
    }, {
        key: "addResource",
        value: function(i, s, o, a) {
            var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                silent: !1
            }
              , c = l.keySeparator !== void 0 ? l.keySeparator : this.options.keySeparator
              , A = [i, s];
            o && (A = A.concat(c ? o.split(c) : o)),
            i.indexOf(".") > -1 && (A = i.split("."),
            a = s,
            s = A[1]),
            this.addNamespaces(s),
            r3(this.data, A, a),
            l.silent || this.emit("added", i, s, o, a)
        }
    }, {
        key: "addResources",
        value: function(i, s, o) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
                silent: !1
            };
            for (var l in o)
                (typeof o[l] == "string" || Object.prototype.toString.apply(o[l]) === "[object Array]") && this.addResource(i, s, l, o[l], {
                    silent: !0
                });
            a.silent || this.emit("added", i, s, o)
        }
    }, {
        key: "addResourceBundle",
        value: function(i, s, o, a, l) {
            var c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
                silent: !1
            }
              , A = [i, s];
            i.indexOf(".") > -1 && (A = i.split("."),
            a = o,
            o = s,
            s = A[1]),
            this.addNamespaces(s);
            var u = cx(this.data, A) || {};
            a ? dV(u, o, l) : u = Oy(Oy({}, u), o),
            r3(this.data, A, u),
            c.silent || this.emit("added", i, s, o)
        }
    }, {
        key: "removeResourceBundle",
        value: function(i, s) {
            this.hasResourceBundle(i, s) && delete this.data[i][s],
            this.removeNamespaces(s),
            this.emit("removed", i, s)
        }
    }, {
        key: "hasResourceBundle",
        value: function(i, s) {
            return this.getResource(i, s) !== void 0
        }
    }, {
        key: "getResourceBundle",
        value: function(i, s) {
            return s || (s = this.options.defaultNS),
            this.options.compatibilityAPI === "v1" ? Oy(Oy({}, {}), this.getResource(i, s)) : this.getResource(i, s)
        }
    }, {
        key: "getDataByLanguage",
        value: function(i) {
            return this.data[i]
        }
    }, {
        key: "hasLanguageSomeTranslations",
        value: function(i) {
            var s = this.getDataByLanguage(i)
              , o = s && Object.keys(s) || [];
            return !!o.find(function(a) {
                return s[a] && Object.keys(s[a]).length > 0
            })
        }
    }, {
        key: "toJSON",
        value: function() {
            return this.data
        }
    }]),
    t
}(bA)
  , pV = {
    processors: {},
    addPostProcessor: function(e) {
        this.processors[e.name] = e
    },
    handle: function(e, t, r, i, s) {
        var o = this;
        return e.forEach(function(a) {
            o.processors[a] && (t = o.processors[a].process(t, r, i, s))
        }),
        t
    }
};
function s3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function pi(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? s3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : s3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function Nve(n) {
    var e = Ove();
    return function() {
        var r = il(n), i;
        if (e) {
            var s = il(this).constructor;
            i = Reflect.construct(r, arguments, s)
        } else
            i = r.apply(this, arguments);
        return M0(this, i)
    }
}
function Ove() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
var o3 = {}
  , a3 = function(n) {
    N1(t, n);
    var e = Nve(t);
    function t(r) {
        var i, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return To(this, t),
        i = e.call(this),
        O1 && bA.call(dA(i)),
        Sve(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], r, dA(i)),
        i.options = s,
        i.options.keySeparator === void 0 && (i.options.keySeparator = "."),
        i.logger = za.create("translator"),
        i
    }
    return Io(t, [{
        key: "changeLanguage",
        value: function(i) {
            i && (this.language = i)
        }
    }, {
        key: "exists",
        value: function(i) {
            var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            };
            if (i == null)
                return !1;
            var o = this.resolve(i, s);
            return o && o.res !== void 0
        }
    }, {
        key: "extractFromKey",
        value: function(i, s) {
            var o = s.nsSeparator !== void 0 ? s.nsSeparator : this.options.nsSeparator;
            o === void 0 && (o = ":");
            var a = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator
              , l = s.ns || this.options.defaultNS || []
              , c = o && i.indexOf(o) > -1
              , A = !this.options.userDefinedKeySeparator && !s.keySeparator && !this.options.userDefinedNsSeparator && !s.nsSeparator && !Fve(i, o, a);
            if (c && !A) {
                var u = i.match(this.interpolator.nestingRegexp);
                if (u && u.length > 0)
                    return {
                        key: i,
                        namespaces: l
                    };
                var f = i.split(o);
                (o !== a || o === a && this.options.ns.indexOf(f[0]) > -1) && (l = f.shift()),
                i = f.join(a)
            }
            return typeof l == "string" && (l = [l]),
            {
                key: i,
                namespaces: l
            }
        }
    }, {
        key: "translate",
        value: function(i, s, o) {
            var a = this;
            if (Ns(s) !== "object" && this.options.overloadTranslationOptionHandler && (s = this.options.overloadTranslationOptionHandler(arguments)),
            Ns(s) === "object" && (s = pi({}, s)),
            s || (s = {}),
            i == null)
                return "";
            Array.isArray(i) || (i = [String(i)]);
            var l = s.returnDetails !== void 0 ? s.returnDetails : this.options.returnDetails
              , c = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator
              , A = this.extractFromKey(i[i.length - 1], s)
              , u = A.key
              , f = A.namespaces
              , h = f[f.length - 1]
              , d = s.lng || this.language
              , m = s.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (d && d.toLowerCase() === "cimode") {
                if (m) {
                    var g = s.nsSeparator || this.options.nsSeparator;
                    return l ? {
                        res: "".concat(h).concat(g).concat(u),
                        usedKey: u,
                        exactUsedKey: u,
                        usedLng: d,
                        usedNS: h
                    } : "".concat(h).concat(g).concat(u)
                }
                return l ? {
                    res: u,
                    usedKey: u,
                    exactUsedKey: u,
                    usedLng: d,
                    usedNS: h
                } : u
            }
            var p = this.resolve(i, s)
              , v = p && p.res
              , w = p && p.usedKey || u
              , _ = p && p.exactUsedKey || u
              , x = Object.prototype.toString.apply(v)
              , b = ["[object Number]", "[object Function]", "[object RegExp]"]
              , B = s.joinArrays !== void 0 ? s.joinArrays : this.options.joinArrays
              , S = !this.i18nFormat || this.i18nFormat.handleAsObject
              , I = typeof v != "string" && typeof v != "boolean" && typeof v != "number";
            if (S && v && I && b.indexOf(x) < 0 && !(typeof B == "string" && x === "[object Array]")) {
                if (!s.returnObjects && !this.options.returnObjects) {
                    this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                    var M = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(w, v, pi(pi({}, s), {}, {
                        ns: f
                    })) : "key '".concat(u, " (").concat(this.language, ")' returned an object instead of string.");
                    return l ? (p.res = M,
                    p) : M
                }
                if (c) {
                    var L = x === "[object Array]"
                      , D = L ? [] : {}
                      , T = L ? _ : w;
                    for (var y in v)
                        if (Object.prototype.hasOwnProperty.call(v, y)) {
                            var E = "".concat(T).concat(c).concat(y);
                            D[y] = this.translate(E, pi(pi({}, s), {
                                joinArrays: !1,
                                ns: f
                            })),
                            D[y] === E && (D[y] = v[y])
                        }
                    v = D
                }
            } else if (S && typeof B == "string" && x === "[object Array]")
                v = v.join(B),
                v && (v = this.extendTranslation(v, i, s, o));
            else {
                var R = !1
                  , F = !1
                  , O = s.count !== void 0 && typeof s.count != "string"
                  , z = t.hasDefaultValue(s)
                  , j = O ? this.pluralResolver.getSuffix(d, s.count, s) : ""
                  , Q = s["defaultValue".concat(j)] || s.defaultValue;
                !this.isValidLookup(v) && z && (R = !0,
                v = Q),
                this.isValidLookup(v) || (F = !0,
                v = u);
                var C = s.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey
                  , W = C && F ? void 0 : v
                  , ee = z && Q !== v && this.options.updateMissing;
                if (F || R || ee) {
                    if (this.logger.log(ee ? "updateKey" : "missingKey", d, h, u, ee ? Q : v),
                    c) {
                        var P = this.resolve(u, pi(pi({}, s), {}, {
                            keySeparator: !1
                        }));
                        P && P.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                    }
                    var re = []
                      , ue = this.languageUtils.getFallbackCodes(this.options.fallbackLng, s.lng || this.language);
                    if (this.options.saveMissingTo === "fallback" && ue && ue[0])
                        for (var le = 0; le < ue.length; le++)
                            re.push(ue[le]);
                    else
                        this.options.saveMissingTo === "all" ? re = this.languageUtils.toResolveHierarchy(s.lng || this.language) : re.push(s.lng || this.language);
                    var me = function(ge, _e, se) {
                        var H = z && se !== v ? se : W;
                        a.options.missingKeyHandler ? a.options.missingKeyHandler(ge, h, _e, H, ee, s) : a.backendConnector && a.backendConnector.saveMissing && a.backendConnector.saveMissing(ge, h, _e, H, ee, s),
                        a.emit("missingKey", ge, h, _e, v)
                    };
                    this.options.saveMissing && (this.options.saveMissingPlurals && O ? re.forEach(function(ie) {
                        a.pluralResolver.getSuffixes(ie, s).forEach(function(ge) {
                            me([ie], u + ge, s["defaultValue".concat(ge)] || Q)
                        })
                    }) : me(re, u, Q))
                }
                v = this.extendTranslation(v, i, s, p, o),
                F && v === u && this.options.appendNamespaceToMissingKey && (v = "".concat(h, ":").concat(u)),
                (F || R) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? v = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(h, ":").concat(u) : u, R ? v : void 0) : v = this.options.parseMissingKeyHandler(v))
            }
            return l ? (p.res = v,
            p) : v
        }
    }, {
        key: "extendTranslation",
        value: function(i, s, o, a, l) {
            var c = this;
            if (this.i18nFormat && this.i18nFormat.parse)
                i = this.i18nFormat.parse(i, pi(pi({}, this.options.interpolation.defaultVariables), o), a.usedLng, a.usedNS, a.usedKey, {
                    resolved: a
                });
            else if (!o.skipInterpolation) {
                o.interpolation && this.interpolator.init(pi(pi({}, o), {
                    interpolation: pi(pi({}, this.options.interpolation), o.interpolation)
                }));
                var A = typeof i == "string" && (o && o.interpolation && o.interpolation.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), u;
                if (A) {
                    var f = i.match(this.interpolator.nestingRegexp);
                    u = f && f.length
                }
                var h = o.replace && typeof o.replace != "string" ? o.replace : o;
                if (this.options.interpolation.defaultVariables && (h = pi(pi({}, this.options.interpolation.defaultVariables), h)),
                i = this.interpolator.interpolate(i, h, o.lng || this.language, o),
                A) {
                    var d = i.match(this.interpolator.nestingRegexp)
                      , m = d && d.length;
                    u < m && (o.nest = !1)
                }
                !o.lng && this.options.compatibilityAPI !== "v1" && a && a.res && (o.lng = a.usedLng),
                o.nest !== !1 && (i = this.interpolator.nest(i, function() {
                    for (var v = arguments.length, w = new Array(v), _ = 0; _ < v; _++)
                        w[_] = arguments[_];
                    return l && l[0] === w[0] && !o.context ? (c.logger.warn("It seems you are nesting recursively key: ".concat(w[0], " in key: ").concat(s[0])),
                    null) : c.translate.apply(c, w.concat([s]))
                }, o)),
                o.interpolation && this.interpolator.reset()
            }
            var g = o.postProcess || this.options.postProcess
              , p = typeof g == "string" ? [g] : g;
            return i != null && p && p.length && o.applyPostProcessor !== !1 && (i = pV.handle(p, i, s, this.options && this.options.postProcessPassResolved ? pi({
                i18nResolved: a
            }, o) : o, this)),
            i
        }
    }, {
        key: "resolve",
        value: function(i) {
            var s = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a, l, c, A, u;
            return typeof i == "string" && (i = [i]),
            i.forEach(function(f) {
                if (!s.isValidLookup(a)) {
                    var h = s.extractFromKey(f, o)
                      , d = h.key;
                    l = d;
                    var m = h.namespaces;
                    s.options.fallbackNS && (m = m.concat(s.options.fallbackNS));
                    var g = o.count !== void 0 && typeof o.count != "string"
                      , p = g && !o.ordinal && o.count === 0 && s.pluralResolver.shouldUseIntlApi()
                      , v = o.context !== void 0 && (typeof o.context == "string" || typeof o.context == "number") && o.context !== ""
                      , w = o.lngs ? o.lngs : s.languageUtils.toResolveHierarchy(o.lng || s.language, o.fallbackLng);
                    m.forEach(function(_) {
                        s.isValidLookup(a) || (u = _,
                        !o3["".concat(w[0], "-").concat(_)] && s.utils && s.utils.hasLoadedNamespace && !s.utils.hasLoadedNamespace(u) && (o3["".concat(w[0], "-").concat(_)] = !0,
                        s.logger.warn('key "'.concat(l, '" for languages "').concat(w.join(", "), `" won't get resolved as namespace "`).concat(u, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                        w.forEach(function(x) {
                            if (!s.isValidLookup(a)) {
                                A = x;
                                var b = [d];
                                if (s.i18nFormat && s.i18nFormat.addLookupKeys)
                                    s.i18nFormat.addLookupKeys(b, d, x, _, o);
                                else {
                                    var B;
                                    g && (B = s.pluralResolver.getSuffix(x, o.count, o));
                                    var S = "".concat(s.options.pluralSeparator, "zero");
                                    if (g && (b.push(d + B),
                                    p && b.push(d + S)),
                                    v) {
                                        var I = "".concat(d).concat(s.options.contextSeparator).concat(o.context);
                                        b.push(I),
                                        g && (b.push(I + B),
                                        p && b.push(I + S))
                                    }
                                }
                                for (var M; M = b.pop(); )
                                    s.isValidLookup(a) || (c = M,
                                    a = s.getResource(x, _, M, o))
                            }
                        }))
                    })
                }
            }),
            {
                res: a,
                usedKey: l,
                exactUsedKey: c,
                usedLng: A,
                usedNS: u
            }
        }
    }, {
        key: "isValidLookup",
        value: function(i) {
            return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === "")
        }
    }, {
        key: "getResource",
        value: function(i, s, o) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, s, o, a) : this.resourceStore.getResource(i, s, o, a)
        }
    }], [{
        key: "hasDefaultValue",
        value: function(i) {
            var s = "defaultValue";
            for (var o in i)
                if (Object.prototype.hasOwnProperty.call(i, o) && s === o.substring(0, s.length) && i[o] !== void 0)
                    return !0;
            return !1
        }
    }]),
    t
}(bA);
function lM(n) {
    return n.charAt(0).toUpperCase() + n.slice(1)
}
var l3 = function() {
    function n(e) {
        To(this, n),
        this.options = e,
        this.supportedLngs = this.options.supportedLngs || !1,
        this.logger = za.create("languageUtils")
    }
    return Io(n, [{
        key: "getScriptPartFromCode",
        value: function(t) {
            if (!t || t.indexOf("-") < 0)
                return null;
            var r = t.split("-");
            return r.length === 2 || (r.pop(),
            r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"))
        }
    }, {
        key: "getLanguagePartFromCode",
        value: function(t) {
            if (!t || t.indexOf("-") < 0)
                return t;
            var r = t.split("-");
            return this.formatLanguageCode(r[0])
        }
    }, {
        key: "formatLanguageCode",
        value: function(t) {
            if (typeof t == "string" && t.indexOf("-") > -1) {
                var r = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"]
                  , i = t.split("-");
                return this.options.lowerCaseLng ? i = i.map(function(s) {
                    return s.toLowerCase()
                }) : i.length === 2 ? (i[0] = i[0].toLowerCase(),
                i[1] = i[1].toUpperCase(),
                r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = lM(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(),
                i[1].length === 2 && (i[1] = i[1].toUpperCase()),
                i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()),
                r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = lM(i[1].toLowerCase())),
                r.indexOf(i[2].toLowerCase()) > -1 && (i[2] = lM(i[2].toLowerCase()))),
                i.join("-")
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t
        }
    }, {
        key: "isSupportedCode",
        value: function(t) {
            return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)),
            !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1
        }
    }, {
        key: "getBestMatchFromCodes",
        value: function(t) {
            var r = this;
            if (!t)
                return null;
            var i;
            return t.forEach(function(s) {
                if (!i) {
                    var o = r.formatLanguageCode(s);
                    (!r.options.supportedLngs || r.isSupportedCode(o)) && (i = o)
                }
            }),
            !i && this.options.supportedLngs && t.forEach(function(s) {
                if (!i) {
                    var o = r.getLanguagePartFromCode(s);
                    if (r.isSupportedCode(o))
                        return i = o;
                    i = r.options.supportedLngs.find(function(a) {
                        if (a === o)
                            return a;
                        if (!(a.indexOf("-") < 0 && o.indexOf("-") < 0) && a.indexOf(o) === 0)
                            return a
                    })
                }
            }),
            i || (i = this.getFallbackCodes(this.options.fallbackLng)[0]),
            i
        }
    }, {
        key: "getFallbackCodes",
        value: function(t, r) {
            if (!t)
                return [];
            if (typeof t == "function" && (t = t(r)),
            typeof t == "string" && (t = [t]),
            Object.prototype.toString.apply(t) === "[object Array]")
                return t;
            if (!r)
                return t.default || [];
            var i = t[r];
            return i || (i = t[this.getScriptPartFromCode(r)]),
            i || (i = t[this.formatLanguageCode(r)]),
            i || (i = t[this.getLanguagePartFromCode(r)]),
            i || (i = t.default),
            i || []
        }
    }, {
        key: "toResolveHierarchy",
        value: function(t, r) {
            var i = this
              , s = this.getFallbackCodes(r || this.options.fallbackLng || [], t)
              , o = []
              , a = function(c) {
                c && (i.isSupportedCode(c) ? o.push(c) : i.logger.warn("rejecting language code not found in supportedLngs: ".concat(c)))
            };
            return typeof t == "string" && t.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && a(this.formatLanguageCode(t)),
            this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && a(this.getScriptPartFromCode(t)),
            this.options.load !== "currentOnly" && a(this.getLanguagePartFromCode(t))) : typeof t == "string" && a(this.formatLanguageCode(t)),
            s.forEach(function(l) {
                o.indexOf(l) < 0 && a(i.formatLanguageCode(l))
            }),
            o
        }
    }]),
    n
}()
  , kve = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
}, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
}, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
}, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
}, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
}, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
}, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
}, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
}, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
}, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
}, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
}, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
}, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
}, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
}, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
}, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
}, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
}, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
}, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
}, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
}, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
}, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
}, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
}]
  , Qve = {
    1: function(e) {
        return +(e > 1)
    },
    2: function(e) {
        return +(e != 1)
    },
    3: function(e) {
        return 0
    },
    4: function(e) {
        return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    5: function(e) {
        return e == 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5
    },
    6: function(e) {
        return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2
    },
    7: function(e) {
        return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    8: function(e) {
        return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3
    },
    9: function(e) {
        return +(e >= 2)
    },
    10: function(e) {
        return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4
    },
    11: function(e) {
        return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3
    },
    12: function(e) {
        return +(e % 10 != 1 || e % 100 == 11)
    },
    13: function(e) {
        return +(e !== 0)
    },
    14: function(e) {
        return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3
    },
    15: function(e) {
        return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2
    },
    16: function(e) {
        return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2
    },
    17: function(e) {
        return e == 1 || e % 10 == 1 && e % 100 != 11 ? 0 : 1
    },
    18: function(e) {
        return e == 0 ? 0 : e == 1 ? 1 : 2
    },
    19: function(e) {
        return e == 1 ? 0 : e == 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3
    },
    20: function(e) {
        return e == 1 ? 0 : e == 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2
    },
    21: function(e) {
        return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0
    },
    22: function(e) {
        return e == 1 ? 0 : e == 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
    }
}
  , Hve = ["v1", "v2", "v3"]
  , c3 = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
};
function zve() {
    var n = {};
    return kve.forEach(function(e) {
        e.lngs.forEach(function(t) {
            n[t] = {
                numbers: e.nr,
                plurals: Qve[e.fc]
            }
        })
    }),
    n
}
var Gve = function() {
    function n(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        To(this, n),
        this.languageUtils = e,
        this.options = t,
        this.logger = za.create("pluralResolver"),
        (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3",
        this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
        this.rules = zve()
    }
    return Io(n, [{
        key: "addRule",
        value: function(t, r) {
            this.rules[t] = r
        }
    }, {
        key: "getRule",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this.shouldUseIntlApi())
                try {
                    return new Intl.PluralRules(t,{
                        type: r.ordinal ? "ordinal" : "cardinal"
                    })
                } catch {
                    return
                }
            return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)]
        }
    }, {
        key: "needsPlural",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
              , i = this.getRule(t, r);
            return this.shouldUseIntlApi() ? i && i.resolvedOptions().pluralCategories.length > 1 : i && i.numbers.length > 1
        }
    }, {
        key: "getPluralFormsOfKey",
        value: function(t, r) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.getSuffixes(t, i).map(function(s) {
                return "".concat(r).concat(s)
            })
        }
    }, {
        key: "getSuffixes",
        value: function(t) {
            var r = this
              , i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
              , s = this.getRule(t, i);
            return s ? this.shouldUseIntlApi() ? s.resolvedOptions().pluralCategories.sort(function(o, a) {
                return c3[o] - c3[a]
            }).map(function(o) {
                return "".concat(r.options.prepend).concat(o)
            }) : s.numbers.map(function(o) {
                return r.getSuffix(t, o, i)
            }) : []
        }
    }, {
        key: "getSuffix",
        value: function(t, r) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
              , s = this.getRule(t, i);
            return s ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(s.select(r)) : this.getSuffixRetroCompatible(s, r) : (this.logger.warn("no plural rule found for: ".concat(t)),
            "")
        }
    }, {
        key: "getSuffixRetroCompatible",
        value: function(t, r) {
            var i = this
              , s = t.noAbs ? t.plurals(r) : t.plurals(Math.abs(r))
              , o = t.numbers[s];
            this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
            var a = function() {
                return i.options.prepend && o.toString() ? i.options.prepend + o.toString() : o.toString()
            };
            return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : a() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && t.numbers.length === 2 && t.numbers[0] === 1 ? a() : this.options.prepend && s.toString() ? this.options.prepend + s.toString() : s.toString()
        }
    }, {
        key: "shouldUseIntlApi",
        value: function() {
            return !Hve.includes(this.options.compatibilityJSON)
        }
    }]),
    n
}();
function A3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function ko(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? A3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : A3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function u3(n, e, t) {
    var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "."
      , i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0
      , s = Tve(n, e, t);
    return !s && i && typeof t == "string" && (s = Ax(n, t, r),
    s === void 0 && (s = Ax(e, t, r))),
    s
}
var Vve = function() {
    function n() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        To(this, n),
        this.logger = za.create("interpolator"),
        this.options = e,
        this.format = e.interpolation && e.interpolation.format || function(t) {
            return t
        }
        ,
        this.init(e)
    }
    return Io(n, [{
        key: "init",
        value: function() {
            var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            t.interpolation || (t.interpolation = {
                escapeValue: !0
            });
            var r = t.interpolation;
            this.escape = r.escape !== void 0 ? r.escape : Rve,
            this.escapeValue = r.escapeValue !== void 0 ? r.escapeValue : !0,
            this.useRawValueToEscape = r.useRawValueToEscape !== void 0 ? r.useRawValueToEscape : !1,
            this.prefix = r.prefix ? Vf(r.prefix) : r.prefixEscaped || "{{",
            this.suffix = r.suffix ? Vf(r.suffix) : r.suffixEscaped || "}}",
            this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",",
            this.unescapePrefix = r.unescapeSuffix ? "" : r.unescapePrefix || "-",
            this.unescapeSuffix = this.unescapePrefix ? "" : r.unescapeSuffix || "",
            this.nestingPrefix = r.nestingPrefix ? Vf(r.nestingPrefix) : r.nestingPrefixEscaped || Vf("$t("),
            this.nestingSuffix = r.nestingSuffix ? Vf(r.nestingSuffix) : r.nestingSuffixEscaped || Vf(")"),
            this.nestingOptionsSeparator = r.nestingOptionsSeparator ? r.nestingOptionsSeparator : r.nestingOptionsSeparator || ",",
            this.maxReplaces = r.maxReplaces ? r.maxReplaces : 1e3,
            this.alwaysFormat = r.alwaysFormat !== void 0 ? r.alwaysFormat : !1,
            this.resetRegExp()
        }
    }, {
        key: "reset",
        value: function() {
            this.options && this.init(this.options)
        }
    }, {
        key: "resetRegExp",
        value: function() {
            var t = "".concat(this.prefix, "(.+?)").concat(this.suffix);
            this.regexp = new RegExp(t,"g");
            var r = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
            this.regexpUnescape = new RegExp(r,"g");
            var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
            this.nestingRegexp = new RegExp(i,"g")
        }
    }, {
        key: "interpolate",
        value: function(t, r, i, s) {
            var o = this, a, l, c, A = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
            function u(g) {
                return g.replace(/\$/g, "$$$$")
            }
            var f = function(p) {
                if (p.indexOf(o.formatSeparator) < 0) {
                    var v = u3(r, A, p, o.options.keySeparator, o.options.ignoreJSONStructure);
                    return o.alwaysFormat ? o.format(v, void 0, i, ko(ko(ko({}, s), r), {}, {
                        interpolationkey: p
                    })) : v
                }
                var w = p.split(o.formatSeparator)
                  , _ = w.shift().trim()
                  , x = w.join(o.formatSeparator).trim();
                return o.format(u3(r, A, _, o.options.keySeparator, o.options.ignoreJSONStructure), x, i, ko(ko(ko({}, s), r), {}, {
                    interpolationkey: _
                }))
            };
            this.resetRegExp();
            var h = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler
              , d = s && s.interpolation && s.interpolation.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables
              , m = [{
                regex: this.regexpUnescape,
                safeValue: function(p) {
                    return u(p)
                }
            }, {
                regex: this.regexp,
                safeValue: function(p) {
                    return o.escapeValue ? u(o.escape(p)) : u(p)
                }
            }];
            return m.forEach(function(g) {
                for (c = 0; a = g.regex.exec(t); ) {
                    var p = a[1].trim();
                    if (l = f(p),
                    l === void 0)
                        if (typeof h == "function") {
                            var v = h(t, a, s);
                            l = typeof v == "string" ? v : ""
                        } else if (s && Object.prototype.hasOwnProperty.call(s, p))
                            l = "";
                        else if (d) {
                            l = a[0];
                            continue
                        } else
                            o.logger.warn("missed to pass in variable ".concat(p, " for interpolating ").concat(t)),
                            l = "";
                    else
                        typeof l != "string" && !o.useRawValueToEscape && (l = n3(l));
                    var w = g.safeValue(l);
                    if (t = t.replace(a[0], w),
                    d ? (g.regex.lastIndex += l.length,
                    g.regex.lastIndex -= a[0].length) : g.regex.lastIndex = 0,
                    c++,
                    c >= o.maxReplaces)
                        break
                }
            }),
            t
        }
    }, {
        key: "nest",
        value: function(t, r) {
            var i = this, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o, a, l;
            function c(h, d) {
                var m = this.nestingOptionsSeparator;
                if (h.indexOf(m) < 0)
                    return h;
                var g = h.split(new RegExp("".concat(m, "[ ]*{")))
                  , p = "{".concat(g[1]);
                h = g[0],
                p = this.interpolate(p, l);
                var v = p.match(/'/g)
                  , w = p.match(/"/g);
                (v && v.length % 2 === 0 && !w || w.length % 2 !== 0) && (p = p.replace(/'/g, '"'));
                try {
                    l = JSON.parse(p),
                    d && (l = ko(ko({}, d), l))
                } catch (_) {
                    return this.logger.warn("failed parsing options string in nesting for key ".concat(h), _),
                    "".concat(h).concat(m).concat(p)
                }
                return delete l.defaultValue,
                h
            }
            for (; o = this.nestingRegexp.exec(t); ) {
                var A = [];
                l = ko({}, s),
                l = l.replace && typeof l.replace != "string" ? l.replace : l,
                l.applyPostProcessor = !1,
                delete l.defaultValue;
                var u = !1;
                if (o[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(o[1])) {
                    var f = o[1].split(this.formatSeparator).map(function(h) {
                        return h.trim()
                    });
                    o[1] = f.shift(),
                    A = f,
                    u = !0
                }
                if (a = r(c.call(this, o[1].trim(), l), l),
                a && o[0] === t && typeof a != "string")
                    return a;
                typeof a != "string" && (a = n3(a)),
                a || (this.logger.warn("missed to resolve ".concat(o[1], " for nesting ").concat(t)),
                a = ""),
                u && (a = A.reduce(function(h, d) {
                    return i.format(h, d, s.lng, ko(ko({}, s), {}, {
                        interpolationkey: o[1].trim()
                    }))
                }, a.trim())),
                t = t.replace(o[0], a),
                this.regexp.lastIndex = 0
            }
            return t
        }
    }]),
    n
}();
function f3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function bl(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? f3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : f3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function jve(n) {
    var e = n.toLowerCase().trim()
      , t = {};
    if (n.indexOf("(") > -1) {
        var r = n.split("(");
        e = r[0].toLowerCase().trim();
        var i = r[1].substring(0, r[1].length - 1);
        if (e === "currency" && i.indexOf(":") < 0)
            t.currency || (t.currency = i.trim());
        else if (e === "relativetime" && i.indexOf(":") < 0)
            t.range || (t.range = i.trim());
        else {
            var s = i.split(";");
            s.forEach(function(o) {
                if (o) {
                    var a = o.split(":")
                      , l = Eve(a)
                      , c = l[0]
                      , A = l.slice(1)
                      , u = A.join(":").trim().replace(/^'+|'+$/g, "");
                    t[c.trim()] || (t[c.trim()] = u),
                    u === "false" && (t[c.trim()] = !1),
                    u === "true" && (t[c.trim()] = !0),
                    isNaN(u) || (t[c.trim()] = parseInt(u, 10))
                }
            })
        }
    }
    return {
        formatName: e,
        formatOptions: t
    }
}
function jf(n) {
    var e = {};
    return function(r, i, s) {
        var o = i + JSON.stringify(s)
          , a = e[o];
        return a || (a = n(i, s),
        e[o] = a),
        a(r)
    }
}
var Wve = function() {
    function n() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        To(this, n),
        this.logger = za.create("formatter"),
        this.options = e,
        this.formats = {
            number: jf(function(t, r) {
                var i = new Intl.NumberFormat(t,bl({}, r));
                return function(s) {
                    return i.format(s)
                }
            }),
            currency: jf(function(t, r) {
                var i = new Intl.NumberFormat(t,bl(bl({}, r), {}, {
                    style: "currency"
                }));
                return function(s) {
                    return i.format(s)
                }
            }),
            datetime: jf(function(t, r) {
                var i = new Intl.DateTimeFormat(t,bl({}, r));
                return function(s) {
                    return i.format(s)
                }
            }),
            relativetime: jf(function(t, r) {
                var i = new Intl.RelativeTimeFormat(t,bl({}, r));
                return function(s) {
                    return i.format(s, r.range || "day")
                }
            }),
            list: jf(function(t, r) {
                var i = new Intl.ListFormat(t,bl({}, r));
                return function(s) {
                    return i.format(s)
                }
            })
        },
        this.init(e)
    }
    return Io(n, [{
        key: "init",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            }
              , i = r.interpolation;
            this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ","
        }
    }, {
        key: "add",
        value: function(t, r) {
            this.formats[t.toLowerCase().trim()] = r
        }
    }, {
        key: "addCached",
        value: function(t, r) {
            this.formats[t.toLowerCase().trim()] = jf(r)
        }
    }, {
        key: "format",
        value: function(t, r, i) {
            var s = this
              , o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
              , a = r.split(this.formatSeparator)
              , l = a.reduce(function(c, A) {
                var u = jve(A)
                  , f = u.formatName
                  , h = u.formatOptions;
                if (s.formats[f]) {
                    var d = c;
                    try {
                        var m = o && o.formatParams && o.formatParams[o.interpolationkey] || {}
                          , g = m.locale || m.lng || o.locale || o.lng || i;
                        d = s.formats[f](c, g, bl(bl(bl({}, h), o), m))
                    } catch (p) {
                        s.logger.warn(p)
                    }
                    return d
                } else
                    s.logger.warn("there was no format function for ".concat(f));
                return c
            }, t);
            return l
        }
    }]),
    n
}();
function h3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function d3(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? h3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : h3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function Kve(n) {
    var e = Xve();
    return function() {
        var r = il(n), i;
        if (e) {
            var s = il(this).constructor;
            i = Reflect.construct(r, arguments, s)
        } else
            i = r.apply(this, arguments);
        return M0(this, i)
    }
}
function Xve() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function Yve(n, e) {
    n.pending[e] !== void 0 && (delete n.pending[e],
    n.pendingCount--)
}
var $ve = function(n) {
    N1(t, n);
    var e = Kve(t);
    function t(r, i, s) {
        var o, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return To(this, t),
        o = e.call(this),
        O1 && bA.call(dA(o)),
        o.backend = r,
        o.store = i,
        o.services = s,
        o.languageUtils = s.languageUtils,
        o.options = a,
        o.logger = za.create("backendConnector"),
        o.waitingReads = [],
        o.maxParallelReads = a.maxParallelReads || 10,
        o.readingCalls = 0,
        o.maxRetries = a.maxRetries >= 0 ? a.maxRetries : 5,
        o.retryTimeout = a.retryTimeout >= 1 ? a.retryTimeout : 350,
        o.state = {},
        o.queue = [],
        o.backend && o.backend.init && o.backend.init(s, a.backend, a),
        o
    }
    return Io(t, [{
        key: "queueLoad",
        value: function(i, s, o, a) {
            var l = this
              , c = {}
              , A = {}
              , u = {}
              , f = {};
            return i.forEach(function(h) {
                var d = !0;
                s.forEach(function(m) {
                    var g = "".concat(h, "|").concat(m);
                    !o.reload && l.store.hasResourceBundle(h, m) ? l.state[g] = 2 : l.state[g] < 0 || (l.state[g] === 1 ? A[g] === void 0 && (A[g] = !0) : (l.state[g] = 1,
                    d = !1,
                    A[g] === void 0 && (A[g] = !0),
                    c[g] === void 0 && (c[g] = !0),
                    f[m] === void 0 && (f[m] = !0)))
                }),
                d || (u[h] = !0)
            }),
            (Object.keys(c).length || Object.keys(A).length) && this.queue.push({
                pending: A,
                pendingCount: Object.keys(A).length,
                loaded: {},
                errors: [],
                callback: a
            }),
            {
                toLoad: Object.keys(c),
                pending: Object.keys(A),
                toLoadLanguages: Object.keys(u),
                toLoadNamespaces: Object.keys(f)
            }
        }
    }, {
        key: "loaded",
        value: function(i, s, o) {
            var a = i.split("|")
              , l = a[0]
              , c = a[1];
            s && this.emit("failedLoading", l, c, s),
            o && this.store.addResourceBundle(l, c, o),
            this.state[i] = s ? -1 : 2;
            var A = {};
            this.queue.forEach(function(u) {
                Cve(u.loaded, [l], c),
                Yve(u, i),
                s && u.errors.push(s),
                u.pendingCount === 0 && !u.done && (Object.keys(u.loaded).forEach(function(f) {
                    A[f] || (A[f] = {});
                    var h = u.loaded[f];
                    h.length && h.forEach(function(d) {
                        A[f][d] === void 0 && (A[f][d] = !0)
                    })
                }),
                u.done = !0,
                u.errors.length ? u.callback(u.errors) : u.callback())
            }),
            this.emit("loaded", A),
            this.queue = this.queue.filter(function(u) {
                return !u.done
            })
        }
    }, {
        key: "read",
        value: function(i, s, o) {
            var a = this
              , l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
              , c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout
              , A = arguments.length > 5 ? arguments[5] : void 0;
            if (!i.length)
                return A(null, {});
            if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                    lng: i,
                    ns: s,
                    fcName: o,
                    tried: l,
                    wait: c,
                    callback: A
                });
                return
            }
            this.readingCalls++;
            var u = function(m, g) {
                if (a.readingCalls--,
                a.waitingReads.length > 0) {
                    var p = a.waitingReads.shift();
                    a.read(p.lng, p.ns, p.fcName, p.tried, p.wait, p.callback)
                }
                if (m && g && l < a.maxRetries) {
                    setTimeout(function() {
                        a.read.call(a, i, s, o, l + 1, c * 2, A)
                    }, c);
                    return
                }
                A(m, g)
            }
              , f = this.backend[o].bind(this.backend);
            if (f.length === 2) {
                try {
                    var h = f(i, s);
                    h && typeof h.then == "function" ? h.then(function(d) {
                        return u(null, d)
                    }).catch(u) : u(null, h)
                } catch (d) {
                    u(d)
                }
                return
            }
            return f(i, s, u)
        }
    }, {
        key: "prepareLoading",
        value: function(i, s) {
            var o = this
              , a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
              , l = arguments.length > 3 ? arguments[3] : void 0;
            if (!this.backend)
                return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
                l && l();
            typeof i == "string" && (i = this.languageUtils.toResolveHierarchy(i)),
            typeof s == "string" && (s = [s]);
            var c = this.queueLoad(i, s, a, l);
            if (!c.toLoad.length)
                return c.pending.length || l(),
                null;
            c.toLoad.forEach(function(A) {
                o.loadOne(A)
            })
        }
    }, {
        key: "load",
        value: function(i, s, o) {
            this.prepareLoading(i, s, {}, o)
        }
    }, {
        key: "reload",
        value: function(i, s, o) {
            this.prepareLoading(i, s, {
                reload: !0
            }, o)
        }
    }, {
        key: "loadOne",
        value: function(i) {
            var s = this
              , o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ""
              , a = i.split("|")
              , l = a[0]
              , c = a[1];
            this.read(l, c, "read", void 0, void 0, function(A, u) {
                A && s.logger.warn("".concat(o, "loading namespace ").concat(c, " for language ").concat(l, " failed"), A),
                !A && u && s.logger.log("".concat(o, "loaded namespace ").concat(c, " for language ").concat(l), u),
                s.loaded(i, A, u)
            })
        }
    }, {
        key: "saveMissing",
        value: function(i, s, o, a, l) {
            var c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}
              , A = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : function() {}
            ;
            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(s)) {
                this.logger.warn('did not save key "'.concat(o, '" as the namespace "').concat(s, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                return
            }
            if (!(o == null || o === "")) {
                if (this.backend && this.backend.create) {
                    var u = d3(d3({}, c), {}, {
                        isUpdate: l
                    })
                      , f = this.backend.create.bind(this.backend);
                    if (f.length < 6)
                        try {
                            var h;
                            f.length === 5 ? h = f(i, s, o, a, u) : h = f(i, s, o, a),
                            h && typeof h.then == "function" ? h.then(function(d) {
                                return A(null, d)
                            }).catch(A) : A(null, h)
                        } catch (d) {
                            A(d)
                        }
                    else
                        f(i, s, o, a, A, u)
                }
                !i || !i[0] || this.store.addResource(i[0], s, o, a)
            }
        }
    }]),
    t
}(bA);
function p3() {
    return {
        debug: !1,
        initImmediate: !0,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: !1,
        supportedLngs: !1,
        nonExplicitSupportedLngs: !1,
        load: "all",
        preload: !1,
        simplifyPluralSuffix: !0,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: !1,
        saveMissing: !1,
        updateMissing: !1,
        saveMissingTo: "fallback",
        saveMissingPlurals: !0,
        missingKeyHandler: !1,
        missingInterpolationHandler: !1,
        postProcess: !1,
        postProcessPassResolved: !1,
        returnNull: !0,
        returnEmptyString: !0,
        returnObjects: !1,
        joinArrays: !1,
        returnedObjectHandler: !1,
        parseMissingKeyHandler: !1,
        appendNamespaceToMissingKey: !1,
        appendNamespaceToCIMode: !1,
        overloadTranslationOptionHandler: function(e) {
            var t = {};
            if (Ns(e[1]) === "object" && (t = e[1]),
            typeof e[1] == "string" && (t.defaultValue = e[1]),
            typeof e[2] == "string" && (t.tDescription = e[2]),
            Ns(e[2]) === "object" || Ns(e[3]) === "object") {
                var r = e[3] || e[2];
                Object.keys(r).forEach(function(i) {
                    t[i] = r[i]
                })
            }
            return t
        },
        interpolation: {
            escapeValue: !0,
            format: function(e, t, r, i) {
                return e
            },
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0
        }
    }
}
function m3(n) {
    return typeof n.ns == "string" && (n.ns = [n.ns]),
    typeof n.fallbackLng == "string" && (n.fallbackLng = [n.fallbackLng]),
    typeof n.fallbackNS == "string" && (n.fallbackNS = [n.fallbackNS]),
    n.supportedLngs && n.supportedLngs.indexOf("cimode") < 0 && (n.supportedLngs = n.supportedLngs.concat(["cimode"])),
    n
}
function g3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function xa(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? g3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : g3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
function Zve(n) {
    var e = Jve();
    return function() {
        var r = il(n), i;
        if (e) {
            var s = il(this).constructor;
            i = Reflect.construct(r, arguments, s)
        } else
            i = r.apply(this, arguments);
        return M0(this, i)
    }
}
function Jve() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function ky() {}
function qve(n) {
    var e = Object.getOwnPropertyNames(Object.getPrototypeOf(n));
    e.forEach(function(t) {
        typeof n[t] == "function" && (n[t] = n[t].bind(n))
    })
}
var ux = function(n) {
    N1(t, n);
    var e = Zve(t);
    function t() {
        var r, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
        if (To(this, t),
        r = e.call(this),
        O1 && bA.call(dA(r)),
        r.options = m3(i),
        r.services = {},
        r.logger = za,
        r.modules = {
            external: []
        },
        qve(dA(r)),
        s && !r.isInitialized && !i.isClone) {
            if (!r.options.initImmediate)
                return r.init(i, s),
                M0(r, dA(r));
            setTimeout(function() {
                r.init(i, s)
            }, 0)
        }
        return r
    }
    return Io(t, [{
        key: "init",
        value: function() {
            var i = this
              , s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , o = arguments.length > 1 ? arguments[1] : void 0;
            typeof s == "function" && (o = s,
            s = {}),
            !s.defaultNS && s.defaultNS !== !1 && s.ns && (typeof s.ns == "string" ? s.defaultNS = s.ns : s.ns.indexOf("translation") < 0 && (s.defaultNS = s.ns[0]));
            var a = p3();
            this.options = xa(xa(xa({}, a), this.options), m3(s)),
            this.options.compatibilityAPI !== "v1" && (this.options.interpolation = xa(xa({}, a.interpolation), this.options.interpolation)),
            s.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = s.keySeparator),
            s.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = s.nsSeparator);
            function l(p) {
                return p ? typeof p == "function" ? new p : p : null
            }
            if (!this.options.isClone) {
                this.modules.logger ? za.init(l(this.modules.logger), this.options) : za.init(null, this.options);
                var c;
                this.modules.formatter ? c = this.modules.formatter : typeof Intl < "u" && (c = Wve);
                var A = new l3(this.options);
                this.store = new Dve(this.options.resources,this.options);
                var u = this.services;
                u.logger = za,
                u.resourceStore = this.store,
                u.languageUtils = A,
                u.pluralResolver = new Gve(A,{
                    prepend: this.options.pluralSeparator,
                    compatibilityJSON: this.options.compatibilityJSON,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix
                }),
                c && (!this.options.interpolation.format || this.options.interpolation.format === a.interpolation.format) && (u.formatter = l(c),
                u.formatter.init(u, this.options),
                this.options.interpolation.format = u.formatter.format.bind(u.formatter)),
                u.interpolator = new Vve(this.options),
                u.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                },
                u.backendConnector = new $ve(l(this.modules.backend),u.resourceStore,u,this.options),
                u.backendConnector.on("*", function(p) {
                    for (var v = arguments.length, w = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
                        w[_ - 1] = arguments[_];
                    i.emit.apply(i, [p].concat(w))
                }),
                this.modules.languageDetector && (u.languageDetector = l(this.modules.languageDetector),
                u.languageDetector.init && u.languageDetector.init(u, this.options.detection, this.options)),
                this.modules.i18nFormat && (u.i18nFormat = l(this.modules.i18nFormat),
                u.i18nFormat.init && u.i18nFormat.init(this)),
                this.translator = new a3(this.services,this.options),
                this.translator.on("*", function(p) {
                    for (var v = arguments.length, w = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
                        w[_ - 1] = arguments[_];
                    i.emit.apply(i, [p].concat(w))
                }),
                this.modules.external.forEach(function(p) {
                    p.init && p.init(i)
                })
            }
            if (this.format = this.options.interpolation.format,
            o || (o = ky),
            this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                var f = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                f.length > 0 && f[0] !== "dev" && (this.options.lng = f[0])
            }
            !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
            var h = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
            h.forEach(function(p) {
                i[p] = function() {
                    var v;
                    return (v = i.store)[p].apply(v, arguments)
                }
            });
            var d = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
            d.forEach(function(p) {
                i[p] = function() {
                    var v;
                    return (v = i.store)[p].apply(v, arguments),
                    i
                }
            });
            var m = om()
              , g = function() {
                var v = function(_, x) {
                    i.isInitialized && !i.initializedStoreOnce && i.logger.warn("init: i18next is already initialized. You should call init just once!"),
                    i.isInitialized = !0,
                    i.options.isClone || i.logger.log("initialized", i.options),
                    i.emit("initialized", i.options),
                    m.resolve(x),
                    o(_, x)
                };
                if (i.languages && i.options.compatibilityAPI !== "v1" && !i.isInitialized)
                    return v(null, i.t.bind(i));
                i.changeLanguage(i.options.lng, v)
            };
            return this.options.resources || !this.options.initImmediate ? g() : setTimeout(g, 0),
            m
        }
    }, {
        key: "loadResources",
        value: function(i) {
            var s = this
              , o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ky
              , a = o
              , l = typeof i == "string" ? i : this.language;
            if (typeof i == "function" && (a = i),
            !this.options.resources || this.options.partialBundledLanguages) {
                if (l && l.toLowerCase() === "cimode")
                    return a();
                var c = []
                  , A = function(h) {
                    if (h) {
                        var d = s.services.languageUtils.toResolveHierarchy(h);
                        d.forEach(function(m) {
                            c.indexOf(m) < 0 && c.push(m)
                        })
                    }
                };
                if (l)
                    A(l);
                else {
                    var u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                    u.forEach(function(f) {
                        return A(f)
                    })
                }
                this.options.preload && this.options.preload.forEach(function(f) {
                    return A(f)
                }),
                this.services.backendConnector.load(c, this.options.ns, function(f) {
                    !f && !s.resolvedLanguage && s.language && s.setResolvedLanguage(s.language),
                    a(f)
                })
            } else
                a(null)
        }
    }, {
        key: "reloadResources",
        value: function(i, s, o) {
            var a = om();
            return i || (i = this.languages),
            s || (s = this.options.ns),
            o || (o = ky),
            this.services.backendConnector.reload(i, s, function(l) {
                a.resolve(),
                o(l)
            }),
            a
        }
    }, {
        key: "use",
        value: function(i) {
            if (!i)
                throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
            if (!i.type)
                throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
            return i.type === "backend" && (this.modules.backend = i),
            (i.type === "logger" || i.log && i.warn && i.error) && (this.modules.logger = i),
            i.type === "languageDetector" && (this.modules.languageDetector = i),
            i.type === "i18nFormat" && (this.modules.i18nFormat = i),
            i.type === "postProcessor" && pV.addPostProcessor(i),
            i.type === "formatter" && (this.modules.formatter = i),
            i.type === "3rdParty" && this.modules.external.push(i),
            this
        }
    }, {
        key: "setResolvedLanguage",
        value: function(i) {
            if (!(!i || !this.languages) && !(["cimode", "dev"].indexOf(i) > -1))
                for (var s = 0; s < this.languages.length; s++) {
                    var o = this.languages[s];
                    if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
                        this.resolvedLanguage = o;
                        break
                    }
                }
        }
    }, {
        key: "changeLanguage",
        value: function(i, s) {
            var o = this;
            this.isLanguageChangingTo = i;
            var a = om();
            this.emit("languageChanging", i);
            var l = function(f) {
                o.language = f,
                o.languages = o.services.languageUtils.toResolveHierarchy(f),
                o.resolvedLanguage = void 0,
                o.setResolvedLanguage(f)
            }
              , c = function(f, h) {
                h ? (l(h),
                o.translator.changeLanguage(h),
                o.isLanguageChangingTo = void 0,
                o.emit("languageChanged", h),
                o.logger.log("languageChanged", h)) : o.isLanguageChangingTo = void 0,
                a.resolve(function() {
                    return o.t.apply(o, arguments)
                }),
                s && s(f, function() {
                    return o.t.apply(o, arguments)
                })
            }
              , A = function(f) {
                !i && !f && o.services.languageDetector && (f = []);
                var h = typeof f == "string" ? f : o.services.languageUtils.getBestMatchFromCodes(f);
                h && (o.language || l(h),
                o.translator.language || o.translator.changeLanguage(h),
                o.services.languageDetector && o.services.languageDetector.cacheUserLanguage && o.services.languageDetector.cacheUserLanguage(h)),
                o.loadResources(h, function(d) {
                    c(d, h)
                })
            };
            return !i && this.services.languageDetector && !this.services.languageDetector.async ? A(this.services.languageDetector.detect()) : !i && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(A) : this.services.languageDetector.detect(A) : A(i),
            a
        }
    }, {
        key: "getFixedT",
        value: function(i, s, o) {
            var a = this
              , l = function c(A, u) {
                var f;
                if (Ns(u) !== "object") {
                    for (var h = arguments.length, d = new Array(h > 2 ? h - 2 : 0), m = 2; m < h; m++)
                        d[m - 2] = arguments[m];
                    f = a.options.overloadTranslationOptionHandler([A, u].concat(d))
                } else
                    f = xa({}, u);
                f.lng = f.lng || c.lng,
                f.lngs = f.lngs || c.lngs,
                f.ns = f.ns || c.ns,
                f.keyPrefix = f.keyPrefix || o || c.keyPrefix;
                var g = a.options.keySeparator || ".", p;
                return f.keyPrefix && Array.isArray(A) ? p = A.map(function(v) {
                    return "".concat(f.keyPrefix).concat(g).concat(v)
                }) : p = f.keyPrefix ? "".concat(f.keyPrefix).concat(g).concat(A) : A,
                a.t(p, f)
            };
            return typeof i == "string" ? l.lng = i : l.lngs = i,
            l.ns = s,
            l.keyPrefix = o,
            l
        }
    }, {
        key: "t",
        value: function() {
            var i;
            return this.translator && (i = this.translator).translate.apply(i, arguments)
        }
    }, {
        key: "exists",
        value: function() {
            var i;
            return this.translator && (i = this.translator).exists.apply(i, arguments)
        }
    }, {
        key: "setDefaultNamespace",
        value: function(i) {
            this.options.defaultNS = i
        }
    }, {
        key: "hasLoadedNamespace",
        value: function(i) {
            var s = this
              , o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this.isInitialized)
                return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
                !1;
            if (!this.languages || !this.languages.length)
                return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
                !1;
            var a = o.lng || this.resolvedLanguage || this.languages[0]
              , l = this.options ? this.options.fallbackLng : !1
              , c = this.languages[this.languages.length - 1];
            if (a.toLowerCase() === "cimode")
                return !0;
            var A = function(h, d) {
                var m = s.services.backendConnector.state["".concat(h, "|").concat(d)];
                return m === -1 || m === 2
            };
            if (o.precheck) {
                var u = o.precheck(this, A);
                if (u !== void 0)
                    return u
            }
            return !!(this.hasResourceBundle(a, i) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || A(a, i) && (!l || A(c, i)))
        }
    }, {
        key: "loadNamespaces",
        value: function(i, s) {
            var o = this
              , a = om();
            return this.options.ns ? (typeof i == "string" && (i = [i]),
            i.forEach(function(l) {
                o.options.ns.indexOf(l) < 0 && o.options.ns.push(l)
            }),
            this.loadResources(function(l) {
                a.resolve(),
                s && s(l)
            }),
            a) : (s && s(),
            Promise.resolve())
        }
    }, {
        key: "loadLanguages",
        value: function(i, s) {
            var o = om();
            typeof i == "string" && (i = [i]);
            var a = this.options.preload || []
              , l = i.filter(function(c) {
                return a.indexOf(c) < 0
            });
            return l.length ? (this.options.preload = a.concat(l),
            this.loadResources(function(c) {
                o.resolve(),
                s && s(c)
            }),
            o) : (s && s(),
            Promise.resolve())
        }
    }, {
        key: "dir",
        value: function(i) {
            if (i || (i = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
            !i)
                return "rtl";
            var s = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"]
              , o = this.services && this.services.languageUtils || new l3(p3());
            return s.indexOf(o.getLanguagePartFromCode(i)) > -1 || i.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
        }
    }, {
        key: "cloneInstance",
        value: function() {
            var i = this
              , s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ky
              , a = xa(xa(xa({}, this.options), s), {
                isClone: !0
            })
              , l = new t(a);
            (s.debug !== void 0 || s.prefix !== void 0) && (l.logger = l.logger.clone(s));
            var c = ["store", "services", "language"];
            return c.forEach(function(A) {
                l[A] = i[A]
            }),
            l.services = xa({}, this.services),
            l.services.utils = {
                hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
            },
            l.translator = new a3(l.services,l.options),
            l.translator.on("*", function(A) {
                for (var u = arguments.length, f = new Array(u > 1 ? u - 1 : 0), h = 1; h < u; h++)
                    f[h - 1] = arguments[h];
                l.emit.apply(l, [A].concat(f))
            }),
            l.init(a, o),
            l.translator.options = l.options,
            l.translator.backendConnector.services.utils = {
                hasLoadedNamespace: l.hasLoadedNamespace.bind(l)
            },
            l
        }
    }, {
        key: "toJSON",
        value: function() {
            return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
            }
        }
    }]),
    t
}(bA);
Al(ux, "createInstance", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
      , e = arguments.length > 1 ? arguments[1] : void 0;
    return new ux(n,e)
});
var Ti = ux.createInstance();
Ti.createInstance = ux.createInstance;
Ti.createInstance;
Ti.dir;
Ti.init;
Ti.loadResources;
Ti.reloadResources;
Ti.use;
Ti.changeLanguage;
Ti.getFixedT;
Ti.t;
Ti.exists;
Ti.setDefaultNamespace;
Ti.hasLoadedNamespace;
Ti.loadNamespaces;
Ti.loadLanguages;
function eye() {
    if (console && console.warn) {
        for (var n, e = arguments.length, t = new Array(e), r = 0; r < e; r++)
            t[r] = arguments[r];
        typeof t[0] == "string" && (t[0] = "react-i18next:: ".concat(t[0])),
        (n = console).warn.apply(n, t)
    }
}
var v3 = {};
function IT() {
    for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
        e[t] = arguments[t];
    typeof e[0] == "string" && v3[e[0]] || (typeof e[0] == "string" && (v3[e[0]] = new Date),
    eye.apply(void 0, e))
}
var mV = function(e, t) {
    return function() {
        if (e.isInitialized)
            t();
        else {
            var r = function i() {
                setTimeout(function() {
                    e.off("initialized", i)
                }, 0),
                t()
            };
            e.on("initialized", r)
        }
    }
};
function y3(n, e, t) {
    n.loadNamespaces(e, mV(n, t))
}
function w3(n, e, t, r) {
    typeof t == "string" && (t = [t]),
    t.forEach(function(i) {
        n.options.ns.indexOf(i) < 0 && n.options.ns.push(i)
    }),
    n.loadLanguages(e, mV(n, r))
}
function tye(n, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      , r = e.languages[0]
      , i = e.options ? e.options.fallbackLng : !1
      , s = e.languages[e.languages.length - 1];
    if (r.toLowerCase() === "cimode")
        return !0;
    var o = function(l, c) {
        var A = e.services.backendConnector.state["".concat(l, "|").concat(c)];
        return A === -1 || A === 2
    };
    return t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && e.services.backendConnector.backend && e.isLanguageChangingTo && !o(e.isLanguageChangingTo, n) ? !1 : !!(e.hasResourceBundle(r, n) || !e.services.backendConnector.backend || e.options.resources && !e.options.partialBundledLanguages || o(r, n) && (!i || o(s, n)))
}
function nye(n, e) {
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e.languages || !e.languages.length)
        return IT("i18n.languages were undefined or empty", e.languages),
        !0;
    var r = e.options.ignoreJSONStructure !== void 0;
    return r ? e.hasLoadedNamespace(n, {
        lng: t.lng,
        precheck: function(s, o) {
            if (t.bindI18n && t.bindI18n.indexOf("languageChanging") > -1 && s.services.backendConnector.backend && s.isLanguageChangingTo && !o(s.isLanguageChangingTo, n))
                return !1
        }
    }) : tye(n, e, t)
}
var rye = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
  , iye = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "©",
    "&#169;": "©",
    "&reg;": "®",
    "&#174;": "®",
    "&hellip;": "…",
    "&#8230;": "…",
    "&#x2F;": "/",
    "&#47;": "/"
}
  , sye = function(e) {
    return iye[e]
}
  , oye = function(e) {
    return e.replace(rye, sye)
};
function _3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function x3(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? _3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : _3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
var RT = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape: oye
};
function aye() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    RT = x3(x3({}, RT), n)
}
function lye() {
    return RT
}
var gV;
function cye(n) {
    gV = n
}
function Aye() {
    return gV
}
var uye = {
    type: "3rdParty",
    init: function(e) {
        aye(e.options.react),
        cye(e)
    }
}
  , fye = be.createContext()
  , hye = function() {
    function n() {
        To(this, n),
        this.usedNamespaces = {}
    }
    return Io(n, [{
        key: "addUsedNamespaces",
        value: function(t) {
            var r = this;
            t.forEach(function(i) {
                r.usedNamespaces[i] || (r.usedNamespaces[i] = !0)
            })
        }
    }, {
        key: "getUsedNamespaces",
        value: function() {
            return Object.keys(this.usedNamespaces)
        }
    }]),
    n
}();
function dye(n, e) {
    var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
    if (t != null) {
        var r, i, s, o, a = [], l = !0, c = !1;
        try {
            if (s = (t = t.call(n)).next,
            e === 0) {
                if (Object(t) !== t)
                    return;
                l = !1
            } else
                for (; !(l = (r = s.call(t)).done) && (a.push(r.value),
                a.length !== e); l = !0)
                    ;
        } catch (A) {
            c = !0,
            i = A
        } finally {
            try {
                if (!l && t.return != null && (o = t.return(),
                Object(o) !== o))
                    return
            } finally {
                if (c)
                    throw i
            }
        }
        return a
    }
}
function pye(n, e) {
    return uV(n) || dye(n, e) || fV(n, e) || hV()
}
function b3(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(n);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(n, i).enumerable
        })),
        t.push.apply(t, r)
    }
    return t
}
function cM(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? b3(Object(t), !0).forEach(function(r) {
            Al(n, r, t[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : b3(Object(t)).forEach(function(r) {
            Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r))
        })
    }
    return n
}
var mye = function(e, t) {
    var r = be.useRef();
    return be.useEffect(function() {
        r.current = t ? r.current : e
    }, [e, t]),
    r.current
};
function gye(n) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
      , t = e.i18n
      , r = be.useContext(fye) || {}
      , i = r.i18n
      , s = r.defaultNS
      , o = t || i || Aye();
    if (o && !o.reportNamespaces && (o.reportNamespaces = new hye),
    !o) {
        IT("You will need to pass in an i18next instance by using initReactI18next");
        var a = function(I, M) {
            return typeof M == "string" ? M : M && Ns(M) === "object" && typeof M.defaultValue == "string" ? M.defaultValue : Array.isArray(I) ? I[I.length - 1] : I
        }
          , l = [a, {}, !1];
        return l.t = a,
        l.i18n = {},
        l.ready = !1,
        l
    }
    o.options.react && o.options.react.wait !== void 0 && IT("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    var c = cM(cM(cM({}, lye()), o.options.react), e)
      , A = c.useSuspense
      , u = c.keyPrefix
      , f = n || s || o.options && o.options.defaultNS;
    f = typeof f == "string" ? [f] : f || ["translation"],
    o.reportNamespaces.addUsedNamespaces && o.reportNamespaces.addUsedNamespaces(f);
    var h = (o.isInitialized || o.initializedStoreOnce) && f.every(function(S) {
        return nye(S, o, c)
    });
    function d() {
        return o.getFixedT(e.lng || null, c.nsMode === "fallback" ? f : f[0], u)
    }
    var m = be.useState(d)
      , g = pye(m, 2)
      , p = g[0]
      , v = g[1]
      , w = f.join();
    e.lng && (w = "".concat(e.lng).concat(w));
    var _ = mye(w)
      , x = be.useRef(!0);
    be.useEffect(function() {
        var S = c.bindI18n
          , I = c.bindI18nStore;
        x.current = !0,
        !h && !A && (e.lng ? w3(o, e.lng, f, function() {
            x.current && v(d)
        }) : y3(o, f, function() {
            x.current && v(d)
        })),
        h && _ && _ !== w && x.current && v(d);
        function M() {
            x.current && v(d)
        }
        return S && o && o.on(S, M),
        I && o && o.store.on(I, M),
        function() {
            x.current = !1,
            S && o && S.split(" ").forEach(function(L) {
                return o.off(L, M)
            }),
            I && o && I.split(" ").forEach(function(L) {
                return o.store.off(L, M)
            })
        }
    }, [o, w]);
    var b = be.useRef(!0);
    be.useEffect(function() {
        x.current && !b.current && v(d),
        b.current = !1
    }, [o, u]);
    var B = [p, o, h];
    if (B.t = p,
    B.i18n = o,
    B.ready = h,
    h || !h && !A)
        return B;
    throw new Promise(function(S) {
        e.lng ? w3(o, e.lng, f, function() {
            return S()
        }) : y3(o, f, function() {
            return S()
        })
    }
    )
}
var vV = []
  , vye = vV.forEach
  , yye = vV.slice;
function wye(n) {
    return vye.call(yye.call(arguments, 1), function(e) {
        if (e)
            for (var t in e)
                n[t] === void 0 && (n[t] = e[t])
    }),
    n
}
var E3 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
  , _ye = function(e, t, r) {
    var i = r || {};
    i.path = i.path || "/";
    var s = encodeURIComponent(t)
      , o = "".concat(e, "=").concat(s);
    if (i.maxAge > 0) {
        var a = i.maxAge - 0;
        if (Number.isNaN(a))
            throw new Error("maxAge should be a Number");
        o += "; Max-Age=".concat(Math.floor(a))
    }
    if (i.domain) {
        if (!E3.test(i.domain))
            throw new TypeError("option domain is invalid");
        o += "; Domain=".concat(i.domain)
    }
    if (i.path) {
        if (!E3.test(i.path))
            throw new TypeError("option path is invalid");
        o += "; Path=".concat(i.path)
    }
    if (i.expires) {
        if (typeof i.expires.toUTCString != "function")
            throw new TypeError("option expires is invalid");
        o += "; Expires=".concat(i.expires.toUTCString())
    }
    if (i.httpOnly && (o += "; HttpOnly"),
    i.secure && (o += "; Secure"),
    i.sameSite) {
        var l = typeof i.sameSite == "string" ? i.sameSite.toLowerCase() : i.sameSite;
        switch (l) {
        case !0:
            o += "; SameSite=Strict";
            break;
        case "lax":
            o += "; SameSite=Lax";
            break;
        case "strict":
            o += "; SameSite=Strict";
            break;
        case "none":
            o += "; SameSite=None";
            break;
        default:
            throw new TypeError("option sameSite is invalid")
        }
    }
    return o
}
  , B3 = {
    create: function(e, t, r, i) {
        var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            path: "/",
            sameSite: "strict"
        };
        r && (s.expires = new Date,
        s.expires.setTime(s.expires.getTime() + r * 60 * 1e3)),
        i && (s.domain = i),
        document.cookie = _ye(e, encodeURIComponent(t), s)
    },
    read: function(e) {
        for (var t = "".concat(e, "="), r = document.cookie.split(";"), i = 0; i < r.length; i++) {
            for (var s = r[i]; s.charAt(0) === " "; )
                s = s.substring(1, s.length);
            if (s.indexOf(t) === 0)
                return s.substring(t.length, s.length)
        }
        return null
    },
    remove: function(e) {
        this.create(e, "", -1)
    }
}
  , xye = {
    name: "cookie",
    lookup: function(e) {
        var t;
        if (e.lookupCookie && typeof document < "u") {
            var r = B3.read(e.lookupCookie);
            r && (t = r)
        }
        return t
    },
    cacheUserLanguage: function(e, t) {
        t.lookupCookie && typeof document < "u" && B3.create(t.lookupCookie, e, t.cookieMinutes, t.cookieDomain, t.cookieOptions)
    }
}
  , bye = {
    name: "querystring",
    lookup: function(e) {
        var t;
        if (typeof window < "u") {
            var r = window.location.search;
            !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (r = window.location.hash.substring(window.location.hash.indexOf("?")));
            for (var i = r.substring(1), s = i.split("&"), o = 0; o < s.length; o++) {
                var a = s[o].indexOf("=");
                if (a > 0) {
                    var l = s[o].substring(0, a);
                    l === e.lookupQuerystring && (t = s[o].substring(a + 1))
                }
            }
        }
        return t
    }
}
  , am = null
  , M3 = function() {
    if (am !== null)
        return am;
    try {
        am = window !== "undefined" && window.localStorage !== null;
        var e = "i18next.translate.boo";
        window.localStorage.setItem(e, "foo"),
        window.localStorage.removeItem(e)
    } catch {
        am = !1
    }
    return am
}
  , Eye = {
    name: "localStorage",
    lookup: function(e) {
        var t;
        if (e.lookupLocalStorage && M3()) {
            var r = window.localStorage.getItem(e.lookupLocalStorage);
            r && (t = r)
        }
        return t
    },
    cacheUserLanguage: function(e, t) {
        t.lookupLocalStorage && M3() && window.localStorage.setItem(t.lookupLocalStorage, e)
    }
}
  , lm = null
  , S3 = function() {
    if (lm !== null)
        return lm;
    try {
        lm = window !== "undefined" && window.sessionStorage !== null;
        var e = "i18next.translate.boo";
        window.sessionStorage.setItem(e, "foo"),
        window.sessionStorage.removeItem(e)
    } catch {
        lm = !1
    }
    return lm
}
  , Bye = {
    name: "sessionStorage",
    lookup: function(e) {
        var t;
        if (e.lookupSessionStorage && S3()) {
            var r = window.sessionStorage.getItem(e.lookupSessionStorage);
            r && (t = r)
        }
        return t
    },
    cacheUserLanguage: function(e, t) {
        t.lookupSessionStorage && S3() && window.sessionStorage.setItem(t.lookupSessionStorage, e)
    }
}
  , Mye = {
    name: "navigator",
    lookup: function(e) {
        var t = [];
        if (typeof navigator < "u") {
            if (navigator.languages)
                for (var r = 0; r < navigator.languages.length; r++)
                    t.push(navigator.languages[r]);
            navigator.userLanguage && t.push(navigator.userLanguage),
            navigator.language && t.push(navigator.language)
        }
        return t.length > 0 ? t : void 0
    }
}
  , Sye = {
    name: "htmlTag",
    lookup: function(e) {
        var t, r = e.htmlTag || (typeof document < "u" ? document.documentElement : null);
        return r && typeof r.getAttribute == "function" && (t = r.getAttribute("lang")),
        t
    }
}
  , Cye = {
    name: "path",
    lookup: function(e) {
        var t;
        if (typeof window < "u") {
            var r = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
            if (r instanceof Array)
                if (typeof e.lookupFromPathIndex == "number") {
                    if (typeof r[e.lookupFromPathIndex] != "string")
                        return;
                    t = r[e.lookupFromPathIndex].replace("/", "")
                } else
                    t = r[0].replace("/", "")
        }
        return t
    }
}
  , Tye = {
    name: "subdomain",
    lookup: function(e) {
        var t = typeof e.lookupFromSubdomainIndex == "number" ? e.lookupFromSubdomainIndex + 1 : 1
          , r = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
        if (r)
            return r[t]
    }
};
function Iye() {
    return {
        order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
        lookupQuerystring: "lng",
        lookupCookie: "i18next",
        lookupLocalStorage: "i18nextLng",
        lookupSessionStorage: "i18nextLng",
        caches: ["localStorage"],
        excludeCacheFor: ["cimode"],
        convertDetectedLanguage: function(e) {
            return e
        }
    }
}
var yV = function() {
    function n(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        To(this, n),
        this.type = "languageDetector",
        this.detectors = {},
        this.init(e, t)
    }
    return Io(n, [{
        key: "init",
        value: function(t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
              , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this.services = t || {
                languageUtils: {}
            },
            this.options = wye(r, this.options || {}, Iye()),
            typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = function(s) {
                return s.replace("-", "_")
            }
            ),
            this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex),
            this.i18nOptions = i,
            this.addDetector(xye),
            this.addDetector(bye),
            this.addDetector(Eye),
            this.addDetector(Bye),
            this.addDetector(Mye),
            this.addDetector(Sye),
            this.addDetector(Cye),
            this.addDetector(Tye)
        }
    }, {
        key: "addDetector",
        value: function(t) {
            return this.detectors[t.name] = t,
            this
        }
    }, {
        key: "detect",
        value: function(t) {
            var r = this;
            t || (t = this.options.order);
            var i = [];
            return t.forEach(function(s) {
                if (r.detectors[s]) {
                    var o = r.detectors[s].lookup(r.options);
                    o && typeof o == "string" && (o = [o]),
                    o && (i = i.concat(o))
                }
            }),
            i = i.map(function(s) {
                return r.options.convertDetectedLanguage(s)
            }),
            this.services.languageUtils.getBestMatchFromCodes ? i : i.length > 0 ? i[0] : null
        }
    }, {
        key: "cacheUserLanguage",
        value: function(t, r) {
            var i = this;
            r || (r = this.options.caches),
            r && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(t) > -1 || r.forEach(function(s) {
                i.detectors[s] && i.detectors[s].cacheUserLanguage(t, i.options)
            }))
        }
    }]),
    n
}();
yV.type = "languageDetector";
const Rye = {
    translation: {
        pageTitles: {
            chooseClass: "Choose Character Class",
            chooseAppearance: "Choose Appearance",
            saveCharacter: "Save Your Character"
        },
        callToAction: {
            next: "Next",
            back: "Back",
            randomize: "Randomize",
            send: "Send"
        },
        editor: {
            title: "Appearance",
            head: "Head",
            body: "Body",
            eyes: "Eyes",
            outer: "Outer",
            chest: "Chest",
            legs: "Legs",
            feet: "Feet",
            accessories: "Accessories"
        },
        labels: {
            name: "Name",
            voice: "Voice",
            favoriteColor: "Favorite Color",
            preferredGreeting: "Preferred Greeting",
            question: "Question",
            yourName: "Your Name",
            conversation: "Conversation"
        },
        text: {
            unoptimized: "Unoptimized",
            apiUnderMaintnance: "Voice generation API is temporarily disabled for maintenance!"
        }
    }
}
  , Uye = {
    translation: {
        pageTitles: {
            chooseClass: "Выбрать Класс Персонажа",
            chooseAppearance: "Выбрать Внешность",
            saveCharacter: "Сохранить Персонажа"
        },
        callToAction: {
            next: "Далее",
            back: "Назад",
            randomize: "Рандомизировать",
            send: "Отправить"
        },
        editor: {
            title: "Внешность",
            head: "Голова",
            body: "Тело",
            eyes: "Глаза",
            outer: "Внешний",
            chest: "Грудь",
            legs: "Ноги",
            feet: "Стопы",
            accessories: "Аксессуары"
        },
        labels: {
            name: "Имя",
            voice: "Голос",
            favoriteColor: "Любимый Цвет",
            preferredGreeting: "Предпочитаемое Приветствие",
            question: "Вопрос",
            yourName: "Ваше Имя",
            conversation: "Разговор"
        },
        text: {
            unoptimized: "Неоптимизи­рованный",
            apiUnderMaintnance: "API генерации голоса временно отключен на техническое обслуживание."
        }
    }
}
  , Fye = {
    translation: {
        pageTitles: {
            chooseClass: "选择角色类型",
            chooseAppearance: "选择外观",
            saveCharacter: "保存角色"
        },
        callToAction: {
            next: "下一步",
            back: "返回",
            randomize: "随机",
            send: "发送"
        },
        editor: {
            title: "外观",
            head: "头部",
            body: "身体",
            eyes: "眼睛",
            outer: "外套",
            chest: "上身",
            legs: "腿部",
            feet: "脚部",
            accessories: "配件"
        },
        labels: {
            name: "名字",
            voice: "语音",
            favoriteColor: "颜色偏好",
            preferredGreeting: "首选问候语",
            question: "问题",
            yourName: "你的名字",
            conversation: "对话"
        },
        text: {
            unoptimized: "未优化",
            apiUnderMaintnance: "语音生成API暂时关闭进行维护!"
        }
    }
}
  , Pye = {
    en: Rye,
    ru: Uye,
    zh: Fye
};
Ti.use(yV).use(uye).init({
    debug: !0,
    fallbackLng: "en",
    interpolation: {
        escapeValue: !1
    },
    resources: Pye
});
const fa = be.createContext()
  , Lye = n => {
    const {t: e} = gye();
    return k.jsx(fa.Provider, {
        value: {
            t: e
        },
        children: n.children
    })
}
  , Dye = `       
  uniform vec3 cameraDir;
  uniform vec3 eye;
  
  varying vec3 vWorldPosition;
  varying vec3 vSurfaceNormal;

  varying vec2 vUv;

  void main() {
    vUv = uv;
    vec3 pos = position;
    vSurfaceNormal = normalize(normal);
    vWorldPosition = (modelMatrix * vec4( pos, 1.0 )).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 ); 
  }
`
  , Nye = ` 
  uniform float switchItemDuration;
  uniform float switchItemTime;
  uniform vec3 cameraDir;
  uniform vec3 eye;

  uniform sampler2D auraTexture;

  varying vec3 vSurfaceNormal;
  varying vec3 vWorldPosition;
  varying vec2 vUv;
  void main() {
    float aura = texture2D(
      auraTexture, 
      vec2(
        vUv.x * 2.0,
        vUv.y * 1.0 * (switchItemDuration - switchItemTime)
      )
    ).r;
    
    float dissolveThreshold = 0.1;
    float auraStep = switchItemTime <= dissolveThreshold ? 0. : clamp(switchItemTime, dissolveThreshold, 1.0);
    aura = smoothstep(0.0, auraStep, aura);
    

    vec3 eyeDirection = normalize(eye - vWorldPosition);
    
    float EdotN = max(0.0, dot(eyeDirection, vSurfaceNormal));
    float rimStrength = 0.7;
    float rim = mix(0.0, 1.0, pow(1. - EdotN, rimStrength));
    float glowIntensity = 2.0;

    vec3 rimColor = mix(vec3(0.00960, 0.833, 0.960), vec3(0., 0., 0.960), rim);
    gl_FragColor.rgb = rimColor * (1. - rim) * glowIntensity;
    gl_FragColor.a = clamp((1. - rim) * glowIntensity, 0.0, 1.0);
    gl_FragColor.a *= (switchItemDuration - switchItemTime);
    gl_FragColor *= aura;
  }
`
  , Oye = `       
  uniform vec4 cameraBillboardQuaternion;

  attribute vec2 scales;
  attribute float opacity;
  attribute vec3 positions;

  varying vec2 vUv;
  varying float vOpacity;
  varying vec3 vWorldPosition;

  vec3 rotateVecQuat(vec3 position, vec4 q) {
      vec3 v = position.xyz;
      return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
  }
  
  void main() {  
    vUv = uv;
    vOpacity = opacity;
    
    vec3 pos = position;
    pos = rotateVecQuat(pos, cameraBillboardQuaternion);
    pos.xz *= scales.x;
    pos.y *= scales.y;
    pos += positions;
    vec4 modelPosition = modelMatrix * vec4(pos, 1.0);
    vWorldPosition = modelPosition.xyz;
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectionPosition = projectionMatrix * viewPosition;
    gl_Position = projectionPosition;
  }
`
  , kye = ` 
  varying vec2 vUv;
  varying float vOpacity;
  varying vec3 vWorldPosition;

  void main() {
    float angle = 0.;
    vec2 trig = vec2(cos(angle), sin(angle));
    
    vec2 pos = (vUv - 0.5) * mat2(trig.x, trig.y, -trig.y, trig.x);
    float size = 0.1;
    
    float dist = length(max(abs(pos) - size, 0.));
    float glow = 1. / (dist * 25. + .5);

    gl_FragColor = vec4(glow);
    gl_FragColor.rgb *= vec3(0.00960, 0.833, 0.960);
    float avatarGroundPosition = 0.;
    if (glow < 0.1 || vWorldPosition.y < avatarGroundPosition) {
      discard;
    }
    gl_FragColor.a *= vOpacity;
  }
`
  , Qye = `       
  attribute vec2 scales;
  attribute float opacity;
  attribute vec3 positions;

  varying vec2 vUv;
  varying float vOpacity;
  varying vec3 vWorldPosition;
  varying vec3 vSurfaceNormal;
  

  void main() {  
    vUv = uv;
    vOpacity = opacity;
    vSurfaceNormal = normalize(normal);
    
    vec3 pos = position;
    pos.xz *= scales.x;
    pos.y *= scales.y;
    pos += positions;
    vec4 modelPosition = modelMatrix * vec4(pos, 1.0);
    vWorldPosition = modelPosition.xyz;
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectionPosition = projectionMatrix * viewPosition;
    gl_Position = projectionPosition;
  }
`
  , Hye = ` 
  uniform float radius;

  varying vec2 vUv;
  varying float vOpacity;
  varying vec3 vWorldPosition;
  varying vec3 vSurfaceNormal;

  void main() {

    vec3 eyeDirection = normalize(vec3(0., 10., 0.) - vWorldPosition);
      
    float EdotN = max(0.0, dot(eyeDirection, vSurfaceNormal));
    float rimStrength = 10.0;
    float rim = distance(vWorldPosition.xz, vec2(0.)) / radius;
    rim = pow(rim, rimStrength);
    
  
    gl_FragColor.rgb = vec3(rim) * vec3(0.00960, 0.833, 0.960) * 2.0;
    gl_FragColor.a = rim;
    gl_FragColor.a = smoothstep(0.3, 0.8, gl_FragColor.a);
    gl_FragColor.a *= vOpacity;
  }
`
  , zye = `       
  uniform vec4 cameraBillboardQuaternion;

  varying vec2 vUv;
  varying vec3 vWorldPosition;
  
  vec3 rotateVecQuat(vec3 position, vec4 q) {
      vec3 v = position.xyz;
      return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
  }
  void main() {  
    vUv = uv;
    
    vec3 pos = position;
    pos = rotateVecQuat(pos, cameraBillboardQuaternion);
    vec4 modelPosition = modelMatrix * vec4(pos, 1.0);
    vWorldPosition = modelPosition.xyz;
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectionPosition = projectionMatrix * viewPosition;
    gl_Position = projectionPosition;
  }
`
  , Gye = ` 
  varying vec2 vUv;
  varying vec3 vWorldPosition;

  void main() {
    float col = smoothstep(0.5, 0.2, length(vUv - 0.5));
    gl_FragColor.rgb = mix(vec3(0., 0., 0.960), vec3(0.00960, 0.833, 0.960), col);
    gl_FragColor.a = col;
    gl_FragColor.a *= clamp(vWorldPosition.y * 10., 0.0, 1.0);
  }
`
  , Vye = `       
  varying vec3 vWorldPosition;
  varying vec3 vSurfaceNormal;

  varying vec2 vUv;

  void main() {
    vUv = uv;
    vec3 pos = position;
    vSurfaceNormal = normalize(normal);
    vWorldPosition = (modelMatrix * vec4( pos, 1.0 )).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 ); 
  }
`
  , jye = ` 
  uniform vec3 cameraDir;
  uniform vec3 eye;

  uniform float opacity;

  varying vec3 vSurfaceNormal;
  varying vec3 vWorldPosition;
  varying vec2 vUv;
  void main() {
    vec3 eyeDirection = normalize(eye - vWorldPosition);
    
    float EdotN = max(0.0, dot(eyeDirection, vSurfaceNormal));
    float rimStrength = 0.7;
    float rim = mix(0.0, 1.0, pow(1. - EdotN, rimStrength));
    float glowIntensity = 2.0;

    vec3 rimColor = mix(vec3(1.0), vec3(0.400, 0.723, 0.910), rim);
    gl_FragColor = vec4(rimColor, pow(1. - rim, 2.0));
    gl_FragColor *= pow(1. - vUv.y, 3.0);
    gl_FragColor *= opacity;
  }
`
  , y2 = (n, e, t) => {
    const r = new Jt;
    ["position", "normal", "uv"].forEach(o => {
        r.setAttribute(o, n.attributes[o])
    }
    ),
    r.setIndex(n.index);
    const i = new Float32Array(t * 3)
      , s = new Vg(i,3);
    r.setAttribute("positions", s);
    for (const o of e) {
        const {name: a, itemSize: l} = o
          , c = new Float32Array(t * l);
        r.setAttribute(a, new Vg(c,l))
    }
    return r
}
  , Wye = n => {
    const r = new m1(.45,.45,5,50,50,!0)
      , i = new mr({
        uniforms: {
            auraTexture: {
                value: null
            }
        },
        vertexShader: Dye,
        fragmentShader: Nye,
        transparent: !0,
        blending: Du
    });
    i.uniforms.cameraDir = n.cameraDir,
    i.uniforms.eye = n.eye,
    i.uniforms.switchItemTime = n.switchItemTime,
    i.uniforms.switchItemDuration = n.switchItemDuration;
    const s = new dn(r,i);
    return s.frustumCulled = !1,
    s.position.y = 5 * .46,
    s
}
  , Kye = () => {
    const e = [];
    e.push({
        name: "opacity",
        itemSize: 1
    }),
    e.push({
        name: "scales",
        itemSize: 2
    });
    const t = .3
      , r = new cc(t,t)
      , i = y2(r, e, 20)
      , s = new mr({
        uniforms: {
            cameraBillboardQuaternion: {
                value: new nt
            }
        },
        vertexShader: Oye,
        fragmentShader: kye,
        depthWrite: !1,
        blending: Du
    })
      , o = new p1(i,s,20);
    return o.info = {
        particleCount: 20,
        velocity: [20]
    },
    o
}
  , Xye = n => {
    const t = [];
    t.push({
        name: "opacity",
        itemSize: 1
    }),
    t.push({
        name: "scales",
        itemSize: 2
    });
    const r = .43
      , i = new VR(r,32,32)
      , s = y2(i, t, 10)
      , o = new mr({
        uniforms: {
            radius: {
                value: r
            }
        },
        vertexShader: Qye,
        fragmentShader: Hye,
        depthWrite: !1,
        blending: Du
    });
    o.uniforms.cameraDir = n.cameraDir,
    o.uniforms.eye = n.eye,
    o.uniforms.fadeInAvatarTime = n.fadeInAvatarTime;
    const a = new p1(s,o,10);
    return a.info = {
        particleCount: 10,
        velocity: [10],
        currentIndex: 0
    },
    a
}
  , Yye = n => {
    const t = new cc(1,1)
      , r = new mr({
        uniforms: {
            cameraBillboardQuaternion: {
                value: new nt
            }
        },
        vertexShader: zye,
        fragmentShader: Gye,
        depthWrite: !1,
        blending: Du
    });
    return new dn(t,r)
}
  , $ye = n => {
    const t = []
      , s = new m1(.645,.43,2.5,50,50,!0)
      , o = y2(s, t, 2)
      , a = new mr({
        uniforms: {
            opacity: {
                value: 0
            }
        },
        vertexShader: Vye,
        fragmentShader: jye,
        transparent: !0,
        blending: Du
    });
    a.uniforms.cameraDir = n.cameraDir,
    a.uniforms.eye = n.eye;
    const l = new p1(o,a,2);
    return l.fadeIn = !1,
    l.frustumCulled = !1,
    l.position.y = 2.5 * .46,
    l
}
  , C3 = 100
  , Zye = 0
  , fx = 1.5
  , Jye = .1
  , kw = 0
  , T3 = 1
  , I3 = .05
  , UT = 0
  , qye = 1
  , ewe = .015
  , Ki = {
    normal: 0,
    switchItem: 1,
    fadeOutAvatar: 2,
    loadingAvatar: 3,
    fadeInAvatar: 4
}
  , twe = new PA
  , wV = twe.load("./public/textures/beam2.png");
wV.wrapS = zs;
class nwe {
    constructor(e, t, r) {
        this.scene = e,
        this.camera = t,
        this.globalUniforms = r,
        this.eye = new $,
        this.cameraDir = new $,
        this.beamMesh = null,
        this.initBeam(),
        this.pixelMesh = null,
        this.initPixel(),
        this.ringMesh = null,
        this.initRing(),
        this.teleportMesh = null,
        this.initTeleport(),
        this.spotLight = null,
        this.initSpotLight()
    }
    emitBeam() {
        this.beamMesh.visible = !0
    }
    emitPixel() {
        this.stopUpdatePixelMesh = !1;
        const e = this.pixelMesh.geometry.getAttribute("scales")
          , t = this.pixelMesh.geometry.getAttribute("positions")
          , r = this.pixelMesh.geometry.getAttribute("opacity")
          , i = this.pixelMesh.info.particleCount
          , s = .25;
        for (let o = 0; o < i; o++) {
            o % 2 === 0 ? e.setXY(o, .2, .2) : e.setXY(o, .1, 3 + Math.random());
            const a = o / i * Math.PI * 2;
            t.setXYZ(o, Math.cos(a) * s, (Math.random() - .5) * 2, Math.sin(a) * s),
            r.setX(o, 1 + Math.random()),
            this.pixelMesh.info.velocity[o] = .02 + Math.random() * .03
        }
        e.needsUpdate = !0,
        t.needsUpdate = !0,
        r.needsUpdate = !0
    }
    emitRespawnPixel() {
        this.stopUpdatePixelMesh = !1;
        const e = this.pixelMesh.geometry.getAttribute("scales")
          , t = this.pixelMesh.geometry.getAttribute("positions")
          , r = this.pixelMesh.geometry.getAttribute("opacity")
          , i = this.pixelMesh.info.particleCount
          , s = .25;
        for (let o = 0; o < i; o++)
            if (r.getX(o) < .01) {
                o % 2 === 0 ? e.setXY(o, .2, .2) : e.setXY(o, .1, 3 + Math.random());
                const a = o / i * Math.PI * 2;
                t.setXYZ(o, Math.cos(a) * s, Math.random() * -1, Math.sin(a) * s),
                r.setX(o, 1 + Math.random()),
                this.pixelMesh.info.velocity[o] = .05 + Math.random() * .05;
                break
            }
        e.needsUpdate = !0,
        t.needsUpdate = !0,
        r.needsUpdate = !0
    }
    emitRing(e) {
        this.ringMesh.visible = !0;
        const t = this.ringMesh.geometry.getAttribute("scales")
          , r = this.ringMesh.geometry.getAttribute("positions")
          , i = this.ringMesh.geometry.getAttribute("opacity")
          , s = this.ringMesh.info.particleCount
          , o = this.ringMesh.info.currentIndex
          , a = o - 1 < 0 ? s - 1 : o - 1
          , l = .1;
        (r.getY(a) > l + e || i.getX(a) <= 0) && (r.setXYZ(o, 0, l, 0),
        t.setXY(o, 1, .06),
        i.setX(o, 1),
        this.ringMesh.info.velocity[o] = .1,
        this.ringMesh.info.currentIndex++,
        this.ringMesh.info.currentIndex >= s && (this.ringMesh.info.currentIndex = 0)),
        t.needsUpdate = !0,
        r.needsUpdate = !0,
        i.needsUpdate = !0
    }
    emitTeleport() {
        this.teleportMesh.visible = !0
    }
    emitSpotLight() {
        this.spotLight.visible = !0,
        this.spotLight.fadeIn = !0
    }
    removeSpotLight() {
        this.spotLight.fadeIn = !1
    }
    update() {
        this.beamMesh.visible && this.beamMesh.update(),
        !this.stopUpdatePixelMesh && this.pixelMesh.update(),
        this.ringMesh.visible && this.ringMesh.update(),
        this.teleportMesh.visible && this.teleportMesh.update(),
        this.spotLight.visible && this.spotLight.update()
    }
    initBeam() {
        this.beamMesh = Wye(this.globalUniforms),
        this.beamMesh.material.uniforms.auraTexture.value = wV,
        this.beamMesh.update = () => this.updateBeam(),
        this.scene.add(this.beamMesh)
    }
    initPixel() {
        this.pixelMesh = Kye(),
        this.pixelMesh.update = () => this.updatePixel(),
        this.scene.add(this.pixelMesh)
    }
    initRing() {
        this.ringMesh = Xye(this.globalUniforms),
        this.ringMesh.update = () => this.updateRing(),
        this.scene.add(this.ringMesh)
    }
    initTeleport() {
        this.teleportMesh = Yye(this.globalUniforms),
        this.teleportMesh.update = () => this.updateTeleport(),
        this.teleportMesh.visible = !1,
        this.scene.add(this.teleportMesh)
    }
    initSpotLight() {
        this.spotLight = $ye(this.globalUniforms),
        this.spotLight.update = () => this.updateSpotLight(),
        this.spotLight.visible = !1,
        this.scene.add(this.spotLight)
    }
    updateBeam() {
        this.beamMesh && this.globalUniforms.transitionEffectType.value !== Ki.switchItem && (this.beamMesh.visible = !1)
    }
    updatePixel() {
        if (this.pixelMesh) {
            let e = 0;
            const t = this.pixelMesh.geometry.getAttribute("positions")
              , r = this.pixelMesh.geometry.getAttribute("opacity")
              , i = this.pixelMesh.info.particleCount;
            for (let s = 0; s < i; s++)
                r.getX(s) > .01 ? (t.setY(s, t.getY(s) + this.pixelMesh.info.velocity[s]),
                r.setX(s, r.getX(s) / 1.3)) : (r.setX(s, 0),
                e++);
            e >= i && (this.stopUpdatePixelMesh = !0),
            t.needsUpdate = !0,
            r.needsUpdate = !0,
            this.pixelMesh.material.uniforms.cameraBillboardQuaternion.value.copy(this.camera.quaternion)
        }
    }
    updateRing() {
        if (this.ringMesh) {
            const e = this.ringMesh.geometry.getAttribute("positions")
              , t = this.ringMesh.geometry.getAttribute("opacity")
              , r = this.ringMesh.info.particleCount;
            for (let i = 0; i < r; i++)
                t.getX(i) > .01 ? (e.setY(i, e.getY(i) + this.ringMesh.info.velocity[i]),
                t.setX(i, t.getX(i) / 1.27)) : t.setX(i, 0);
            e.needsUpdate = !0,
            t.needsUpdate = !0,
            this.globalUniforms.transitionEffectType.value !== Ki.fadeInAvatar && (this.ringMesh.visible = !1)
        }
    }
    updateTeleport() {
        if (this.teleportMesh) {
            if (this.globalUniforms.transitionEffectType.value === Ki.fadeOutAvatar) {
                const e = this.globalUniforms.fadeOutAvatarTime.value
                  , t = .2;
                if (e < t) {
                    const r = e * (1 / t)
                      , i = .6
                      , s = 5;
                    this.teleportMesh.scale.set(i, r * s, i),
                    this.teleportMesh.position.y = r * s * .35
                } else
                    this.teleportMesh.scale.x > 0 ? (this.teleportMesh.scale.x = this.teleportMesh.scale.x - .2,
                    this.teleportMesh.scale.z = this.teleportMesh.scale.z - .2) : this.teleportMesh.visible = !1
            } else
                this.teleportMesh.visible = !1;
            this.teleportMesh.material.uniforms.cameraBillboardQuaternion.value.copy(this.camera.quaternion)
        }
    }
    updateSpotLight() {
        this.spotLight && (this.spotLight.fadeIn ? this.spotLight.material.uniforms.opacity.value < 1 && (this.spotLight.material.uniforms.opacity.value = 1) : this.spotLight.material.uniforms.opacity.value > 0 ? this.spotLight.material.uniforms.opacity.value -= .025 : (this.spotLight.material.uniforms.opacity.value = 0,
        this.spotLight.visible = !1))
    }
}
const _V = new PA
  , FT = _V.load("./public/textures/pixel9.png");
FT.wrapS = FT.wrapT = zs;
const PT = _V.load("./public/textures/noise3.jpg");
PT.wrapS = PT.wrapT = zs;
const Qt = {
    switchItemDuration: {
        value: fx
    },
    switchItemTime: {
        value: fx
    },
    eye: {
        value: new $
    },
    cameraDir: {
        value: new $
    },
    fadeOutAvatarTime: {
        value: kw
    },
    fadeInAvatarTime: {
        value: UT
    },
    transitionEffectType: {
        value: Ki.normal
    }
}
  , R3 = {
    pixelTexture: {
        value: FT
    },
    noiseTexture: {
        value: PT
    }
};
class rwe extends EventTarget {
    constructor() {
        super();
        Ne(this, "setTransitionEffect", t => {
            this.transitionEffectType = t
        }
        );
        Ne(this, "getTransitionEffect", t => this.transitionEffectType === t);
        this.cameraDir = new $,
        this.frameRate = 1e3 / 30,
        this.initParticle = !1,
        this.transitionEffectType = null,
        this.transitionTime = C3,
        this.update()
    }
    setCustomShader(t) {
        t.vertexShader && (t.vertexShader = t.vertexShader.replace("varying vec3 vViewPosition;", `
      varying vec3 vViewPosition;
      varying vec3 vWorldPosition;
      varying vec3 vSurfaceNormal;
      `),
        t.vertexShader = t.vertexShader.replace("void main() {", `
      void main() {
        vSurfaceNormal = normalize(normal);
      `),
        t.vertexShader = t.vertexShader.replace("#include <worldpos_vertex>", `
      #include <worldpos_vertex>
      vWorldPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;
      `),
        t.fragmentShader = t.fragmentShader.replace("uniform vec3 litFactor;", `
      uniform vec3 litFactor;
      uniform vec3 cameraDir;
      uniform vec3 eye;
      uniform float switchItemTime;
      uniform float switchItemDuration;
      uniform sampler2D pixelTexture;
      uniform sampler2D noiseTexture;
      uniform float transitionEffectType;

      uniform float fadeInAvatarTime;
      
      varying vec3 vWorldPosition;
      varying vec3 vSurfaceNormal;

      vec4 textureRemap(vec4 In, vec2 InMinMax, vec2 OutMinMax) {
        return OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
      }

      float getRim(vec3 normal, float rimStrength, float glowIntensity) {
        vec3 eyeDirection = normalize(eye - vWorldPosition);
        float EdotN = max(0.0, dot(eyeDirection, normal));
        float bodyRim = pow(1. - EdotN, rimStrength);
        return bodyRim * glowIntensity;
      }

      vec3 getPixelColor(float pixelStrength) {
        float pixelUvScale = 2.0;
        vec2 pixelUv = vec2(
          vWorldPosition.x * pixelUvScale * -cameraDir.z + vWorldPosition.z * pixelUvScale * cameraDir.x,
          vWorldPosition.y * pixelUvScale
        );
        float pixel = texture2D(
          pixelTexture, 
          pixelUv
        ).r;
        return mix(vec3(0.0396, 0.768, 0.990), vec3(0.0142, 0.478, 0.710), pixel * pixelStrength);
      }

      float getDissolveLimit(float noiseUvScale, float noiseStrength, float bottomPosition, float avatarHeight, float time) {
        vec2 noiseUv = vec2(
          vWorldPosition.x * noiseUvScale * -cameraDir.z + vWorldPosition.z * noiseUvScale * cameraDir.x,
          vWorldPosition.y * noiseUvScale
        );
        vec4 noise = texture2D(
          noiseTexture, 
          noiseUv
        );
        
        float noiseCutout = textureRemap(noise, vec2(0.0, 1.0), vec2(-noiseStrength, noiseStrength)).r;
        float cutoutHeight = time * avatarHeight + bottomPosition;
        return cutoutHeight + noiseCutout;
      }

      `),
        t.fragmentShader = t.fragmentShader.replace("gl_FragColor = vec4( col, diffuseColor.a );", `
      gl_FragColor = vec4(col, diffuseColor.a);
      `),
        t.fragmentShader = t.fragmentShader.replace("gl_FragColor = vec4( col, diffuseColor.a );", `
      //################################################## normal ###############################################################
      if (transitionEffectType < 0.5) { 

      }
      //################################################## switch item ###############################################################
      else if (transitionEffectType < 1.5) { 
        // vec3 pixelColor = getPixelColor(2.0);

        // float timeProgress = switchItemTime / switchItemDuration;
        // float rim = getRim(
        //   vSurfaceNormal, 
        //   mix(0.1, mix(0.1, 5.0, timeProgress), timeProgress), 
        //   mix(50., 10., timeProgress)
        // );
        
        // col = mix(pixelColor * rim, col, timeProgress);
      }
      //################################################## fade out avatar ###############################################################
      else if (transitionEffectType < 2.5) { 
        discard;
      }
      //################################################## loading avatar ###############################################################
      else if (transitionEffectType < 3.5) { 
        discard;
      }
      //################################################## fade in avatar ###############################################################
      else if (transitionEffectType < 4.5) { 
        if (fadeInAvatarTime < 0.5) { // phase 1
          float timer = fadeInAvatarTime * 2.;
          
          float border = 0.02;
          float limit = getDissolveLimit(
            1.2,
            0.1,
            -0.3 - border,
            2.0 + border,
            timer
          );
          
          float upperBound = limit + border;
  
          if (vWorldPosition.y > limit && vWorldPosition.y < upperBound) {

            vec3 pixelColor = getPixelColor(1.5);
        
            float rim = getRim(
              vSurfaceNormal, 
              0.1,
              10.
            );
      
            col = pixelColor * rim;
          }
          else if (vWorldPosition.y >= upperBound) {
            discard;
          }
          else {

            vec3 pixelColor = getPixelColor(1.5);
            
            float rim = getRim(
              vSurfaceNormal, 
              0.1,
              3.0
            );
            col = pixelColor * rim;
          }
        }
        else { // phase 2
          float timer = fadeInAvatarTime * 2. - 1.;
          
          float bottomPosition = -0.3;
          float avatarHeight = 2.0;
          
          float rim = getRim(
            vSurfaceNormal, 
            mix(0.1, 2.0 * timer, timer),
            mix(3.0, 20. * (1. - timer), timer)
          );
          
          float fadeStrength = 10.;
          rim *= pow((vWorldPosition.y - bottomPosition) / (avatarHeight - bottomPosition), timer * fadeStrength);
          
          vec3 pixelColor = getPixelColor(1.5);
          col = mix(pixelColor * rim, col, timer);

        }
      }

      gl_FragColor = vec4( col, diffuseColor.a );
      `),
        t.uniforms.pixelTexture = R3.pixelTexture,
        t.uniforms.noiseTexture = R3.noiseTexture,
        t.uniforms.cameraDir = Qt.cameraDir,
        t.uniforms.eye = Qt.eye,
        t.uniforms.switchItemTime = Qt.switchItemTime,
        t.uniforms.switchItemDuration = Qt.switchItemDuration,
        t.uniforms.transitionEffectType = Qt.transitionEffectType,
        t.uniforms.fadeInAvatarTime = Qt.fadeInAvatarTime)
    }
    playFadeOutEffect() {
        Qt.transitionEffectType.value = Ki.fadeOutAvatar,
        this.particleEffect.emitSpotLight(),
        this.particleEffect.emitPixel(),
        this.particleEffect.emitTeleport(),
        this.transitionTime = this.frameRate * ((T3 - kw) / I3),
        this.initialFadeOutTimer()
    }
    playFadeInEffect() {
        Qt.transitionEffectType.value = Ki.fadeInAvatar,
        this.initialFadeInTimer()
    }
    playSwitchItemEffect() {
        Qt.switchItemTime.value = Zye,
        Qt.transitionEffectType.value = Ki.switchItem,
        this.transitionTime = C3
    }
    setParticle(t, r) {
        this.particleEffect = new nwe(t,r,Qt)
    }
    initialFadeOutTimer() {
        Qt.fadeOutAvatarTime.value = kw
    }
    initialFadeInTimer() {
        Qt.fadeInAvatarTime.value = UT
    }
    update() {
        setInterval( () => {
            this.scene && this.camera && !this.initParticle && (this.setParticle(this.scene, this.camera),
            this.initParticle = !0),
            this.initParticle && this.particleEffect.update(),
            Qt.transitionEffectType.value === Ki.switchItem ? Qt.switchItemTime.value < fx ? Qt.switchItemTime.value += Jye : (Qt.switchItemTime.value = fx,
            Qt.transitionEffectType.value = Ki.normal,
            this.setTransitionEffect("normal"),
            this.dispatchEvent(new Event("fadeintraitend"))) : Qt.transitionEffectType.value === Ki.fadeOutAvatar ? (Qt.fadeOutAvatarTime.value += I3,
            Qt.fadeOutAvatarTime.value > T3 && (Qt.fadeOutAvatarTime.value = kw,
            Qt.transitionEffectType.value = Ki.loadingAvatar)) : Qt.transitionEffectType.value === Ki.loadingAvatar || Qt.transitionEffectType.value === Ki.fadeInAvatar && (Qt.fadeInAvatarTime.value > .1 && Qt.fadeInAvatarTime.value < .5 && (this.particleEffect.emitRing(.5 * (1 - Qt.fadeInAvatarTime.value)),
            this.particleEffect.emitRespawnPixel()),
            Qt.fadeInAvatarTime.value >= .5 && this.particleEffect.removeSpotLight(),
            Qt.fadeInAvatarTime.value += ewe,
            Qt.fadeInAvatarTime.value > qye && (Qt.fadeInAvatarTime.value = UT,
            Qt.transitionEffectType.value = Ki.normal,
            this.setTransitionEffect("normal"),
            this.dispatchEvent(new Event("fadeinavatarend")))),
            this.camera && (this.cameraDir.set(0, 0, -1),
            this.cameraDir.applyQuaternion(this.camera.quaternion),
            this.cameraDir.normalize(),
            Qt.cameraDir.value.copy(this.cameraDir),
            Qt.eye.value.copy(this.camera.position))
        }
        , this.frameRate)
    }
}
const iwe = "_container_1fjfz_1"
  , swe = "_messageWindow_1fjfz_11"
  , owe = "_messageTitle_1fjfz_25"
  , awe = "_buttonContainer_1fjfz_36"
  , Qy = {
    container: iwe,
    messageWindow: swe,
    messageTitle: owe,
    buttonContainer: awe
};
var xV = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(n) {
    (function() {
        var e = {}.hasOwnProperty;
        function t() {
            for (var s = "", o = 0; o < arguments.length; o++) {
                var a = arguments[o];
                a && (s = i(s, r(a)))
            }
            return s
        }
        function r(s) {
            if (typeof s == "string" || typeof s == "number")
                return s;
            if (typeof s != "object")
                return "";
            if (Array.isArray(s))
                return t.apply(null, s);
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
                return s.toString();
            var o = "";
            for (var a in s)
                e.call(s, a) && s[a] && (o = i(o, a));
            return o
        }
        function i(s, o) {
            return o ? s ? s + " " + o : s + o : s
        }
        n.exports ? (t.default = t,
        n.exports = t) : window.classNames = t
    }
    )()
}
)(xV);
var bV = xV.exports;
const ud = oc(bV)
  , lwe = "_iconButtonWrap_1fm7l_1"
  , cwe = "_buttonBackground_1fm7l_8"
  , Awe = "_buttonBackgroundColor_1fm7l_13"
  , uwe = "_innerBackgroundColor_1fm7l_16"
  , fwe = "_dark_1fm7l_20"
  , hwe = "_iconWrap_1fm7l_28"
  , dwe = "_icon_1fm7l_1"
  , pwe = "_active_1fm7l_83"
  , mwe = "_buttonWrap_1fm7l_95"
  , gwe = "_buttonIconWrap_1fm7l_108"
  , vwe = "_innerWrap_1fm7l_127"
  , Zn = {
    iconButtonWrap: lwe,
    buttonBackground: cwe,
    buttonBackgroundColor: Awe,
    innerBackgroundColor: uwe,
    dark: fwe,
    iconWrap: hwe,
    icon: dwe,
    active: pwe,
    buttonWrap: mwe,
    buttonIconWrap: gwe,
    innerWrap: vwe
}
  , ywe = [{
    name: "backpack",
    file: "./public/assets/icons/backpack.svg"
}, {
    name: "microphone",
    file: "./public/assets/icons/microphone.svg"
}, {
    name: "speechToText",
    file: "./public/assets/icons/speechToText.svg"
}, {
    name: "arrowRight",
    file: "./public/assets/icons/arrowRight.svg"
}, {
    name: "arrowLeft",
    file: "./public/assets/icons/arrowLeft.svg"
}, {
    name: "rooms",
    file: "./public/assets/icons/rooms.svg"
}, {
    name: "scenes",
    file: "./public/assets/icons/scenes.svg"
}, {
    name: "settings",
    file: "./public/assets/icons/settings.svg"
}, {
    name: "tokens",
    file: "./public/assets/icons/tokens.svg"
}, {
    name: "voice",
    file: "./public/assets/icons/voice.svg"
}, {
    name: "vr",
    file: "./public/assets/icons/vr.svg"
}, {
    name: "discord",
    file: "./public/assets/icons/discord.svg"
}, {
    name: "metamask",
    file: "./public/assets/icons/metamask.svg"
}, {
    name: "close",
    file: "./public/assets/icons/close.svg"
}, {
    name: "hide",
    file: "./public/assets/icons/hide.svg"
}, {
    name: "map",
    file: "./public/assets/icons/map.svg"
}, {
    name: "login",
    file: "./public/assets/icons/login.svg"
}, {
    name: "logout",
    file: "./public/assets/icons/logout.svg"
}, {
    name: "plus",
    file: "./public/assets/icons/plus.svg"
}, {
    name: "minus",
    file: "./public/assets/icons/minus.svg"
}, {
    name: "mint",
    file: "./public/assets/icons/mint.svg"
}, {
    name: "download",
    file: "./public/assets/icons/download.svg"
}, {
    name: "classDropHunter",
    file: "./public/assets/icons/class-drop-hunter.svg"
}, {
    name: "classEndineer",
    file: "./public/assets/icons/class-engineer.svg"
}, {
    name: "classCustom",
    file: "./public/assets/icons/class-custom.svg"
}, {
    name: "classNeuralHacker",
    file: "./public/assets/icons/class-neural-hacker.svg"
}, {
    name: "classLiskWitch",
    file: "./public/assets/icons/class-lisk-witch.svg"
}, {
    name: "classBruiser",
    file: "./public/assets/icons/class-bruiser.svg"
}, {
    name: "classBeastPainter",
    file: "./public/assets/icons/class-beast-painter.svg"
}, {
    name: "soundon",
    file: "./public/assets/icons/soundon.svg"
}, {
    name: "soundoff",
    file: "./public/assets/icons/soundoff.svg"
}, {
    name: "soundoff",
    file: "./public/assets/icons/soundoff.svg"
}, {
    name: "polygon",
    file: "./public/assets/icons/polygon.svg"
}];
async function wwe(n) {
    const e = ywe.find(t => t.name === n);
    return await fetch(e.file).then(t => t.text()).then(t => new DOMParser().parseFromString(t, "image/svg+xml").firstElementChild)
}
function Bn(n) {
    const {size: e, icon: t, className: r, onClick: i, theme: s, type: o, text: a, onMouseEnter: l, active: c, onSubmit: A, minWidth: u, disabled: f} = n
      , h = be.useRef(null);
    return be.useEffect( () => {
        t && wwe(t).then(d => {
            h.current && (h.current.innerHTML = "",
            d && (d.classList.add(Zn.icon),
            h.current.append(d)))
        }
        )
    }
    , [t]),
    o && o === "login" ? k.jsxs("div", {
        className: ud(r, Zn.iconButtonWrap, s && s === "dark" ? Zn.dark : Zn.light, c && Zn.active),
        style: {
            height: e
        },
        onClick: i,
        onMouseEnter: l,
        children: [k.jsxs("svg", {
            width: "71",
            height: "67",
            viewBox: "0 0 71 67",
            className: Zn.buttonBackground,
            xmlns: "http://www.w3.org/2000/svg",
            children: [k.jsx("path", {
                d: "M2 2H68.8452L64.1437 65H2V2Z",
                className: Zn.buttonBackgroundColor,
                fill: "#D9D9D9",
                stroke: "#050B0E",
                strokeWidth: "4"
            }), k.jsx("path", {
                d: "M9 9H62L58.2676 58H9V9Z",
                fill: "#050B0E",
                className: Zn.innerBackgroundColor
            })]
        }), k.jsx("span", {
            ref: h,
            className: Zn.iconWrap
        })]
    }) : o && o === "icon" ? k.jsxs("div", {
        className: ud(r, Zn.iconButtonWrap, s && s === "dark" ? Zn.dark : Zn.light, c && Zn.active),
        style: {
            height: e
        },
        onClick: i,
        onMouseEnter: l,
        children: [k.jsxs("svg", {
            className: Zn.buttonBackground,
            width: "69",
            height: "63",
            viewBox: "0 0 69 63",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [k.jsx("path", {
                d: "M5 2H2.85562L3.00485 4.13918L6.7903 58.4048L6.9201 60.2656H8.78545H62.6772H64.6178L64.6763 58.3259L66.3135 4.06031L66.3756 2H64.3144H5Z",
                fill: "#efefef",
                className: Zn.buttonBackgroundColor,
                stroke: "black",
                strokeWidth: "4"
            }), k.jsx("path", {
                d: "M8.77795 7.28503H61.7957L59.8437 54.7911H11.367L8.77795 7.28503Z",
                fill: "black",
                className: Zn.innerBackgroundColor
            })]
        }), k.jsx("span", {
            ref: h,
            className: Zn.iconWrap
        })]
    }) : k.jsx("button", {
        className: ud(r, Zn.buttonWrap, s && s === "dark" ? Zn.dark : Zn.light),
        onClick: i,
        onMouseEnter: l,
        onSubmit: A,
        type: o,
        disabled: f,
        style: {
            minWidth: u ? u + "px" : ""
        },
        children: k.jsxs("div", {
            className: Zn.innerWrap,
            style: {
                fontSize: e
            },
            children: [t && k.jsx("span", {
                ref: h,
                className: Zn.buttonIconWrap,
                style: {
                    height: e,
                    width: e,
                    opacity: f ? "0.4" : "1"
                }
            }), a && a]
        })
    })
}
function _we(n) {
    const {cancelOption: e=!0, confirmDialogText: t, confirmDialogWindow: r, setConfirmDialogWindow: i, confirmDialogCallback: s} = n;
    return r ? k.jsx("div", {
        className: Qy.container,
        children: k.jsxs("div", {
            className: Qy.messageWindow,
            children: [k.jsx("div", {
                className: Qy.messageTitle,
                children: t
            }), k.jsxs("div", {
                className: Qy.buttonContainer,
                children: [e && k.jsx(Bn, {
                    size: 16,
                    theme: "light",
                    text: "Cancel",
                    onClick: () => {
                        s[0](!1),
                        i(!1)
                    }
                }), k.jsx(Bn, {
                    size: 16,
                    theme: "light",
                    text: "Continue",
                    onClick: () => {
                        s[0](!0),
                        i(!1)
                    }
                })]
            })]
        })
    }) : k.jsx("div", {})
}
const xwe = "_backgroundImg_1yy0g_1"
  , bwe = "_darkBackground_1yy0g_16"
  , Ewe = "_logo_1yy0g_29"
  , Hy = {
    backgroundImg: xwe,
    darkBackground: bwe,
    logo: Ewe
};
function Bwe() {
    const {debugMode: n} = Z.useContext($n);
    return k.jsxs("div", {
        className: n ? Hy.darkBackground : Hy.backgroundImg,
        children: [k.jsx("div", {
            className: Hy.backgroundBlur
        }), k.jsx("div", {
            className: Hy.Background
        })]
    })
}
const Mwe = "_buttonContainer_1x1gj_1"
  , Swe = "_buttonLeft_1x1gj_10"
  , Cwe = "_buttonRight_1x1gj_14"
  , Twe = "_buttonCenter_1x1gj_18"
  , Iwe = "_sideMenu_1x1gj_33"
  , Rwe = "_scrollContainer_1x1gj_44"
  , Uwe = "_scrollContainerOptions_1x1gj_52"
  , Fwe = "_bottomLine_1x1gj_60"
  , Pwe = "_editorButton_1x1gj_94"
  , Lwe = "_editorText_1x1gj_102"
  , Dwe = "_selectorContainerPos_1x1gj_112"
  , Nwe = "_selectorButton_1x1gj_137"
  , Owe = "_selectorColorPickerUI_1x1gj_146"
  , kwe = "_selectorColorPickerButton_1x1gj_152"
  , Qwe = "_selectorPickerTabs_1x1gj_162"
  , Hwe = "_selectorColorPickerImg_1x1gj_170"
  , zwe = "_uploadContainer_1x1gj_176"
  , Gwe = "_uploadButton_1x1gj_189"
  , Vwe = "_relativeBox_1x1gj_209"
  , jwe = "_blendshapeGroup_1x1gj_213"
  , jt = {
    buttonContainer: Mwe,
    buttonLeft: Swe,
    buttonRight: Cwe,
    buttonCenter: Twe,
    sideMenu: Iwe,
    scrollContainer: Rwe,
    scrollContainerOptions: Uwe,
    bottomLine: Fwe,
    "editor-container": "_editor-container_1x1gj_87",
    editorButton: Pwe,
    editorText: Lwe,
    selectorContainerPos: Dwe,
    "selector-container": "_selector-container_1x1gj_123",
    "selector-container-column": "_selector-container-column_1x1gj_129",
    selectorButton: Nwe,
    selectorColorPickerUI: Owe,
    selectorColorPickerButton: kwe,
    selectorPickerTabs: Qwe,
    selectorColorPickerImg: Hwe,
    uploadContainer: zwe,
    uploadButton: Gwe,
    relativeBox: Vwe,
    blendshapeGroup: jwe
}
  , Wwe = "_dropArea_1a0z4_1"
  , Kwe = {
    dropArea: Wwe
};
function S0({onFilesDrop: n}) {
    const [e,t] = be.useState(!1)
      , [r,i] = Z.useState(null);
    be.useEffect( () => {
        const o = l => {
            l.preventDefault(),
            t(!1);
            const c = l.dataTransfer.files;
            n && i(c)
        }
          , a = l => {
            l.preventDefault(),
            t(!0)
        }
        ;
        return window.addEventListener("drop", o),
        window.addEventListener("dragover", a),
        () => {
            window.removeEventListener("drop", o),
            window.removeEventListener("dragover", a)
        }
    }
    , []),
    be.useEffect( () => {
        r && n(r)
    }
    , [r]);
    const s = () => {
        t(!1)
    }
    ;
    return k.jsx("div", {
        onDragLeave: s,
        className: Kwe.dropArea,
        style: {
            display: e ? "flex" : "none"
        }
    })
}
const Xwe = "_mainTitleWrap_4fb0s_1"
  , Ywe = "_mainTitle_4fb0s_1"
  , $we = "_topLine_4fb0s_18"
  , AM = {
    mainTitleWrap: Xwe,
    mainTitle: Ywe,
    topLine: $we
};
function Aa({title: n, width: e, left: t, right: r}) {
    const i = {
        width: e ? `${e}px` : null,
        left: t ? `${t}px` : null,
        right: r ? `${r}px` : null
    };
    return n && k.jsxs("div", {
        className: AM.mainTitleWrap,
        style: i,
        children: [k.jsx("div", {
            className: AM.topLine
        }), k.jsx("div", {
            className: AM.mainTitle,
            children: n
        })]
    })
}
const Zwe = "_ContainerPositionTop_v15ql_2"
  , Jwe = "_ContainerPosition_v15ql_2"
  , qwe = "_Container_v15ql_2"
  , e_e = "_topLine_v15ql_68"
  , t_e = "_traitInfoTitle_v15ql_96"
  , n_e = "_flexSelect_v15ql_105"
  , r_e = "_flexButtons_v15ql_114"
  , i_e = "_flexButtonsTop_v15ql_122"
  , s_e = "_optionButtons_v15ql_131"
  , o_e = "_optionButtonsSmall_v15ql_143"
  , vr = {
    ContainerPositionTop: Zwe,
    ContainerPosition: Jwe,
    Container: qwe,
    "arrow-button": "_arrow-button_v15ql_39",
    "left-button": "_left-button_v15ql_55",
    "right-button": "_right-button_v15ql_62",
    topLine: e_e,
    traitInfoTitle: t_e,
    flexSelect: n_e,
    flexButtons: r_e,
    flexButtonsTop: i_e,
    optionButtons: s_e,
    optionButtonsSmall: o_e
}
  , a_e = "/public/assets/randomize-green.png"
  , l_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFu2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wMS0xN1QwMDoyNDo0My0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MjAtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MjAtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNiOTBlZjU3LTIwOWItYzQ0Zi05OWNjLTkwYjYxM2Q0MWJiOCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NWQ3ZjJiYi1jMWI3LWI3NDMtYWJiMy0xZjNlYzYzMWIxNDQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2NWQ3ZjJiYi1jMWI3LWI3NDMtYWJiMy0xZjNlYzYzMWIxNDQiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjY1ZDdmMmJiLWMxYjctYjc0My1hYmIzLTFmM2VjNjMxYjE0NCIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xN1QwMDoyNDo0My0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDozYjkwZWY1Ny0yMDliLWM0NGYtOTljYy05MGI2MTNkNDFiYjgiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTdUMDA6Mjk6MjAtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6bbHqfAAAFoklEQVR42u2duWtWQRTFo5hGRNAETKFiIQqCSxGto4iCqSLon6BoQJJCEcEFLASbD7QRRcTKNbihoLgUWhj/AItUCi7gVmjikubzPphAiOYts9659xQHAnl5M2/u73vnzHwvbzra7XaHNg1cPrKadJs0bnSHtEbjWGgr/HxSi9SeRWeLYwCAzOIPmk97u0ITpAMAQE7h+0ivaxR+psZIWwBAvoVfSXpsUfiZelZkBgAgx+dtJTIfaPV5W4nLB9p93lZi8oEEn39iWcRPpK2kzaSPlud4mns+0Ojzk6QTpM5p5+skHSP90ZYPtPn8DVJ3ybkXk65oygdafH6UtKlBW72klxrygfT5/BfSLoe2B0xWELt+oMbnHfoxj3RUaj6Q6vNdAfq0SGI+UOvzDn0UlQ/U+7z2fACfV54P4PPK8wF8Xnk+gM8rzwfweeX5AD6vPB/A55XnA/i88nwAn1eeD+DzyvMBfF55PoDPK88H8Hnl+aBup/aQflp26HrZc3hQaT64Zjnmv0h7nQEwT8u24PNJQdjokA9aVXfdqsaH4fNsQNhJ+mxRj2EXAO41bGw/ihUchH0Na3LXBYC7DRs7T1qOQgUr/lLSuZgA3LL0nkukhSiat8IvIF2wrMWtFABMJdHDpLkoolPxD5mxbOcGwJTekfpRzMaF305662H8kwMwpRekDShuZeHXkp57HHc2ACAfhPP5JAB8MB3+jXyQzOeLJfaLpPcpAPhmjlnmcMtSnQ8cfb6w1BXmPF9TAFB8N9Az7dhtpDfIB8F9vvjQ7Jh2rp6K72mCArDkP39z0GHaIjofOPr8lG3OmXHOJawAmHah57F+4G0+P+sHgyUAHm91/fD5cmtkDYDmfODT57MHQFM+COHzYgCQng9C+bwoACTmg9A+LxIACfkgls+LBiDHfBDb51UAkEs+SOHzagDgnA9S+rw6ADjlAw4+rxaAlPmAk8+rByB2PuDm8wAgUj7g6vMAIHA+4O7zACDc7fqk+a/lbJel1QPgIR9k/cUUAAj7SDX7r6YBgP98wM7nAUCa9YOo83kAwC8f5PIACgDwnA+yegQNADQfsGdlb9rK8HoAQMMBK3vryT0AIB+ARyXX9AgAyAfgYck1PQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlALQAwCSX0+y18V/L/a3BQDJr2cx6UcKAMZz3BRaIADdphZJNo16ldsG0ZIAoP721thY2gmAulvH3iB1AYCot/0rMbaObbJ59KR53UonAAjW907ScTPWUfYOHpK2fXyuADhsHz/kAkBBXMvy5QqjHPNBbgBQnzbW8PnZ1Kq6I9ftxJ6KuWaZrnOaLeQCQDHFJl1zeLPJ3jrtNOnQfIe7AZt8wB0A6sM80lHSH8uxPlPUqm57Nh1cSXps2bnk+YAzANT+AOmT5dg+Ja1q2qZLZ/tIry07m2z9gCMAjj4/Rtpi27aPzg9WrERVrR90awXAzOevWo7dBOmAax98XUg2+YADAGZ2dSyWzwcHIKd8kBoAM5+P6vPRAMghH6QCIKXPRweAcz6IDQAHn08GAMd8EAsATj6fFABu+SAGANx8ngUAXPJBSAC4+jwrADzlg5u2+SAEANx9niUAqfKBTwBy8Xm2AHjKB19Ju2MDkJPPswcgZj5wBSBHn88GgBj5wBaAnH0+OwBC5oOmAEjw+SwBCJUPmrwuXorPZw2Ax3yw3pxnpOS4EXPMOkk+LwKAGflgwrI4p0kPSn5/n3RKms+LAsBDPggh1j4vDgBP+cCHsvB5sQB4ygfifV48AJ7WD8T6vBoAAueDbH1eFQAB8kH2Pq8SAA/5QIzPqwbAIh+I83kAUD8fiPR5APAvCKtJt80dYdz8vEbjWPwFnWtJD/nY2zYAAAAASUVORK5CYII="
  , c_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFu2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wMS0xN1QwMDoyNDo1MS0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MjYtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MjYtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmM2NDY5Y2JiLWFkMzUtYmQ0Ny04M2Q1LWU0NGQ0MTI2YmYwNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMjUyMzZlNS1mYTFiLWUzNDUtOGQzNi0xOWJkMmE0YmYzNTEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyMjUyMzZlNS1mYTFiLWUzNDUtOGQzNi0xOWJkMmE0YmYzNTEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjIyNTIzNmU1LWZhMWItZTM0NS04ZDM2LTE5YmQyYTRiZjM1MSIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xN1QwMDoyNDo1MS0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpjNjQ2OWNiYi1hZDM1LWJkNDctODNkNS1lNDRkNDEyNmJmMDYiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTdUMDA6Mjk6MjYtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6qPgTwAAAEeUlEQVR42u2dX4tNURiH58KfwR1K0USSj6BoIpdydcY0TUMmIy58BPdK/uTCLReaG7kwooQoH4FQyneQMNw53t2cqdOJPfusvfZa77ve5+JX1DlnOns9PM+cqT0T/X5/wtt6D64ekj2W/ZKtDv582OO18Hbwk7I7sv5/dle2DQDKPPzLsp81h7++6n+EKwBQzsGfkH1ucPCj+yI7CQB2D/6A7GXAwY/utewgAJTj+dAV2QdePR+64vrAu+dDV0wf4HnnfYDnnfcBnnfeB3jeeR/geed9gOed9wGed94HeN55H+B5532A5533AZ533gd43nkf4HnnfYDnnfcBnnfeB3jeeR/geed9gOed9wGed94HeN55H+B5530wzsHvkr3hQqvfW9nuLgDYKXvGBVa/F50AMATCHtkKF1rdqn+ce1NG4BHZOy589n2QHc35beBZ2VcOIvm+yRa1fBC0SXZN9oeDSbLrss0aPwqmDxR6PggA+ULnZRfpA9uel+ddkJ0LAWB56AOG/fSBLc/L86ZkrwavsxwCwOgPd6q/T9IHuj0vz9kquzl6djEAqPZDdok+0Ol5ed6S7Ps/XjMaAOurfgh0nD5Q4/lp2aea144OwPDHjvRBXs8/b/A1OgOAPtDj+awA0Af5PZ8dAPogr+fVAEAf5PG8OgDog7SeVwuA1z5I7XnVAHjqg1yeNwFAyX2Q2/OmACitDzR43iQA1vtAk+fNAmCxDzR63jwAFvpAs+eLAUBrH2j3fHEAaOkDK54vEoCcfWDN80UDkLIPrHreBQBd94Flz7sCIEYfPCnM8+4AiNEHZ2RzhXjeLQCt+6AQz7sHoFUfFOB5AIjRB4Y9DwAx+8Cg5wEgVh8Y9TwANNjt6rOADT4nuFHg+waAoc3WvOfZQt8zAAxtruY9zwFA+QDM1LznGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANsA3AeAYnYvBIBTsvcAYH4fZaeDf328PHmxt3bzRACwteqWNkvBvz5+5MJs6a3dRBEAbOxWdVOrJmc77j1z9smeAoDaVbe1mRrnTENvnnSst3YzZQDQsepGVtMhZ9n29mkW+6AkABp5vjMAjPZBKQA09nynABjsA+sAjO35JAAY6gOrAAR7PikABvrAGgCtPZ8FAMV9YAmAKJ7PBoDSPrAAQFTPZwdAWR9oBqATz6sBQEkfaASgU8+rAyBzH2gDoHPPqwQgYx9oASCZ51UDkKEPcgOQ3PMmAEjYB7kAyOZ5UwAk6IMcAGT1vDkAOu6DlACo8LxZADrqgxQAqPK8eQAi90GXAKj0fDEAROqDrgBQ6/miAIjQB7EBUO/5IgFo0QexADDj+aIBCOiDtgCY87wLAMbogzYAmPS8GwAa9kEIAKY97w6ADfpgHACK8LxbAEb6YHVwqPM1j5sfPOZ3SZ53D8DgcLfLHsoWah6zIHsk2+HluvwF92zupxEV3NQAAAAASUVORK5CYII="
  , A_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFu2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wMS0xN1QwMDoyMjo0Mi0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDEtMTdUMDA6Mjg6NTEtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDEtMTdUMDA6Mjg6NTEtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmY3YWFkYzZiLWM2ZmEtNjE0OC05YWZkLTgxN2Q1OWRkZTI0MiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3NjUxYWZkMi1lOWE3LTk3NGYtYWVhZC03YjFjMjg0NmFhM2YiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NjUxYWZkMi1lOWE3LTk3NGYtYWVhZC03YjFjMjg0NmFhM2YiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc2NTFhZmQyLWU5YTctOTc0Zi1hZWFkLTdiMWMyODQ2YWEzZiIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xN1QwMDoyMjo0Mi0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmN2FhZGM2Yi1jNmZhLTYxNDgtOWFmZC04MTdkNTlkZGUyNDIiIHN0RXZ0OndoZW49IjIwMjQtMDEtMTdUMDA6Mjg6NTEtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6TWt7cAAAFm0lEQVR42u2dT2xURQCHSTXpQTH0oIJpgfZKi1ETiSK1MV7FbORQNcG0Hmg3oQVjjKARrhDBBDEYMSEYS6kWkxoVAheDiBc9kHBBuaGgMSo1KgTF+pt0JLq6dOe93X3z5zt8SbPdvtmZ37fvvc7Mm5k3MzMzD9KFRkAAGgEBAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABPKO0f3OrWCxWiTViROwQ+8QBcchywL62w77HvLdPdJpjIEAYYd8sHhDPiD3iuLggfhczGblqj/GJ2Cs2il5xCwL4EfoK8bw4LH7MEbQrF8UR8aK4T7QgQPNC77On6jNNDHwuzopXzGdDgMaEvlRsEqc8Cr0ap+2ZoRMB8gdvrulviT8CCP7/7h/GxIMI4B78Q+KjAEOvhrlHeRgB5g7e3FB9GFHwlZi6rUSA/wZ/m3g94uAreVMsRIDZ8J8S3yUU/t98L55OVgDby3Y4weArMf0JXUkJoAo/Ln4i/GtMiyeTEEAV3U3gVXktWgFUuXbxKSHPyWeiIyoBVKG7xXnCrRnTVvdEIYAqsjrniFwjGteciabEuGXKvnbes57ER4MWQBVY60FD/ioOiiHRfb3xfTt/oNu+1/zNLx58/rVBCqAPPlxww52x4/e356jDrfYYXxZcl+GgBCg4/Gk7KaSljvVpsSJcLLBe5SAEMB+04L72JQ08qy0ueKyi7LUABYe/pYn/0r4UiwSxhD9UQIfWuhgkiOGav67A8YzgJeC0n7/+W0KWIOTwj3o0keVoqBKEGv5vYoFHAiwQl0KUIMTwDSM5wuoQg3Ya90HLTvtaR47jjhbcJuWmCOBB+OcyBrTcPgJ25TrHvmKFuDNjGedCkyC08DN9+20vnms5GwM8CzhLEFr45jo73zGUbTnK2+5Y1nxxOSQJQgrf8G4B38gRxzInPWmrcl0E8Ch8w4BDEF11LLfLodwBj9qrnEsAz8I3LHMI4r06ljvpUO4yz9qsnEkA/WG/ZxX5VtxQYwh3NKD8RTWWfaOHzzn0OwmgP2izU5J8qsQJh2/hYMGXnxMePqja5iLAdg8nSk45BPBqA8rf5VD+lIftt81FgC88rMC4QwDvNKD8CYfyxz1sv88RAAG4BHAJSOMmcICbwBw3gRH8G7ioAeUvTObfwEg6giYL6gjqjqIjiK7gzF3Bg6VYuoIjGAwaYTAoruHgywwHFzAc7JkEoxkmamwQfzIhJI4pYd9knK7VU+OUMNOJszxjGV9HPSXMIwlGc0zebLf9BDsrJoWa19pzHHdDEpNCPZHgUrWOjYKmhbclNS3cEwmOeSTAseQeDPFEgq08GsbDoUMFhj+U/MOhnpwJhgmfBSK2ctpniRizx8DSBga/hCVi/JfgZ/FsrUPHjotETbNIVDjLxH1lVwtjmTgWitw8YYXsqWGhyB773gkWiqyPBI/M0f/ebC7YZWHf/0dXsPn5pP2dL5/TLK+7OpbFou8ygzgsAl37gJdpM5aLT5OTeQalQtgwYhchV2V3KlvG9LNlzL8waxA/kdqmUWY7WDaNmm2DtDaNYtu4a9vGDbJxZJobR75RYuPIqlvHfhBx8GYc4X62jk1v82hTFzaPzrh9/H7PNp2qFbPl/duil+3j6zMMu0mcCiD40+IF0RlC2wYhQIUMveJluymUL6GftWsP94XWnsEJUCHDveI5e439oYmBm06sI/abvqKeG1QhQHYZbhIr7fj9HvFxaXYjyDz3D1ftMY6LvfbYq1yfT0SA4qRotcvDm5vJNfZpYXP52CfGxCHLmH3N/G69eMyczkuzW9y3xtxGUQsACAAIAAgACAAIAAgACAAIAAgACAAIAAiAADQCAgACAAIAAgACAAIAAgACAAIAAgACAAIAAkCc/AWkhfX2hx9ZaQAAAABJRU5ErkJggg=="
  , u_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAATr2AAE69gE6sVc6AAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wMS0xN1QwMDoyMjo0OS0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MTQtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDEtMTdUMDA6Mjk6MTQtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjhhZWE1MDNlLTM3NGItYmM0NC1iOGNjLTU0OWU2MDUyYzYxMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4YWVhNTAzZS0zNzRiLWJjNDQtYjhjYy01NDllNjA1MmM2MTMiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4YWVhNTAzZS0zNzRiLWJjNDQtYjhjYy01NDllNjA1MmM2MTMiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjhhZWE1MDNlLTM3NGItYmM0NC1iOGNjLTU0OWU2MDUyYzYxMyIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0xN1QwMDoyMjo0OS0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PslPja4AAAbiSURBVHja7Z17iFVFHMc1K80ybc3SP9K21YrubtLDiIJqK5WMpbYt1MpSKiKkba0gtU0rCCpoyxRXSKrNiJIwCmtD0u2JEWFuSC/t2sueghDU2svbd2D+uFzce89rzvxm5vvHB2TX5Zw758PMufN7zJBSqTSEhAsHgQJwECgAoQCEAhAKQCgAoQCEAhAKQCgAoQCEAhAKQCgAoQDVaO1ZOgWsB7+CAbALLAPDOdCeC4CH3AJKg/AlGM/B9lQAPNxG8HcVARS7wQQOuJ8CPFvj4VMCXwXAAx0BfowoACXwUIA68EcMASiBh0vApzEFoASeCdCZQABK4JEAw0A/JQh7H2A8KFKCsHcCxUugX1qnghlgLrgBzNP/bgXTwTRwAjiEAsQf4AkpJChmJYF+0M1gIegGm8Dn4M+I9/If+B68B3rAneBiMIoCCJwJ8DejwZVgBfgQ7E94/Vqor7ybwVJwOgWwKAH+z3HgJrDR4AOvxU7wIDiFAuQoAX7XZumBV0MtF20UID8JnhMoQUlvjXeAw5kQYl6CVUIlUOwD7WBo8BlBhiVYK1gCxU/giuBTwgxL8IJwCRTvg/qgcwINS/CKAxIolgSdFGpYgjcdkeATMDHYrGDDErzriASK+cGmhZuSAD8/DHzskARrg60LMCjBkQkTVWwuCccGWRhiUIIx4DOHJNgLCkFWBhmUYJzer3dFAhWFnOXjRtAosA6cb0ECFaL+xiEJFAt8E6BXf7Cfq22GGJRgIvjBMQlu9yUWsOUgW6M2JGgAvzgmQYfr0cA3quyPm5KgWEWCaXpLVhWtXqVp11k/6uffCpRgoav5AC9GCJvWS0svw99NVhs0OtHkgBAJ5rmWEbQiRqSs3saOYcTPcTzoAv8KkGCGKzmBnQnCpbkvBwlE2GRZAJXQ2ig9K3hOipi52Jmg7D7aLUvwXdbp81k+/DPAPykTJ1yQYKbld4MPJFYGHZPi4bgowaWWZ4I10gTYmHEKlQsS3GxZgtukFIfeayiPzgUJnrYswVm2G0Q0G06mFC2BCuHq7W1bAmxPW8OYNsBjOtJmUoKvwaQMJOiwPAussiVAXoUZJiVQJWW/gR3gSdXrMME4jIzZJ8kEl+UqgC7EzDu33pQElSxPMB6PWRZANeU8KhcBdJKFDeNNxg4q6Yk5JhcJ2CpemZcA6yxX2YibCVQdoIBlQHGhUQHUWiOk+PLEnCRoTJD0YpM+0wJIybS9xmCnknK6YozNGiFjM8eIAAJ2vsqjYlEaSGQxE2yLMT4PCBmfreBkEwK8JuQDfhTjnpsySNUeGfFaiwVlEd1hQoBXhXy4vpjf0femvF6TYzOAMQGkLAHbY763bEt5vWLEJadb0BIwxeeXQJXZOyLGPT+ewTVrSqDi9EIEmO3718DI07K+50JG16xVlfywgHHpzWMj6CkBH/SWmPe8PCcJHrU4JurUltPyEODoDDdakvJ8gvvuyejaRaES3JVnMMj2UvA7GJvgvu/zdCbYYiMc/IRlCRYlvO8GHfrdoY+42+/4TPBXkqk/q4wgm504dsf5NlDlM0zS4VQTM8Ej0nMD0w5ewWKf3kSxews9i0xK8LKEpND5lpeCMx2QwMRyoFLaxkhJC++yKIBay48IcCY4T1pl0GaLErzuSAu7rGaCzJpHZCnAOD0AtiTYEIgEqyUXhxYSHCSZaahYlal5LME7LpSHTxewSdTioQS7TPQSNNUgYoGAeMFbWdTTm+xPEEMCVbvQ4FqLmEVCIodv62PhRjs6E6iS+7NdbRJ1j6AsmQEtw0r1Fg2uBVdrHtJNoqYKlKDZ9TZxSxxqy2atIHWQfYLLfWkUeTcliC3BTN+OjLmVEkSSQEUqr/f1yJgWQb33vGhS4eKRMY36aw0lECCBrfbwdQ6d6uG1BLbPCeimBHYlkHBYxNyU/QUpgScnhmylBPlLIOoUS71Dd4ASBCpAWW1/LyUIVICyQbxE+IFPXkgg/nx7DMSNQvrveCmBeAEqRJA4I+wD57oqgTMCVHTqlvaO0GcrnyA4ASpeFhdn0AAiKTt1HF8dRHWozaSSIAWoGNyTdM/eDQbjDOq0jvX61JCmFPsdoiTwQoCDNG08R7e0Wa1zA7/SGUFRBnqP3pRSp57dD9rAqWBohjOX1TOQvBagysCP1V3DLgCz9IOdDa4DrarSRjWgBMNcPSuZArglpAgJ+DDclaA/i9mKD8JtCTopQNgS9FOAsCVQdZh1FCBcCfakbZPDgXdbgme4BIQrgWoMWaAA/kqgTiz/oooALdwH8F+C4WCZDjwN6L6GL4HJ3AkkFIBQAEIBCAUgFIBQAEIBCAUgFIBQAEIBCAUgFIBQAEIByGD8DzQJyO8fOgE8AAAAAElFTkSuQmCC"
  , f_e = "/public/assets/play.png"
  , h_e = "/public/assets/reverse.png"
  , d_e = "/public/assets/pausepng"
  , p_e = "/public/assets/fast-forward.png"
  , m_e = "/public/assets/fast-backward.png";
function k1({loadedAnimationName: n, randomize: e}) {
    const {characterManager: t, toggleDebugMode: r, debugMode: i, lookAtManager: s, animationManager: o} = be.useContext($n)
      , [a,l] = be.useState(s.userActivated)
      , [c,A] = Z.useState((o == null ? void 0 : o.getCurrentAnimationName()) || "");
    be.useEffect( () => {
        n == null && (n = "T-Pose"),
        n != "" && A(n)
    }
    , [n]);
    const u = () => {
        r()
    }
      , f = p => {
        p ? o.play() : o.pause(),
        o.setSpeed(1)
    }
      , h = p => {
        o.play(),
        o.setSpeed(p)
    }
      , d = () => {
        s.setActive(!a),
        o.enableMouseLook(!a),
        l(!a)
    }
      , m = async () => {
        console.log("play next"),
        await o.loadNextAnimation(),
        A(o.getCurrentAnimationName())
    }
      , g = async () => {
        console.log("play prev"),
        await o.loadPreviousAnimation(),
        A(o.getCurrentAnimationName())
    }
    ;
    return k.jsxs("div", {
        className: vr.Container,
        children: [k.jsx("div", {
            className: vr.ContainerPositionTop,
            children: k.jsxs("div", {
                className: vr.flexButtonsTop,
                children: [k.jsx("div", {
                    className: `${vr.optionButtonsSmall}`,
                    onClick: () => {
                        h(-2)
                    }
                    ,
                    children: k.jsx("img", {
                        src: m_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtonsSmall}`,
                    onClick: () => {
                        h(-1)
                    }
                    ,
                    children: k.jsx("img", {
                        src: h_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtonsSmall}`,
                    onClick: () => {
                        f(!1)
                    }
                    ,
                    children: k.jsx("img", {
                        src: d_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtonsSmall}`,
                    onClick: () => {
                        f(!0)
                    }
                    ,
                    children: k.jsx("img", {
                        src: f_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtonsSmall}`,
                    onClick: () => {
                        h(2)
                    }
                    ,
                    children: k.jsx("img", {
                        src: p_e
                    })
                })]
            })
        }), k.jsxs("div", {
            className: vr.ContainerPosition,
            children: [k.jsx("div", {
                className: vr.topLine
            }), k.jsxs("div", {
                className: vr.flexSelect,
                children: [k.jsx("div", {
                    className: `${vr["arrow-button"]} ${vr["left-button"]}`,
                    onClick: g
                }), k.jsx("div", {
                    className: vr.traitInfoTitle,
                    style: {
                        marginBottom: "10px"
                    },
                    children: c
                }), k.jsx("div", {
                    className: `${vr["arrow-button"]} ${vr["right-button"]}`,
                    onClick: m
                })]
            }), k.jsxs("div", {
                className: vr.flexButtons,
                children: [e && k.jsx("div", {
                    className: `${vr.optionButtons}`,
                    onClick: e,
                    children: k.jsx("img", {
                        src: a_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtons}`,
                    onClick: d,
                    children: k.jsx("img", {
                        src: a ? u_e : A_e
                    })
                }), k.jsx("div", {
                    className: `${vr.optionButtons}`,
                    onClick: u,
                    children: k.jsx("img", {
                        src: i ? c_e : l_e
                    })
                })]
            })]
        })]
    })
}
const g_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABAAQMAAACQp+OdAAAAAXNSR0IB2cksfwAAAAlwSFlzAAACxQAAAsUBidZ/7wAAAAZQTFRFAAAAr8rpn4DGigAAAAJ0Uk5TAP9bkSK1AAABRUlEQVR4nEWSMU6GQBSE5wEJGAvotIPOY/AbC8/hLfwr2Nh4HU+gHOEv7aSTTgrjkgDrvLeaP0DyhX07zM4gALpeAN65x1wp1B/YMoWu1wVeO8eGg+gIOCQov9D3SyGcHW73LRO0r4k+gu5YcFkEYWyQrk5kd9QJg6Sr6OceJP9JCO2L5N8ZoT5JORWEcpJyrAj5LPXQENLlDK07EGQ7Qye92Y7QvhEczK2BupXAb9It3yY2EoEnCwYB2BTSFVgUdNP8D6Osme0e9A1zgVMwmT8IiQL1GAKBeowlAoMKom7Ghn4UmGEE19Pz02rxGoQEPNfdasm37t5TBjz7TSzFgHkynytPGcJUesqAGV56LYupXnjKgDkXnjJq8fmRMlwNn9eUIdAoZQi0ThlogyoD61T70ZZVxnpXGfsTjkWE+lRFyN+1ll9u0JghRPMM5gAAAABJRU5ErkJggg=="
  , v_e = "_tokenBoxWrap_q4pvo_1"
  , y_e = "_mask_q4pvo_7"
  , w_e = "_timer_q4pvo_31"
  , __e = "_level_q4pvo_42"
  , x_e = "_mythic_q4pvo_55"
  , b_e = "_epic_q4pvo_60"
  , E_e = "_rare_q4pvo_65"
  , B_e = "_uncommon_q4pvo_70"
  , M_e = "_common_q4pvo_75"
  , S_e = "_none_q4pvo_80"
  , C_e = "_value_q4pvo_85"
  , T_e = "_frame_q4pvo_95"
  , I_e = "_emptyIcon_q4pvo_111"
  , R_e = "_badge_q4pvo_123"
  , U_e = "_frameActive_q4pvo_131"
  , Rc = {
    tokenBoxWrap: v_e,
    mask: y_e,
    timer: w_e,
    level: __e,
    mythic: x_e,
    epic: b_e,
    rare: E_e,
    uncommon: B_e,
    common: M_e,
    none: S_e,
    value: C_e,
    frame: T_e,
    emptyIcon: I_e,
    badge: R_e,
    frameActive: U_e,
    default: "_default_q4pvo_159"
}
  , F_e = "/public/assets/magic-box.png"
  , Jo = n => {
    const {size: e, active: t, onClick: r, level: i, icon: s, rarity: o, style: a} = n
      , [l,c] = Z.useState(!1)
      , A = () => {
        c(!0)
    }
    ;
    return k.jsxs("div", {
        className: Rc.tokenBoxWrap,
        style: {
            width: e,
            height: e
        },
        onClick: r,
        children: [t && k.jsx("div", {
            className: ud(Rc.frame, Rc.frameActive)
        }), k.jsx("div", {
            className: ud(Rc.frame, o && Rc[o])
        }), k.jsx("img", {
            src: l ? F_e : s,
            className: Rc.emptyIcon,
            style: a,
            onError: A
        }), i && k.jsxs("div", {
            className: ud(Rc.level, o && Rc[o]),
            children: ["Lv.", i]
        })]
    })
}
  , P_e = "_InformationContainerPos_72ckd_2"
  , L_e = "_scrollContainer_72ckd_15"
  , D_e = "_traitInfoTitle_72ckd_27"
  , N_e = "_traitInfoText_72ckd_35"
  , O_e = "_flexSelect_72ckd_62"
  , k_e = "_checked_72ckd_119"
  , Q_e = "_checkmark_72ckd_123"
  , H_e = "_checkboxHolder_72ckd_136"
  , ba = {
    InformationContainerPos: P_e,
    scrollContainer: L_e,
    traitInfoTitle: D_e,
    traitInfoText: N_e,
    "input-box": "_input-box_72ckd_43",
    flexSelect: O_e,
    "arrow-button": "_arrow-button_72ckd_70",
    "left-button": "_left-button_72ckd_86",
    "right-button": "_right-button_72ckd_93",
    "anim-button": "_anim-button_72ckd_100",
    "custom-checkbox": "_custom-checkbox_72ckd_105",
    "checkbox-container": "_checkbox-container_72ckd_110",
    checked: k_e,
    checkmark: Q_e,
    checkboxHolder: H_e
};
function w2({jsonSelectionArray: n, byManifest: e=!1}) {
    const {isLoading: t, setIsLoading: r} = Z.useContext(us)
      , {characterManager: i} = be.useContext($n)
      , [s,o] = be.useState(0)
      , [a,l] = Z.useState({})
      , [c,A] = Z.useState([])
      , u = m => {
        i.setManifest(m),
        i.loadInitialTraits().then( () => {
            r(!1)
        }
        )
    }
    ;
    be.useEffect( () => {
        t == !1 && (l(i.getAvatarSelection()),
        A(Object.keys(i.getAvatarSelection())))
    }
    , [t]);
    const f = m => {
        i.loadTraitsFromNFTObject(m).then( () => {
            r(!1)
        }
        )
    }
      , h = async () => {
        if (!t)
            if (r(!0),
            s >= n.length - 1)
                e ? u(n[0]) : f(n[0]),
                o(0);
            else {
                const m = s + 1;
                e ? u(n[m]) : f(n[m]),
                o(m)
            }
    }
      , d = async () => {
        if (!t)
            if (r(!0),
            s <= 0)
                e ? u(n[n.length - 1]) : f(n[n.length - 1]),
                o(n.length - 1);
            else {
                const m = s - 1;
                e ? u(n[m]) : f(n[m]),
                o(m)
            }
    }
    ;
    return (n == null ? void 0 : n.length) > 0 ? k.jsxs("div", {
        className: ba.InformationContainerPos,
        children: [k.jsx(Aa, {
            title: "Trait Selection",
            width: 180,
            right: 20
        }), k.jsxs("div", {
            className: ba.scrollContainer,
            children: [k.jsxs("div", {
                className: ba.flexSelect,
                children: [(n == null ? void 0 : n.length) > 1 ? k.jsx("div", {
                    className: `${ba["arrow-button"]} ${ba["left-button"]}`,
                    onClick: d
                }) : k.jsx(k.Fragment, {}), (n[s].name || n[s].manifestName) && k.jsx("div", {
                    style: {
                        textAlign: "center",
                        flex: 1
                    },
                    children: k.jsx("div", {
                        className: ba.traitInfoTitle,
                        children: e ? n[s].manifestName : n[s].name
                    })
                }), (n == null ? void 0 : n.length) > 1 ? k.jsx("div", {
                    className: `${ba["arrow-button"]} ${ba["right-button"]}`,
                    onClick: h
                }) : k.jsx(k.Fragment, {})]
            }), (n[s].thumb || n[s].thumbnail) && k.jsx("img", {
                src: n[s].thumb || n[s].thumbnail,
                alt: "Selection Thumbnail",
                style: {
                    width: "280px",
                    height: "460px",
                    display: "block",
                    margin: "20px auto 20px"
                }
            }), n[s].attributes && n[s].attributes.map(m => k.jsx("div", {
                children: k.jsx("div", {
                    className: ba.traitInfoText,
                    children: `${m.trait_type} : ${m.value}`
                })
            }, `json:${m.trait_type}_${m.value}`)), e && c.map(m => k.jsx("div", {
                children: k.jsx("div", {
                    className: ba.traitInfoText,
                    children: `${m} : ${a[m].id}`
                })
            }, `val:${m}`))]
        })]
    }) : k.jsx(k.Fragment, {})
}
const hx = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAYAAABxlTA0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAXASURBVHgB7ZzNchNHEMd7ZiWf5WtSCSIfVa5cLN+MTRXrEFPcWJwHwNxys/0Etm+5YZ4Ac0pOIG4EU2WlCgffIm4+pIhS8ADKEQlt07OSKKGdlVdSz64K9++kmhlpR3+Pe3qmuwUgCIIgCIIgCIIgCIIgCIIgCIIgXHAUzCDLflDWRfCVgkVA5aOCkgqhRLMt9cdQW0MhNEBhHRFehW2ondaqDZgxZkZg3w9KrTm9RdJtknBlmAwjeLXTgvuzInbuAi//FPieUrv00gdW1GGnHe7nLXRuAkdmoKDvKYUBOCVfoT3IgSvrP295Gn4nG1sB91S0p4Kvvl34/83rszpkTOYrePXGxj1A3E41GKGGCl/Rq7oXQpM2tma/q0PC0R+orFAt0rfwU32eUgcnzx7tQIZkJrDZxNpFdUwvR6/arqgP59pQrdWqTUj52a0iBCT2nRRi14ttXEv72dOSicCpxCVhFeD+i+fVGkzB8s2g7HVgj77anRHDMhO5ABkwUlzjz4Z4d1ph+5w+jTazzZX1oEYmYTfB5av05rQEjtHgmMjmJoiLqKrFFi5xiTtEPTqcJFPpzc0pTk0EraJNBeqBrU9hZA72wAH03ArZ4+PBk18Socadl39UD8ARzgTuHnfVMT2gPNw3K+L2aHbauOTKT3ZmIrwi7NrENWYhR3Ftm1pJz2lnpsKJwGb10jrdjHXQhhYWQid+6Hnimv8a8hwum0siS19wlY7s4AAnApvVC9aH4U5vl2cljbjmv8a4ZZo8FtsY7N6HsMNug83q9YrqX8ujDk+OHt0FZtKKO9i2un7buGj+8Fha4fPcvjH7CtYeWI/BHS/cB2YmEbffbhvfKkC6I/wY8JsIrW7F2uiUxm0aJhXX0PO7a7H3qJGnv4lgFdiYB6vnQHcLwMg04n6cE1jnVF75ceMSMMIqsAnz2NrNxQ0wwSHu6DmFa8AIr4kILUdiMg9cGweXuIbenGqxDo/3jppVYKXpbnaI3n3u1HCK+3FuYXxuZIevASOsApNdK8faMO7Yj4sLcSM0xCMcmPqInfIRjNDFTnm4jWJSU4VpnIlr5hbaj87AiPPrymlwKa6hrS6wwK7FzQpegTG+Ijp6/BXxuYhr4N3kFMYEVu/HEzhLcZU90tIARrg3ubhNG8OvzHrlWuN1OMMCk1/553Abib6Y5r15mAWXfnsfXhusrS6Zb8L2o96Wh7i9OfmWrqncymFYBQ49y9GTaGkIkt6T14ZmElVs7UnfYVJYBTZXknSaawy3K89+DZint6BsiSkUTuK+VuX3gxFs14D+cMwrT3G7McO4eUDEJ8AMu8Bz7+HA1j4Y88rbz02KGZJ5YM+PcJIXkRTzIuHWQjqe5inuletBoLV6HO9xEzN0clROinnRKn6Qp7hRxEUraw6Ei5ihwYnAJuZlEkwsXeU8j79RRj3YkgHVoYt0guiZ4IgowQQhVSQjC3FXbmzsWssVyHNwtXoNzkoI3v5z1vz6m4V3FCK4OWpcZuIi7tn6yK3cefnMSXZnhNMajTevz04vXV6YJ5GXrQPM6mnDztvGGUvMbhhzWvviux9+U4C/gPXxeP/kqPorOCSTDHfyKv6G5Ox2czjZ/+uoegiMmPIwbTZVSKy5q58cPXaegJ1JhrtJ1x+R5V42OcSr6xvXOMqtUtbdRSUEkAGzVwRDoXSTFDJREUz3+OufM/zzK4IZ5Or14AC12ko5vGZqkcMQ/sOBWy5FURK6yy31apkrtFNV0iRcG5v74qi6DRmSS6WnKS0YUaDigiZdNOyfPHdXKpBELpWepuLyy+8XnmiEefobp454TII58IQFvE2u2FPIgfyLwdPVtY0PU93dtMzMzxkYoXUHtsl03JrUdJCdbmjEhwW60ctqEzuP2fxBjq7YPph6ZFSLaGqSP/VnmyQm3cqZ+uUoDlif1R/kEARBEARBEARBEARBEARBEARBEC48HwDC3eeu0ZVWOQAAAABJRU5ErkJggg=="
  , U3 = ({active: n, src: e, select: t}) => k.jsx("div", {
    className: `${jt.selectorButton}`,
    onClick: t,
    children: k.jsx(Jo, {
        size: 56,
        icon: e || "",
        rarity: n ? "mythic" : "none"
    })
})
  , z_e = ({selectedTraitGroup: n, onBack: e}) => {
    const {decalManager: t, characterManager: r} = Z.useContext($n)
      , [i,s] = Z.useState([])
      , o = n.getAllDecals();
    return Z.useEffect( () => {
        const a = Array.from(t.applied.keys());
        s(a.map(l => l))
    }
    , []),
    k.jsxs("div", {
        className: jt["selector-container-column"],
        children: [k.jsx(Bn, {
            theme: "dark",
            text: "Back",
            size: 14,
            className: jt.buttonLeft,
            onClick: e
        }), k.jsxs("div", {
            className: jt["selector-container"],
            children: [k.jsx(U3, {
                src: hx,
                active: !1,
                select: () => {
                    t.removeAllOverlayedTextures(),
                    s([])
                }
            }, "empty"), o.map(a => {
                const l = sV(r.manifestData.getTraitsDirectory(), a.thumbnail);
                return k.jsx(U3, {
                    src: l,
                    active: i.includes(a.id),
                    select: () => {
                        i.includes(a.id) ? t.removeOverlayTexture(a.id).then( () => {
                            s(i.filter(c => c !== a.id))
                        }
                        ) : t.loadOverlayTexture(n, a.id).then( () => {
                            s(i.concat([a.id]))
                        }
                        )
                    }
                }, a.id)
            }
            )]
        })]
    })
}
  , G_e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAYAAABxlTA0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFyWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wMS0wMlQxMTo0OTozNy0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDEtMDJUMTE6NTI6MjMtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDEtMDJUMTE6NTI6MjMtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjBmNjkzZGRkLWI4ZWYtZTU0Ni05YWQ2LTRjNzJkOTg4MTJhNCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjBiNWViMTliLTkxMmEtMmI0NS1iOTZlLTliNDUxOGUzZDU4NyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjg4ODliZDlkLTAxZjItMTQ0Ni04NDE4LWYyYzNjNjQ1ODNlOCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ODg4OWJkOWQtMDFmMi0xNDQ2LTg0MTgtZjJjM2M2NDU4M2U4IiBzdEV2dDp3aGVuPSIyMDI0LTAxLTAyVDExOjQ5OjM3LTA2OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjBmNjkzZGRkLWI4ZWYtZTU0Ni05YWQ2LTRjNzJkOTg4MTJhNCIgc3RFdnQ6d2hlbj0iMjAyNC0wMS0wMlQxMTo1MjoyMy0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv0y+4AAAASPSURBVHja7ZxrSBVBFMctyqIgC0ujJ5UFaQpZRC/7YoUVQYUUkZQYQoVfJBF62PtBlhlJoJWSUQRSEYUFUVRiSEWRiokVgZqRWUEv7W3/oQkul53Ze+/OXWfyfPh98e6cPfNjnZ2ZPbshnZ2dIUTwIAkkmAQTJJgEk2CCBJNgEkyQYBKsgFnzlsaCanARZICFIJwEqxN8CXR68R08479lgxVgDAkOTPATC8EiXoLbYB9YDeJJsFzucPDLD8FWvABlIBcsAeNBKAn+K3i+Q7ki3oNycAys4eP8gO4oeH2QBFvxFVSAYj6uR3cHwWdcFGzFG1AF8sBakOBkeNFR8AMbAY/BedDqovQPoA6UgghjBbMxkXfGqpMfwUyv4w90wRV+1GTBCyQdmy5oc8hlwQdMFrxF0KlzkjbDwA8XBSebLPikv1cNfusBml0UHGWy4BpBp0olbYaAjgBlselZHBgNloNGm+PbQF8jBfsgKlrQbnuActMtYoWCBkmb68ZO09hNzEbIUzDCq82GAOXekuSRJGl3xGTBmT6IYXsU10Ahn5cGOo5ukeQxCLQL2q0zWXCBizeq7TZD1XdBu1iTBVe4KPieJI9kQZtPYKCRgpF4P/DW5QVDnkUeUVyk1fH3jd2L4Pu1KqSxMfohH6cbfbmS+eqRTdX22ixYck0WnKZAbguY5BV3o8IrPsVkwWUKBMQIYmcpEjzdZMF3eCfaA4C1OxGkld4/WgPdE9ZBLttLGMwJD4AI0F8SvycfPpwIvkuFJ2LBQyXzWl8pck0wmwuCcWCUZrCcwizy3aZg/E13RTBONMXjpL81g+W0wyvf/YpucHPdEpzbxQ8k7djlkesmRTHbnZRt+Ss4T3PBOz1y3aooZq1rj+1xsoMGCd6sKOYFEhxcwRm6Cf4JvmksuIUXlrz2MeZknQTv5k95e4HZvCM6CU73c5O/w2ldskrBqTbL4K4WnCbIL0MS75GrtWkSwZWSNgkaCK63Wao3CeKd0kVwgaRNmGQT2y3BZ236VS6Il6OL4OOSNpEK9gKcCq6y6VetIF6iLoKbRdt5vNhZhzE4UZDfYkm8kboIZpy2OH4C+KyJYFZsPdUrvzmSWM9dL8D2YZpWw4tBlrEyTz4n1mmaxvK5DvLBTY9NIitKdBT8P63k1pPg4ApOMllwBX+9agZYKamqdCI4x0Ec9vg+0lTBhYLYVxQLznYQp65L3jJSILhN9G4a/j5RseAefBW5gy00/PwvuWSq4GKb+PWqBAviR/Ay2UxeTV8pqObJMlVwiU38hmAKlizl4/iCqIjXIS8yeYgIE8SOUTlEGPkyuKKb3FlB7FskWN00jX1sIxVM4/uxTaqnad1dcNAXGiSYBGsjuJoXvJTy95VJsEJWeZ2/N7hBghWXQXnl0Ae8IsHOGSfJ4zAJdv59HVlR9SYS7JxESR4XSbBzLgtyiKebnDqugrEe248pkveISbAD3oEvtNCglRwJ1l1wvuaC95gueJ/mgnNMFxzFH6m84V841YVW/nZ9DH0/mD4xTpBgEkyQYBJMggkSTIJJMEGCteYPxO/zzCRZDV4AAAAASUVORK5CYII="
  , V_e = "/public/assets/color-palette.png";
var lo = {}
  , C0 = {}
  , j_e = typeof ka == "object" && ka && ka.Object === Object && ka
  , EV = j_e
  , W_e = EV
  , K_e = typeof self == "object" && self && self.Object === Object && self
  , X_e = W_e || K_e || Function("return this")()
  , ul = X_e
  , Y_e = ul
  , $_e = Y_e.Symbol
  , T0 = $_e
  , F3 = T0
  , BV = Object.prototype
  , Z_e = BV.hasOwnProperty
  , J_e = BV.toString
  , cm = F3 ? F3.toStringTag : void 0;
function q_e(n) {
    var e = Z_e.call(n, cm)
      , t = n[cm];
    try {
        n[cm] = void 0;
        var r = !0
    } catch {}
    var i = J_e.call(n);
    return r && (e ? n[cm] = t : delete n[cm]),
    i
}
var exe = q_e
  , txe = Object.prototype
  , nxe = txe.toString;
function rxe(n) {
    return nxe.call(n)
}
var ixe = rxe
  , P3 = T0
  , sxe = exe
  , oxe = ixe
  , axe = "[object Null]"
  , lxe = "[object Undefined]"
  , L3 = P3 ? P3.toStringTag : void 0;
function cxe(n) {
    return n == null ? n === void 0 ? lxe : axe : L3 && L3 in Object(n) ? sxe(n) : oxe(n)
}
var Zu = cxe
  , Axe = Array.isArray
  , ha = Axe;
function uxe(n) {
    return n != null && typeof n == "object"
}
var uc = uxe
  , fxe = Zu
  , hxe = ha
  , dxe = uc
  , pxe = "[object String]";
function mxe(n) {
    return typeof n == "string" || !hxe(n) && dxe(n) && fxe(n) == pxe
}
var gxe = mxe;
function vxe(n) {
    return function(e, t, r) {
        for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
            var l = o[n ? a : ++i];
            if (t(s[l], l, s) === !1)
                break
        }
        return e
    }
}
var yxe = vxe
  , wxe = yxe
  , _xe = wxe()
  , xxe = _xe;
function bxe(n, e) {
    for (var t = -1, r = Array(n); ++t < n; )
        r[t] = e(t);
    return r
}
var Exe = bxe
  , Bxe = Zu
  , Mxe = uc
  , Sxe = "[object Arguments]";
function Cxe(n) {
    return Mxe(n) && Bxe(n) == Sxe
}
var Txe = Cxe
  , D3 = Txe
  , Ixe = uc
  , MV = Object.prototype
  , Rxe = MV.hasOwnProperty
  , Uxe = MV.propertyIsEnumerable
  , Fxe = D3(function() {
    return arguments
}()) ? D3 : function(n) {
    return Ixe(n) && Rxe.call(n, "callee") && !Uxe.call(n, "callee")
}
  , SV = Fxe
  , dx = {
    exports: {}
};
function Pxe() {
    return !1
}
var Lxe = Pxe;
dx.exports;
(function(n, e) {
    var t = ul
      , r = Lxe
      , i = e && !e.nodeType && e
      , s = i && !0 && n && !n.nodeType && n
      , o = s && s.exports === i
      , a = o ? t.Buffer : void 0
      , l = a ? a.isBuffer : void 0
      , c = l || r;
    n.exports = c
}
)(dx, dx.exports);
var _2 = dx.exports
  , Dxe = 9007199254740991
  , Nxe = /^(?:0|[1-9]\d*)$/;
function Oxe(n, e) {
    var t = typeof n;
    return e = e ?? Dxe,
    !!e && (t == "number" || t != "symbol" && Nxe.test(n)) && n > -1 && n % 1 == 0 && n < e
}
var CV = Oxe
  , kxe = 9007199254740991;
function Qxe(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= kxe
}
var x2 = Qxe
  , Hxe = Zu
  , zxe = x2
  , Gxe = uc
  , Vxe = "[object Arguments]"
  , jxe = "[object Array]"
  , Wxe = "[object Boolean]"
  , Kxe = "[object Date]"
  , Xxe = "[object Error]"
  , Yxe = "[object Function]"
  , $xe = "[object Map]"
  , Zxe = "[object Number]"
  , Jxe = "[object Object]"
  , qxe = "[object RegExp]"
  , e1e = "[object Set]"
  , t1e = "[object String]"
  , n1e = "[object WeakMap]"
  , r1e = "[object ArrayBuffer]"
  , i1e = "[object DataView]"
  , s1e = "[object Float32Array]"
  , o1e = "[object Float64Array]"
  , a1e = "[object Int8Array]"
  , l1e = "[object Int16Array]"
  , c1e = "[object Int32Array]"
  , A1e = "[object Uint8Array]"
  , u1e = "[object Uint8ClampedArray]"
  , f1e = "[object Uint16Array]"
  , h1e = "[object Uint32Array]"
  , Cn = {};
Cn[s1e] = Cn[o1e] = Cn[a1e] = Cn[l1e] = Cn[c1e] = Cn[A1e] = Cn[u1e] = Cn[f1e] = Cn[h1e] = !0;
Cn[Vxe] = Cn[jxe] = Cn[r1e] = Cn[Wxe] = Cn[i1e] = Cn[Kxe] = Cn[Xxe] = Cn[Yxe] = Cn[$xe] = Cn[Zxe] = Cn[Jxe] = Cn[qxe] = Cn[e1e] = Cn[t1e] = Cn[n1e] = !1;
function d1e(n) {
    return Gxe(n) && zxe(n.length) && !!Cn[Hxe(n)]
}
var p1e = d1e;
function m1e(n) {
    return function(e) {
        return n(e)
    }
}
var b2 = m1e
  , px = {
    exports: {}
};
px.exports;
(function(n, e) {
    var t = EV
      , r = e && !e.nodeType && e
      , i = r && !0 && n && !n.nodeType && n
      , s = i && i.exports === r
      , o = s && t.process
      , a = function() {
        try {
            var l = i && i.require && i.require("util").types;
            return l || o && o.binding && o.binding("util")
        } catch {}
    }();
    n.exports = a
}
)(px, px.exports);
var E2 = px.exports
  , g1e = p1e
  , v1e = b2
  , N3 = E2
  , O3 = N3 && N3.isTypedArray
  , y1e = O3 ? v1e(O3) : g1e
  , TV = y1e
  , w1e = Exe
  , _1e = SV
  , x1e = ha
  , b1e = _2
  , E1e = CV
  , B1e = TV
  , M1e = Object.prototype
  , S1e = M1e.hasOwnProperty;
function C1e(n, e) {
    var t = x1e(n)
      , r = !t && _1e(n)
      , i = !t && !r && b1e(n)
      , s = !t && !r && !i && B1e(n)
      , o = t || r || i || s
      , a = o ? w1e(n.length, String) : []
      , l = a.length;
    for (var c in n)
        (e || S1e.call(n, c)) && !(o && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || E1e(c, l))) && a.push(c);
    return a
}
var IV = C1e
  , T1e = Object.prototype;
function I1e(n) {
    var e = n && n.constructor
      , t = typeof e == "function" && e.prototype || T1e;
    return n === t
}
var B2 = I1e;
function R1e(n, e) {
    return function(t) {
        return n(e(t))
    }
}
var RV = R1e
  , U1e = RV
  , F1e = U1e(Object.keys, Object)
  , P1e = F1e
  , L1e = B2
  , D1e = P1e
  , N1e = Object.prototype
  , O1e = N1e.hasOwnProperty;
function k1e(n) {
    if (!L1e(n))
        return D1e(n);
    var e = [];
    for (var t in Object(n))
        O1e.call(n, t) && t != "constructor" && e.push(t);
    return e
}
var Q1e = k1e;
function H1e(n) {
    var e = typeof n;
    return n != null && (e == "object" || e == "function")
}
var tp = H1e
  , z1e = Zu
  , G1e = tp
  , V1e = "[object AsyncFunction]"
  , j1e = "[object Function]"
  , W1e = "[object GeneratorFunction]"
  , K1e = "[object Proxy]";
function X1e(n) {
    if (!G1e(n))
        return !1;
    var e = z1e(n);
    return e == j1e || e == W1e || e == V1e || e == K1e
}
var UV = X1e
  , Y1e = UV
  , $1e = x2;
function Z1e(n) {
    return n != null && $1e(n.length) && !Y1e(n)
}
var Q1 = Z1e
  , J1e = IV
  , q1e = Q1e
  , ebe = Q1;
function tbe(n) {
    return ebe(n) ? J1e(n) : q1e(n)
}
var I0 = tbe
  , nbe = xxe
  , rbe = I0;
function ibe(n, e) {
    return n && nbe(n, e, rbe)
}
var FV = ibe;
function sbe(n) {
    return n
}
var PV = sbe
  , obe = PV;
function abe(n) {
    return typeof n == "function" ? n : obe
}
var lbe = abe
  , cbe = FV
  , Abe = lbe;
function ube(n, e) {
    return n && cbe(n, Abe(e))
}
var M2 = ube
  , fbe = RV
  , hbe = fbe(Object.getPrototypeOf, Object)
  , S2 = hbe
  , dbe = Zu
  , pbe = S2
  , mbe = uc
  , gbe = "[object Object]"
  , vbe = Function.prototype
  , ybe = Object.prototype
  , LV = vbe.toString
  , wbe = ybe.hasOwnProperty
  , _be = LV.call(Object);
function xbe(n) {
    if (!mbe(n) || dbe(n) != gbe)
        return !1;
    var e = pbe(n);
    if (e === null)
        return !0;
    var t = wbe.call(e, "constructor") && e.constructor;
    return typeof t == "function" && t instanceof t && LV.call(t) == _be
}
var bbe = xbe;
function Ebe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length, i = Array(r); ++t < r; )
        i[t] = e(n[t], t, n);
    return i
}
var DV = Ebe;
function Bbe() {
    this.__data__ = [],
    this.size = 0
}
var Mbe = Bbe;
function Sbe(n, e) {
    return n === e || n !== n && e !== e
}
var C2 = Sbe
  , Cbe = C2;
function Tbe(n, e) {
    for (var t = n.length; t--; )
        if (Cbe(n[t][0], e))
            return t;
    return -1
}
var H1 = Tbe
  , Ibe = H1
  , Rbe = Array.prototype
  , Ube = Rbe.splice;
function Fbe(n) {
    var e = this.__data__
      , t = Ibe(e, n);
    if (t < 0)
        return !1;
    var r = e.length - 1;
    return t == r ? e.pop() : Ube.call(e, t, 1),
    --this.size,
    !0
}
var Pbe = Fbe
  , Lbe = H1;
function Dbe(n) {
    var e = this.__data__
      , t = Lbe(e, n);
    return t < 0 ? void 0 : e[t][1]
}
var Nbe = Dbe
  , Obe = H1;
function kbe(n) {
    return Obe(this.__data__, n) > -1
}
var Qbe = kbe
  , Hbe = H1;
function zbe(n, e) {
    var t = this.__data__
      , r = Hbe(t, n);
    return r < 0 ? (++this.size,
    t.push([n, e])) : t[r][1] = e,
    this
}
var Gbe = zbe
  , Vbe = Mbe
  , jbe = Pbe
  , Wbe = Nbe
  , Kbe = Qbe
  , Xbe = Gbe;
function np(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
np.prototype.clear = Vbe;
np.prototype.delete = jbe;
np.prototype.get = Wbe;
np.prototype.has = Kbe;
np.prototype.set = Xbe;
var z1 = np
  , Ybe = z1;
function $be() {
    this.__data__ = new Ybe,
    this.size = 0
}
var Zbe = $be;
function Jbe(n) {
    var e = this.__data__
      , t = e.delete(n);
    return this.size = e.size,
    t
}
var qbe = Jbe;
function eEe(n) {
    return this.__data__.get(n)
}
var tEe = eEe;
function nEe(n) {
    return this.__data__.has(n)
}
var rEe = nEe
  , iEe = ul
  , sEe = iEe["__core-js_shared__"]
  , oEe = sEe
  , uM = oEe
  , k3 = function() {
    var n = /[^.]+$/.exec(uM && uM.keys && uM.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : ""
}();
function aEe(n) {
    return !!k3 && k3 in n
}
var lEe = aEe
  , cEe = Function.prototype
  , AEe = cEe.toString;
function uEe(n) {
    if (n != null) {
        try {
            return AEe.call(n)
        } catch {}
        try {
            return n + ""
        } catch {}
    }
    return ""
}
var NV = uEe
  , fEe = UV
  , hEe = lEe
  , dEe = tp
  , pEe = NV
  , mEe = /[\\^$.*+?()[\]{}|]/g
  , gEe = /^\[object .+?Constructor\]$/
  , vEe = Function.prototype
  , yEe = Object.prototype
  , wEe = vEe.toString
  , _Ee = yEe.hasOwnProperty
  , xEe = RegExp("^" + wEe.call(_Ee).replace(mEe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function bEe(n) {
    if (!dEe(n) || hEe(n))
        return !1;
    var e = fEe(n) ? xEe : gEe;
    return e.test(pEe(n))
}
var EEe = bEe;
function BEe(n, e) {
    return n == null ? void 0 : n[e]
}
var MEe = BEe
  , SEe = EEe
  , CEe = MEe;
function TEe(n, e) {
    var t = CEe(n, e);
    return SEe(t) ? t : void 0
}
var Ju = TEe
  , IEe = Ju
  , REe = ul
  , UEe = IEe(REe, "Map")
  , T2 = UEe
  , FEe = Ju
  , PEe = FEe(Object, "create")
  , G1 = PEe
  , Q3 = G1;
function LEe() {
    this.__data__ = Q3 ? Q3(null) : {},
    this.size = 0
}
var DEe = LEe;
function NEe(n) {
    var e = this.has(n) && delete this.__data__[n];
    return this.size -= e ? 1 : 0,
    e
}
var OEe = NEe
  , kEe = G1
  , QEe = "__lodash_hash_undefined__"
  , HEe = Object.prototype
  , zEe = HEe.hasOwnProperty;
function GEe(n) {
    var e = this.__data__;
    if (kEe) {
        var t = e[n];
        return t === QEe ? void 0 : t
    }
    return zEe.call(e, n) ? e[n] : void 0
}
var VEe = GEe
  , jEe = G1
  , WEe = Object.prototype
  , KEe = WEe.hasOwnProperty;
function XEe(n) {
    var e = this.__data__;
    return jEe ? e[n] !== void 0 : KEe.call(e, n)
}
var YEe = XEe
  , $Ee = G1
  , ZEe = "__lodash_hash_undefined__";
function JEe(n, e) {
    var t = this.__data__;
    return this.size += this.has(n) ? 0 : 1,
    t[n] = $Ee && e === void 0 ? ZEe : e,
    this
}
var qEe = JEe
  , eBe = DEe
  , tBe = OEe
  , nBe = VEe
  , rBe = YEe
  , iBe = qEe;
function rp(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
rp.prototype.clear = eBe;
rp.prototype.delete = tBe;
rp.prototype.get = nBe;
rp.prototype.has = rBe;
rp.prototype.set = iBe;
var sBe = rp
  , H3 = sBe
  , oBe = z1
  , aBe = T2;
function lBe() {
    this.size = 0,
    this.__data__ = {
        hash: new H3,
        map: new (aBe || oBe),
        string: new H3
    }
}
var cBe = lBe;
function ABe(n) {
    var e = typeof n;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null
}
var uBe = ABe
  , fBe = uBe;
function hBe(n, e) {
    var t = n.__data__;
    return fBe(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
}
var V1 = hBe
  , dBe = V1;
function pBe(n) {
    var e = dBe(this, n).delete(n);
    return this.size -= e ? 1 : 0,
    e
}
var mBe = pBe
  , gBe = V1;
function vBe(n) {
    return gBe(this, n).get(n)
}
var yBe = vBe
  , wBe = V1;
function _Be(n) {
    return wBe(this, n).has(n)
}
var xBe = _Be
  , bBe = V1;
function EBe(n, e) {
    var t = bBe(this, n)
      , r = t.size;
    return t.set(n, e),
    this.size += t.size == r ? 0 : 1,
    this
}
var BBe = EBe
  , MBe = cBe
  , SBe = mBe
  , CBe = yBe
  , TBe = xBe
  , IBe = BBe;
function ip(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
ip.prototype.clear = MBe;
ip.prototype.delete = SBe;
ip.prototype.get = CBe;
ip.prototype.has = TBe;
ip.prototype.set = IBe;
var I2 = ip
  , RBe = z1
  , UBe = T2
  , FBe = I2
  , PBe = 200;
function LBe(n, e) {
    var t = this.__data__;
    if (t instanceof RBe) {
        var r = t.__data__;
        if (!UBe || r.length < PBe - 1)
            return r.push([n, e]),
            this.size = ++t.size,
            this;
        t = this.__data__ = new FBe(r)
    }
    return t.set(n, e),
    this.size = t.size,
    this
}
var DBe = LBe
  , NBe = z1
  , OBe = Zbe
  , kBe = qbe
  , QBe = tEe
  , HBe = rEe
  , zBe = DBe;
function sp(n) {
    var e = this.__data__ = new NBe(n);
    this.size = e.size
}
sp.prototype.clear = OBe;
sp.prototype.delete = kBe;
sp.prototype.get = QBe;
sp.prototype.has = HBe;
sp.prototype.set = zBe;
var R2 = sp
  , GBe = "__lodash_hash_undefined__";
function VBe(n) {
    return this.__data__.set(n, GBe),
    this
}
var jBe = VBe;
function WBe(n) {
    return this.__data__.has(n)
}
var KBe = WBe
  , XBe = I2
  , YBe = jBe
  , $Be = KBe;
function mx(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.__data__ = new XBe; ++e < t; )
        this.add(n[e])
}
mx.prototype.add = mx.prototype.push = YBe;
mx.prototype.has = $Be;
var ZBe = mx;
function JBe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length; ++t < r; )
        if (e(n[t], t, n))
            return !0;
    return !1
}
var qBe = JBe;
function eMe(n, e) {
    return n.has(e)
}
var tMe = eMe
  , nMe = ZBe
  , rMe = qBe
  , iMe = tMe
  , sMe = 1
  , oMe = 2;
function aMe(n, e, t, r, i, s) {
    var o = t & sMe
      , a = n.length
      , l = e.length;
    if (a != l && !(o && l > a))
        return !1;
    var c = s.get(n)
      , A = s.get(e);
    if (c && A)
        return c == e && A == n;
    var u = -1
      , f = !0
      , h = t & oMe ? new nMe : void 0;
    for (s.set(n, e),
    s.set(e, n); ++u < a; ) {
        var d = n[u]
          , m = e[u];
        if (r)
            var g = o ? r(m, d, u, e, n, s) : r(d, m, u, n, e, s);
        if (g !== void 0) {
            if (g)
                continue;
            f = !1;
            break
        }
        if (h) {
            if (!rMe(e, function(p, v) {
                if (!iMe(h, v) && (d === p || i(d, p, t, r, s)))
                    return h.push(v)
            })) {
                f = !1;
                break
            }
        } else if (!(d === m || i(d, m, t, r, s))) {
            f = !1;
            break
        }
    }
    return s.delete(n),
    s.delete(e),
    f
}
var OV = aMe
  , lMe = ul
  , cMe = lMe.Uint8Array
  , kV = cMe;
function AMe(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(r, i) {
        t[++e] = [i, r]
    }),
    t
}
var uMe = AMe;
function fMe(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(r) {
        t[++e] = r
    }),
    t
}
var hMe = fMe
  , z3 = T0
  , G3 = kV
  , dMe = C2
  , pMe = OV
  , mMe = uMe
  , gMe = hMe
  , vMe = 1
  , yMe = 2
  , wMe = "[object Boolean]"
  , _Me = "[object Date]"
  , xMe = "[object Error]"
  , bMe = "[object Map]"
  , EMe = "[object Number]"
  , BMe = "[object RegExp]"
  , MMe = "[object Set]"
  , SMe = "[object String]"
  , CMe = "[object Symbol]"
  , TMe = "[object ArrayBuffer]"
  , IMe = "[object DataView]"
  , V3 = z3 ? z3.prototype : void 0
  , fM = V3 ? V3.valueOf : void 0;
function RMe(n, e, t, r, i, s, o) {
    switch (t) {
    case IMe:
        if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
            return !1;
        n = n.buffer,
        e = e.buffer;
    case TMe:
        return !(n.byteLength != e.byteLength || !s(new G3(n), new G3(e)));
    case wMe:
    case _Me:
    case EMe:
        return dMe(+n, +e);
    case xMe:
        return n.name == e.name && n.message == e.message;
    case BMe:
    case SMe:
        return n == e + "";
    case bMe:
        var a = mMe;
    case MMe:
        var l = r & vMe;
        if (a || (a = gMe),
        n.size != e.size && !l)
            return !1;
        var c = o.get(n);
        if (c)
            return c == e;
        r |= yMe,
        o.set(n, e);
        var A = pMe(a(n), a(e), r, i, s, o);
        return o.delete(n),
        A;
    case CMe:
        if (fM)
            return fM.call(n) == fM.call(e)
    }
    return !1
}
var UMe = RMe;
function FMe(n, e) {
    for (var t = -1, r = e.length, i = n.length; ++t < r; )
        n[i + t] = e[t];
    return n
}
var QV = FMe
  , PMe = QV
  , LMe = ha;
function DMe(n, e, t) {
    var r = e(n);
    return LMe(n) ? r : PMe(r, t(n))
}
var HV = DMe;
function NMe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length, i = 0, s = []; ++t < r; ) {
        var o = n[t];
        e(o, t, n) && (s[i++] = o)
    }
    return s
}
var OMe = NMe;
function kMe() {
    return []
}
var zV = kMe
  , QMe = OMe
  , HMe = zV
  , zMe = Object.prototype
  , GMe = zMe.propertyIsEnumerable
  , j3 = Object.getOwnPropertySymbols
  , VMe = j3 ? function(n) {
    return n == null ? [] : (n = Object(n),
    QMe(j3(n), function(e) {
        return GMe.call(n, e)
    }))
}
: HMe
  , U2 = VMe
  , jMe = HV
  , WMe = U2
  , KMe = I0;
function XMe(n) {
    return jMe(n, KMe, WMe)
}
var GV = XMe
  , W3 = GV
  , YMe = 1
  , $Me = Object.prototype
  , ZMe = $Me.hasOwnProperty;
function JMe(n, e, t, r, i, s) {
    var o = t & YMe
      , a = W3(n)
      , l = a.length
      , c = W3(e)
      , A = c.length;
    if (l != A && !o)
        return !1;
    for (var u = l; u--; ) {
        var f = a[u];
        if (!(o ? f in e : ZMe.call(e, f)))
            return !1
    }
    var h = s.get(n)
      , d = s.get(e);
    if (h && d)
        return h == e && d == n;
    var m = !0;
    s.set(n, e),
    s.set(e, n);
    for (var g = o; ++u < l; ) {
        f = a[u];
        var p = n[f]
          , v = e[f];
        if (r)
            var w = o ? r(v, p, f, e, n, s) : r(p, v, f, n, e, s);
        if (!(w === void 0 ? p === v || i(p, v, t, r, s) : w)) {
            m = !1;
            break
        }
        g || (g = f == "constructor")
    }
    if (m && !g) {
        var _ = n.constructor
          , x = e.constructor;
        _ != x && "constructor"in n && "constructor"in e && !(typeof _ == "function" && _ instanceof _ && typeof x == "function" && x instanceof x) && (m = !1)
    }
    return s.delete(n),
    s.delete(e),
    m
}
var qMe = JMe
  , eSe = Ju
  , tSe = ul
  , nSe = eSe(tSe, "DataView")
  , rSe = nSe
  , iSe = Ju
  , sSe = ul
  , oSe = iSe(sSe, "Promise")
  , aSe = oSe
  , lSe = Ju
  , cSe = ul
  , ASe = lSe(cSe, "Set")
  , uSe = ASe
  , fSe = Ju
  , hSe = ul
  , dSe = fSe(hSe, "WeakMap")
  , pSe = dSe
  , LT = rSe
  , DT = T2
  , NT = aSe
  , OT = uSe
  , kT = pSe
  , VV = Zu
  , op = NV
  , K3 = "[object Map]"
  , mSe = "[object Object]"
  , X3 = "[object Promise]"
  , Y3 = "[object Set]"
  , $3 = "[object WeakMap]"
  , Z3 = "[object DataView]"
  , gSe = op(LT)
  , vSe = op(DT)
  , ySe = op(NT)
  , wSe = op(OT)
  , _Se = op(kT)
  , iu = VV;
(LT && iu(new LT(new ArrayBuffer(1))) != Z3 || DT && iu(new DT) != K3 || NT && iu(NT.resolve()) != X3 || OT && iu(new OT) != Y3 || kT && iu(new kT) != $3) && (iu = function(n) {
    var e = VV(n)
      , t = e == mSe ? n.constructor : void 0
      , r = t ? op(t) : "";
    if (r)
        switch (r) {
        case gSe:
            return Z3;
        case vSe:
            return K3;
        case ySe:
            return X3;
        case wSe:
            return Y3;
        case _Se:
            return $3
        }
    return e
}
);
var j1 = iu
  , hM = R2
  , xSe = OV
  , bSe = UMe
  , ESe = qMe
  , J3 = j1
  , q3 = ha
  , ek = _2
  , BSe = TV
  , MSe = 1
  , tk = "[object Arguments]"
  , nk = "[object Array]"
  , zy = "[object Object]"
  , SSe = Object.prototype
  , rk = SSe.hasOwnProperty;
function CSe(n, e, t, r, i, s) {
    var o = q3(n)
      , a = q3(e)
      , l = o ? nk : J3(n)
      , c = a ? nk : J3(e);
    l = l == tk ? zy : l,
    c = c == tk ? zy : c;
    var A = l == zy
      , u = c == zy
      , f = l == c;
    if (f && ek(n)) {
        if (!ek(e))
            return !1;
        o = !0,
        A = !1
    }
    if (f && !A)
        return s || (s = new hM),
        o || BSe(n) ? xSe(n, e, t, r, i, s) : bSe(n, e, l, t, r, i, s);
    if (!(t & MSe)) {
        var h = A && rk.call(n, "__wrapped__")
          , d = u && rk.call(e, "__wrapped__");
        if (h || d) {
            var m = h ? n.value() : n
              , g = d ? e.value() : e;
            return s || (s = new hM),
            i(m, g, t, r, s)
        }
    }
    return f ? (s || (s = new hM),
    ESe(n, e, t, r, i, s)) : !1
}
var TSe = CSe
  , ISe = TSe
  , ik = uc;
function jV(n, e, t, r, i) {
    return n === e ? !0 : n == null || e == null || !ik(n) && !ik(e) ? n !== n && e !== e : ISe(n, e, t, r, jV, i)
}
var WV = jV
  , RSe = R2
  , USe = WV
  , FSe = 1
  , PSe = 2;
function LSe(n, e, t, r) {
    var i = t.length
      , s = i
      , o = !r;
    if (n == null)
        return !s;
    for (n = Object(n); i--; ) {
        var a = t[i];
        if (o && a[2] ? a[1] !== n[a[0]] : !(a[0]in n))
            return !1
    }
    for (; ++i < s; ) {
        a = t[i];
        var l = a[0]
          , c = n[l]
          , A = a[1];
        if (o && a[2]) {
            if (c === void 0 && !(l in n))
                return !1
        } else {
            var u = new RSe;
            if (r)
                var f = r(c, A, l, n, e, u);
            if (!(f === void 0 ? USe(A, c, FSe | PSe, r, u) : f))
                return !1
        }
    }
    return !0
}
var DSe = LSe
  , NSe = tp;
function OSe(n) {
    return n === n && !NSe(n)
}
var KV = OSe
  , kSe = KV
  , QSe = I0;
function HSe(n) {
    for (var e = QSe(n), t = e.length; t--; ) {
        var r = e[t]
          , i = n[r];
        e[t] = [r, i, kSe(i)]
    }
    return e
}
var zSe = HSe;
function GSe(n, e) {
    return function(t) {
        return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t))
    }
}
var XV = GSe
  , VSe = DSe
  , jSe = zSe
  , WSe = XV;
function KSe(n) {
    var e = jSe(n);
    return e.length == 1 && e[0][2] ? WSe(e[0][0], e[0][1]) : function(t) {
        return t === n || VSe(t, n, e)
    }
}
var XSe = KSe
  , YSe = Zu
  , $Se = uc
  , ZSe = "[object Symbol]";
function JSe(n) {
    return typeof n == "symbol" || $Se(n) && YSe(n) == ZSe
}
var F2 = JSe
  , qSe = ha
  , eCe = F2
  , tCe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , nCe = /^\w*$/;
function rCe(n, e) {
    if (qSe(n))
        return !1;
    var t = typeof n;
    return t == "number" || t == "symbol" || t == "boolean" || n == null || eCe(n) ? !0 : nCe.test(n) || !tCe.test(n) || e != null && n in Object(e)
}
var P2 = rCe
  , YV = I2
  , iCe = "Expected a function";
function L2(n, e) {
    if (typeof n != "function" || e != null && typeof e != "function")
        throw new TypeError(iCe);
    var t = function() {
        var r = arguments
          , i = e ? e.apply(this, r) : r[0]
          , s = t.cache;
        if (s.has(i))
            return s.get(i);
        var o = n.apply(this, r);
        return t.cache = s.set(i, o) || s,
        o
    };
    return t.cache = new (L2.Cache || YV),
    t
}
L2.Cache = YV;
var sCe = L2
  , oCe = sCe
  , aCe = 500;
function lCe(n) {
    var e = oCe(n, function(r) {
        return t.size === aCe && t.clear(),
        r
    })
      , t = e.cache;
    return e
}
var cCe = lCe
  , ACe = cCe
  , uCe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , fCe = /\\(\\)?/g
  , hCe = ACe(function(n) {
    var e = [];
    return n.charCodeAt(0) === 46 && e.push(""),
    n.replace(uCe, function(t, r, i, s) {
        e.push(i ? s.replace(fCe, "$1") : r || t)
    }),
    e
})
  , dCe = hCe
  , sk = T0
  , pCe = DV
  , mCe = ha
  , gCe = F2
  , vCe = 1 / 0
  , ok = sk ? sk.prototype : void 0
  , ak = ok ? ok.toString : void 0;
function $V(n) {
    if (typeof n == "string")
        return n;
    if (mCe(n))
        return pCe(n, $V) + "";
    if (gCe(n))
        return ak ? ak.call(n) : "";
    var e = n + "";
    return e == "0" && 1 / n == -vCe ? "-0" : e
}
var yCe = $V
  , wCe = yCe;
function _Ce(n) {
    return n == null ? "" : wCe(n)
}
var xCe = _Ce
  , bCe = ha
  , ECe = P2
  , BCe = dCe
  , MCe = xCe;
function SCe(n, e) {
    return bCe(n) ? n : ECe(n, e) ? [n] : BCe(MCe(n))
}
var ZV = SCe
  , CCe = F2
  , TCe = 1 / 0;
function ICe(n) {
    if (typeof n == "string" || CCe(n))
        return n;
    var e = n + "";
    return e == "0" && 1 / n == -TCe ? "-0" : e
}
var W1 = ICe
  , RCe = ZV
  , UCe = W1;
function FCe(n, e) {
    e = RCe(e, n);
    for (var t = 0, r = e.length; n != null && t < r; )
        n = n[UCe(e[t++])];
    return t && t == r ? n : void 0
}
var JV = FCe
  , PCe = JV;
function LCe(n, e, t) {
    var r = n == null ? void 0 : PCe(n, e);
    return r === void 0 ? t : r
}
var DCe = LCe;
function NCe(n, e) {
    return n != null && e in Object(n)
}
var OCe = NCe
  , kCe = ZV
  , QCe = SV
  , HCe = ha
  , zCe = CV
  , GCe = x2
  , VCe = W1;
function jCe(n, e, t) {
    e = kCe(e, n);
    for (var r = -1, i = e.length, s = !1; ++r < i; ) {
        var o = VCe(e[r]);
        if (!(s = n != null && t(n, o)))
            break;
        n = n[o]
    }
    return s || ++r != i ? s : (i = n == null ? 0 : n.length,
    !!i && GCe(i) && zCe(o, i) && (HCe(n) || QCe(n)))
}
var WCe = jCe
  , KCe = OCe
  , XCe = WCe;
function YCe(n, e) {
    return n != null && XCe(n, e, KCe)
}
var $Ce = YCe
  , ZCe = WV
  , JCe = DCe
  , qCe = $Ce
  , eTe = P2
  , tTe = KV
  , nTe = XV
  , rTe = W1
  , iTe = 1
  , sTe = 2;
function oTe(n, e) {
    return eTe(n) && tTe(e) ? nTe(rTe(n), e) : function(t) {
        var r = JCe(t, n);
        return r === void 0 && r === e ? qCe(t, n) : ZCe(e, r, iTe | sTe)
    }
}
var aTe = oTe;
function lTe(n) {
    return function(e) {
        return e == null ? void 0 : e[n]
    }
}
var cTe = lTe
  , ATe = JV;
function uTe(n) {
    return function(e) {
        return ATe(e, n)
    }
}
var fTe = uTe
  , hTe = cTe
  , dTe = fTe
  , pTe = P2
  , mTe = W1;
function gTe(n) {
    return pTe(n) ? hTe(mTe(n)) : dTe(n)
}
var vTe = gTe
  , yTe = XSe
  , wTe = aTe
  , _Te = PV
  , xTe = ha
  , bTe = vTe;
function ETe(n) {
    return typeof n == "function" ? n : n == null ? _Te : typeof n == "object" ? xTe(n) ? wTe(n[0], n[1]) : yTe(n) : bTe(n)
}
var BTe = ETe
  , MTe = Q1;
function STe(n, e) {
    return function(t, r) {
        if (t == null)
            return t;
        if (!MTe(t))
            return n(t, r);
        for (var i = t.length, s = e ? i : -1, o = Object(t); (e ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
            ;
        return t
    }
}
var CTe = STe
  , TTe = FV
  , ITe = CTe
  , RTe = ITe(TTe)
  , UTe = RTe
  , FTe = UTe
  , PTe = Q1;
function LTe(n, e) {
    var t = -1
      , r = PTe(n) ? Array(n.length) : [];
    return FTe(n, function(i, s, o) {
        r[++t] = e(i, s, o)
    }),
    r
}
var DTe = LTe
  , NTe = DV
  , OTe = BTe
  , kTe = DTe
  , QTe = ha;
function HTe(n, e) {
    var t = QTe(n) ? NTe : kTe;
    return t(n, OTe(e))
}
var zTe = HTe;
Object.defineProperty(C0, "__esModule", {
    value: !0
});
C0.flattenNames = void 0;
var GTe = gxe
  , VTe = K1(GTe)
  , jTe = M2
  , WTe = K1(jTe)
  , KTe = bbe
  , XTe = K1(KTe)
  , YTe = zTe
  , $Te = K1(YTe);
function K1(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
var ZTe = C0.flattenNames = function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
      , t = [];
    return (0,
    $Te.default)(e, function(r) {
        Array.isArray(r) ? n(r).map(function(i) {
            return t.push(i)
        }) : (0,
        XTe.default)(r) ? (0,
        WTe.default)(r, function(i, s) {
            i === !0 && t.push(s),
            t.push(s + "-" + i)
        }) : (0,
        VTe.default)(r) && t.push(r)
    }),
    t
}
;
C0.default = ZTe;
var R0 = {};
function JTe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length; ++t < r && e(n[t], t, n) !== !1; )
        ;
    return n
}
var qTe = JTe
  , eIe = Ju
  , tIe = function() {
    try {
        var n = eIe(Object, "defineProperty");
        return n({}, "", {}),
        n
    } catch {}
}()
  , nIe = tIe
  , lk = nIe;
function rIe(n, e, t) {
    e == "__proto__" && lk ? lk(n, e, {
        configurable: !0,
        enumerable: !0,
        value: t,
        writable: !0
    }) : n[e] = t
}
var qV = rIe
  , iIe = qV
  , sIe = C2
  , oIe = Object.prototype
  , aIe = oIe.hasOwnProperty;
function lIe(n, e, t) {
    var r = n[e];
    (!(aIe.call(n, e) && sIe(r, t)) || t === void 0 && !(e in n)) && iIe(n, e, t)
}
var ej = lIe
  , cIe = ej
  , AIe = qV;
function uIe(n, e, t, r) {
    var i = !t;
    t || (t = {});
    for (var s = -1, o = e.length; ++s < o; ) {
        var a = e[s]
          , l = r ? r(t[a], n[a], a, t, n) : void 0;
        l === void 0 && (l = n[a]),
        i ? AIe(t, a, l) : cIe(t, a, l)
    }
    return t
}
var X1 = uIe
  , fIe = X1
  , hIe = I0;
function dIe(n, e) {
    return n && fIe(e, hIe(e), n)
}
var pIe = dIe;
function mIe(n) {
    var e = [];
    if (n != null)
        for (var t in Object(n))
            e.push(t);
    return e
}
var gIe = mIe
  , vIe = tp
  , yIe = B2
  , wIe = gIe
  , _Ie = Object.prototype
  , xIe = _Ie.hasOwnProperty;
function bIe(n) {
    if (!vIe(n))
        return wIe(n);
    var e = yIe(n)
      , t = [];
    for (var r in n)
        r == "constructor" && (e || !xIe.call(n, r)) || t.push(r);
    return t
}
var EIe = bIe
  , BIe = IV
  , MIe = EIe
  , SIe = Q1;
function CIe(n) {
    return SIe(n) ? BIe(n, !0) : MIe(n)
}
var D2 = CIe
  , TIe = X1
  , IIe = D2;
function RIe(n, e) {
    return n && TIe(e, IIe(e), n)
}
var UIe = RIe
  , gx = {
    exports: {}
};
gx.exports;
(function(n, e) {
    var t = ul
      , r = e && !e.nodeType && e
      , i = r && !0 && n && !n.nodeType && n
      , s = i && i.exports === r
      , o = s ? t.Buffer : void 0
      , a = o ? o.allocUnsafe : void 0;
    function l(c, A) {
        if (A)
            return c.slice();
        var u = c.length
          , f = a ? a(u) : new c.constructor(u);
        return c.copy(f),
        f
    }
    n.exports = l
}
)(gx, gx.exports);
var FIe = gx.exports;
function PIe(n, e) {
    var t = -1
      , r = n.length;
    for (e || (e = Array(r)); ++t < r; )
        e[t] = n[t];
    return e
}
var LIe = PIe
  , DIe = X1
  , NIe = U2;
function OIe(n, e) {
    return DIe(n, NIe(n), e)
}
var kIe = OIe
  , QIe = QV
  , HIe = S2
  , zIe = U2
  , GIe = zV
  , VIe = Object.getOwnPropertySymbols
  , jIe = VIe ? function(n) {
    for (var e = []; n; )
        QIe(e, zIe(n)),
        n = HIe(n);
    return e
}
: GIe
  , tj = jIe
  , WIe = X1
  , KIe = tj;
function XIe(n, e) {
    return WIe(n, KIe(n), e)
}
var YIe = XIe
  , $Ie = HV
  , ZIe = tj
  , JIe = D2;
function qIe(n) {
    return $Ie(n, JIe, ZIe)
}
var eRe = qIe
  , tRe = Object.prototype
  , nRe = tRe.hasOwnProperty;
function rRe(n) {
    var e = n.length
      , t = new n.constructor(e);
    return e && typeof n[0] == "string" && nRe.call(n, "index") && (t.index = n.index,
    t.input = n.input),
    t
}
var iRe = rRe
  , ck = kV;
function sRe(n) {
    var e = new n.constructor(n.byteLength);
    return new ck(e).set(new ck(n)),
    e
}
var N2 = sRe
  , oRe = N2;
function aRe(n, e) {
    var t = e ? oRe(n.buffer) : n.buffer;
    return new n.constructor(t,n.byteOffset,n.byteLength)
}
var lRe = aRe
  , cRe = /\w*$/;
function ARe(n) {
    var e = new n.constructor(n.source,cRe.exec(n));
    return e.lastIndex = n.lastIndex,
    e
}
var uRe = ARe
  , Ak = T0
  , uk = Ak ? Ak.prototype : void 0
  , fk = uk ? uk.valueOf : void 0;
function fRe(n) {
    return fk ? Object(fk.call(n)) : {}
}
var hRe = fRe
  , dRe = N2;
function pRe(n, e) {
    var t = e ? dRe(n.buffer) : n.buffer;
    return new n.constructor(t,n.byteOffset,n.length)
}
var mRe = pRe
  , gRe = N2
  , vRe = lRe
  , yRe = uRe
  , wRe = hRe
  , _Re = mRe
  , xRe = "[object Boolean]"
  , bRe = "[object Date]"
  , ERe = "[object Map]"
  , BRe = "[object Number]"
  , MRe = "[object RegExp]"
  , SRe = "[object Set]"
  , CRe = "[object String]"
  , TRe = "[object Symbol]"
  , IRe = "[object ArrayBuffer]"
  , RRe = "[object DataView]"
  , URe = "[object Float32Array]"
  , FRe = "[object Float64Array]"
  , PRe = "[object Int8Array]"
  , LRe = "[object Int16Array]"
  , DRe = "[object Int32Array]"
  , NRe = "[object Uint8Array]"
  , ORe = "[object Uint8ClampedArray]"
  , kRe = "[object Uint16Array]"
  , QRe = "[object Uint32Array]";
function HRe(n, e, t) {
    var r = n.constructor;
    switch (e) {
    case IRe:
        return gRe(n);
    case xRe:
    case bRe:
        return new r(+n);
    case RRe:
        return vRe(n, t);
    case URe:
    case FRe:
    case PRe:
    case LRe:
    case DRe:
    case NRe:
    case ORe:
    case kRe:
    case QRe:
        return _Re(n, t);
    case ERe:
        return new r;
    case BRe:
    case CRe:
        return new r(n);
    case MRe:
        return yRe(n);
    case SRe:
        return new r;
    case TRe:
        return wRe(n)
    }
}
var zRe = HRe
  , GRe = tp
  , hk = Object.create
  , VRe = function() {
    function n() {}
    return function(e) {
        if (!GRe(e))
            return {};
        if (hk)
            return hk(e);
        n.prototype = e;
        var t = new n;
        return n.prototype = void 0,
        t
    }
}()
  , jRe = VRe
  , WRe = jRe
  , KRe = S2
  , XRe = B2;
function YRe(n) {
    return typeof n.constructor == "function" && !XRe(n) ? WRe(KRe(n)) : {}
}
var $Re = YRe
  , ZRe = j1
  , JRe = uc
  , qRe = "[object Map]";
function e2e(n) {
    return JRe(n) && ZRe(n) == qRe
}
var t2e = e2e
  , n2e = t2e
  , r2e = b2
  , dk = E2
  , pk = dk && dk.isMap
  , i2e = pk ? r2e(pk) : n2e
  , s2e = i2e
  , o2e = j1
  , a2e = uc
  , l2e = "[object Set]";
function c2e(n) {
    return a2e(n) && o2e(n) == l2e
}
var A2e = c2e
  , u2e = A2e
  , f2e = b2
  , mk = E2
  , gk = mk && mk.isSet
  , h2e = gk ? f2e(gk) : u2e
  , d2e = h2e
  , p2e = R2
  , m2e = qTe
  , g2e = ej
  , v2e = pIe
  , y2e = UIe
  , w2e = FIe
  , _2e = LIe
  , x2e = kIe
  , b2e = YIe
  , E2e = GV
  , B2e = eRe
  , M2e = j1
  , S2e = iRe
  , C2e = zRe
  , T2e = $Re
  , I2e = ha
  , R2e = _2
  , U2e = s2e
  , F2e = tp
  , P2e = d2e
  , L2e = I0
  , D2e = D2
  , N2e = 1
  , O2e = 2
  , k2e = 4
  , nj = "[object Arguments]"
  , Q2e = "[object Array]"
  , H2e = "[object Boolean]"
  , z2e = "[object Date]"
  , G2e = "[object Error]"
  , rj = "[object Function]"
  , V2e = "[object GeneratorFunction]"
  , j2e = "[object Map]"
  , W2e = "[object Number]"
  , ij = "[object Object]"
  , K2e = "[object RegExp]"
  , X2e = "[object Set]"
  , Y2e = "[object String]"
  , $2e = "[object Symbol]"
  , Z2e = "[object WeakMap]"
  , J2e = "[object ArrayBuffer]"
  , q2e = "[object DataView]"
  , eUe = "[object Float32Array]"
  , tUe = "[object Float64Array]"
  , nUe = "[object Int8Array]"
  , rUe = "[object Int16Array]"
  , iUe = "[object Int32Array]"
  , sUe = "[object Uint8Array]"
  , oUe = "[object Uint8ClampedArray]"
  , aUe = "[object Uint16Array]"
  , lUe = "[object Uint32Array]"
  , wn = {};
wn[nj] = wn[Q2e] = wn[J2e] = wn[q2e] = wn[H2e] = wn[z2e] = wn[eUe] = wn[tUe] = wn[nUe] = wn[rUe] = wn[iUe] = wn[j2e] = wn[W2e] = wn[ij] = wn[K2e] = wn[X2e] = wn[Y2e] = wn[$2e] = wn[sUe] = wn[oUe] = wn[aUe] = wn[lUe] = !0;
wn[G2e] = wn[rj] = wn[Z2e] = !1;
function Qw(n, e, t, r, i, s) {
    var o, a = e & N2e, l = e & O2e, c = e & k2e;
    if (t && (o = i ? t(n, r, i, s) : t(n)),
    o !== void 0)
        return o;
    if (!F2e(n))
        return n;
    var A = I2e(n);
    if (A) {
        if (o = S2e(n),
        !a)
            return _2e(n, o)
    } else {
        var u = M2e(n)
          , f = u == rj || u == V2e;
        if (R2e(n))
            return w2e(n, a);
        if (u == ij || u == nj || f && !i) {
            if (o = l || f ? {} : T2e(n),
            !a)
                return l ? b2e(n, y2e(o, n)) : x2e(n, v2e(o, n))
        } else {
            if (!wn[u])
                return i ? n : {};
            o = C2e(n, u, a)
        }
    }
    s || (s = new p2e);
    var h = s.get(n);
    if (h)
        return h;
    s.set(n, o),
    P2e(n) ? n.forEach(function(g) {
        o.add(Qw(g, e, t, g, n, s))
    }) : U2e(n) && n.forEach(function(g, p) {
        o.set(p, Qw(g, e, t, p, n, s))
    });
    var d = c ? l ? B2e : E2e : l ? D2e : L2e
      , m = A ? void 0 : d(n);
    return m2e(m || n, function(g, p) {
        m && (p = g,
        g = n[p]),
        g2e(o, p, Qw(g, e, t, p, n, s))
    }),
    o
}
var cUe = Qw
  , AUe = cUe
  , uUe = 1
  , fUe = 4;
function hUe(n) {
    return AUe(n, uUe | fUe)
}
var dUe = hUe;
Object.defineProperty(R0, "__esModule", {
    value: !0
});
R0.mergeClasses = void 0;
var pUe = M2
  , mUe = sj(pUe)
  , gUe = dUe
  , vUe = sj(gUe)
  , yUe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
;
function sj(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
var wUe = R0.mergeClasses = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
      , r = e.default && (0,
    vUe.default)(e.default) || {};
    return t.map(function(i) {
        var s = e[i];
        return s && (0,
        mUe.default)(s, function(o, a) {
            r[a] || (r[a] = {}),
            r[a] = yUe({}, r[a], s[a])
        }),
        i
    }),
    r
}
;
R0.default = wUe;
var U0 = {};
Object.defineProperty(U0, "__esModule", {
    value: !0
});
U0.autoprefix = void 0;
var _Ue = M2
  , vk = bUe(_Ue)
  , xUe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
;
function bUe(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
var EUe = {
    borderRadius: function(e) {
        return {
            msBorderRadius: e,
            MozBorderRadius: e,
            OBorderRadius: e,
            WebkitBorderRadius: e,
            borderRadius: e
        }
    },
    boxShadow: function(e) {
        return {
            msBoxShadow: e,
            MozBoxShadow: e,
            OBoxShadow: e,
            WebkitBoxShadow: e,
            boxShadow: e
        }
    },
    userSelect: function(e) {
        return {
            WebkitTouchCallout: e,
            KhtmlUserSelect: e,
            MozUserSelect: e,
            msUserSelect: e,
            WebkitUserSelect: e,
            userSelect: e
        }
    },
    flex: function(e) {
        return {
            WebkitBoxFlex: e,
            MozBoxFlex: e,
            WebkitFlex: e,
            msFlex: e,
            flex: e
        }
    },
    flexBasis: function(e) {
        return {
            WebkitFlexBasis: e,
            flexBasis: e
        }
    },
    justifyContent: function(e) {
        return {
            WebkitJustifyContent: e,
            justifyContent: e
        }
    },
    transition: function(e) {
        return {
            msTransition: e,
            MozTransition: e,
            OTransition: e,
            WebkitTransition: e,
            transition: e
        }
    },
    transform: function(e) {
        return {
            msTransform: e,
            MozTransform: e,
            OTransform: e,
            WebkitTransform: e,
            transform: e
        }
    },
    absolute: function(e) {
        var t = e && e.split(" ");
        return {
            position: "absolute",
            top: t && t[0],
            right: t && t[1],
            bottom: t && t[2],
            left: t && t[3]
        }
    },
    extend: function(e, t) {
        var r = t[e];
        return r || {
            extend: e
        }
    }
}
  , BUe = U0.autoprefix = function(e) {
    var t = {};
    return (0,
    vk.default)(e, function(r, i) {
        var s = {};
        (0,
        vk.default)(r, function(o, a) {
            var l = EUe[a];
            l ? s = xUe({}, s, l(o)) : s[a] = o
        }),
        t[i] = s
    }),
    t
}
;
U0.default = BUe;
var F0 = {};
Object.defineProperty(F0, "__esModule", {
    value: !0
});
F0.hover = void 0;
var MUe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , SUe = be
  , dM = CUe(SUe);
function CUe(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function TUe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function yk(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function IUe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var RUe = F0.hover = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
    return function(r) {
        IUe(i, r);
        function i() {
            var s, o, a, l;
            TUe(this, i);
            for (var c = arguments.length, A = Array(c), u = 0; u < c; u++)
                A[u] = arguments[u];
            return l = (o = (a = yk(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(A))),
            a),
            a.state = {
                hover: !1
            },
            a.handleMouseOver = function() {
                return a.setState({
                    hover: !0
                })
            }
            ,
            a.handleMouseOut = function() {
                return a.setState({
                    hover: !1
                })
            }
            ,
            a.render = function() {
                return dM.default.createElement(t, {
                    onMouseOver: a.handleMouseOver,
                    onMouseOut: a.handleMouseOut
                }, dM.default.createElement(e, MUe({}, a.props, a.state)))
            }
            ,
            o),
            yk(a, l)
        }
        return i
    }(dM.default.Component)
}
;
F0.default = RUe;
var P0 = {};
Object.defineProperty(P0, "__esModule", {
    value: !0
});
P0.active = void 0;
var UUe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , FUe = be
  , pM = PUe(FUe);
function PUe(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function LUe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function wk(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function DUe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var NUe = P0.active = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
    return function(r) {
        DUe(i, r);
        function i() {
            var s, o, a, l;
            LUe(this, i);
            for (var c = arguments.length, A = Array(c), u = 0; u < c; u++)
                A[u] = arguments[u];
            return l = (o = (a = wk(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(A))),
            a),
            a.state = {
                active: !1
            },
            a.handleMouseDown = function() {
                return a.setState({
                    active: !0
                })
            }
            ,
            a.handleMouseUp = function() {
                return a.setState({
                    active: !1
                })
            }
            ,
            a.render = function() {
                return pM.default.createElement(t, {
                    onMouseDown: a.handleMouseDown,
                    onMouseUp: a.handleMouseUp
                }, pM.default.createElement(e, UUe({}, a.props, a.state)))
            }
            ,
            o),
            wk(a, l)
        }
        return i
    }(pM.default.Component)
}
;
P0.default = NUe;
var O2 = {};
Object.defineProperty(O2, "__esModule", {
    value: !0
});
var OUe = function(e, t) {
    var r = {}
      , i = function(o) {
        var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        r[o] = a
    };
    return e === 0 && i("first-child"),
    e === t - 1 && i("last-child"),
    (e === 0 || e % 2 === 0) && i("even"),
    Math.abs(e % 2) === 1 && i("odd"),
    i("nth-child", e),
    r
};
O2.default = OUe;
Object.defineProperty(lo, "__esModule", {
    value: !0
});
lo.ReactCSS = lo.loop = lo.handleActive = k2 = lo.handleHover = lo.hover = void 0;
var kUe = C0
  , QUe = ap(kUe)
  , HUe = R0
  , zUe = ap(HUe)
  , GUe = U0
  , VUe = ap(GUe)
  , jUe = F0
  , oj = ap(jUe)
  , WUe = P0
  , KUe = ap(WUe)
  , XUe = O2
  , YUe = ap(XUe);
function ap(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
lo.hover = oj.default;
var k2 = lo.handleHover = oj.default;
lo.handleActive = KUe.default;
lo.loop = YUe.default;
var $Ue = lo.ReactCSS = function(e) {
    for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
        r[i - 1] = arguments[i];
    var s = (0,
    QUe.default)(r)
      , o = (0,
    zUe.default)(e, s);
    return (0,
    VUe.default)(o)
}
  , vt = lo.default = $Ue
  , ZUe = function(e, t, r, i, s) {
    var o = s.clientWidth
      , a = s.clientHeight
      , l = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX
      , c = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY
      , A = l - (s.getBoundingClientRect().left + window.pageXOffset)
      , u = c - (s.getBoundingClientRect().top + window.pageYOffset);
    if (r === "vertical") {
        var f = void 0;
        if (u < 0 ? f = 0 : u > a ? f = 1 : f = Math.round(u * 100 / a) / 100,
        t.a !== f)
            return {
                h: t.h,
                s: t.s,
                l: t.l,
                a: f,
                source: "rgb"
            }
    } else {
        var h = void 0;
        if (A < 0 ? h = 0 : A > o ? h = 1 : h = Math.round(A * 100 / o) / 100,
        i !== h)
            return {
                h: t.h,
                s: t.s,
                l: t.l,
                a: h,
                source: "rgb"
            }
    }
    return null
}
  , mM = {}
  , JUe = function(e, t, r, i) {
    if (typeof document > "u" && !i)
        return null;
    var s = i ? new i : document.createElement("canvas");
    s.width = r * 2,
    s.height = r * 2;
    var o = s.getContext("2d");
    return o ? (o.fillStyle = e,
    o.fillRect(0, 0, s.width, s.height),
    o.fillStyle = t,
    o.fillRect(0, 0, r, r),
    o.translate(r, r),
    o.fillRect(0, 0, r, r),
    s.toDataURL()) : null
}
  , qUe = function(e, t, r, i) {
    var s = e + "-" + t + "-" + r + (i ? "-server" : "");
    if (mM[s])
        return mM[s];
    var o = JUe(e, t, r, i);
    return mM[s] = o,
    o
}
  , _k = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , lp = function(e) {
    var t = e.white
      , r = e.grey
      , i = e.size
      , s = e.renderers
      , o = e.borderRadius
      , a = e.boxShadow
      , l = e.children
      , c = vt({
        default: {
            grid: {
                borderRadius: o,
                boxShadow: a,
                absolute: "0px 0px 0px 0px",
                background: "url(" + qUe(t, r, i, s.canvas) + ") center left"
            }
        }
    });
    return be.isValidElement(l) ? Z.cloneElement(l, _k({}, l.props, {
        style: _k({}, l.props.style, c.grid)
    })) : Z.createElement("div", {
        style: c.grid
    })
};
lp.defaultProps = {
    size: 8,
    white: "transparent",
    grey: "rgba(0,0,0,.08)",
    renderers: {}
};
var eFe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , tFe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function nFe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function xk(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function rFe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var Q2 = function(n) {
    rFe(e, n);
    function e() {
        var t, r, i, s;
        nFe(this, e);
        for (var o = arguments.length, a = Array(o), l = 0; l < o; l++)
            a[l] = arguments[l];
        return s = (r = (i = xk(this, (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(t, [this].concat(a))),
        i),
        i.handleChange = function(c) {
            var A = ZUe(c, i.props.hsl, i.props.direction, i.props.a, i.container);
            A && typeof i.props.onChange == "function" && i.props.onChange(A, c)
        }
        ,
        i.handleMouseDown = function(c) {
            i.handleChange(c),
            window.addEventListener("mousemove", i.handleChange),
            window.addEventListener("mouseup", i.handleMouseUp)
        }
        ,
        i.handleMouseUp = function() {
            i.unbindEventListeners()
        }
        ,
        i.unbindEventListeners = function() {
            window.removeEventListener("mousemove", i.handleChange),
            window.removeEventListener("mouseup", i.handleMouseUp)
        }
        ,
        r),
        xk(i, s)
    }
    return tFe(e, [{
        key: "componentWillUnmount",
        value: function() {
            this.unbindEventListeners()
        }
    }, {
        key: "render",
        value: function() {
            var r = this
              , i = this.props.rgb
              , s = vt({
                default: {
                    alpha: {
                        absolute: "0px 0px 0px 0px",
                        borderRadius: this.props.radius
                    },
                    checkboard: {
                        absolute: "0px 0px 0px 0px",
                        overflow: "hidden",
                        borderRadius: this.props.radius
                    },
                    gradient: {
                        absolute: "0px 0px 0px 0px",
                        background: "linear-gradient(to right, rgba(" + i.r + "," + i.g + "," + i.b + `, 0) 0%,
           rgba(` + i.r + "," + i.g + "," + i.b + ", 1) 100%)",
                        boxShadow: this.props.shadow,
                        borderRadius: this.props.radius
                    },
                    container: {
                        position: "relative",
                        height: "100%",
                        margin: "0 3px"
                    },
                    pointer: {
                        position: "absolute",
                        left: i.a * 100 + "%"
                    },
                    slider: {
                        width: "4px",
                        borderRadius: "1px",
                        height: "8px",
                        boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                        background: "#fff",
                        marginTop: "1px",
                        transform: "translateX(-2px)"
                    }
                },
                vertical: {
                    gradient: {
                        background: "linear-gradient(to bottom, rgba(" + i.r + "," + i.g + "," + i.b + `, 0) 0%,
           rgba(` + i.r + "," + i.g + "," + i.b + ", 1) 100%)"
                    },
                    pointer: {
                        left: 0,
                        top: i.a * 100 + "%"
                    }
                },
                overwrite: eFe({}, this.props.style)
            }, {
                vertical: this.props.direction === "vertical",
                overwrite: !0
            });
            return Z.createElement("div", {
                style: s.alpha
            }, Z.createElement("div", {
                style: s.checkboard
            }, Z.createElement(lp, {
                renderers: this.props.renderers
            })), Z.createElement("div", {
                style: s.gradient
            }), Z.createElement("div", {
                style: s.container,
                ref: function(a) {
                    return r.container = a
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
            }, Z.createElement("div", {
                style: s.pointer
            }, this.props.pointer ? Z.createElement(this.props.pointer, this.props) : Z.createElement("div", {
                style: s.slider
            }))))
        }
    }]),
    e
}(be.PureComponent || be.Component)
  , iFe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function sFe(n, e, t) {
    return e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function oFe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function aFe(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function lFe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var cFe = 1
  , aj = 38
  , AFe = 40
  , uFe = [aj, AFe]
  , fFe = function(e) {
    return uFe.indexOf(e) > -1
}
  , hFe = function(e) {
    return Number(String(e).replace(/%/g, ""))
}
  , dFe = 1
  , Ht = function(n) {
    lFe(e, n);
    function e(t) {
        oFe(this, e);
        var r = aFe(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
        return r.handleBlur = function() {
            r.state.blurValue && r.setState({
                value: r.state.blurValue,
                blurValue: null
            })
        }
        ,
        r.handleChange = function(i) {
            r.setUpdatedValue(i.target.value, i)
        }
        ,
        r.handleKeyDown = function(i) {
            var s = hFe(i.target.value);
            if (!isNaN(s) && fFe(i.keyCode)) {
                var o = r.getArrowOffset()
                  , a = i.keyCode === aj ? s + o : s - o;
                r.setUpdatedValue(a, i)
            }
        }
        ,
        r.handleDrag = function(i) {
            if (r.props.dragLabel) {
                var s = Math.round(r.props.value + i.movementX);
                s >= 0 && s <= r.props.dragMax && r.props.onChange && r.props.onChange(r.getValueObjectWithLabel(s), i)
            }
        }
        ,
        r.handleMouseDown = function(i) {
            r.props.dragLabel && (i.preventDefault(),
            r.handleDrag(i),
            window.addEventListener("mousemove", r.handleDrag),
            window.addEventListener("mouseup", r.handleMouseUp))
        }
        ,
        r.handleMouseUp = function() {
            r.unbindEventListeners()
        }
        ,
        r.unbindEventListeners = function() {
            window.removeEventListener("mousemove", r.handleDrag),
            window.removeEventListener("mouseup", r.handleMouseUp)
        }
        ,
        r.state = {
            value: String(t.value).toUpperCase(),
            blurValue: String(t.value).toUpperCase()
        },
        r.inputId = "rc-editable-input-" + dFe++,
        r
    }
    return iFe(e, [{
        key: "componentDidUpdate",
        value: function(r, i) {
            this.props.value !== this.state.value && (r.value !== this.props.value || i.value !== this.state.value) && (this.input === document.activeElement ? this.setState({
                blurValue: String(this.props.value).toUpperCase()
            }) : this.setState({
                value: String(this.props.value).toUpperCase(),
                blurValue: !this.state.blurValue && String(this.props.value).toUpperCase()
            }))
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            this.unbindEventListeners()
        }
    }, {
        key: "getValueObjectWithLabel",
        value: function(r) {
            return sFe({}, this.props.label, r)
        }
    }, {
        key: "getArrowOffset",
        value: function() {
            return this.props.arrowOffset || cFe
        }
    }, {
        key: "setUpdatedValue",
        value: function(r, i) {
            var s = this.props.label ? this.getValueObjectWithLabel(r) : r;
            this.props.onChange && this.props.onChange(s, i),
            this.setState({
                value: r
            })
        }
    }, {
        key: "render",
        value: function() {
            var r = this
              , i = vt({
                default: {
                    wrap: {
                        position: "relative"
                    }
                },
                "user-override": {
                    wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
                    input: this.props.style && this.props.style.input ? this.props.style.input : {},
                    label: this.props.style && this.props.style.label ? this.props.style.label : {}
                },
                "dragLabel-true": {
                    label: {
                        cursor: "ew-resize"
                    }
                }
            }, {
                "user-override": !0
            }, this.props);
            return Z.createElement("div", {
                style: i.wrap
            }, Z.createElement("input", {
                id: this.inputId,
                style: i.input,
                ref: function(o) {
                    return r.input = o
                },
                value: this.state.value,
                onKeyDown: this.handleKeyDown,
                onChange: this.handleChange,
                onBlur: this.handleBlur,
                placeholder: this.props.placeholder,
                spellCheck: "false"
            }), this.props.label && !this.props.hideLabel ? Z.createElement("label", {
                htmlFor: this.inputId,
                style: i.label,
                onMouseDown: this.handleMouseDown
            }, this.props.label) : null)
        }
    }]),
    e
}(be.PureComponent || be.Component)
  , pFe = function(e, t, r, i) {
    var s = i.clientWidth
      , o = i.clientHeight
      , a = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX
      , l = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY
      , c = a - (i.getBoundingClientRect().left + window.pageXOffset)
      , A = l - (i.getBoundingClientRect().top + window.pageYOffset);
    if (t === "vertical") {
        var u = void 0;
        if (A < 0)
            u = 359;
        else if (A > o)
            u = 0;
        else {
            var f = -(A * 100 / o) + 100;
            u = 360 * f / 100
        }
        if (r.h !== u)
            return {
                h: u,
                s: r.s,
                l: r.l,
                a: r.a,
                source: "hsl"
            }
    } else {
        var h = void 0;
        if (c < 0)
            h = 0;
        else if (c > s)
            h = 359;
        else {
            var d = c * 100 / s;
            h = 360 * d / 100
        }
        if (r.h !== h)
            return {
                h,
                s: r.s,
                l: r.l,
                a: r.a,
                source: "hsl"
            }
    }
    return null
}
  , mFe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function gFe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function bk(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function vFe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var cp = function(n) {
    vFe(e, n);
    function e() {
        var t, r, i, s;
        gFe(this, e);
        for (var o = arguments.length, a = Array(o), l = 0; l < o; l++)
            a[l] = arguments[l];
        return s = (r = (i = bk(this, (t = e.__proto__ || Object.getPrototypeOf(e)).call.apply(t, [this].concat(a))),
        i),
        i.handleChange = function(c) {
            var A = pFe(c, i.props.direction, i.props.hsl, i.container);
            A && typeof i.props.onChange == "function" && i.props.onChange(A, c)
        }
        ,
        i.handleMouseDown = function(c) {
            i.handleChange(c),
            window.addEventListener("mousemove", i.handleChange),
            window.addEventListener("mouseup", i.handleMouseUp)
        }
        ,
        i.handleMouseUp = function() {
            i.unbindEventListeners()
        }
        ,
        r),
        bk(i, s)
    }
    return mFe(e, [{
        key: "componentWillUnmount",
        value: function() {
            this.unbindEventListeners()
        }
    }, {
        key: "unbindEventListeners",
        value: function() {
            window.removeEventListener("mousemove", this.handleChange),
            window.removeEventListener("mouseup", this.handleMouseUp)
        }
    }, {
        key: "render",
        value: function() {
            var r = this
              , i = this.props.direction
              , s = i === void 0 ? "horizontal" : i
              , o = vt({
                default: {
                    hue: {
                        absolute: "0px 0px 0px 0px",
                        borderRadius: this.props.radius,
                        boxShadow: this.props.shadow
                    },
                    container: {
                        padding: "0 2px",
                        position: "relative",
                        height: "100%",
                        borderRadius: this.props.radius
                    },
                    pointer: {
                        position: "absolute",
                        left: this.props.hsl.h * 100 / 360 + "%"
                    },
                    slider: {
                        marginTop: "1px",
                        width: "4px",
                        borderRadius: "1px",
                        height: "8px",
                        boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                        background: "#fff",
                        transform: "translateX(-2px)"
                    }
                },
                vertical: {
                    pointer: {
                        left: "0px",
                        top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
                    }
                }
            }, {
                vertical: s === "vertical"
            });
            return Z.createElement("div", {
                style: o.hue
            }, Z.createElement("div", {
                className: "hue-" + s,
                style: o.container,
                ref: function(l) {
                    return r.container = l
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
            }, Z.createElement("style", null, `
            .hue-horizontal {
              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0
                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
              background: -webkit-linear-gradient(to right, #f00 0%, #ff0
                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
            }

            .hue-vertical {
              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,
                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,
                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);
            }
          `), Z.createElement("div", {
                style: o.pointer
            }, this.props.pointer ? Z.createElement(this.props.pointer, this.props) : Z.createElement("div", {
                style: o.slider
            }))))
        }
    }]),
    e
}(be.PureComponent || be.Component)
  , lj = {
    exports: {}
}
  , yFe = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , wFe = yFe
  , _Fe = wFe;
function cj() {}
function Aj() {}
Aj.resetWarningCache = cj;
var xFe = function() {
    function n(r, i, s, o, a, l) {
        if (l !== _Fe) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation",
            c
        }
    }
    n.isRequired = n;
    function e() {
        return n
    }
    var t = {
        array: n,
        bigint: n,
        bool: n,
        func: n,
        number: n,
        object: n,
        string: n,
        symbol: n,
        any: n,
        arrayOf: e,
        element: n,
        elementType: n,
        instanceOf: e,
        node: n,
        objectOf: e,
        oneOf: e,
        oneOfType: e,
        shape: e,
        exact: e,
        checkPropTypes: Aj,
        resetWarningCache: cj
    };
    return t.PropTypes = t,
    t
};
lj.exports = xFe();
var bFe = lj.exports;
const Ve = oc(bFe);
function EFe() {
    this.__data__ = [],
    this.size = 0
}
function L0(n, e) {
    return n === e || n !== n && e !== e
}
function Y1(n, e) {
    for (var t = n.length; t--; )
        if (L0(n[t][0], e))
            return t;
    return -1
}
var BFe = Array.prototype
  , MFe = BFe.splice;
function SFe(n) {
    var e = this.__data__
      , t = Y1(e, n);
    if (t < 0)
        return !1;
    var r = e.length - 1;
    return t == r ? e.pop() : MFe.call(e, t, 1),
    --this.size,
    !0
}
function CFe(n) {
    var e = this.__data__
      , t = Y1(e, n);
    return t < 0 ? void 0 : e[t][1]
}
function TFe(n) {
    return Y1(this.__data__, n) > -1
}
function IFe(n, e) {
    var t = this.__data__
      , r = Y1(t, n);
    return r < 0 ? (++this.size,
    t.push([n, e])) : t[r][1] = e,
    this
}
function fc(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
fc.prototype.clear = EFe;
fc.prototype.delete = SFe;
fc.prototype.get = CFe;
fc.prototype.has = TFe;
fc.prototype.set = IFe;
function RFe() {
    this.__data__ = new fc,
    this.size = 0
}
function UFe(n) {
    var e = this.__data__
      , t = e.delete(n);
    return this.size = e.size,
    t
}
function FFe(n) {
    return this.__data__.get(n)
}
function PFe(n) {
    return this.__data__.has(n)
}
var LFe = typeof global == "object" && global && global.Object === Object && global;
const uj = LFe;
var DFe = typeof self == "object" && self && self.Object === Object && self
  , NFe = uj || DFe || Function("return this")();
const da = NFe;
var OFe = da.Symbol;
const EA = OFe;
var fj = Object.prototype
  , kFe = fj.hasOwnProperty
  , QFe = fj.toString
  , Am = EA ? EA.toStringTag : void 0;
function HFe(n) {
    var e = kFe.call(n, Am)
      , t = n[Am];
    try {
        n[Am] = void 0;
        var r = !0
    } catch {}
    var i = QFe.call(n);
    return r && (e ? n[Am] = t : delete n[Am]),
    i
}
var zFe = Object.prototype
  , GFe = zFe.toString;
function VFe(n) {
    return GFe.call(n)
}
var jFe = "[object Null]"
  , WFe = "[object Undefined]"
  , Ek = EA ? EA.toStringTag : void 0;
function qu(n) {
    return n == null ? n === void 0 ? WFe : jFe : Ek && Ek in Object(n) ? HFe(n) : VFe(n)
}
function Eo(n) {
    var e = typeof n;
    return n != null && (e == "object" || e == "function")
}
var KFe = "[object AsyncFunction]"
  , XFe = "[object Function]"
  , YFe = "[object GeneratorFunction]"
  , $Fe = "[object Proxy]";
function H2(n) {
    if (!Eo(n))
        return !1;
    var e = qu(n);
    return e == XFe || e == YFe || e == KFe || e == $Fe
}
var ZFe = da["__core-js_shared__"];
const gM = ZFe;
var Bk = function() {
    var n = /[^.]+$/.exec(gM && gM.keys && gM.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : ""
}();
function JFe(n) {
    return !!Bk && Bk in n
}
var qFe = Function.prototype
  , ePe = qFe.toString;
function ef(n) {
    if (n != null) {
        try {
            return ePe.call(n)
        } catch {}
        try {
            return n + ""
        } catch {}
    }
    return ""
}
var tPe = /[\\^$.*+?()[\]{}|]/g
  , nPe = /^\[object .+?Constructor\]$/
  , rPe = Function.prototype
  , iPe = Object.prototype
  , sPe = rPe.toString
  , oPe = iPe.hasOwnProperty
  , aPe = RegExp("^" + sPe.call(oPe).replace(tPe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function lPe(n) {
    if (!Eo(n) || JFe(n))
        return !1;
    var e = H2(n) ? aPe : nPe;
    return e.test(ef(n))
}
function cPe(n, e) {
    return n == null ? void 0 : n[e]
}
function tf(n, e) {
    var t = cPe(n, e);
    return lPe(t) ? t : void 0
}
var APe = tf(da, "Map");
const qg = APe;
var uPe = tf(Object, "create");
const e0 = uPe;
function fPe() {
    this.__data__ = e0 ? e0(null) : {},
    this.size = 0
}
function hPe(n) {
    var e = this.has(n) && delete this.__data__[n];
    return this.size -= e ? 1 : 0,
    e
}
var dPe = "__lodash_hash_undefined__"
  , pPe = Object.prototype
  , mPe = pPe.hasOwnProperty;
function gPe(n) {
    var e = this.__data__;
    if (e0) {
        var t = e[n];
        return t === dPe ? void 0 : t
    }
    return mPe.call(e, n) ? e[n] : void 0
}
var vPe = Object.prototype
  , yPe = vPe.hasOwnProperty;
function wPe(n) {
    var e = this.__data__;
    return e0 ? e[n] !== void 0 : yPe.call(e, n)
}
var _Pe = "__lodash_hash_undefined__";
function xPe(n, e) {
    var t = this.__data__;
    return this.size += this.has(n) ? 0 : 1,
    t[n] = e0 && e === void 0 ? _Pe : e,
    this
}
function Hu(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
Hu.prototype.clear = fPe;
Hu.prototype.delete = hPe;
Hu.prototype.get = gPe;
Hu.prototype.has = wPe;
Hu.prototype.set = xPe;
function bPe() {
    this.size = 0,
    this.__data__ = {
        hash: new Hu,
        map: new (qg || fc),
        string: new Hu
    }
}
function EPe(n) {
    var e = typeof n;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null
}
function $1(n, e) {
    var t = n.__data__;
    return EPe(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map
}
function BPe(n) {
    var e = $1(this, n).delete(n);
    return this.size -= e ? 1 : 0,
    e
}
function MPe(n) {
    return $1(this, n).get(n)
}
function SPe(n) {
    return $1(this, n).has(n)
}
function CPe(n, e) {
    var t = $1(this, n)
      , r = t.size;
    return t.set(n, e),
    this.size += t.size == r ? 0 : 1,
    this
}
function hc(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.clear(); ++e < t; ) {
        var r = n[e];
        this.set(r[0], r[1])
    }
}
hc.prototype.clear = bPe;
hc.prototype.delete = BPe;
hc.prototype.get = MPe;
hc.prototype.has = SPe;
hc.prototype.set = CPe;
var TPe = 200;
function IPe(n, e) {
    var t = this.__data__;
    if (t instanceof fc) {
        var r = t.__data__;
        if (!qg || r.length < TPe - 1)
            return r.push([n, e]),
            this.size = ++t.size,
            this;
        t = this.__data__ = new hc(r)
    }
    return t.set(n, e),
    this.size = t.size,
    this
}
function Ya(n) {
    var e = this.__data__ = new fc(n);
    this.size = e.size
}
Ya.prototype.clear = RFe;
Ya.prototype.delete = UFe;
Ya.prototype.get = FFe;
Ya.prototype.has = PFe;
Ya.prototype.set = IPe;
var RPe = function() {
    try {
        var n = tf(Object, "defineProperty");
        return n({}, "", {}),
        n
    } catch {}
}();
const vx = RPe;
function z2(n, e, t) {
    e == "__proto__" && vx ? vx(n, e, {
        configurable: !0,
        enumerable: !0,
        value: t,
        writable: !0
    }) : n[e] = t
}
function QT(n, e, t) {
    (t !== void 0 && !L0(n[e], t) || t === void 0 && !(e in n)) && z2(n, e, t)
}
function UPe(n) {
    return function(e, t, r) {
        for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
            var l = o[n ? a : ++i];
            if (t(s[l], l, s) === !1)
                break
        }
        return e
    }
}
var FPe = UPe();
const hj = FPe;
var dj = typeof exports == "object" && exports && !exports.nodeType && exports
  , Mk = dj && typeof module == "object" && module && !module.nodeType && module
  , PPe = Mk && Mk.exports === dj
  , Sk = PPe ? da.Buffer : void 0
  , Ck = Sk ? Sk.allocUnsafe : void 0;
function LPe(n, e) {
    if (e)
        return n.slice();
    var t = n.length
      , r = Ck ? Ck(t) : new n.constructor(t);
    return n.copy(r),
    r
}
var DPe = da.Uint8Array;
const yx = DPe;
function NPe(n) {
    var e = new n.constructor(n.byteLength);
    return new yx(e).set(new yx(n)),
    e
}
function OPe(n, e) {
    var t = e ? NPe(n.buffer) : n.buffer;
    return new n.constructor(t,n.byteOffset,n.length)
}
function kPe(n, e) {
    var t = -1
      , r = n.length;
    for (e || (e = Array(r)); ++t < r; )
        e[t] = n[t];
    return e
}
var Tk = Object.create
  , QPe = function() {
    function n() {}
    return function(e) {
        if (!Eo(e))
            return {};
        if (Tk)
            return Tk(e);
        n.prototype = e;
        var t = new n;
        return n.prototype = void 0,
        t
    }
}();
const HPe = QPe;
function pj(n, e) {
    return function(t) {
        return n(e(t))
    }
}
var zPe = pj(Object.getPrototypeOf, Object);
const mj = zPe;
var GPe = Object.prototype;
function G2(n) {
    var e = n && n.constructor
      , t = typeof e == "function" && e.prototype || GPe;
    return n === t
}
function VPe(n) {
    return typeof n.constructor == "function" && !G2(n) ? HPe(mj(n)) : {}
}
function BA(n) {
    return n != null && typeof n == "object"
}
var jPe = "[object Arguments]";
function Ik(n) {
    return BA(n) && qu(n) == jPe
}
var gj = Object.prototype
  , WPe = gj.hasOwnProperty
  , KPe = gj.propertyIsEnumerable
  , XPe = Ik(function() {
    return arguments
}()) ? Ik : function(n) {
    return BA(n) && WPe.call(n, "callee") && !KPe.call(n, "callee")
}
;
const wx = XPe;
var YPe = Array.isArray;
const Gs = YPe;
var $Pe = 9007199254740991;
function V2(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= $Pe
}
function Ap(n) {
    return n != null && V2(n.length) && !H2(n)
}
function ZPe(n) {
    return BA(n) && Ap(n)
}
function JPe() {
    return !1
}
var vj = typeof exports == "object" && exports && !exports.nodeType && exports
  , Rk = vj && typeof module == "object" && module && !module.nodeType && module
  , qPe = Rk && Rk.exports === vj
  , Uk = qPe ? da.Buffer : void 0
  , eLe = Uk ? Uk.isBuffer : void 0
  , tLe = eLe || JPe;
const _x = tLe;
var nLe = "[object Object]"
  , rLe = Function.prototype
  , iLe = Object.prototype
  , yj = rLe.toString
  , sLe = iLe.hasOwnProperty
  , oLe = yj.call(Object);
function aLe(n) {
    if (!BA(n) || qu(n) != nLe)
        return !1;
    var e = mj(n);
    if (e === null)
        return !0;
    var t = sLe.call(e, "constructor") && e.constructor;
    return typeof t == "function" && t instanceof t && yj.call(t) == oLe
}
var lLe = "[object Arguments]"
  , cLe = "[object Array]"
  , ALe = "[object Boolean]"
  , uLe = "[object Date]"
  , fLe = "[object Error]"
  , hLe = "[object Function]"
  , dLe = "[object Map]"
  , pLe = "[object Number]"
  , mLe = "[object Object]"
  , gLe = "[object RegExp]"
  , vLe = "[object Set]"
  , yLe = "[object String]"
  , wLe = "[object WeakMap]"
  , _Le = "[object ArrayBuffer]"
  , xLe = "[object DataView]"
  , bLe = "[object Float32Array]"
  , ELe = "[object Float64Array]"
  , BLe = "[object Int8Array]"
  , MLe = "[object Int16Array]"
  , SLe = "[object Int32Array]"
  , CLe = "[object Uint8Array]"
  , TLe = "[object Uint8ClampedArray]"
  , ILe = "[object Uint16Array]"
  , RLe = "[object Uint32Array]"
  , Tn = {};
Tn[bLe] = Tn[ELe] = Tn[BLe] = Tn[MLe] = Tn[SLe] = Tn[CLe] = Tn[TLe] = Tn[ILe] = Tn[RLe] = !0;
Tn[lLe] = Tn[cLe] = Tn[_Le] = Tn[ALe] = Tn[xLe] = Tn[uLe] = Tn[fLe] = Tn[hLe] = Tn[dLe] = Tn[pLe] = Tn[mLe] = Tn[gLe] = Tn[vLe] = Tn[yLe] = Tn[wLe] = !1;
function ULe(n) {
    return BA(n) && V2(n.length) && !!Tn[qu(n)]
}
function FLe(n) {
    return function(e) {
        return n(e)
    }
}
var wj = typeof exports == "object" && exports && !exports.nodeType && exports
  , lg = wj && typeof module == "object" && module && !module.nodeType && module
  , PLe = lg && lg.exports === wj
  , vM = PLe && uj.process
  , LLe = function() {
    try {
        var n = lg && lg.require && lg.require("util").types;
        return n || vM && vM.binding && vM.binding("util")
    } catch {}
}();
const Fk = LLe;
var Pk = Fk && Fk.isTypedArray
  , DLe = Pk ? FLe(Pk) : ULe;
const j2 = DLe;
function HT(n, e) {
    if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
        return n[e]
}
var NLe = Object.prototype
  , OLe = NLe.hasOwnProperty;
function kLe(n, e, t) {
    var r = n[e];
    (!(OLe.call(n, e) && L0(r, t)) || t === void 0 && !(e in n)) && z2(n, e, t)
}
function QLe(n, e, t, r) {
    var i = !t;
    t || (t = {});
    for (var s = -1, o = e.length; ++s < o; ) {
        var a = e[s]
          , l = r ? r(t[a], n[a], a, t, n) : void 0;
        l === void 0 && (l = n[a]),
        i ? z2(t, a, l) : kLe(t, a, l)
    }
    return t
}
function HLe(n, e) {
    for (var t = -1, r = Array(n); ++t < n; )
        r[t] = e(t);
    return r
}
var zLe = 9007199254740991
  , GLe = /^(?:0|[1-9]\d*)$/;
function W2(n, e) {
    var t = typeof n;
    return e = e ?? zLe,
    !!e && (t == "number" || t != "symbol" && GLe.test(n)) && n > -1 && n % 1 == 0 && n < e
}
var VLe = Object.prototype
  , jLe = VLe.hasOwnProperty;
function _j(n, e) {
    var t = Gs(n)
      , r = !t && wx(n)
      , i = !t && !r && _x(n)
      , s = !t && !r && !i && j2(n)
      , o = t || r || i || s
      , a = o ? HLe(n.length, String) : []
      , l = a.length;
    for (var c in n)
        (e || jLe.call(n, c)) && !(o && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || W2(c, l))) && a.push(c);
    return a
}
function WLe(n) {
    var e = [];
    if (n != null)
        for (var t in Object(n))
            e.push(t);
    return e
}
var KLe = Object.prototype
  , XLe = KLe.hasOwnProperty;
function YLe(n) {
    if (!Eo(n))
        return WLe(n);
    var e = G2(n)
      , t = [];
    for (var r in n)
        r == "constructor" && (e || !XLe.call(n, r)) || t.push(r);
    return t
}
function xj(n) {
    return Ap(n) ? _j(n, !0) : YLe(n)
}
function $Le(n) {
    return QLe(n, xj(n))
}
function ZLe(n, e, t, r, i, s, o) {
    var a = HT(n, t)
      , l = HT(e, t)
      , c = o.get(l);
    if (c) {
        QT(n, t, c);
        return
    }
    var A = s ? s(a, l, t + "", n, e, o) : void 0
      , u = A === void 0;
    if (u) {
        var f = Gs(l)
          , h = !f && _x(l)
          , d = !f && !h && j2(l);
        A = l,
        f || h || d ? Gs(a) ? A = a : ZPe(a) ? A = kPe(a) : h ? (u = !1,
        A = LPe(l, !0)) : d ? (u = !1,
        A = OPe(l, !0)) : A = [] : aLe(l) || wx(l) ? (A = a,
        wx(a) ? A = $Le(a) : (!Eo(a) || H2(a)) && (A = VPe(l))) : u = !1
    }
    u && (o.set(l, A),
    i(A, l, r, s, o),
    o.delete(l)),
    QT(n, t, A)
}
function bj(n, e, t, r, i) {
    n !== e && hj(e, function(s, o) {
        if (i || (i = new Ya),
        Eo(s))
            ZLe(n, e, o, t, bj, r, i);
        else {
            var a = r ? r(HT(n, o), s, o + "", n, e, i) : void 0;
            a === void 0 && (a = s),
            QT(n, o, a)
        }
    }, xj)
}
function Z1(n) {
    return n
}
function JLe(n, e, t) {
    switch (t.length) {
    case 0:
        return n.call(e);
    case 1:
        return n.call(e, t[0]);
    case 2:
        return n.call(e, t[0], t[1]);
    case 3:
        return n.call(e, t[0], t[1], t[2])
    }
    return n.apply(e, t)
}
var Lk = Math.max;
function qLe(n, e, t) {
    return e = Lk(e === void 0 ? n.length - 1 : e, 0),
    function() {
        for (var r = arguments, i = -1, s = Lk(r.length - e, 0), o = Array(s); ++i < s; )
            o[i] = r[e + i];
        i = -1;
        for (var a = Array(e + 1); ++i < e; )
            a[i] = r[i];
        return a[e] = t(o),
        JLe(n, this, a)
    }
}
function eDe(n) {
    return function() {
        return n
    }
}
var tDe = vx ? function(n, e) {
    return vx(n, "toString", {
        configurable: !0,
        enumerable: !1,
        value: eDe(e),
        writable: !0
    })
}
: Z1;
const nDe = tDe;
var rDe = 800
  , iDe = 16
  , sDe = Date.now;
function oDe(n) {
    var e = 0
      , t = 0;
    return function() {
        var r = sDe()
          , i = iDe - (r - t);
        if (t = r,
        i > 0) {
            if (++e >= rDe)
                return arguments[0]
        } else
            e = 0;
        return n.apply(void 0, arguments)
    }
}
var aDe = oDe(nDe);
const lDe = aDe;
function cDe(n, e) {
    return lDe(qLe(n, e, Z1), n + "")
}
function ADe(n, e, t) {
    if (!Eo(t))
        return !1;
    var r = typeof e;
    return (r == "number" ? Ap(t) && W2(e, t.length) : r == "string" && e in t) ? L0(t[e], n) : !1
}
function uDe(n) {
    return cDe(function(e, t) {
        var r = -1
          , i = t.length
          , s = i > 1 ? t[i - 1] : void 0
          , o = i > 2 ? t[2] : void 0;
        for (s = n.length > 3 && typeof s == "function" ? (i--,
        s) : void 0,
        o && ADe(t[0], t[1], o) && (s = i < 3 ? void 0 : s,
        i = 1),
        e = Object(e); ++r < i; ) {
            var a = t[r];
            a && n(e, a, r, s)
        }
        return e
    })
}
var fDe = uDe(function(n, e, t) {
    bj(n, e, t)
});
const fs = fDe;
var D0 = function(e) {
    var t = e.zDepth
      , r = e.radius
      , i = e.background
      , s = e.children
      , o = e.styles
      , a = o === void 0 ? {} : o
      , l = vt(fs({
        default: {
            wrap: {
                position: "relative",
                display: "inline-block"
            },
            content: {
                position: "relative"
            },
            bg: {
                absolute: "0px 0px 0px 0px",
                boxShadow: "0 " + t + "px " + t * 4 + "px rgba(0,0,0,.24)",
                borderRadius: r,
                background: i
            }
        },
        "zDepth-0": {
            bg: {
                boxShadow: "none"
            }
        },
        "zDepth-1": {
            bg: {
                boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
            }
        },
        "zDepth-2": {
            bg: {
                boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
            }
        },
        "zDepth-3": {
            bg: {
                boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
            }
        },
        "zDepth-4": {
            bg: {
                boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
            }
        },
        "zDepth-5": {
            bg: {
                boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
            }
        },
        square: {
            bg: {
                borderRadius: "0"
            }
        },
        circle: {
            bg: {
                borderRadius: "50%"
            }
        }
    }, a), {
        "zDepth-1": t === 1
    });
    return Z.createElement("div", {
        style: l.wrap
    }, Z.createElement("div", {
        style: l.bg
    }), Z.createElement("div", {
        style: l.content
    }, s))
};
D0.propTypes = {
    background: Ve.string,
    zDepth: Ve.oneOf([0, 1, 2, 3, 4, 5]),
    radius: Ve.number,
    styles: Ve.object
};
D0.defaultProps = {
    background: "#fff",
    zDepth: 1,
    radius: 2,
    styles: {}
};
var hDe = function() {
    return da.Date.now()
};
const yM = hDe;
var dDe = /\s/;
function pDe(n) {
    for (var e = n.length; e-- && dDe.test(n.charAt(e)); )
        ;
    return e
}
var mDe = /^\s+/;
function gDe(n) {
    return n && n.slice(0, pDe(n) + 1).replace(mDe, "")
}
var vDe = "[object Symbol]";
function J1(n) {
    return typeof n == "symbol" || BA(n) && qu(n) == vDe
}
var Dk = 0 / 0
  , yDe = /^[-+]0x[0-9a-f]+$/i
  , wDe = /^0b[01]+$/i
  , _De = /^0o[0-7]+$/i
  , xDe = parseInt;
function Nk(n) {
    if (typeof n == "number")
        return n;
    if (J1(n))
        return Dk;
    if (Eo(n)) {
        var e = typeof n.valueOf == "function" ? n.valueOf() : n;
        n = Eo(e) ? e + "" : e
    }
    if (typeof n != "string")
        return n === 0 ? n : +n;
    n = gDe(n);
    var t = wDe.test(n);
    return t || _De.test(n) ? xDe(n.slice(2), t ? 2 : 8) : yDe.test(n) ? Dk : +n
}
var bDe = "Expected a function"
  , EDe = Math.max
  , BDe = Math.min;
function Ej(n, e, t) {
    var r, i, s, o, a, l, c = 0, A = !1, u = !1, f = !0;
    if (typeof n != "function")
        throw new TypeError(bDe);
    e = Nk(e) || 0,
    Eo(t) && (A = !!t.leading,
    u = "maxWait"in t,
    s = u ? EDe(Nk(t.maxWait) || 0, e) : s,
    f = "trailing"in t ? !!t.trailing : f);
    function h(b) {
        var B = r
          , S = i;
        return r = i = void 0,
        c = b,
        o = n.apply(S, B),
        o
    }
    function d(b) {
        return c = b,
        a = setTimeout(p, e),
        A ? h(b) : o
    }
    function m(b) {
        var B = b - l
          , S = b - c
          , I = e - B;
        return u ? BDe(I, s - S) : I
    }
    function g(b) {
        var B = b - l
          , S = b - c;
        return l === void 0 || B >= e || B < 0 || u && S >= s
    }
    function p() {
        var b = yM();
        if (g(b))
            return v(b);
        a = setTimeout(p, m(b))
    }
    function v(b) {
        return a = void 0,
        f && r ? h(b) : (r = i = void 0,
        o)
    }
    function w() {
        a !== void 0 && clearTimeout(a),
        c = 0,
        r = l = i = a = void 0
    }
    function _() {
        return a === void 0 ? o : v(yM())
    }
    function x() {
        var b = yM()
          , B = g(b);
        if (r = arguments,
        i = this,
        l = b,
        B) {
            if (a === void 0)
                return d(l);
            if (u)
                return clearTimeout(a),
                a = setTimeout(p, e),
                h(l)
        }
        return a === void 0 && (a = setTimeout(p, e)),
        o
    }
    return x.cancel = w,
    x.flush = _,
    x
}
var MDe = "Expected a function";
function SDe(n, e, t) {
    var r = !0
      , i = !0;
    if (typeof n != "function")
        throw new TypeError(MDe);
    return Eo(t) && (r = "leading"in t ? !!t.leading : r,
    i = "trailing"in t ? !!t.trailing : i),
    Ej(n, e, {
        leading: r,
        maxWait: e,
        trailing: i
    })
}
var CDe = function(e, t, r) {
    var i = r.getBoundingClientRect()
      , s = i.width
      , o = i.height
      , a = typeof e.pageX == "number" ? e.pageX : e.touches[0].pageX
      , l = typeof e.pageY == "number" ? e.pageY : e.touches[0].pageY
      , c = a - (r.getBoundingClientRect().left + window.pageXOffset)
      , A = l - (r.getBoundingClientRect().top + window.pageYOffset);
    c < 0 ? c = 0 : c > s && (c = s),
    A < 0 ? A = 0 : A > o && (A = o);
    var u = c / s
      , f = 1 - A / o;
    return {
        h: t.h,
        s: u,
        v: f,
        a: t.a,
        source: "hsv"
    }
}
  , TDe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function IDe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function RDe(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function UDe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var q1 = function(n) {
    UDe(e, n);
    function e(t) {
        IDe(this, e);
        var r = RDe(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t));
        return r.handleChange = function(i) {
            typeof r.props.onChange == "function" && r.throttle(r.props.onChange, CDe(i, r.props.hsl, r.container), i)
        }
        ,
        r.handleMouseDown = function(i) {
            r.handleChange(i);
            var s = r.getContainerRenderWindow();
            s.addEventListener("mousemove", r.handleChange),
            s.addEventListener("mouseup", r.handleMouseUp)
        }
        ,
        r.handleMouseUp = function() {
            r.unbindEventListeners()
        }
        ,
        r.throttle = SDe(function(i, s, o) {
            i(s, o)
        }, 50),
        r
    }
    return TDe(e, [{
        key: "componentWillUnmount",
        value: function() {
            this.throttle.cancel(),
            this.unbindEventListeners()
        }
    }, {
        key: "getContainerRenderWindow",
        value: function() {
            for (var r = this.container, i = window; !i.document.contains(r) && i.parent !== i; )
                i = i.parent;
            return i
        }
    }, {
        key: "unbindEventListeners",
        value: function() {
            var r = this.getContainerRenderWindow();
            r.removeEventListener("mousemove", this.handleChange),
            r.removeEventListener("mouseup", this.handleMouseUp)
        }
    }, {
        key: "render",
        value: function() {
            var r = this
              , i = this.props.style || {}
              , s = i.color
              , o = i.white
              , a = i.black
              , l = i.pointer
              , c = i.circle
              , A = vt({
                default: {
                    color: {
                        absolute: "0px 0px 0px 0px",
                        background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
                        borderRadius: this.props.radius
                    },
                    white: {
                        absolute: "0px 0px 0px 0px",
                        borderRadius: this.props.radius
                    },
                    black: {
                        absolute: "0px 0px 0px 0px",
                        boxShadow: this.props.shadow,
                        borderRadius: this.props.radius
                    },
                    pointer: {
                        position: "absolute",
                        top: -(this.props.hsv.v * 100) + 100 + "%",
                        left: this.props.hsv.s * 100 + "%",
                        cursor: "default"
                    },
                    circle: {
                        width: "4px",
                        height: "4px",
                        boxShadow: `0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),
            0 0 1px 2px rgba(0,0,0,.4)`,
                        borderRadius: "50%",
                        cursor: "hand",
                        transform: "translate(-2px, -2px)"
                    }
                },
                custom: {
                    color: s,
                    white: o,
                    black: a,
                    pointer: l,
                    circle: c
                }
            }, {
                custom: !!this.props.style
            });
            return Z.createElement("div", {
                style: A.color,
                ref: function(f) {
                    return r.container = f
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
            }, Z.createElement("style", null, `
          .saturation-white {
            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));
            background: linear-gradient(to right, #fff, rgba(255,255,255,0));
          }
          .saturation-black {
            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));
            background: linear-gradient(to top, #000, rgba(0,0,0,0));
          }
        `), Z.createElement("div", {
                style: A.white,
                className: "saturation-white"
            }, Z.createElement("div", {
                style: A.black,
                className: "saturation-black"
            }), Z.createElement("div", {
                style: A.pointer
            }, this.props.pointer ? Z.createElement(this.props.pointer, this.props) : Z.createElement("div", {
                style: A.circle
            }))))
        }
    }]),
    e
}(be.PureComponent || be.Component);
function FDe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length; ++t < r && e(n[t], t, n) !== !1; )
        ;
    return n
}
var PDe = pj(Object.keys, Object);
const LDe = PDe;
var DDe = Object.prototype
  , NDe = DDe.hasOwnProperty;
function ODe(n) {
    if (!G2(n))
        return LDe(n);
    var e = [];
    for (var t in Object(n))
        NDe.call(n, t) && t != "constructor" && e.push(t);
    return e
}
function K2(n) {
    return Ap(n) ? _j(n) : ODe(n)
}
function kDe(n, e) {
    return n && hj(n, e, K2)
}
function QDe(n, e) {
    return function(t, r) {
        if (t == null)
            return t;
        if (!Ap(t))
            return n(t, r);
        for (var i = t.length, s = e ? i : -1, o = Object(t); (e ? s-- : ++s < i) && r(o[s], s, o) !== !1; )
            ;
        return t
    }
}
var HDe = QDe(kDe);
const Bj = HDe;
function zDe(n) {
    return typeof n == "function" ? n : Z1
}
function GDe(n, e) {
    var t = Gs(n) ? FDe : Bj;
    return t(n, zDe(e))
}
function xx(n) {
    "@babel/helpers - typeof";
    return xx = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    xx(n)
}
var VDe = /^\s+/
  , jDe = /\s+$/;
function ot(n, e) {
    if (n = n || "",
    e = e || {},
    n instanceof ot)
        return n;
    if (!(this instanceof ot))
        return new ot(n,e);
    var t = WDe(n);
    this._originalInput = n,
    this._r = t.r,
    this._g = t.g,
    this._b = t.b,
    this._a = t.a,
    this._roundA = Math.round(100 * this._a) / 100,
    this._format = e.format || t.format,
    this._gradientType = e.gradientType,
    this._r < 1 && (this._r = Math.round(this._r)),
    this._g < 1 && (this._g = Math.round(this._g)),
    this._b < 1 && (this._b = Math.round(this._b)),
    this._ok = t.ok
}
ot.prototype = {
    isDark: function() {
        return this.getBrightness() < 128
    },
    isLight: function() {
        return !this.isDark()
    },
    isValid: function() {
        return this._ok
    },
    getOriginalInput: function() {
        return this._originalInput
    },
    getFormat: function() {
        return this._format
    },
    getAlpha: function() {
        return this._a
    },
    getBrightness: function() {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
    },
    getLuminance: function() {
        var e = this.toRgb(), t, r, i, s, o, a;
        return t = e.r / 255,
        r = e.g / 255,
        i = e.b / 255,
        t <= .03928 ? s = t / 12.92 : s = Math.pow((t + .055) / 1.055, 2.4),
        r <= .03928 ? o = r / 12.92 : o = Math.pow((r + .055) / 1.055, 2.4),
        i <= .03928 ? a = i / 12.92 : a = Math.pow((i + .055) / 1.055, 2.4),
        .2126 * s + .7152 * o + .0722 * a
    },
    setAlpha: function(e) {
        return this._a = Mj(e),
        this._roundA = Math.round(100 * this._a) / 100,
        this
    },
    toHsv: function() {
        var e = kk(this._r, this._g, this._b);
        return {
            h: e.h * 360,
            s: e.s,
            v: e.v,
            a: this._a
        }
    },
    toHsvString: function() {
        var e = kk(this._r, this._g, this._b)
          , t = Math.round(e.h * 360)
          , r = Math.round(e.s * 100)
          , i = Math.round(e.v * 100);
        return this._a == 1 ? "hsv(" + t + ", " + r + "%, " + i + "%)" : "hsva(" + t + ", " + r + "%, " + i + "%, " + this._roundA + ")"
    },
    toHsl: function() {
        var e = Ok(this._r, this._g, this._b);
        return {
            h: e.h * 360,
            s: e.s,
            l: e.l,
            a: this._a
        }
    },
    toHslString: function() {
        var e = Ok(this._r, this._g, this._b)
          , t = Math.round(e.h * 360)
          , r = Math.round(e.s * 100)
          , i = Math.round(e.l * 100);
        return this._a == 1 ? "hsl(" + t + ", " + r + "%, " + i + "%)" : "hsla(" + t + ", " + r + "%, " + i + "%, " + this._roundA + ")"
    },
    toHex: function(e) {
        return Qk(this._r, this._g, this._b, e)
    },
    toHexString: function(e) {
        return "#" + this.toHex(e)
    },
    toHex8: function(e) {
        return $De(this._r, this._g, this._b, this._a, e)
    },
    toHex8String: function(e) {
        return "#" + this.toHex8(e)
    },
    toRgb: function() {
        return {
            r: Math.round(this._r),
            g: Math.round(this._g),
            b: Math.round(this._b),
            a: this._a
        }
    },
    toRgbString: function() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")"
    },
    toPercentageRgb: function() {
        return {
            r: Math.round(Dn(this._r, 255) * 100) + "%",
            g: Math.round(Dn(this._g, 255) * 100) + "%",
            b: Math.round(Dn(this._b, 255) * 100) + "%",
            a: this._a
        }
    },
    toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + Math.round(Dn(this._r, 255) * 100) + "%, " + Math.round(Dn(this._g, 255) * 100) + "%, " + Math.round(Dn(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(Dn(this._r, 255) * 100) + "%, " + Math.round(Dn(this._g, 255) * 100) + "%, " + Math.round(Dn(this._b, 255) * 100) + "%, " + this._roundA + ")"
    },
    toName: function() {
        return this._a === 0 ? "transparent" : this._a < 1 ? !1 : lNe[Qk(this._r, this._g, this._b, !0)] || !1
    },
    toFilter: function(e) {
        var t = "#" + Hk(this._r, this._g, this._b, this._a)
          , r = t
          , i = this._gradientType ? "GradientType = 1, " : "";
        if (e) {
            var s = ot(e);
            r = "#" + Hk(s._r, s._g, s._b, s._a)
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + t + ",endColorstr=" + r + ")"
    },
    toString: function(e) {
        var t = !!e;
        e = e || this._format;
        var r = !1
          , i = this._a < 1 && this._a >= 0
          , s = !t && i && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
        return s ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()),
        e === "prgb" && (r = this.toPercentageRgbString()),
        (e === "hex" || e === "hex6") && (r = this.toHexString()),
        e === "hex3" && (r = this.toHexString(!0)),
        e === "hex4" && (r = this.toHex8String(!0)),
        e === "hex8" && (r = this.toHex8String()),
        e === "name" && (r = this.toName()),
        e === "hsl" && (r = this.toHslString()),
        e === "hsv" && (r = this.toHsvString()),
        r || this.toHexString())
    },
    clone: function() {
        return ot(this.toString())
    },
    _applyModification: function(e, t) {
        var r = e.apply(null, [this].concat([].slice.call(t)));
        return this._r = r._r,
        this._g = r._g,
        this._b = r._b,
        this.setAlpha(r._a),
        this
    },
    lighten: function() {
        return this._applyModification(eNe, arguments)
    },
    brighten: function() {
        return this._applyModification(tNe, arguments)
    },
    darken: function() {
        return this._applyModification(nNe, arguments)
    },
    desaturate: function() {
        return this._applyModification(ZDe, arguments)
    },
    saturate: function() {
        return this._applyModification(JDe, arguments)
    },
    greyscale: function() {
        return this._applyModification(qDe, arguments)
    },
    spin: function() {
        return this._applyModification(rNe, arguments)
    },
    _applyCombination: function(e, t) {
        return e.apply(null, [this].concat([].slice.call(t)))
    },
    analogous: function() {
        return this._applyCombination(oNe, arguments)
    },
    complement: function() {
        return this._applyCombination(iNe, arguments)
    },
    monochromatic: function() {
        return this._applyCombination(aNe, arguments)
    },
    splitcomplement: function() {
        return this._applyCombination(sNe, arguments)
    },
    triad: function() {
        return this._applyCombination(zk, [3])
    },
    tetrad: function() {
        return this._applyCombination(zk, [4])
    }
};
ot.fromRatio = function(n, e) {
    if (xx(n) == "object") {
        var t = {};
        for (var r in n)
            n.hasOwnProperty(r) && (r === "a" ? t[r] = n[r] : t[r] = Dm(n[r]));
        n = t
    }
    return ot(n, e)
}
;
function WDe(n) {
    var e = {
        r: 0,
        g: 0,
        b: 0
    }
      , t = 1
      , r = null
      , i = null
      , s = null
      , o = !1
      , a = !1;
    return typeof n == "string" && (n = fNe(n)),
    xx(n) == "object" && (El(n.r) && El(n.g) && El(n.b) ? (e = KDe(n.r, n.g, n.b),
    o = !0,
    a = String(n.r).substr(-1) === "%" ? "prgb" : "rgb") : El(n.h) && El(n.s) && El(n.v) ? (r = Dm(n.s),
    i = Dm(n.v),
    e = YDe(n.h, r, i),
    o = !0,
    a = "hsv") : El(n.h) && El(n.s) && El(n.l) && (r = Dm(n.s),
    s = Dm(n.l),
    e = XDe(n.h, r, s),
    o = !0,
    a = "hsl"),
    n.hasOwnProperty("a") && (t = n.a)),
    t = Mj(t),
    {
        ok: o,
        format: n.format || a,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: t
    }
}
function KDe(n, e, t) {
    return {
        r: Dn(n, 255) * 255,
        g: Dn(e, 255) * 255,
        b: Dn(t, 255) * 255
    }
}
function Ok(n, e, t) {
    n = Dn(n, 255),
    e = Dn(e, 255),
    t = Dn(t, 255);
    var r = Math.max(n, e, t), i = Math.min(n, e, t), s, o, a = (r + i) / 2;
    if (r == i)
        s = o = 0;
    else {
        var l = r - i;
        switch (o = a > .5 ? l / (2 - r - i) : l / (r + i),
        r) {
        case n:
            s = (e - t) / l + (e < t ? 6 : 0);
            break;
        case e:
            s = (t - n) / l + 2;
            break;
        case t:
            s = (n - e) / l + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: o,
        l: a
    }
}
function XDe(n, e, t) {
    var r, i, s;
    n = Dn(n, 360),
    e = Dn(e, 100),
    t = Dn(t, 100);
    function o(c, A, u) {
        return u < 0 && (u += 1),
        u > 1 && (u -= 1),
        u < 1 / 6 ? c + (A - c) * 6 * u : u < 1 / 2 ? A : u < 2 / 3 ? c + (A - c) * (2 / 3 - u) * 6 : c
    }
    if (e === 0)
        r = i = s = t;
    else {
        var a = t < .5 ? t * (1 + e) : t + e - t * e
          , l = 2 * t - a;
        r = o(l, a, n + 1 / 3),
        i = o(l, a, n),
        s = o(l, a, n - 1 / 3)
    }
    return {
        r: r * 255,
        g: i * 255,
        b: s * 255
    }
}
function kk(n, e, t) {
    n = Dn(n, 255),
    e = Dn(e, 255),
    t = Dn(t, 255);
    var r = Math.max(n, e, t), i = Math.min(n, e, t), s, o, a = r, l = r - i;
    if (o = r === 0 ? 0 : l / r,
    r == i)
        s = 0;
    else {
        switch (r) {
        case n:
            s = (e - t) / l + (e < t ? 6 : 0);
            break;
        case e:
            s = (t - n) / l + 2;
            break;
        case t:
            s = (n - e) / l + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: o,
        v: a
    }
}
function YDe(n, e, t) {
    n = Dn(n, 360) * 6,
    e = Dn(e, 100),
    t = Dn(t, 100);
    var r = Math.floor(n)
      , i = n - r
      , s = t * (1 - e)
      , o = t * (1 - i * e)
      , a = t * (1 - (1 - i) * e)
      , l = r % 6
      , c = [t, o, s, s, a, t][l]
      , A = [a, t, t, o, s, s][l]
      , u = [s, s, a, t, t, o][l];
    return {
        r: c * 255,
        g: A * 255,
        b: u * 255
    }
}
function Qk(n, e, t, r) {
    var i = [ta(Math.round(n).toString(16)), ta(Math.round(e).toString(16)), ta(Math.round(t).toString(16))];
    return r && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}
function $De(n, e, t, r, i) {
    var s = [ta(Math.round(n).toString(16)), ta(Math.round(e).toString(16)), ta(Math.round(t).toString(16)), ta(Sj(r))];
    return i && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) && s[3].charAt(0) == s[3].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
}
function Hk(n, e, t, r) {
    var i = [ta(Sj(r)), ta(Math.round(n).toString(16)), ta(Math.round(e).toString(16)), ta(Math.round(t).toString(16))];
    return i.join("")
}
ot.equals = function(n, e) {
    return !n || !e ? !1 : ot(n).toRgbString() == ot(e).toRgbString()
}
;
ot.random = function() {
    return ot.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
    })
}
;
function ZDe(n, e) {
    e = e === 0 ? 0 : e || 10;
    var t = ot(n).toHsl();
    return t.s -= e / 100,
    t.s = eb(t.s),
    ot(t)
}
function JDe(n, e) {
    e = e === 0 ? 0 : e || 10;
    var t = ot(n).toHsl();
    return t.s += e / 100,
    t.s = eb(t.s),
    ot(t)
}
function qDe(n) {
    return ot(n).desaturate(100)
}
function eNe(n, e) {
    e = e === 0 ? 0 : e || 10;
    var t = ot(n).toHsl();
    return t.l += e / 100,
    t.l = eb(t.l),
    ot(t)
}
function tNe(n, e) {
    e = e === 0 ? 0 : e || 10;
    var t = ot(n).toRgb();
    return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))),
    t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))),
    t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))),
    ot(t)
}
function nNe(n, e) {
    e = e === 0 ? 0 : e || 10;
    var t = ot(n).toHsl();
    return t.l -= e / 100,
    t.l = eb(t.l),
    ot(t)
}
function rNe(n, e) {
    var t = ot(n).toHsl()
      , r = (t.h + e) % 360;
    return t.h = r < 0 ? 360 + r : r,
    ot(t)
}
function iNe(n) {
    var e = ot(n).toHsl();
    return e.h = (e.h + 180) % 360,
    ot(e)
}
function zk(n, e) {
    if (isNaN(e) || e <= 0)
        throw new Error("Argument to polyad must be a positive number");
    for (var t = ot(n).toHsl(), r = [ot(n)], i = 360 / e, s = 1; s < e; s++)
        r.push(ot({
            h: (t.h + s * i) % 360,
            s: t.s,
            l: t.l
        }));
    return r
}
function sNe(n) {
    var e = ot(n).toHsl()
      , t = e.h;
    return [ot(n), ot({
        h: (t + 72) % 360,
        s: e.s,
        l: e.l
    }), ot({
        h: (t + 216) % 360,
        s: e.s,
        l: e.l
    })]
}
function oNe(n, e, t) {
    e = e || 6,
    t = t || 30;
    var r = ot(n).toHsl()
      , i = 360 / t
      , s = [ot(n)];
    for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
        r.h = (r.h + i) % 360,
        s.push(ot(r));
    return s
}
function aNe(n, e) {
    e = e || 6;
    for (var t = ot(n).toHsv(), r = t.h, i = t.s, s = t.v, o = [], a = 1 / e; e--; )
        o.push(ot({
            h: r,
            s: i,
            v: s
        })),
        s = (s + a) % 1;
    return o
}
ot.mix = function(n, e, t) {
    t = t === 0 ? 0 : t || 50;
    var r = ot(n).toRgb()
      , i = ot(e).toRgb()
      , s = t / 100
      , o = {
        r: (i.r - r.r) * s + r.r,
        g: (i.g - r.g) * s + r.g,
        b: (i.b - r.b) * s + r.b,
        a: (i.a - r.a) * s + r.a
    };
    return ot(o)
}
;
ot.readability = function(n, e) {
    var t = ot(n)
      , r = ot(e);
    return (Math.max(t.getLuminance(), r.getLuminance()) + .05) / (Math.min(t.getLuminance(), r.getLuminance()) + .05)
}
;
ot.isReadable = function(n, e, t) {
    var r = ot.readability(n, e), i, s;
    switch (s = !1,
    i = hNe(t),
    i.level + i.size) {
    case "AAsmall":
    case "AAAlarge":
        s = r >= 4.5;
        break;
    case "AAlarge":
        s = r >= 3;
        break;
    case "AAAsmall":
        s = r >= 7;
        break
    }
    return s
}
;
ot.mostReadable = function(n, e, t) {
    var r = null, i = 0, s, o, a, l;
    t = t || {},
    o = t.includeFallbackColors,
    a = t.level,
    l = t.size;
    for (var c = 0; c < e.length; c++)
        s = ot.readability(n, e[c]),
        s > i && (i = s,
        r = ot(e[c]));
    return ot.isReadable(n, r, {
        level: a,
        size: l
    }) || !o ? r : (t.includeFallbackColors = !1,
    ot.mostReadable(n, ["#fff", "#000"], t))
}
;
var zT = ot.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
}
  , lNe = ot.hexNames = cNe(zT);
function cNe(n) {
    var e = {};
    for (var t in n)
        n.hasOwnProperty(t) && (e[n[t]] = t);
    return e
}
function Mj(n) {
    return n = parseFloat(n),
    (isNaN(n) || n < 0 || n > 1) && (n = 1),
    n
}
function Dn(n, e) {
    ANe(n) && (n = "100%");
    var t = uNe(n);
    return n = Math.min(e, Math.max(0, parseFloat(n))),
    t && (n = parseInt(n * e, 10) / 100),
    Math.abs(n - e) < 1e-6 ? 1 : n % e / parseFloat(e)
}
function eb(n) {
    return Math.min(1, Math.max(0, n))
}
function ys(n) {
    return parseInt(n, 16)
}
function ANe(n) {
    return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1
}
function uNe(n) {
    return typeof n == "string" && n.indexOf("%") != -1
}
function ta(n) {
    return n.length == 1 ? "0" + n : "" + n
}
function Dm(n) {
    return n <= 1 && (n = n * 100 + "%"),
    n
}
function Sj(n) {
    return Math.round(parseFloat(n) * 255).toString(16)
}
function Gk(n) {
    return ys(n) / 255
}
var Go = function() {
    var n = "[-\\+]?\\d+%?"
      , e = "[-\\+]?\\d*\\.\\d+%?"
      , t = "(?:" + e + ")|(?:" + n + ")"
      , r = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?"
      , i = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?";
    return {
        CSS_UNIT: new RegExp(t),
        rgb: new RegExp("rgb" + r),
        rgba: new RegExp("rgba" + i),
        hsl: new RegExp("hsl" + r),
        hsla: new RegExp("hsla" + i),
        hsv: new RegExp("hsv" + r),
        hsva: new RegExp("hsva" + i),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    }
}();
function El(n) {
    return !!Go.CSS_UNIT.exec(n)
}
function fNe(n) {
    n = n.replace(VDe, "").replace(jDe, "").toLowerCase();
    var e = !1;
    if (zT[n])
        n = zT[n],
        e = !0;
    else if (n == "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    var t;
    return (t = Go.rgb.exec(n)) ? {
        r: t[1],
        g: t[2],
        b: t[3]
    } : (t = Go.rgba.exec(n)) ? {
        r: t[1],
        g: t[2],
        b: t[3],
        a: t[4]
    } : (t = Go.hsl.exec(n)) ? {
        h: t[1],
        s: t[2],
        l: t[3]
    } : (t = Go.hsla.exec(n)) ? {
        h: t[1],
        s: t[2],
        l: t[3],
        a: t[4]
    } : (t = Go.hsv.exec(n)) ? {
        h: t[1],
        s: t[2],
        v: t[3]
    } : (t = Go.hsva.exec(n)) ? {
        h: t[1],
        s: t[2],
        v: t[3],
        a: t[4]
    } : (t = Go.hex8.exec(n)) ? {
        r: ys(t[1]),
        g: ys(t[2]),
        b: ys(t[3]),
        a: Gk(t[4]),
        format: e ? "name" : "hex8"
    } : (t = Go.hex6.exec(n)) ? {
        r: ys(t[1]),
        g: ys(t[2]),
        b: ys(t[3]),
        format: e ? "name" : "hex"
    } : (t = Go.hex4.exec(n)) ? {
        r: ys(t[1] + "" + t[1]),
        g: ys(t[2] + "" + t[2]),
        b: ys(t[3] + "" + t[3]),
        a: Gk(t[4] + "" + t[4]),
        format: e ? "name" : "hex8"
    } : (t = Go.hex3.exec(n)) ? {
        r: ys(t[1] + "" + t[1]),
        g: ys(t[2] + "" + t[2]),
        b: ys(t[3] + "" + t[3]),
        format: e ? "name" : "hex"
    } : !1
}
function hNe(n) {
    var e, t;
    return n = n || {
        level: "AA",
        size: "small"
    },
    e = (n.level || "AA").toUpperCase(),
    t = (n.size || "small").toLowerCase(),
    e !== "AA" && e !== "AAA" && (e = "AA"),
    t !== "small" && t !== "large" && (t = "small"),
    {
        level: e,
        size: t
    }
}
var Vk = function(e) {
    var t = ["r", "g", "b", "a", "h", "s", "l", "v"]
      , r = 0
      , i = 0;
    return GDe(t, function(s) {
        if (e[s] && (r += 1,
        isNaN(e[s]) || (i += 1),
        s === "s" || s === "l")) {
            var o = /^\d+%$/;
            o.test(e[s]) && (i += 1)
        }
    }),
    r === i ? e : !1
}
  , Nm = function(e, t) {
    var r = e.hex ? ot(e.hex) : ot(e)
      , i = r.toHsl()
      , s = r.toHsv()
      , o = r.toRgb()
      , a = r.toHex();
    i.s === 0 && (i.h = t || 0,
    s.h = t || 0);
    var l = a === "000000" && o.a === 0;
    return {
        hsl: i,
        hex: l ? "transparent" : "#" + a,
        rgb: o,
        hsv: s,
        oldHue: e.h || t || i.h,
        source: e.source
    }
}
  , LA = function(e) {
    if (e === "transparent")
        return !0;
    var t = String(e).charAt(0) === "#" ? 1 : 0;
    return e.length !== 4 + t && e.length < 7 + t && ot(e).isValid()
}
  , X2 = function(e) {
    if (!e)
        return "#fff";
    var t = Nm(e);
    if (t.hex === "transparent")
        return "rgba(0,0,0,0.4)";
    var r = (t.rgb.r * 299 + t.rgb.g * 587 + t.rgb.b * 114) / 1e3;
    return r >= 128 ? "#000" : "#fff"
}
  , wM = function(e, t) {
    var r = e.replace("°", "");
    return ot(t + " (" + r + ")")._ok
}
  , um = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , dNe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function pNe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function mNe(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function gNe(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var hs = function(e) {
    var t = function(r) {
        gNe(i, r);
        function i(s) {
            pNe(this, i);
            var o = mNe(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this));
            return o.handleChange = function(a, l) {
                var c = Vk(a);
                if (c) {
                    var A = Nm(a, a.h || o.state.oldHue);
                    o.setState(A),
                    o.props.onChangeComplete && o.debounce(o.props.onChangeComplete, A, l),
                    o.props.onChange && o.props.onChange(A, l)
                }
            }
            ,
            o.handleSwatchHover = function(a, l) {
                var c = Vk(a);
                if (c) {
                    var A = Nm(a, a.h || o.state.oldHue);
                    o.props.onSwatchHover && o.props.onSwatchHover(A, l)
                }
            }
            ,
            o.state = um({}, Nm(s.color, 0)),
            o.debounce = Ej(function(a, l, c) {
                a(l, c)
            }, 100),
            o
        }
        return dNe(i, [{
            key: "render",
            value: function() {
                var o = {};
                return this.props.onSwatchHover && (o.onSwatchHover = this.handleSwatchHover),
                Z.createElement(e, um({}, this.props, this.state, {
                    onChange: this.handleChange
                }, o))
            }
        }], [{
            key: "getDerivedStateFromProps",
            value: function(o, a) {
                return um({}, Nm(o.color, a.oldHue))
            }
        }]),
        i
    }(be.PureComponent || be.Component);
    return t.propTypes = um({}, e.propTypes),
    t.defaultProps = um({}, e.defaultProps, {
        color: {
            h: 250,
            s: .5,
            l: .2,
            a: 1
        }
    }),
    t
}
  , vNe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , yNe = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function wNe(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function jk(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function _Ne(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var xNe = function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
    return function(r) {
        _Ne(i, r);
        function i() {
            var s, o, a, l;
            wNe(this, i);
            for (var c = arguments.length, A = Array(c), u = 0; u < c; u++)
                A[u] = arguments[u];
            return l = (o = (a = jk(this, (s = i.__proto__ || Object.getPrototypeOf(i)).call.apply(s, [this].concat(A))),
            a),
            a.state = {
                focus: !1
            },
            a.handleFocus = function() {
                return a.setState({
                    focus: !0
                })
            }
            ,
            a.handleBlur = function() {
                return a.setState({
                    focus: !1
                })
            }
            ,
            o),
            jk(a, l)
        }
        return yNe(i, [{
            key: "render",
            value: function() {
                return Z.createElement(t, {
                    onFocus: this.handleFocus,
                    onBlur: this.handleBlur
                }, Z.createElement(e, vNe({}, this.props, this.state)))
            }
        }]),
        i
    }(Z.Component)
}
  , Wk = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , bNe = 13
  , ENe = function(e) {
    var t = e.color
      , r = e.style
      , i = e.onClick
      , s = i === void 0 ? function() {}
    : i
      , o = e.onHover
      , a = e.title
      , l = a === void 0 ? t : a
      , c = e.children
      , A = e.focus
      , u = e.focusStyle
      , f = u === void 0 ? {} : u
      , h = t === "transparent"
      , d = vt({
        default: {
            swatch: Wk({
                background: t,
                height: "100%",
                width: "100%",
                cursor: "pointer",
                position: "relative",
                outline: "none"
            }, r, A ? f : {})
        }
    })
      , m = function(_) {
        return s(t, _)
    }
      , g = function(_) {
        return _.keyCode === bNe && s(t, _)
    }
      , p = function(_) {
        return o(t, _)
    }
      , v = {};
    return o && (v.onMouseOver = p),
    Z.createElement("div", Wk({
        style: d.swatch,
        onClick: m,
        title: l,
        tabIndex: 0,
        onKeyDown: g
    }, v), c, h && Z.createElement(lp, {
        borderRadius: d.swatch.borderRadius,
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    }))
};
const nf = xNe(ENe);
var BNe = function(e) {
    var t = e.direction
      , r = vt({
        default: {
            picker: {
                width: "18px",
                height: "18px",
                borderRadius: "50%",
                transform: "translate(-9px, -1px)",
                backgroundColor: "rgb(248, 248, 248)",
                boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
            }
        },
        vertical: {
            picker: {
                transform: "translate(-3px, -9px)"
            }
        }
    }, {
        vertical: t === "vertical"
    });
    return Z.createElement("div", {
        style: r.picker
    })
}
  , MNe = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , Cj = function(e) {
    var t = e.rgb
      , r = e.hsl
      , i = e.width
      , s = e.height
      , o = e.onChange
      , a = e.direction
      , l = e.style
      , c = e.renderers
      , A = e.pointer
      , u = e.className
      , f = u === void 0 ? "" : u
      , h = vt({
        default: {
            picker: {
                position: "relative",
                width: i,
                height: s
            },
            alpha: {
                radius: "2px",
                style: l
            }
        }
    });
    return Z.createElement("div", {
        style: h.picker,
        className: "alpha-picker " + f
    }, Z.createElement(Q2, MNe({}, h.alpha, {
        rgb: t,
        hsl: r,
        pointer: A,
        renderers: c,
        onChange: o,
        direction: a
    })))
};
Cj.defaultProps = {
    width: "316px",
    height: "16px",
    direction: "horizontal",
    pointer: BNe
};
hs(Cj);
function Tj(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length, i = Array(r); ++t < r; )
        i[t] = e(n[t], t, n);
    return i
}
var SNe = "__lodash_hash_undefined__";
function CNe(n) {
    return this.__data__.set(n, SNe),
    this
}
function TNe(n) {
    return this.__data__.has(n)
}
function bx(n) {
    var e = -1
      , t = n == null ? 0 : n.length;
    for (this.__data__ = new hc; ++e < t; )
        this.add(n[e])
}
bx.prototype.add = bx.prototype.push = CNe;
bx.prototype.has = TNe;
function INe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length; ++t < r; )
        if (e(n[t], t, n))
            return !0;
    return !1
}
function RNe(n, e) {
    return n.has(e)
}
var UNe = 1
  , FNe = 2;
function Ij(n, e, t, r, i, s) {
    var o = t & UNe
      , a = n.length
      , l = e.length;
    if (a != l && !(o && l > a))
        return !1;
    var c = s.get(n)
      , A = s.get(e);
    if (c && A)
        return c == e && A == n;
    var u = -1
      , f = !0
      , h = t & FNe ? new bx : void 0;
    for (s.set(n, e),
    s.set(e, n); ++u < a; ) {
        var d = n[u]
          , m = e[u];
        if (r)
            var g = o ? r(m, d, u, e, n, s) : r(d, m, u, n, e, s);
        if (g !== void 0) {
            if (g)
                continue;
            f = !1;
            break
        }
        if (h) {
            if (!INe(e, function(p, v) {
                if (!RNe(h, v) && (d === p || i(d, p, t, r, s)))
                    return h.push(v)
            })) {
                f = !1;
                break
            }
        } else if (!(d === m || i(d, m, t, r, s))) {
            f = !1;
            break
        }
    }
    return s.delete(n),
    s.delete(e),
    f
}
function PNe(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(r, i) {
        t[++e] = [i, r]
    }),
    t
}
function LNe(n) {
    var e = -1
      , t = Array(n.size);
    return n.forEach(function(r) {
        t[++e] = r
    }),
    t
}
var DNe = 1
  , NNe = 2
  , ONe = "[object Boolean]"
  , kNe = "[object Date]"
  , QNe = "[object Error]"
  , HNe = "[object Map]"
  , zNe = "[object Number]"
  , GNe = "[object RegExp]"
  , VNe = "[object Set]"
  , jNe = "[object String]"
  , WNe = "[object Symbol]"
  , KNe = "[object ArrayBuffer]"
  , XNe = "[object DataView]"
  , Kk = EA ? EA.prototype : void 0
  , _M = Kk ? Kk.valueOf : void 0;
function YNe(n, e, t, r, i, s, o) {
    switch (t) {
    case XNe:
        if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
            return !1;
        n = n.buffer,
        e = e.buffer;
    case KNe:
        return !(n.byteLength != e.byteLength || !s(new yx(n), new yx(e)));
    case ONe:
    case kNe:
    case zNe:
        return L0(+n, +e);
    case QNe:
        return n.name == e.name && n.message == e.message;
    case GNe:
    case jNe:
        return n == e + "";
    case HNe:
        var a = PNe;
    case VNe:
        var l = r & DNe;
        if (a || (a = LNe),
        n.size != e.size && !l)
            return !1;
        var c = o.get(n);
        if (c)
            return c == e;
        r |= NNe,
        o.set(n, e);
        var A = Ij(a(n), a(e), r, i, s, o);
        return o.delete(n),
        A;
    case WNe:
        if (_M)
            return _M.call(n) == _M.call(e)
    }
    return !1
}
function $Ne(n, e) {
    for (var t = -1, r = e.length, i = n.length; ++t < r; )
        n[i + t] = e[t];
    return n
}
function ZNe(n, e, t) {
    var r = e(n);
    return Gs(n) ? r : $Ne(r, t(n))
}
function JNe(n, e) {
    for (var t = -1, r = n == null ? 0 : n.length, i = 0, s = []; ++t < r; ) {
        var o = n[t];
        e(o, t, n) && (s[i++] = o)
    }
    return s
}
function qNe() {
    return []
}
var eOe = Object.prototype
  , tOe = eOe.propertyIsEnumerable
  , Xk = Object.getOwnPropertySymbols
  , nOe = Xk ? function(n) {
    return n == null ? [] : (n = Object(n),
    JNe(Xk(n), function(e) {
        return tOe.call(n, e)
    }))
}
: qNe;
const rOe = nOe;
function Yk(n) {
    return ZNe(n, K2, rOe)
}
var iOe = 1
  , sOe = Object.prototype
  , oOe = sOe.hasOwnProperty;
function aOe(n, e, t, r, i, s) {
    var o = t & iOe
      , a = Yk(n)
      , l = a.length
      , c = Yk(e)
      , A = c.length;
    if (l != A && !o)
        return !1;
    for (var u = l; u--; ) {
        var f = a[u];
        if (!(o ? f in e : oOe.call(e, f)))
            return !1
    }
    var h = s.get(n)
      , d = s.get(e);
    if (h && d)
        return h == e && d == n;
    var m = !0;
    s.set(n, e),
    s.set(e, n);
    for (var g = o; ++u < l; ) {
        f = a[u];
        var p = n[f]
          , v = e[f];
        if (r)
            var w = o ? r(v, p, f, e, n, s) : r(p, v, f, n, e, s);
        if (!(w === void 0 ? p === v || i(p, v, t, r, s) : w)) {
            m = !1;
            break
        }
        g || (g = f == "constructor")
    }
    if (m && !g) {
        var _ = n.constructor
          , x = e.constructor;
        _ != x && "constructor"in n && "constructor"in e && !(typeof _ == "function" && _ instanceof _ && typeof x == "function" && x instanceof x) && (m = !1)
    }
    return s.delete(n),
    s.delete(e),
    m
}
var lOe = tf(da, "DataView");
const GT = lOe;
var cOe = tf(da, "Promise");
const VT = cOe;
var AOe = tf(da, "Set");
const jT = AOe;
var uOe = tf(da, "WeakMap");
const WT = uOe;
var $k = "[object Map]"
  , fOe = "[object Object]"
  , Zk = "[object Promise]"
  , Jk = "[object Set]"
  , qk = "[object WeakMap]"
  , e4 = "[object DataView]"
  , hOe = ef(GT)
  , dOe = ef(qg)
  , pOe = ef(VT)
  , mOe = ef(jT)
  , gOe = ef(WT)
  , su = qu;
(GT && su(new GT(new ArrayBuffer(1))) != e4 || qg && su(new qg) != $k || VT && su(VT.resolve()) != Zk || jT && su(new jT) != Jk || WT && su(new WT) != qk) && (su = function(n) {
    var e = qu(n)
      , t = e == fOe ? n.constructor : void 0
      , r = t ? ef(t) : "";
    if (r)
        switch (r) {
        case hOe:
            return e4;
        case dOe:
            return $k;
        case pOe:
            return Zk;
        case mOe:
            return Jk;
        case gOe:
            return qk
        }
    return e
}
);
const t4 = su;
var vOe = 1
  , n4 = "[object Arguments]"
  , r4 = "[object Array]"
  , Gy = "[object Object]"
  , yOe = Object.prototype
  , i4 = yOe.hasOwnProperty;
function wOe(n, e, t, r, i, s) {
    var o = Gs(n)
      , a = Gs(e)
      , l = o ? r4 : t4(n)
      , c = a ? r4 : t4(e);
    l = l == n4 ? Gy : l,
    c = c == n4 ? Gy : c;
    var A = l == Gy
      , u = c == Gy
      , f = l == c;
    if (f && _x(n)) {
        if (!_x(e))
            return !1;
        o = !0,
        A = !1
    }
    if (f && !A)
        return s || (s = new Ya),
        o || j2(n) ? Ij(n, e, t, r, i, s) : YNe(n, e, l, t, r, i, s);
    if (!(t & vOe)) {
        var h = A && i4.call(n, "__wrapped__")
          , d = u && i4.call(e, "__wrapped__");
        if (h || d) {
            var m = h ? n.value() : n
              , g = d ? e.value() : e;
            return s || (s = new Ya),
            i(m, g, t, r, s)
        }
    }
    return f ? (s || (s = new Ya),
    aOe(n, e, t, r, i, s)) : !1
}
function Y2(n, e, t, r, i) {
    return n === e ? !0 : n == null || e == null || !BA(n) && !BA(e) ? n !== n && e !== e : wOe(n, e, t, r, Y2, i)
}
var _Oe = 1
  , xOe = 2;
function bOe(n, e, t, r) {
    var i = t.length
      , s = i
      , o = !r;
    if (n == null)
        return !s;
    for (n = Object(n); i--; ) {
        var a = t[i];
        if (o && a[2] ? a[1] !== n[a[0]] : !(a[0]in n))
            return !1
    }
    for (; ++i < s; ) {
        a = t[i];
        var l = a[0]
          , c = n[l]
          , A = a[1];
        if (o && a[2]) {
            if (c === void 0 && !(l in n))
                return !1
        } else {
            var u = new Ya;
            if (r)
                var f = r(c, A, l, n, e, u);
            if (!(f === void 0 ? Y2(A, c, _Oe | xOe, r, u) : f))
                return !1
        }
    }
    return !0
}
function Rj(n) {
    return n === n && !Eo(n)
}
function EOe(n) {
    for (var e = K2(n), t = e.length; t--; ) {
        var r = e[t]
          , i = n[r];
        e[t] = [r, i, Rj(i)]
    }
    return e
}
function Uj(n, e) {
    return function(t) {
        return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t))
    }
}
function BOe(n) {
    var e = EOe(n);
    return e.length == 1 && e[0][2] ? Uj(e[0][0], e[0][1]) : function(t) {
        return t === n || bOe(t, n, e)
    }
}
var MOe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , SOe = /^\w*$/;
function $2(n, e) {
    if (Gs(n))
        return !1;
    var t = typeof n;
    return t == "number" || t == "symbol" || t == "boolean" || n == null || J1(n) ? !0 : SOe.test(n) || !MOe.test(n) || e != null && n in Object(e)
}
var COe = "Expected a function";
function Z2(n, e) {
    if (typeof n != "function" || e != null && typeof e != "function")
        throw new TypeError(COe);
    var t = function() {
        var r = arguments
          , i = e ? e.apply(this, r) : r[0]
          , s = t.cache;
        if (s.has(i))
            return s.get(i);
        var o = n.apply(this, r);
        return t.cache = s.set(i, o) || s,
        o
    };
    return t.cache = new (Z2.Cache || hc),
    t
}
Z2.Cache = hc;
var TOe = 500;
function IOe(n) {
    var e = Z2(n, function(r) {
        return t.size === TOe && t.clear(),
        r
    })
      , t = e.cache;
    return e
}
var ROe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , UOe = /\\(\\)?/g
  , FOe = IOe(function(n) {
    var e = [];
    return n.charCodeAt(0) === 46 && e.push(""),
    n.replace(ROe, function(t, r, i, s) {
        e.push(i ? s.replace(UOe, "$1") : r || t)
    }),
    e
});
const POe = FOe;
var LOe = 1 / 0
  , s4 = EA ? EA.prototype : void 0
  , o4 = s4 ? s4.toString : void 0;
function Fj(n) {
    if (typeof n == "string")
        return n;
    if (Gs(n))
        return Tj(n, Fj) + "";
    if (J1(n))
        return o4 ? o4.call(n) : "";
    var e = n + "";
    return e == "0" && 1 / n == -LOe ? "-0" : e
}
function DOe(n) {
    return n == null ? "" : Fj(n)
}
function Pj(n, e) {
    return Gs(n) ? n : $2(n, e) ? [n] : POe(DOe(n))
}
var NOe = 1 / 0;
function tb(n) {
    if (typeof n == "string" || J1(n))
        return n;
    var e = n + "";
    return e == "0" && 1 / n == -NOe ? "-0" : e
}
function Lj(n, e) {
    e = Pj(e, n);
    for (var t = 0, r = e.length; n != null && t < r; )
        n = n[tb(e[t++])];
    return t && t == r ? n : void 0
}
function OOe(n, e, t) {
    var r = n == null ? void 0 : Lj(n, e);
    return r === void 0 ? t : r
}
function kOe(n, e) {
    return n != null && e in Object(n)
}
function QOe(n, e, t) {
    e = Pj(e, n);
    for (var r = -1, i = e.length, s = !1; ++r < i; ) {
        var o = tb(e[r]);
        if (!(s = n != null && t(n, o)))
            break;
        n = n[o]
    }
    return s || ++r != i ? s : (i = n == null ? 0 : n.length,
    !!i && V2(i) && W2(o, i) && (Gs(n) || wx(n)))
}
function HOe(n, e) {
    return n != null && QOe(n, e, kOe)
}
var zOe = 1
  , GOe = 2;
function VOe(n, e) {
    return $2(n) && Rj(e) ? Uj(tb(n), e) : function(t) {
        var r = OOe(t, n);
        return r === void 0 && r === e ? HOe(t, n) : Y2(e, r, zOe | GOe)
    }
}
function jOe(n) {
    return function(e) {
        return e == null ? void 0 : e[n]
    }
}
function WOe(n) {
    return function(e) {
        return Lj(e, n)
    }
}
function KOe(n) {
    return $2(n) ? jOe(tb(n)) : WOe(n)
}
function XOe(n) {
    return typeof n == "function" ? n : n == null ? Z1 : typeof n == "object" ? Gs(n) ? VOe(n[0], n[1]) : BOe(n) : KOe(n)
}
function YOe(n, e) {
    var t = -1
      , r = Ap(n) ? Array(n.length) : [];
    return Bj(n, function(i, s, o) {
        r[++t] = e(i, s, o)
    }),
    r
}
function rf(n, e) {
    var t = Gs(n) ? Tj : YOe;
    return t(n, XOe(e))
}
var $Oe = function(e) {
    var t = e.colors
      , r = e.onClick
      , i = e.onSwatchHover
      , s = vt({
        default: {
            swatches: {
                marginRight: "-10px"
            },
            swatch: {
                width: "22px",
                height: "22px",
                float: "left",
                marginRight: "10px",
                marginBottom: "10px",
                borderRadius: "4px"
            },
            clear: {
                clear: "both"
            }
        }
    });
    return Z.createElement("div", {
        style: s.swatches
    }, rf(t, function(o) {
        return Z.createElement(nf, {
            key: o,
            color: o,
            style: s.swatch,
            onClick: r,
            onHover: i,
            focusStyle: {
                boxShadow: "0 0 4px " + o
            }
        })
    }), Z.createElement("div", {
        style: s.clear
    }))
}
  , J2 = function(e) {
    var t = e.onChange
      , r = e.onSwatchHover
      , i = e.hex
      , s = e.colors
      , o = e.width
      , a = e.triangle
      , l = e.styles
      , c = l === void 0 ? {} : l
      , A = e.className
      , u = A === void 0 ? "" : A
      , f = i === "transparent"
      , h = function(g, p) {
        LA(g) && t({
            hex: g,
            source: "hex"
        }, p)
    }
      , d = vt(fs({
        default: {
            card: {
                width: o,
                background: "#fff",
                boxShadow: "0 1px rgba(0,0,0,.1)",
                borderRadius: "6px",
                position: "relative"
            },
            head: {
                height: "110px",
                background: i,
                borderRadius: "6px 6px 0 0",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                position: "relative"
            },
            body: {
                padding: "10px"
            },
            label: {
                fontSize: "18px",
                color: X2(i),
                position: "relative"
            },
            triangle: {
                width: "0px",
                height: "0px",
                borderStyle: "solid",
                borderWidth: "0 10px 10px 10px",
                borderColor: "transparent transparent " + i + " transparent",
                position: "absolute",
                top: "-10px",
                left: "50%",
                marginLeft: "-10px"
            },
            input: {
                width: "100%",
                fontSize: "12px",
                color: "#666",
                border: "0px",
                outline: "none",
                height: "22px",
                boxShadow: "inset 0 0 0 1px #ddd",
                borderRadius: "4px",
                padding: "0 7px",
                boxSizing: "border-box"
            }
        },
        "hide-triangle": {
            triangle: {
                display: "none"
            }
        }
    }, c), {
        "hide-triangle": a === "hide"
    });
    return Z.createElement("div", {
        style: d.card,
        className: "block-picker " + u
    }, Z.createElement("div", {
        style: d.triangle
    }), Z.createElement("div", {
        style: d.head
    }, f && Z.createElement(lp, {
        borderRadius: "6px 6px 0 0"
    }), Z.createElement("div", {
        style: d.label
    }, i)), Z.createElement("div", {
        style: d.body
    }, Z.createElement($Oe, {
        colors: s,
        onClick: h,
        onSwatchHover: r
    }), Z.createElement(Ht, {
        style: {
            input: d.input
        },
        value: i,
        onChange: h
    })))
};
J2.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    colors: Ve.arrayOf(Ve.string),
    triangle: Ve.oneOf(["top", "hide"]),
    styles: Ve.object
};
J2.defaultProps = {
    width: 170,
    colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
    triangle: "top",
    styles: {}
};
hs(J2);
var Jf = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    a100: "#ff8a80",
    a200: "#ff5252",
    a400: "#ff1744",
    a700: "#d50000"
}
  , qf = {
    50: "#fce4ec",
    100: "#f8bbd0",
    200: "#f48fb1",
    300: "#f06292",
    400: "#ec407a",
    500: "#e91e63",
    600: "#d81b60",
    700: "#c2185b",
    800: "#ad1457",
    900: "#880e4f",
    a100: "#ff80ab",
    a200: "#ff4081",
    a400: "#f50057",
    a700: "#c51162"
}
  , eh = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    a100: "#ea80fc",
    a200: "#e040fb",
    a400: "#d500f9",
    a700: "#aa00ff"
}
  , th = {
    50: "#ede7f6",
    100: "#d1c4e9",
    200: "#b39ddb",
    300: "#9575cd",
    400: "#7e57c2",
    500: "#673ab7",
    600: "#5e35b1",
    700: "#512da8",
    800: "#4527a0",
    900: "#311b92",
    a100: "#b388ff",
    a200: "#7c4dff",
    a400: "#651fff",
    a700: "#6200ea"
}
  , nh = {
    50: "#e8eaf6",
    100: "#c5cae9",
    200: "#9fa8da",
    300: "#7986cb",
    400: "#5c6bc0",
    500: "#3f51b5",
    600: "#3949ab",
    700: "#303f9f",
    800: "#283593",
    900: "#1a237e",
    a100: "#8c9eff",
    a200: "#536dfe",
    a400: "#3d5afe",
    a700: "#304ffe"
}
  , rh = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    a100: "#82b1ff",
    a200: "#448aff",
    a400: "#2979ff",
    a700: "#2962ff"
}
  , ih = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    a100: "#80d8ff",
    a200: "#40c4ff",
    a400: "#00b0ff",
    a700: "#0091ea"
}
  , sh = {
    50: "#e0f7fa",
    100: "#b2ebf2",
    200: "#80deea",
    300: "#4dd0e1",
    400: "#26c6da",
    500: "#00bcd4",
    600: "#00acc1",
    700: "#0097a7",
    800: "#00838f",
    900: "#006064",
    a100: "#84ffff",
    a200: "#18ffff",
    a400: "#00e5ff",
    a700: "#00b8d4"
}
  , oh = {
    50: "#e0f2f1",
    100: "#b2dfdb",
    200: "#80cbc4",
    300: "#4db6ac",
    400: "#26a69a",
    500: "#009688",
    600: "#00897b",
    700: "#00796b",
    800: "#00695c",
    900: "#004d40",
    a100: "#a7ffeb",
    a200: "#64ffda",
    a400: "#1de9b6",
    a700: "#00bfa5"
}
  , Om = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    a100: "#b9f6ca",
    a200: "#69f0ae",
    a400: "#00e676",
    a700: "#00c853"
}
  , ah = {
    50: "#f1f8e9",
    100: "#dcedc8",
    200: "#c5e1a5",
    300: "#aed581",
    400: "#9ccc65",
    500: "#8bc34a",
    600: "#7cb342",
    700: "#689f38",
    800: "#558b2f",
    900: "#33691e",
    a100: "#ccff90",
    a200: "#b2ff59",
    a400: "#76ff03",
    a700: "#64dd17"
}
  , lh = {
    50: "#f9fbe7",
    100: "#f0f4c3",
    200: "#e6ee9c",
    300: "#dce775",
    400: "#d4e157",
    500: "#cddc39",
    600: "#c0ca33",
    700: "#afb42b",
    800: "#9e9d24",
    900: "#827717",
    a100: "#f4ff81",
    a200: "#eeff41",
    a400: "#c6ff00",
    a700: "#aeea00"
}
  , ch = {
    50: "#fffde7",
    100: "#fff9c4",
    200: "#fff59d",
    300: "#fff176",
    400: "#ffee58",
    500: "#ffeb3b",
    600: "#fdd835",
    700: "#fbc02d",
    800: "#f9a825",
    900: "#f57f17",
    a100: "#ffff8d",
    a200: "#ffff00",
    a400: "#ffea00",
    a700: "#ffd600"
}
  , Ah = {
    50: "#fff8e1",
    100: "#ffecb3",
    200: "#ffe082",
    300: "#ffd54f",
    400: "#ffca28",
    500: "#ffc107",
    600: "#ffb300",
    700: "#ffa000",
    800: "#ff8f00",
    900: "#ff6f00",
    a100: "#ffe57f",
    a200: "#ffd740",
    a400: "#ffc400",
    a700: "#ffab00"
}
  , uh = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    a100: "#ffd180",
    a200: "#ffab40",
    a400: "#ff9100",
    a700: "#ff6d00"
}
  , fh = {
    50: "#fbe9e7",
    100: "#ffccbc",
    200: "#ffab91",
    300: "#ff8a65",
    400: "#ff7043",
    500: "#ff5722",
    600: "#f4511e",
    700: "#e64a19",
    800: "#d84315",
    900: "#bf360c",
    a100: "#ff9e80",
    a200: "#ff6e40",
    a400: "#ff3d00",
    a700: "#dd2c00"
}
  , hh = {
    50: "#efebe9",
    100: "#d7ccc8",
    200: "#bcaaa4",
    300: "#a1887f",
    400: "#8d6e63",
    500: "#795548",
    600: "#6d4c41",
    700: "#5d4037",
    800: "#4e342e",
    900: "#3e2723"
}
  , dh = {
    50: "#eceff1",
    100: "#cfd8dc",
    200: "#b0bec5",
    300: "#90a4ae",
    400: "#78909c",
    500: "#607d8b",
    600: "#546e7a",
    700: "#455a64",
    800: "#37474f",
    900: "#263238"
}
  , Dj = function(e) {
    var t = e.color
      , r = e.onClick
      , i = e.onSwatchHover
      , s = e.hover
      , o = e.active
      , a = e.circleSize
      , l = e.circleSpacing
      , c = vt({
        default: {
            swatch: {
                width: a,
                height: a,
                marginRight: l,
                marginBottom: l,
                transform: "scale(1)",
                transition: "100ms transform ease"
            },
            Swatch: {
                borderRadius: "50%",
                background: "transparent",
                boxShadow: "inset 0 0 0 " + (a / 2 + 1) + "px " + t,
                transition: "100ms box-shadow ease"
            }
        },
        hover: {
            swatch: {
                transform: "scale(1.2)"
            }
        },
        active: {
            Swatch: {
                boxShadow: "inset 0 0 0 3px " + t
            }
        }
    }, {
        hover: s,
        active: o
    });
    return Z.createElement("div", {
        style: c.swatch
    }, Z.createElement(nf, {
        style: c.Swatch,
        color: t,
        onClick: r,
        onHover: i,
        focusStyle: {
            boxShadow: c.Swatch.boxShadow + ", 0 0 5px " + t
        }
    }))
};
Dj.defaultProps = {
    circleSize: 28,
    circleSpacing: 14
};
const ZOe = k2(Dj);
var q2 = function(e) {
    var t = e.width
      , r = e.onChange
      , i = e.onSwatchHover
      , s = e.colors
      , o = e.hex
      , a = e.circleSize
      , l = e.styles
      , c = l === void 0 ? {} : l
      , A = e.circleSpacing
      , u = e.className
      , f = u === void 0 ? "" : u
      , h = vt(fs({
        default: {
            card: {
                width: t,
                display: "flex",
                flexWrap: "wrap",
                marginRight: -A,
                marginBottom: -A
            }
        }
    }, c))
      , d = function(g, p) {
        return r({
            hex: g,
            source: "hex"
        }, p)
    };
    return Z.createElement("div", {
        style: h.card,
        className: "circle-picker " + f
    }, rf(s, function(m) {
        return Z.createElement(ZOe, {
            key: m,
            color: m,
            onClick: d,
            onSwatchHover: i,
            active: o === m.toLowerCase(),
            circleSize: a,
            circleSpacing: A
        })
    }))
};
q2.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    circleSize: Ve.number,
    circleSpacing: Ve.number,
    styles: Ve.object
};
q2.defaultProps = {
    width: 252,
    circleSize: 28,
    circleSpacing: 14,
    colors: [Jf[500], qf[500], eh[500], th[500], nh[500], rh[500], ih[500], sh[500], oh[500], Om[500], ah[500], lh[500], ch[500], Ah[500], uh[500], fh[500], hh[500], dh[500]],
    styles: {}
};
hs(q2);
function a4(n) {
    return n === void 0
}
var Nj = {};
Object.defineProperty(Nj, "__esModule", {
    value: !0
});
var l4 = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , JOe = be
  , c4 = qOe(JOe);
function qOe(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function e3e(n, e) {
    var t = {};
    for (var r in n)
        e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    return t
}
var Vy = 24
  , t3e = Nj.default = function(n) {
    var e = n.fill
      , t = e === void 0 ? "currentColor" : e
      , r = n.width
      , i = r === void 0 ? Vy : r
      , s = n.height
      , o = s === void 0 ? Vy : s
      , a = n.style
      , l = a === void 0 ? {} : a
      , c = e3e(n, ["fill", "width", "height", "style"]);
    return c4.default.createElement("svg", l4({
        viewBox: "0 0 " + Vy + " " + Vy,
        style: l4({
            fill: t,
            width: i,
            height: o
        }, l)
    }, c), c4.default.createElement("path", {
        d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
    }))
}
  , n3e = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function r3e(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function i3e(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function s3e(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var Oj = function(n) {
    s3e(e, n);
    function e(t) {
        r3e(this, e);
        var r = i3e(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
        return r.toggleViews = function() {
            r.state.view === "hex" ? r.setState({
                view: "rgb"
            }) : r.state.view === "rgb" ? r.setState({
                view: "hsl"
            }) : r.state.view === "hsl" && (r.props.hsl.a === 1 ? r.setState({
                view: "hex"
            }) : r.setState({
                view: "rgb"
            }))
        }
        ,
        r.handleChange = function(i, s) {
            i.hex ? LA(i.hex) && r.props.onChange({
                hex: i.hex,
                source: "hex"
            }, s) : i.r || i.g || i.b ? r.props.onChange({
                r: i.r || r.props.rgb.r,
                g: i.g || r.props.rgb.g,
                b: i.b || r.props.rgb.b,
                source: "rgb"
            }, s) : i.a ? (i.a < 0 ? i.a = 0 : i.a > 1 && (i.a = 1),
            r.props.onChange({
                h: r.props.hsl.h,
                s: r.props.hsl.s,
                l: r.props.hsl.l,
                a: Math.round(i.a * 100) / 100,
                source: "rgb"
            }, s)) : (i.h || i.s || i.l) && (typeof i.s == "string" && i.s.includes("%") && (i.s = i.s.replace("%", "")),
            typeof i.l == "string" && i.l.includes("%") && (i.l = i.l.replace("%", "")),
            i.s == 1 ? i.s = .01 : i.l == 1 && (i.l = .01),
            r.props.onChange({
                h: i.h || r.props.hsl.h,
                s: Number(a4(i.s) ? r.props.hsl.s : i.s),
                l: Number(a4(i.l) ? r.props.hsl.l : i.l),
                source: "hsl"
            }, s))
        }
        ,
        r.showHighlight = function(i) {
            i.currentTarget.style.background = "#eee"
        }
        ,
        r.hideHighlight = function(i) {
            i.currentTarget.style.background = "transparent"
        }
        ,
        t.hsl.a !== 1 && t.view === "hex" ? r.state = {
            view: "rgb"
        } : r.state = {
            view: t.view
        },
        r
    }
    return n3e(e, [{
        key: "render",
        value: function() {
            var r = this
              , i = vt({
                default: {
                    wrap: {
                        paddingTop: "16px",
                        display: "flex"
                    },
                    fields: {
                        flex: "1",
                        display: "flex",
                        marginLeft: "-6px"
                    },
                    field: {
                        paddingLeft: "6px",
                        width: "100%"
                    },
                    alpha: {
                        paddingLeft: "6px",
                        width: "100%"
                    },
                    toggle: {
                        width: "32px",
                        textAlign: "right",
                        position: "relative"
                    },
                    icon: {
                        marginRight: "-4px",
                        marginTop: "12px",
                        cursor: "pointer",
                        position: "relative"
                    },
                    iconHighlight: {
                        position: "absolute",
                        width: "24px",
                        height: "28px",
                        background: "#eee",
                        borderRadius: "4px",
                        top: "10px",
                        left: "12px",
                        display: "none"
                    },
                    input: {
                        fontSize: "11px",
                        color: "#333",
                        width: "100%",
                        borderRadius: "2px",
                        border: "none",
                        boxShadow: "inset 0 0 0 1px #dadada",
                        height: "21px",
                        textAlign: "center"
                    },
                    label: {
                        textTransform: "uppercase",
                        fontSize: "11px",
                        lineHeight: "11px",
                        color: "#969696",
                        textAlign: "center",
                        display: "block",
                        marginTop: "12px"
                    },
                    svg: {
                        fill: "#333",
                        width: "24px",
                        height: "24px",
                        border: "1px transparent solid",
                        borderRadius: "5px"
                    }
                },
                disableAlpha: {
                    alpha: {
                        display: "none"
                    }
                }
            }, this.props, this.state)
              , s = void 0;
            return this.state.view === "hex" ? s = Z.createElement("div", {
                style: i.fields,
                className: "flexbox-fix"
            }, Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "hex",
                value: this.props.hex,
                onChange: this.handleChange
            }))) : this.state.view === "rgb" ? s = Z.createElement("div", {
                style: i.fields,
                className: "flexbox-fix"
            }, Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "r",
                value: this.props.rgb.r,
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "g",
                value: this.props.rgb.g,
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "b",
                value: this.props.rgb.b,
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.alpha
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "a",
                value: this.props.rgb.a,
                arrowOffset: .01,
                onChange: this.handleChange
            }))) : this.state.view === "hsl" && (s = Z.createElement("div", {
                style: i.fields,
                className: "flexbox-fix"
            }, Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "h",
                value: Math.round(this.props.hsl.h),
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "s",
                value: Math.round(this.props.hsl.s * 100) + "%",
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.field
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "l",
                value: Math.round(this.props.hsl.l * 100) + "%",
                onChange: this.handleChange
            })), Z.createElement("div", {
                style: i.alpha
            }, Z.createElement(Ht, {
                style: {
                    input: i.input,
                    label: i.label
                },
                label: "a",
                value: this.props.hsl.a,
                arrowOffset: .01,
                onChange: this.handleChange
            })))),
            Z.createElement("div", {
                style: i.wrap,
                className: "flexbox-fix"
            }, s, Z.createElement("div", {
                style: i.toggle
            }, Z.createElement("div", {
                style: i.icon,
                onClick: this.toggleViews,
                ref: function(a) {
                    return r.icon = a
                }
            }, Z.createElement(t3e, {
                style: i.svg,
                onMouseOver: this.showHighlight,
                onMouseEnter: this.showHighlight,
                onMouseOut: this.hideHighlight
            }))))
        }
    }], [{
        key: "getDerivedStateFromProps",
        value: function(r, i) {
            return r.hsl.a !== 1 && i.view === "hex" ? {
                view: "rgb"
            } : null
        }
    }]),
    e
}(Z.Component);
Oj.defaultProps = {
    view: "hex"
};
var A4 = function() {
    var e = vt({
        default: {
            picker: {
                width: "12px",
                height: "12px",
                borderRadius: "6px",
                transform: "translate(-6px, -1px)",
                backgroundColor: "rgb(248, 248, 248)",
                boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
            }
        }
    });
    return Z.createElement("div", {
        style: e.picker
    })
}
  , o3e = function() {
    var e = vt({
        default: {
            picker: {
                width: "12px",
                height: "12px",
                borderRadius: "6px",
                boxShadow: "inset 0 0 0 1px #fff",
                transform: "translate(-6px, -6px)"
            }
        }
    });
    return Z.createElement("div", {
        style: e.picker
    })
}
  , eU = function(e) {
    var t = e.width
      , r = e.onChange
      , i = e.disableAlpha
      , s = e.rgb
      , o = e.hsl
      , a = e.hsv
      , l = e.hex
      , c = e.renderers
      , A = e.styles
      , u = A === void 0 ? {} : A
      , f = e.className
      , h = f === void 0 ? "" : f
      , d = e.defaultView
      , m = vt(fs({
        default: {
            picker: {
                width: t,
                background: "#fff",
                borderRadius: "2px",
                boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
                boxSizing: "initial",
                fontFamily: "Menlo"
            },
            saturation: {
                width: "100%",
                paddingBottom: "55%",
                position: "relative",
                borderRadius: "2px 2px 0 0",
                overflow: "hidden"
            },
            Saturation: {
                radius: "2px 2px 0 0"
            },
            body: {
                padding: "16px 16px 12px"
            },
            controls: {
                display: "flex"
            },
            color: {
                width: "32px"
            },
            swatch: {
                marginTop: "6px",
                width: "16px",
                height: "16px",
                borderRadius: "8px",
                position: "relative",
                overflow: "hidden"
            },
            active: {
                absolute: "0px 0px 0px 0px",
                borderRadius: "8px",
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
                background: "rgba(" + s.r + ", " + s.g + ", " + s.b + ", " + s.a + ")",
                zIndex: "2"
            },
            toggles: {
                flex: "1"
            },
            hue: {
                height: "10px",
                position: "relative",
                marginBottom: "8px"
            },
            Hue: {
                radius: "2px"
            },
            alpha: {
                height: "10px",
                position: "relative"
            },
            Alpha: {
                radius: "2px"
            }
        },
        disableAlpha: {
            color: {
                width: "22px"
            },
            alpha: {
                display: "none"
            },
            hue: {
                marginBottom: "0px"
            },
            swatch: {
                width: "10px",
                height: "10px",
                marginTop: "0px"
            }
        }
    }, u), {
        disableAlpha: i
    });
    return Z.createElement("div", {
        style: m.picker,
        className: "chrome-picker " + h
    }, Z.createElement("div", {
        style: m.saturation
    }, Z.createElement(q1, {
        style: m.Saturation,
        hsl: o,
        hsv: a,
        pointer: o3e,
        onChange: r
    })), Z.createElement("div", {
        style: m.body
    }, Z.createElement("div", {
        style: m.controls,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: m.color
    }, Z.createElement("div", {
        style: m.swatch
    }, Z.createElement("div", {
        style: m.active
    }), Z.createElement(lp, {
        renderers: c
    }))), Z.createElement("div", {
        style: m.toggles
    }, Z.createElement("div", {
        style: m.hue
    }, Z.createElement(cp, {
        style: m.Hue,
        hsl: o,
        pointer: A4,
        onChange: r
    })), Z.createElement("div", {
        style: m.alpha
    }, Z.createElement(Q2, {
        style: m.Alpha,
        rgb: s,
        hsl: o,
        pointer: A4,
        renderers: c,
        onChange: r
    })))), Z.createElement(Oj, {
        rgb: s,
        hsl: o,
        hex: l,
        view: d,
        onChange: r,
        disableAlpha: i
    })))
};
eU.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    disableAlpha: Ve.bool,
    styles: Ve.object,
    defaultView: Ve.oneOf(["hex", "rgb", "hsl"])
};
eU.defaultProps = {
    width: 225,
    disableAlpha: !1,
    styles: {}
};
const a3e = hs(eU);
var l3e = function(e) {
    var t = e.color
      , r = e.onClick
      , i = r === void 0 ? function() {}
    : r
      , s = e.onSwatchHover
      , o = e.active
      , a = vt({
        default: {
            color: {
                background: t,
                width: "15px",
                height: "15px",
                float: "left",
                marginRight: "5px",
                marginBottom: "5px",
                position: "relative",
                cursor: "pointer"
            },
            dot: {
                absolute: "5px 5px 5px 5px",
                background: X2(t),
                borderRadius: "50%",
                opacity: "0"
            }
        },
        active: {
            dot: {
                opacity: "1"
            }
        },
        "color-#FFFFFF": {
            color: {
                boxShadow: "inset 0 0 0 1px #ddd"
            },
            dot: {
                background: "#000"
            }
        },
        transparent: {
            dot: {
                background: "#000"
            }
        }
    }, {
        active: o,
        "color-#FFFFFF": t === "#FFFFFF",
        transparent: t === "transparent"
    });
    return Z.createElement(nf, {
        style: a.color,
        color: t,
        onClick: i,
        onHover: s,
        focusStyle: {
            boxShadow: "0 0 4px " + t
        }
    }, Z.createElement("div", {
        style: a.dot
    }))
}
  , c3e = function(e) {
    var t = e.hex
      , r = e.rgb
      , i = e.onChange
      , s = vt({
        default: {
            fields: {
                display: "flex",
                paddingBottom: "6px",
                paddingRight: "5px",
                position: "relative"
            },
            active: {
                position: "absolute",
                top: "6px",
                left: "5px",
                height: "9px",
                width: "9px",
                background: t
            },
            HEXwrap: {
                flex: "6",
                position: "relative"
            },
            HEXinput: {
                width: "80%",
                padding: "0px",
                paddingLeft: "20%",
                border: "none",
                outline: "none",
                background: "none",
                fontSize: "12px",
                color: "#333",
                height: "16px"
            },
            HEXlabel: {
                display: "none"
            },
            RGBwrap: {
                flex: "3",
                position: "relative"
            },
            RGBinput: {
                width: "70%",
                padding: "0px",
                paddingLeft: "30%",
                border: "none",
                outline: "none",
                background: "none",
                fontSize: "12px",
                color: "#333",
                height: "16px"
            },
            RGBlabel: {
                position: "absolute",
                top: "3px",
                left: "0px",
                lineHeight: "16px",
                textTransform: "uppercase",
                fontSize: "12px",
                color: "#999"
            }
        }
    })
      , o = function(l, c) {
        l.r || l.g || l.b ? i({
            r: l.r || r.r,
            g: l.g || r.g,
            b: l.b || r.b,
            source: "rgb"
        }, c) : i({
            hex: l.hex,
            source: "hex"
        }, c)
    };
    return Z.createElement("div", {
        style: s.fields,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: s.active
    }), Z.createElement(Ht, {
        style: {
            wrap: s.HEXwrap,
            input: s.HEXinput,
            label: s.HEXlabel
        },
        label: "hex",
        value: t,
        onChange: o
    }), Z.createElement(Ht, {
        style: {
            wrap: s.RGBwrap,
            input: s.RGBinput,
            label: s.RGBlabel
        },
        label: "r",
        value: r.r,
        onChange: o
    }), Z.createElement(Ht, {
        style: {
            wrap: s.RGBwrap,
            input: s.RGBinput,
            label: s.RGBlabel
        },
        label: "g",
        value: r.g,
        onChange: o
    }), Z.createElement(Ht, {
        style: {
            wrap: s.RGBwrap,
            input: s.RGBinput,
            label: s.RGBlabel
        },
        label: "b",
        value: r.b,
        onChange: o
    }))
}
  , tU = function(e) {
    var t = e.onChange
      , r = e.onSwatchHover
      , i = e.colors
      , s = e.hex
      , o = e.rgb
      , a = e.styles
      , l = a === void 0 ? {} : a
      , c = e.className
      , A = c === void 0 ? "" : c
      , u = vt(fs({
        default: {
            Compact: {
                background: "#f6f6f6",
                radius: "4px"
            },
            compact: {
                paddingTop: "5px",
                paddingLeft: "5px",
                boxSizing: "initial",
                width: "240px"
            },
            clear: {
                clear: "both"
            }
        }
    }, l))
      , f = function(d, m) {
        d.hex ? LA(d.hex) && t({
            hex: d.hex,
            source: "hex"
        }, m) : t(d, m)
    };
    return Z.createElement(D0, {
        style: u.Compact,
        styles: l
    }, Z.createElement("div", {
        style: u.compact,
        className: "compact-picker " + A
    }, Z.createElement("div", null, rf(i, function(h) {
        return Z.createElement(l3e, {
            key: h,
            color: h,
            active: h.toLowerCase() === s,
            onClick: f,
            onSwatchHover: r
        })
    }), Z.createElement("div", {
        style: u.clear
    })), Z.createElement(c3e, {
        hex: s,
        rgb: o,
        onChange: f
    })))
};
tU.propTypes = {
    colors: Ve.arrayOf(Ve.string),
    styles: Ve.object
};
tU.defaultProps = {
    colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
    styles: {}
};
hs(tU);
var A3e = function(e) {
    var t = e.hover
      , r = e.color
      , i = e.onClick
      , s = e.onSwatchHover
      , o = {
        position: "relative",
        zIndex: "2",
        outline: "2px solid #fff",
        boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
    }
      , a = vt({
        default: {
            swatch: {
                width: "25px",
                height: "25px",
                fontSize: "0"
            }
        },
        hover: {
            swatch: o
        }
    }, {
        hover: t
    });
    return Z.createElement("div", {
        style: a.swatch
    }, Z.createElement(nf, {
        color: r,
        onClick: i,
        onHover: s,
        focusStyle: o
    }))
};
const u3e = k2(A3e);
var nU = function(e) {
    var t = e.width
      , r = e.colors
      , i = e.onChange
      , s = e.onSwatchHover
      , o = e.triangle
      , a = e.styles
      , l = a === void 0 ? {} : a
      , c = e.className
      , A = c === void 0 ? "" : c
      , u = vt(fs({
        default: {
            card: {
                width: t,
                background: "#fff",
                border: "1px solid rgba(0,0,0,0.2)",
                boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
                borderRadius: "4px",
                position: "relative",
                padding: "5px",
                display: "flex",
                flexWrap: "wrap"
            },
            triangle: {
                position: "absolute",
                border: "7px solid transparent",
                borderBottomColor: "#fff"
            },
            triangleShadow: {
                position: "absolute",
                border: "8px solid transparent",
                borderBottomColor: "rgba(0,0,0,0.15)"
            }
        },
        "hide-triangle": {
            triangle: {
                display: "none"
            },
            triangleShadow: {
                display: "none"
            }
        },
        "top-left-triangle": {
            triangle: {
                top: "-14px",
                left: "10px"
            },
            triangleShadow: {
                top: "-16px",
                left: "9px"
            }
        },
        "top-right-triangle": {
            triangle: {
                top: "-14px",
                right: "10px"
            },
            triangleShadow: {
                top: "-16px",
                right: "9px"
            }
        },
        "bottom-left-triangle": {
            triangle: {
                top: "35px",
                left: "10px",
                transform: "rotate(180deg)"
            },
            triangleShadow: {
                top: "37px",
                left: "9px",
                transform: "rotate(180deg)"
            }
        },
        "bottom-right-triangle": {
            triangle: {
                top: "35px",
                right: "10px",
                transform: "rotate(180deg)"
            },
            triangleShadow: {
                top: "37px",
                right: "9px",
                transform: "rotate(180deg)"
            }
        }
    }, l), {
        "hide-triangle": o === "hide",
        "top-left-triangle": o === "top-left",
        "top-right-triangle": o === "top-right",
        "bottom-left-triangle": o === "bottom-left",
        "bottom-right-triangle": o === "bottom-right"
    })
      , f = function(d, m) {
        return i({
            hex: d,
            source: "hex"
        }, m)
    };
    return Z.createElement("div", {
        style: u.card,
        className: "github-picker " + A
    }, Z.createElement("div", {
        style: u.triangleShadow
    }), Z.createElement("div", {
        style: u.triangle
    }), rf(r, function(h) {
        return Z.createElement(u3e, {
            color: h,
            key: h,
            onClick: f,
            onSwatchHover: s
        })
    }))
};
nU.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    colors: Ve.arrayOf(Ve.string),
    triangle: Ve.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
    styles: Ve.object
};
nU.defaultProps = {
    width: 200,
    colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
    triangle: "top-left",
    styles: {}
};
hs(nU);
var f3e = function(e) {
    var t = e.direction
      , r = vt({
        default: {
            picker: {
                width: "18px",
                height: "18px",
                borderRadius: "50%",
                transform: "translate(-9px, -1px)",
                backgroundColor: "rgb(248, 248, 248)",
                boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
            }
        },
        vertical: {
            picker: {
                transform: "translate(-3px, -9px)"
            }
        }
    }, {
        vertical: t === "vertical"
    });
    return Z.createElement("div", {
        style: r.picker
    })
}
  , h3e = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , rU = function(e) {
    var t = e.width
      , r = e.height
      , i = e.onChange
      , s = e.hsl
      , o = e.direction
      , a = e.pointer
      , l = e.styles
      , c = l === void 0 ? {} : l
      , A = e.className
      , u = A === void 0 ? "" : A
      , f = vt(fs({
        default: {
            picker: {
                position: "relative",
                width: t,
                height: r
            },
            hue: {
                radius: "2px"
            }
        }
    }, c))
      , h = function(m) {
        return i({
            a: 1,
            h: m.h,
            l: .5,
            s: 1
        })
    };
    return Z.createElement("div", {
        style: f.picker,
        className: "hue-picker " + u
    }, Z.createElement(cp, h3e({}, f.hue, {
        hsl: s,
        pointer: a,
        onChange: h,
        direction: o
    })))
};
rU.propTypes = {
    styles: Ve.object
};
rU.defaultProps = {
    width: "316px",
    height: "16px",
    direction: "horizontal",
    pointer: f3e,
    styles: {}
};
hs(rU);
var d3e = function(e) {
    var t = e.onChange
      , r = e.hex
      , i = e.rgb
      , s = e.styles
      , o = s === void 0 ? {} : s
      , a = e.className
      , l = a === void 0 ? "" : a
      , c = vt(fs({
        default: {
            material: {
                width: "98px",
                height: "98px",
                padding: "16px",
                fontFamily: "Roboto"
            },
            HEXwrap: {
                position: "relative"
            },
            HEXinput: {
                width: "100%",
                marginTop: "12px",
                fontSize: "15px",
                color: "#333",
                padding: "0px",
                border: "0px",
                borderBottom: "2px solid " + r,
                outline: "none",
                height: "30px"
            },
            HEXlabel: {
                position: "absolute",
                top: "0px",
                left: "0px",
                fontSize: "11px",
                color: "#999999",
                textTransform: "capitalize"
            },
            Hex: {
                style: {}
            },
            RGBwrap: {
                position: "relative"
            },
            RGBinput: {
                width: "100%",
                marginTop: "12px",
                fontSize: "15px",
                color: "#333",
                padding: "0px",
                border: "0px",
                borderBottom: "1px solid #eee",
                outline: "none",
                height: "30px"
            },
            RGBlabel: {
                position: "absolute",
                top: "0px",
                left: "0px",
                fontSize: "11px",
                color: "#999999",
                textTransform: "capitalize"
            },
            split: {
                display: "flex",
                marginRight: "-10px",
                paddingTop: "11px"
            },
            third: {
                flex: "1",
                paddingRight: "10px"
            }
        }
    }, o))
      , A = function(f, h) {
        f.hex ? LA(f.hex) && t({
            hex: f.hex,
            source: "hex"
        }, h) : (f.r || f.g || f.b) && t({
            r: f.r || i.r,
            g: f.g || i.g,
            b: f.b || i.b,
            source: "rgb"
        }, h)
    };
    return Z.createElement(D0, {
        styles: o
    }, Z.createElement("div", {
        style: c.material,
        className: "material-picker " + l
    }, Z.createElement(Ht, {
        style: {
            wrap: c.HEXwrap,
            input: c.HEXinput,
            label: c.HEXlabel
        },
        label: "hex",
        value: r,
        onChange: A
    }), Z.createElement("div", {
        style: c.split,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: c.third
    }, Z.createElement(Ht, {
        style: {
            wrap: c.RGBwrap,
            input: c.RGBinput,
            label: c.RGBlabel
        },
        label: "r",
        value: i.r,
        onChange: A
    })), Z.createElement("div", {
        style: c.third
    }, Z.createElement(Ht, {
        style: {
            wrap: c.RGBwrap,
            input: c.RGBinput,
            label: c.RGBlabel
        },
        label: "g",
        value: i.g,
        onChange: A
    })), Z.createElement("div", {
        style: c.third
    }, Z.createElement(Ht, {
        style: {
            wrap: c.RGBwrap,
            input: c.RGBinput,
            label: c.RGBlabel
        },
        label: "b",
        value: i.b,
        onChange: A
    })))))
};
hs(d3e);
var p3e = function(e) {
    var t = e.onChange
      , r = e.rgb
      , i = e.hsv
      , s = e.hex
      , o = vt({
        default: {
            fields: {
                paddingTop: "5px",
                paddingBottom: "9px",
                width: "80px",
                position: "relative"
            },
            divider: {
                height: "5px"
            },
            RGBwrap: {
                position: "relative"
            },
            RGBinput: {
                marginLeft: "40%",
                width: "40%",
                height: "18px",
                border: "1px solid #888888",
                boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
                marginBottom: "5px",
                fontSize: "13px",
                paddingLeft: "3px",
                marginRight: "10px"
            },
            RGBlabel: {
                left: "0px",
                top: "0px",
                width: "34px",
                textTransform: "uppercase",
                fontSize: "13px",
                height: "18px",
                lineHeight: "22px",
                position: "absolute"
            },
            HEXwrap: {
                position: "relative"
            },
            HEXinput: {
                marginLeft: "20%",
                width: "80%",
                height: "18px",
                border: "1px solid #888888",
                boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
                marginBottom: "6px",
                fontSize: "13px",
                paddingLeft: "3px"
            },
            HEXlabel: {
                position: "absolute",
                top: "0px",
                left: "0px",
                width: "14px",
                textTransform: "uppercase",
                fontSize: "13px",
                height: "18px",
                lineHeight: "22px"
            },
            fieldSymbols: {
                position: "absolute",
                top: "5px",
                right: "-7px",
                fontSize: "13px"
            },
            symbol: {
                height: "20px",
                lineHeight: "22px",
                paddingBottom: "7px"
            }
        }
    })
      , a = function(c, A) {
        c["#"] ? LA(c["#"]) && t({
            hex: c["#"],
            source: "hex"
        }, A) : c.r || c.g || c.b ? t({
            r: c.r || r.r,
            g: c.g || r.g,
            b: c.b || r.b,
            source: "rgb"
        }, A) : (c.h || c.s || c.v) && t({
            h: c.h || i.h,
            s: c.s || i.s,
            v: c.v || i.v,
            source: "hsv"
        }, A)
    };
    return Z.createElement("div", {
        style: o.fields
    }, Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "h",
        value: Math.round(i.h),
        onChange: a
    }), Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "s",
        value: Math.round(i.s * 100),
        onChange: a
    }), Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "v",
        value: Math.round(i.v * 100),
        onChange: a
    }), Z.createElement("div", {
        style: o.divider
    }), Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "r",
        value: r.r,
        onChange: a
    }), Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "g",
        value: r.g,
        onChange: a
    }), Z.createElement(Ht, {
        style: {
            wrap: o.RGBwrap,
            input: o.RGBinput,
            label: o.RGBlabel
        },
        label: "b",
        value: r.b,
        onChange: a
    }), Z.createElement("div", {
        style: o.divider
    }), Z.createElement(Ht, {
        style: {
            wrap: o.HEXwrap,
            input: o.HEXinput,
            label: o.HEXlabel
        },
        label: "#",
        value: s.replace("#", ""),
        onChange: a
    }), Z.createElement("div", {
        style: o.fieldSymbols
    }, Z.createElement("div", {
        style: o.symbol
    }, "°"), Z.createElement("div", {
        style: o.symbol
    }, "%"), Z.createElement("div", {
        style: o.symbol
    }, "%")))
}
  , m3e = function(e) {
    var t = e.hsl
      , r = vt({
        default: {
            picker: {
                width: "12px",
                height: "12px",
                borderRadius: "6px",
                boxShadow: "inset 0 0 0 1px #fff",
                transform: "translate(-6px, -6px)"
            }
        },
        "black-outline": {
            picker: {
                boxShadow: "inset 0 0 0 1px #000"
            }
        }
    }, {
        "black-outline": t.l > .5
    });
    return Z.createElement("div", {
        style: r.picker
    })
}
  , g3e = function() {
    var e = vt({
        default: {
            triangle: {
                width: 0,
                height: 0,
                borderStyle: "solid",
                borderWidth: "4px 0 4px 6px",
                borderColor: "transparent transparent transparent #fff",
                position: "absolute",
                top: "1px",
                left: "1px"
            },
            triangleBorder: {
                width: 0,
                height: 0,
                borderStyle: "solid",
                borderWidth: "5px 0 5px 8px",
                borderColor: "transparent transparent transparent #555"
            },
            left: {
                Extend: "triangleBorder",
                transform: "translate(-13px, -4px)"
            },
            leftInside: {
                Extend: "triangle",
                transform: "translate(-8px, -5px)"
            },
            right: {
                Extend: "triangleBorder",
                transform: "translate(20px, -14px) rotate(180deg)"
            },
            rightInside: {
                Extend: "triangle",
                transform: "translate(-8px, -5px)"
            }
        }
    });
    return Z.createElement("div", {
        style: e.pointer
    }, Z.createElement("div", {
        style: e.left
    }, Z.createElement("div", {
        style: e.leftInside
    })), Z.createElement("div", {
        style: e.right
    }, Z.createElement("div", {
        style: e.rightInside
    })))
}
  , u4 = function(e) {
    var t = e.onClick
      , r = e.label
      , i = e.children
      , s = e.active
      , o = vt({
        default: {
            button: {
                backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
                border: "1px solid #878787",
                borderRadius: "2px",
                height: "20px",
                boxShadow: "0 1px 0 0 #EAEAEA",
                fontSize: "14px",
                color: "#000",
                lineHeight: "20px",
                textAlign: "center",
                marginBottom: "10px",
                cursor: "pointer"
            }
        },
        active: {
            button: {
                boxShadow: "0 0 0 1px #878787"
            }
        }
    }, {
        active: s
    });
    return Z.createElement("div", {
        style: o.button,
        onClick: t
    }, r || i)
}
  , v3e = function(e) {
    var t = e.rgb
      , r = e.currentColor
      , i = vt({
        default: {
            swatches: {
                border: "1px solid #B3B3B3",
                borderBottom: "1px solid #F0F0F0",
                marginBottom: "2px",
                marginTop: "1px"
            },
            new: {
                height: "34px",
                background: "rgb(" + t.r + "," + t.g + ", " + t.b + ")",
                boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
            },
            current: {
                height: "34px",
                background: r,
                boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
            },
            label: {
                fontSize: "14px",
                color: "#000",
                textAlign: "center"
            }
        }
    });
    return Z.createElement("div", null, Z.createElement("div", {
        style: i.label
    }, "new"), Z.createElement("div", {
        style: i.swatches
    }, Z.createElement("div", {
        style: i.new
    }), Z.createElement("div", {
        style: i.current
    })), Z.createElement("div", {
        style: i.label
    }, "current"))
}
  , y3e = function() {
    function n(e, t) {
        for (var r = 0; r < t.length; r++) {
            var i = t[r];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, r) {
        return t && n(e.prototype, t),
        r && n(e, r),
        e
    }
}();
function w3e(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function _3e(n, e) {
    if (!n)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e && (typeof e == "object" || typeof e == "function") ? e : n
}
function x3e(n, e) {
    if (typeof e != "function" && e !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof e);
    n.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e)
}
var iU = function(n) {
    x3e(e, n);
    function e(t) {
        w3e(this, e);
        var r = _3e(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
        return r.state = {
            currentColor: t.hex
        },
        r
    }
    return y3e(e, [{
        key: "render",
        value: function() {
            var r = this.props
              , i = r.styles
              , s = i === void 0 ? {} : i
              , o = r.className
              , a = o === void 0 ? "" : o
              , l = vt(fs({
                default: {
                    picker: {
                        background: "#DCDCDC",
                        borderRadius: "4px",
                        boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
                        boxSizing: "initial",
                        width: "513px"
                    },
                    head: {
                        backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
                        borderBottom: "1px solid #B1B1B1",
                        boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
                        height: "23px",
                        lineHeight: "24px",
                        borderRadius: "4px 4px 0 0",
                        fontSize: "13px",
                        color: "#4D4D4D",
                        textAlign: "center"
                    },
                    body: {
                        padding: "15px 15px 0",
                        display: "flex"
                    },
                    saturation: {
                        width: "256px",
                        height: "256px",
                        position: "relative",
                        border: "2px solid #B3B3B3",
                        borderBottom: "2px solid #F0F0F0",
                        overflow: "hidden"
                    },
                    hue: {
                        position: "relative",
                        height: "256px",
                        width: "19px",
                        marginLeft: "10px",
                        border: "2px solid #B3B3B3",
                        borderBottom: "2px solid #F0F0F0"
                    },
                    controls: {
                        width: "180px",
                        marginLeft: "10px"
                    },
                    top: {
                        display: "flex"
                    },
                    previews: {
                        width: "60px"
                    },
                    actions: {
                        flex: "1",
                        marginLeft: "20px"
                    }
                }
            }, s));
            return Z.createElement("div", {
                style: l.picker,
                className: "photoshop-picker " + a
            }, Z.createElement("div", {
                style: l.head
            }, this.props.header), Z.createElement("div", {
                style: l.body,
                className: "flexbox-fix"
            }, Z.createElement("div", {
                style: l.saturation
            }, Z.createElement(q1, {
                hsl: this.props.hsl,
                hsv: this.props.hsv,
                pointer: m3e,
                onChange: this.props.onChange
            })), Z.createElement("div", {
                style: l.hue
            }, Z.createElement(cp, {
                direction: "vertical",
                hsl: this.props.hsl,
                pointer: g3e,
                onChange: this.props.onChange
            })), Z.createElement("div", {
                style: l.controls
            }, Z.createElement("div", {
                style: l.top,
                className: "flexbox-fix"
            }, Z.createElement("div", {
                style: l.previews
            }, Z.createElement(v3e, {
                rgb: this.props.rgb,
                currentColor: this.state.currentColor
            })), Z.createElement("div", {
                style: l.actions
            }, Z.createElement(u4, {
                label: "OK",
                onClick: this.props.onAccept,
                active: !0
            }), Z.createElement(u4, {
                label: "Cancel",
                onClick: this.props.onCancel
            }), Z.createElement(p3e, {
                onChange: this.props.onChange,
                rgb: this.props.rgb,
                hsv: this.props.hsv,
                hex: this.props.hex
            }))))))
        }
    }]),
    e
}(Z.Component);
iU.propTypes = {
    header: Ve.string,
    styles: Ve.object
};
iU.defaultProps = {
    header: "Color Picker",
    styles: {}
};
hs(iU);
var b3e = function(e) {
    var t = e.onChange
      , r = e.rgb
      , i = e.hsl
      , s = e.hex
      , o = e.disableAlpha
      , a = vt({
        default: {
            fields: {
                display: "flex",
                paddingTop: "4px"
            },
            single: {
                flex: "1",
                paddingLeft: "6px"
            },
            alpha: {
                flex: "1",
                paddingLeft: "6px"
            },
            double: {
                flex: "2"
            },
            input: {
                width: "80%",
                padding: "4px 10% 3px",
                border: "none",
                boxShadow: "inset 0 0 0 1px #ccc",
                fontSize: "11px"
            },
            label: {
                display: "block",
                textAlign: "center",
                fontSize: "11px",
                color: "#222",
                paddingTop: "3px",
                paddingBottom: "4px",
                textTransform: "capitalize"
            }
        },
        disableAlpha: {
            alpha: {
                display: "none"
            }
        }
    }, {
        disableAlpha: o
    })
      , l = function(A, u) {
        A.hex ? LA(A.hex) && t({
            hex: A.hex,
            source: "hex"
        }, u) : A.r || A.g || A.b ? t({
            r: A.r || r.r,
            g: A.g || r.g,
            b: A.b || r.b,
            a: r.a,
            source: "rgb"
        }, u) : A.a && (A.a < 0 ? A.a = 0 : A.a > 100 && (A.a = 100),
        A.a /= 100,
        t({
            h: i.h,
            s: i.s,
            l: i.l,
            a: A.a,
            source: "rgb"
        }, u))
    };
    return Z.createElement("div", {
        style: a.fields,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: a.double
    }, Z.createElement(Ht, {
        style: {
            input: a.input,
            label: a.label
        },
        label: "hex",
        value: s.replace("#", ""),
        onChange: l
    })), Z.createElement("div", {
        style: a.single
    }, Z.createElement(Ht, {
        style: {
            input: a.input,
            label: a.label
        },
        label: "r",
        value: r.r,
        onChange: l,
        dragLabel: "true",
        dragMax: "255"
    })), Z.createElement("div", {
        style: a.single
    }, Z.createElement(Ht, {
        style: {
            input: a.input,
            label: a.label
        },
        label: "g",
        value: r.g,
        onChange: l,
        dragLabel: "true",
        dragMax: "255"
    })), Z.createElement("div", {
        style: a.single
    }, Z.createElement(Ht, {
        style: {
            input: a.input,
            label: a.label
        },
        label: "b",
        value: r.b,
        onChange: l,
        dragLabel: "true",
        dragMax: "255"
    })), Z.createElement("div", {
        style: a.alpha
    }, Z.createElement(Ht, {
        style: {
            input: a.input,
            label: a.label
        },
        label: "a",
        value: Math.round(r.a * 100),
        onChange: l,
        dragLabel: "true",
        dragMax: "100"
    })))
}
  , E3e = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , kj = function(e) {
    var t = e.colors
      , r = e.onClick
      , i = r === void 0 ? function() {}
    : r
      , s = e.onSwatchHover
      , o = vt({
        default: {
            colors: {
                margin: "0 -10px",
                padding: "10px 0 0 10px",
                borderTop: "1px solid #eee",
                display: "flex",
                flexWrap: "wrap",
                position: "relative"
            },
            swatchWrap: {
                width: "16px",
                height: "16px",
                margin: "0 10px 10px 0"
            },
            swatch: {
                borderRadius: "3px",
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
            }
        },
        "no-presets": {
            colors: {
                display: "none"
            }
        }
    }, {
        "no-presets": !t || !t.length
    })
      , a = function(c, A) {
        i({
            hex: c,
            source: "hex"
        }, A)
    };
    return Z.createElement("div", {
        style: o.colors,
        className: "flexbox-fix"
    }, t.map(function(l) {
        var c = typeof l == "string" ? {
            color: l
        } : l
          , A = "" + c.color + (c.title || "");
        return Z.createElement("div", {
            key: A,
            style: o.swatchWrap
        }, Z.createElement(nf, E3e({}, c, {
            style: o.swatch,
            onClick: a,
            onHover: s,
            focusStyle: {
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c.color
            }
        })))
    }))
};
kj.propTypes = {
    colors: Ve.arrayOf(Ve.oneOfType([Ve.string, Ve.shape({
        color: Ve.string,
        title: Ve.string
    })])).isRequired
};
var B3e = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , sU = function(e) {
    var t = e.width
      , r = e.rgb
      , i = e.hex
      , s = e.hsv
      , o = e.hsl
      , a = e.onChange
      , l = e.onSwatchHover
      , c = e.disableAlpha
      , A = e.presetColors
      , u = e.renderers
      , f = e.styles
      , h = f === void 0 ? {} : f
      , d = e.className
      , m = d === void 0 ? "" : d
      , g = vt(fs({
        default: B3e({
            picker: {
                width: t,
                padding: "10px 10px 0",
                boxSizing: "initial",
                background: "#fff",
                borderRadius: "4px",
                boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
            },
            saturation: {
                width: "100%",
                paddingBottom: "75%",
                position: "relative",
                overflow: "hidden"
            },
            Saturation: {
                radius: "3px",
                shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
            },
            controls: {
                display: "flex"
            },
            sliders: {
                padding: "4px 0",
                flex: "1"
            },
            color: {
                width: "24px",
                height: "24px",
                position: "relative",
                marginTop: "4px",
                marginLeft: "4px",
                borderRadius: "3px"
            },
            activeColor: {
                absolute: "0px 0px 0px 0px",
                borderRadius: "2px",
                background: "rgba(" + r.r + "," + r.g + "," + r.b + "," + r.a + ")",
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
            },
            hue: {
                position: "relative",
                height: "10px",
                overflow: "hidden"
            },
            Hue: {
                radius: "2px",
                shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
            },
            alpha: {
                position: "relative",
                height: "10px",
                marginTop: "4px",
                overflow: "hidden"
            },
            Alpha: {
                radius: "2px",
                shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
            }
        }, h),
        disableAlpha: {
            color: {
                height: "10px"
            },
            hue: {
                height: "10px"
            },
            alpha: {
                display: "none"
            }
        }
    }, h), {
        disableAlpha: c
    });
    return Z.createElement("div", {
        style: g.picker,
        className: "sketch-picker " + m
    }, Z.createElement("div", {
        style: g.saturation
    }, Z.createElement(q1, {
        style: g.Saturation,
        hsl: o,
        hsv: s,
        onChange: a
    })), Z.createElement("div", {
        style: g.controls,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: g.sliders
    }, Z.createElement("div", {
        style: g.hue
    }, Z.createElement(cp, {
        style: g.Hue,
        hsl: o,
        onChange: a
    })), Z.createElement("div", {
        style: g.alpha
    }, Z.createElement(Q2, {
        style: g.Alpha,
        rgb: r,
        hsl: o,
        renderers: u,
        onChange: a
    }))), Z.createElement("div", {
        style: g.color
    }, Z.createElement(lp, null), Z.createElement("div", {
        style: g.activeColor
    }))), Z.createElement(b3e, {
        rgb: r,
        hsl: o,
        hex: i,
        onChange: a,
        disableAlpha: c
    }), Z.createElement(kj, {
        colors: A,
        onClick: a,
        onSwatchHover: l
    }))
};
sU.propTypes = {
    disableAlpha: Ve.bool,
    width: Ve.oneOfType([Ve.string, Ve.number]),
    styles: Ve.object
};
sU.defaultProps = {
    disableAlpha: !1,
    width: 200,
    styles: {},
    presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
hs(sU);
var fm = function(e) {
    var t = e.hsl
      , r = e.offset
      , i = e.onClick
      , s = i === void 0 ? function() {}
    : i
      , o = e.active
      , a = e.first
      , l = e.last
      , c = vt({
        default: {
            swatch: {
                height: "12px",
                background: "hsl(" + t.h + ", 50%, " + r * 100 + "%)",
                cursor: "pointer"
            }
        },
        first: {
            swatch: {
                borderRadius: "2px 0 0 2px"
            }
        },
        last: {
            swatch: {
                borderRadius: "0 2px 2px 0"
            }
        },
        active: {
            swatch: {
                transform: "scaleY(1.8)",
                borderRadius: "3.6px/2px"
            }
        }
    }, {
        active: o,
        first: a,
        last: l
    })
      , A = function(f) {
        return s({
            h: t.h,
            s: .5,
            l: r,
            source: "hsl"
        }, f)
    };
    return Z.createElement("div", {
        style: c.swatch,
        onClick: A
    })
}
  , M3e = function(e) {
    var t = e.onClick
      , r = e.hsl
      , i = vt({
        default: {
            swatches: {
                marginTop: "20px"
            },
            swatch: {
                boxSizing: "border-box",
                width: "20%",
                paddingRight: "1px",
                float: "left"
            },
            clear: {
                clear: "both"
            }
        }
    })
      , s = .1;
    return Z.createElement("div", {
        style: i.swatches
    }, Z.createElement("div", {
        style: i.swatch
    }, Z.createElement(fm, {
        hsl: r,
        offset: ".80",
        active: Math.abs(r.l - .8) < s && Math.abs(r.s - .5) < s,
        onClick: t,
        first: !0
    })), Z.createElement("div", {
        style: i.swatch
    }, Z.createElement(fm, {
        hsl: r,
        offset: ".65",
        active: Math.abs(r.l - .65) < s && Math.abs(r.s - .5) < s,
        onClick: t
    })), Z.createElement("div", {
        style: i.swatch
    }, Z.createElement(fm, {
        hsl: r,
        offset: ".50",
        active: Math.abs(r.l - .5) < s && Math.abs(r.s - .5) < s,
        onClick: t
    })), Z.createElement("div", {
        style: i.swatch
    }, Z.createElement(fm, {
        hsl: r,
        offset: ".35",
        active: Math.abs(r.l - .35) < s && Math.abs(r.s - .5) < s,
        onClick: t
    })), Z.createElement("div", {
        style: i.swatch
    }, Z.createElement(fm, {
        hsl: r,
        offset: ".20",
        active: Math.abs(r.l - .2) < s && Math.abs(r.s - .5) < s,
        onClick: t,
        last: !0
    })), Z.createElement("div", {
        style: i.clear
    }))
}
  , S3e = function() {
    var e = vt({
        default: {
            picker: {
                width: "14px",
                height: "14px",
                borderRadius: "6px",
                transform: "translate(-7px, -1px)",
                backgroundColor: "rgb(248, 248, 248)",
                boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
            }
        }
    });
    return Z.createElement("div", {
        style: e.picker
    })
}
  , oU = function(e) {
    var t = e.hsl
      , r = e.onChange
      , i = e.pointer
      , s = e.styles
      , o = s === void 0 ? {} : s
      , a = e.className
      , l = a === void 0 ? "" : a
      , c = vt(fs({
        default: {
            hue: {
                height: "12px",
                position: "relative"
            },
            Hue: {
                radius: "2px"
            }
        }
    }, o));
    return Z.createElement("div", {
        style: c.wrap || {},
        className: "slider-picker " + l
    }, Z.createElement("div", {
        style: c.hue
    }, Z.createElement(cp, {
        style: c.Hue,
        hsl: t,
        pointer: i,
        onChange: r
    })), Z.createElement("div", {
        style: c.swatches
    }, Z.createElement(M3e, {
        hsl: t,
        onClick: r
    })))
};
oU.propTypes = {
    styles: Ve.object
};
oU.defaultProps = {
    pointer: S3e,
    styles: {}
};
hs(oU);
var Qj = {};
Object.defineProperty(Qj, "__esModule", {
    value: !0
});
var f4 = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
    }
    return n
}
  , C3e = be
  , h4 = T3e(C3e);
function T3e(n) {
    return n && n.__esModule ? n : {
        default: n
    }
}
function I3e(n, e) {
    var t = {};
    for (var r in n)
        e.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    return t
}
var jy = 24
  , R3e = Qj.default = function(n) {
    var e = n.fill
      , t = e === void 0 ? "currentColor" : e
      , r = n.width
      , i = r === void 0 ? jy : r
      , s = n.height
      , o = s === void 0 ? jy : s
      , a = n.style
      , l = a === void 0 ? {} : a
      , c = I3e(n, ["fill", "width", "height", "style"]);
    return h4.default.createElement("svg", f4({
        viewBox: "0 0 " + jy + " " + jy,
        style: f4({
            fill: t,
            width: i,
            height: o
        }, l)
    }, c), h4.default.createElement("path", {
        d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"
    }))
}
  , U3e = function(e) {
    var t = e.color
      , r = e.onClick
      , i = r === void 0 ? function() {}
    : r
      , s = e.onSwatchHover
      , o = e.first
      , a = e.last
      , l = e.active
      , c = vt({
        default: {
            color: {
                width: "40px",
                height: "24px",
                cursor: "pointer",
                background: t,
                marginBottom: "1px"
            },
            check: {
                color: X2(t),
                marginLeft: "8px",
                display: "none"
            }
        },
        first: {
            color: {
                overflow: "hidden",
                borderRadius: "2px 2px 0 0"
            }
        },
        last: {
            color: {
                overflow: "hidden",
                borderRadius: "0 0 2px 2px"
            }
        },
        active: {
            check: {
                display: "block"
            }
        },
        "color-#FFFFFF": {
            color: {
                boxShadow: "inset 0 0 0 1px #ddd"
            },
            check: {
                color: "#333"
            }
        },
        transparent: {
            check: {
                color: "#333"
            }
        }
    }, {
        first: o,
        last: a,
        active: l,
        "color-#FFFFFF": t === "#FFFFFF",
        transparent: t === "transparent"
    });
    return Z.createElement(nf, {
        color: t,
        style: c.color,
        onClick: i,
        onHover: s,
        focusStyle: {
            boxShadow: "0 0 4px " + t
        }
    }, Z.createElement("div", {
        style: c.check
    }, Z.createElement(R3e, null)))
}
  , F3e = function(e) {
    var t = e.onClick
      , r = e.onSwatchHover
      , i = e.group
      , s = e.active
      , o = vt({
        default: {
            group: {
                paddingBottom: "10px",
                width: "40px",
                float: "left",
                marginRight: "10px"
            }
        }
    });
    return Z.createElement("div", {
        style: o.group
    }, rf(i, function(a, l) {
        return Z.createElement(U3e, {
            key: a,
            color: a,
            active: a.toLowerCase() === s,
            first: l === 0,
            last: l === i.length - 1,
            onClick: t,
            onSwatchHover: r
        })
    }))
}
  , aU = function(e) {
    var t = e.width
      , r = e.height
      , i = e.onChange
      , s = e.onSwatchHover
      , o = e.colors
      , a = e.hex
      , l = e.styles
      , c = l === void 0 ? {} : l
      , A = e.className
      , u = A === void 0 ? "" : A
      , f = vt(fs({
        default: {
            picker: {
                width: t,
                height: r
            },
            overflow: {
                height: r,
                overflowY: "scroll"
            },
            body: {
                padding: "16px 0 6px 16px"
            },
            clear: {
                clear: "both"
            }
        }
    }, c))
      , h = function(m, g) {
        return i({
            hex: m,
            source: "hex"
        }, g)
    };
    return Z.createElement("div", {
        style: f.picker,
        className: "swatches-picker " + u
    }, Z.createElement(D0, null, Z.createElement("div", {
        style: f.overflow
    }, Z.createElement("div", {
        style: f.body
    }, rf(o, function(d) {
        return Z.createElement(F3e, {
            key: d.toString(),
            group: d,
            active: a,
            onClick: h,
            onSwatchHover: s
        })
    }), Z.createElement("div", {
        style: f.clear
    })))))
};
aU.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    height: Ve.oneOfType([Ve.string, Ve.number]),
    colors: Ve.arrayOf(Ve.arrayOf(Ve.string)),
    styles: Ve.object
};
aU.defaultProps = {
    width: 320,
    height: 240,
    colors: [[Jf[900], Jf[700], Jf[500], Jf[300], Jf[100]], [qf[900], qf[700], qf[500], qf[300], qf[100]], [eh[900], eh[700], eh[500], eh[300], eh[100]], [th[900], th[700], th[500], th[300], th[100]], [nh[900], nh[700], nh[500], nh[300], nh[100]], [rh[900], rh[700], rh[500], rh[300], rh[100]], [ih[900], ih[700], ih[500], ih[300], ih[100]], [sh[900], sh[700], sh[500], sh[300], sh[100]], [oh[900], oh[700], oh[500], oh[300], oh[100]], ["#194D33", Om[700], Om[500], Om[300], Om[100]], [ah[900], ah[700], ah[500], ah[300], ah[100]], [lh[900], lh[700], lh[500], lh[300], lh[100]], [ch[900], ch[700], ch[500], ch[300], ch[100]], [Ah[900], Ah[700], Ah[500], Ah[300], Ah[100]], [uh[900], uh[700], uh[500], uh[300], uh[100]], [fh[900], fh[700], fh[500], fh[300], fh[100]], [hh[900], hh[700], hh[500], hh[300], hh[100]], [dh[900], dh[700], dh[500], dh[300], dh[100]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
    styles: {}
};
hs(aU);
var lU = function(e) {
    var t = e.onChange
      , r = e.onSwatchHover
      , i = e.hex
      , s = e.colors
      , o = e.width
      , a = e.triangle
      , l = e.styles
      , c = l === void 0 ? {} : l
      , A = e.className
      , u = A === void 0 ? "" : A
      , f = vt(fs({
        default: {
            card: {
                width: o,
                background: "#fff",
                border: "0 solid rgba(0,0,0,0.25)",
                boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
                borderRadius: "4px",
                position: "relative"
            },
            body: {
                padding: "15px 9px 9px 15px"
            },
            label: {
                fontSize: "18px",
                color: "#fff"
            },
            triangle: {
                width: "0px",
                height: "0px",
                borderStyle: "solid",
                borderWidth: "0 9px 10px 9px",
                borderColor: "transparent transparent #fff transparent",
                position: "absolute"
            },
            triangleShadow: {
                width: "0px",
                height: "0px",
                borderStyle: "solid",
                borderWidth: "0 9px 10px 9px",
                borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
                position: "absolute"
            },
            hash: {
                background: "#F0F0F0",
                height: "30px",
                width: "30px",
                borderRadius: "4px 0 0 4px",
                float: "left",
                color: "#98A1A4",
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
            },
            input: {
                width: "100px",
                fontSize: "14px",
                color: "#666",
                border: "0px",
                outline: "none",
                height: "28px",
                boxShadow: "inset 0 0 0 1px #F0F0F0",
                boxSizing: "content-box",
                borderRadius: "0 4px 4px 0",
                float: "left",
                paddingLeft: "8px"
            },
            swatch: {
                width: "30px",
                height: "30px",
                float: "left",
                borderRadius: "4px",
                margin: "0 6px 6px 0"
            },
            clear: {
                clear: "both"
            }
        },
        "hide-triangle": {
            triangle: {
                display: "none"
            },
            triangleShadow: {
                display: "none"
            }
        },
        "top-left-triangle": {
            triangle: {
                top: "-10px",
                left: "12px"
            },
            triangleShadow: {
                top: "-11px",
                left: "12px"
            }
        },
        "top-right-triangle": {
            triangle: {
                top: "-10px",
                right: "12px"
            },
            triangleShadow: {
                top: "-11px",
                right: "12px"
            }
        }
    }, c), {
        "hide-triangle": a === "hide",
        "top-left-triangle": a === "top-left",
        "top-right-triangle": a === "top-right"
    })
      , h = function(m, g) {
        LA(m) && t({
            hex: m,
            source: "hex"
        }, g)
    };
    return Z.createElement("div", {
        style: f.card,
        className: "twitter-picker " + u
    }, Z.createElement("div", {
        style: f.triangleShadow
    }), Z.createElement("div", {
        style: f.triangle
    }), Z.createElement("div", {
        style: f.body
    }, rf(s, function(d, m) {
        return Z.createElement(nf, {
            key: m,
            color: d,
            hex: d,
            style: f.swatch,
            onClick: h,
            onHover: r,
            focusStyle: {
                boxShadow: "0 0 4px " + d
            }
        })
    }), Z.createElement("div", {
        style: f.hash
    }, "#"), Z.createElement(Ht, {
        label: null,
        style: {
            input: f.input
        },
        value: i.replace("#", ""),
        onChange: h
    }), Z.createElement("div", {
        style: f.clear
    })))
};
lU.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    triangle: Ve.oneOf(["hide", "top-left", "top-right"]),
    colors: Ve.arrayOf(Ve.string),
    styles: Ve.object
};
lU.defaultProps = {
    width: 276,
    colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
    triangle: "top-left",
    styles: {}
};
hs(lU);
var cU = function(e) {
    var t = vt({
        default: {
            picker: {
                width: "20px",
                height: "20px",
                borderRadius: "22px",
                border: "2px #fff solid",
                transform: "translate(-12px, -13px)",
                background: "hsl(" + Math.round(e.hsl.h) + ", " + Math.round(e.hsl.s * 100) + "%, " + Math.round(e.hsl.l * 100) + "%)"
            }
        }
    });
    return Z.createElement("div", {
        style: t.picker
    })
};
cU.propTypes = {
    hsl: Ve.shape({
        h: Ve.number,
        s: Ve.number,
        l: Ve.number,
        a: Ve.number
    })
};
cU.defaultProps = {
    hsl: {
        a: 1,
        h: 249.94,
        l: .2,
        s: .5
    }
};
var AU = function(e) {
    var t = vt({
        default: {
            picker: {
                width: "20px",
                height: "20px",
                borderRadius: "22px",
                transform: "translate(-10px, -7px)",
                background: "hsl(" + Math.round(e.hsl.h) + ", 100%, 50%)",
                border: "2px white solid"
            }
        }
    });
    return Z.createElement("div", {
        style: t.picker
    })
};
AU.propTypes = {
    hsl: Ve.shape({
        h: Ve.number,
        s: Ve.number,
        l: Ve.number,
        a: Ve.number
    })
};
AU.defaultProps = {
    hsl: {
        a: 1,
        h: 249.94,
        l: .2,
        s: .5
    }
};
var P3e = function(e) {
    var t = e.onChange
      , r = e.rgb
      , i = e.hsl
      , s = e.hex
      , o = e.hsv
      , a = function(h, d) {
        if (h.hex)
            LA(h.hex) && t({
                hex: h.hex,
                source: "hex"
            }, d);
        else if (h.rgb) {
            var m = h.rgb.split(",");
            wM(h.rgb, "rgb") && t({
                r: m[0],
                g: m[1],
                b: m[2],
                a: 1,
                source: "rgb"
            }, d)
        } else if (h.hsv) {
            var g = h.hsv.split(",");
            wM(h.hsv, "hsv") && (g[2] = g[2].replace("%", ""),
            g[1] = g[1].replace("%", ""),
            g[0] = g[0].replace("°", ""),
            g[1] == 1 ? g[1] = .01 : g[2] == 1 && (g[2] = .01),
            t({
                h: Number(g[0]),
                s: Number(g[1]),
                v: Number(g[2]),
                source: "hsv"
            }, d))
        } else if (h.hsl) {
            var p = h.hsl.split(",");
            wM(h.hsl, "hsl") && (p[2] = p[2].replace("%", ""),
            p[1] = p[1].replace("%", ""),
            p[0] = p[0].replace("°", ""),
            u[1] == 1 ? u[1] = .01 : u[2] == 1 && (u[2] = .01),
            t({
                h: Number(p[0]),
                s: Number(p[1]),
                v: Number(p[2]),
                source: "hsl"
            }, d))
        }
    }
      , l = vt({
        default: {
            wrap: {
                display: "flex",
                height: "100px",
                marginTop: "4px"
            },
            fields: {
                width: "100%"
            },
            column: {
                paddingTop: "10px",
                display: "flex",
                justifyContent: "space-between"
            },
            double: {
                padding: "0px 4.4px",
                boxSizing: "border-box"
            },
            input: {
                width: "100%",
                height: "38px",
                boxSizing: "border-box",
                padding: "4px 10% 3px",
                textAlign: "center",
                border: "1px solid #dadce0",
                fontSize: "11px",
                textTransform: "lowercase",
                borderRadius: "5px",
                outline: "none",
                fontFamily: "Roboto,Arial,sans-serif"
            },
            input2: {
                height: "38px",
                width: "100%",
                border: "1px solid #dadce0",
                boxSizing: "border-box",
                fontSize: "11px",
                textTransform: "lowercase",
                borderRadius: "5px",
                outline: "none",
                paddingLeft: "10px",
                fontFamily: "Roboto,Arial,sans-serif"
            },
            label: {
                textAlign: "center",
                fontSize: "12px",
                background: "#fff",
                position: "absolute",
                textTransform: "uppercase",
                color: "#3c4043",
                width: "35px",
                top: "-6px",
                left: "0",
                right: "0",
                marginLeft: "auto",
                marginRight: "auto",
                fontFamily: "Roboto,Arial,sans-serif"
            },
            label2: {
                left: "10px",
                textAlign: "center",
                fontSize: "12px",
                background: "#fff",
                position: "absolute",
                textTransform: "uppercase",
                color: "#3c4043",
                width: "32px",
                top: "-6px",
                fontFamily: "Roboto,Arial,sans-serif"
            },
            single: {
                flexGrow: "1",
                margin: "0px 4.4px"
            }
        }
    })
      , c = r.r + ", " + r.g + ", " + r.b
      , A = Math.round(i.h) + "°, " + Math.round(i.s * 100) + "%, " + Math.round(i.l * 100) + "%"
      , u = Math.round(o.h) + "°, " + Math.round(o.s * 100) + "%, " + Math.round(o.v * 100) + "%";
    return Z.createElement("div", {
        style: l.wrap,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: l.fields
    }, Z.createElement("div", {
        style: l.double
    }, Z.createElement(Ht, {
        style: {
            input: l.input,
            label: l.label
        },
        label: "hex",
        value: s,
        onChange: a
    })), Z.createElement("div", {
        style: l.column
    }, Z.createElement("div", {
        style: l.single
    }, Z.createElement(Ht, {
        style: {
            input: l.input2,
            label: l.label2
        },
        label: "rgb",
        value: c,
        onChange: a
    })), Z.createElement("div", {
        style: l.single
    }, Z.createElement(Ht, {
        style: {
            input: l.input2,
            label: l.label2
        },
        label: "hsv",
        value: u,
        onChange: a
    })), Z.createElement("div", {
        style: l.single
    }, Z.createElement(Ht, {
        style: {
            input: l.input2,
            label: l.label2
        },
        label: "hsl",
        value: A,
        onChange: a
    })))))
}
  , uU = function(e) {
    var t = e.width
      , r = e.onChange
      , i = e.rgb
      , s = e.hsl
      , o = e.hsv
      , a = e.hex
      , l = e.header
      , c = e.styles
      , A = c === void 0 ? {} : c
      , u = e.className
      , f = u === void 0 ? "" : u
      , h = vt(fs({
        default: {
            picker: {
                width: t,
                background: "#fff",
                border: "1px solid #dfe1e5",
                boxSizing: "initial",
                display: "flex",
                flexWrap: "wrap",
                borderRadius: "8px 8px 0px 0px"
            },
            head: {
                height: "57px",
                width: "100%",
                paddingTop: "16px",
                paddingBottom: "16px",
                paddingLeft: "16px",
                fontSize: "20px",
                boxSizing: "border-box",
                fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
            },
            saturation: {
                width: "70%",
                padding: "0px",
                position: "relative",
                overflow: "hidden"
            },
            swatch: {
                width: "30%",
                height: "228px",
                padding: "0px",
                background: "rgba(" + i.r + ", " + i.g + ", " + i.b + ", 1)",
                position: "relative",
                overflow: "hidden"
            },
            body: {
                margin: "auto",
                width: "95%"
            },
            controls: {
                display: "flex",
                boxSizing: "border-box",
                height: "52px",
                paddingTop: "22px"
            },
            color: {
                width: "32px"
            },
            hue: {
                height: "8px",
                position: "relative",
                margin: "0px 16px 0px 16px",
                width: "100%"
            },
            Hue: {
                radius: "2px"
            }
        }
    }, A));
    return Z.createElement("div", {
        style: h.picker,
        className: "google-picker " + f
    }, Z.createElement("div", {
        style: h.head
    }, l), Z.createElement("div", {
        style: h.swatch
    }), Z.createElement("div", {
        style: h.saturation
    }, Z.createElement(q1, {
        hsl: s,
        hsv: o,
        pointer: cU,
        onChange: r
    })), Z.createElement("div", {
        style: h.body
    }, Z.createElement("div", {
        style: h.controls,
        className: "flexbox-fix"
    }, Z.createElement("div", {
        style: h.hue
    }, Z.createElement(cp, {
        style: h.Hue,
        hsl: s,
        radius: "4px",
        pointer: AU,
        onChange: r
    }))), Z.createElement(P3e, {
        rgb: i,
        hsl: s,
        hex: a,
        hsv: o,
        onChange: r
    })))
};
uU.propTypes = {
    width: Ve.oneOfType([Ve.string, Ve.number]),
    styles: Ve.object,
    header: Ve.string
};
uU.defaultProps = {
    width: 652,
    styles: {},
    header: "Color picker"
};
hs(uU);
const L3e = "_InformationContainerPos_1dnrx_2"
  , D3e = "_scrollContainer_1dnrx_15"
  , xM = {
    InformationContainerPos: L3e,
    scrollContainer: D3e,
    "options-container": "_options-container_1dnrx_24"
}
  , N3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAABE5AAAROQEb2ZNGAAAGiGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wNS0xNVQxNzoxODowNS0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6NDctMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6NDctMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmU1ZTg4ZDczLWQ3YmItNjg0NS1iNDkxLWYxZTU0YmRhZDE1MiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDphYTA0ZDdmOC1lYzY0LWU4NGQtYjI0My1kOGY0YTI1ZTdmM2YiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphYTA0ZDdmOC1lYzY0LWU4NGQtYjI0My1kOGY0YTI1ZTdmM2YiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFhMDRkN2Y4LWVjNjQtZTg0ZC1iMjQzLWQ4ZjRhMjVlN2YzZiIgc3RFdnQ6d2hlbj0iMjAyNC0wNS0xNVQxNzoxODowNS0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDozNzgwNzA3Yy0zNDg5LTAzNDctYmEwNy1kOTFhY2ZkYmUwODYiIHN0RXZ0OndoZW49IjIwMjQtMDUtMTVUMTc6MzA6MjQtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZTVlODhkNzMtZDdiYi02ODQ1LWI0OTEtZjFlNTRiZGFkMTUyIiBzdEV2dDp3aGVuPSIyMDI0LTA1LTE1VDE3OjMyOjQ3LTA2OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+okruHwAAA6NJREFUeNrt279LG2EYwHG1CCqKPwKOJQU3cXYqXZ0KofgPuBWcUmsgoouCFArS0UXaWUpTFxHcUnE4cO6fULoUbWnTFk2ftz4p19BoLve+d33vvsN3KWre97lPUvPm7Gs2m32U3xgCABgCAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABABnlV5VR6QH0mOpIq229VSacPj4E/oY7Y9b0TWZtY0AwO7Qp6WH0q70XrqSmh1qSLMO1zKrj9Hp8a90jbu65mkAxBv4svRR+nHD0MOZr5t3uJ75iGsxa18GQPRBl6Sgy0GHu5QWHa5rUR8j6rrMXkoAuH3Ag9KLHgYcbsfh+nZirs3sbRAA/x5uQXrb4zMs3AdpyMH6hvRnx1nbpe6xAIC/hzssHcUcbrjnUr/F9fXrz7S1PrPXYQBcD3dKemdxuKZP0pzFNc7pz7S5RrPnqVwDkAGMSTXLg211auNtmL4NPXW0RrP3sVwC0EOVwNFgW9XjPMv01anueI2By8Or/xKAbHhSeuN4sK3OpPvSQIT1Dej3nCW0RjOLyVwA0Jf9IKHBhk8IX0vFLtZX1K9tJLzGII3/DtJ4q1dLeLDhvkjH0jNpSXqkLem/HevXpLW+WtJvEZP+IKee4nB9qZ7kB0pJPvOPuLiRzgkKmQCgz/xDLmrkDpN4JUjikOeEi9lzJ64Pi1wDOOAixu7AZwBVLmDsqr7/DrAhfeVCRs7MbCMr7wLWuKCRW8vaOYC5cfIbF/bWzIwqWT0J3LRww0eWM7PZzPpnAeUUztl9yMyknJdPA7el71z0P5lZbOftfgDzSvCTi/97BuW83hG0lfNfDM3et/J+T+BKjgGscFfwNYL1DodF+yl/Pm/j/oP9Doc869wVfPNh0Z50Vzr3GMC57mEvjUMeH/8yqKJvh15Ko9I96cJjABe6h1HdUyPJQx4fAdyRFtruz/MdQDG0nwWzRwB0DyJTAPjjUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAhgDMSJ89BmDWPgOA3gGMS0+kVU8zax8HAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIACQlX4BjeT0VuSSEBUAAAAASUVORK5CYII="
  , O3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAGiGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wNS0xNVQxNzoyMTozMy0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6MTgtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6MTgtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjA4MDc2OWJhLTIwNzQtMjU0Zi1iNjM5LWJiZjEyMTFlMjljNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpjMTM0ZDhjYS01ZTFlLWMzNGMtOWZjNC0zZWU4MjRkNWE1YWMiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpjMTM0ZDhjYS01ZTFlLWMzNGMtOWZjNC0zZWU4MjRkNWE1YWMiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmMxMzRkOGNhLTVlMWUtYzM0Yy05ZmM0LTNlZTgyNGQ1YTVhYyIgc3RFdnQ6d2hlbj0iMjAyNC0wNS0xNVQxNzoyMTozMy0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NzUzMzYxZC05NmIzLTgwNDctYTA0ZC0wODcxYmNiNzY4MDAiIHN0RXZ0OndoZW49IjIwMjQtMDUtMTVUMTc6Mjk6NTctMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDgwNzY5YmEtMjA3NC0yNTRmLWI2MzktYmJmMTIxMWUyOWM1IiBzdEV2dDp3aGVuPSIyMDI0LTA1LTE1VDE3OjMyOjE4LTA2OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Yrc/VQAAAzxJREFUeNrt3b9LFnEcwHE3IW1oiUCF/gCXcgibmhyaDEqnWhoCaRXqUQhByKVVXAqsMbQyGgIHA6GhSdpNc7E/IBehp8/h94ErRLzoOc671/Ce7/O572t4/PHc9bTb7R41NzcBADcBAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAiAinVrudUfPY92o+0ut5uu1Q9AtQCsRe2SWgMAAAAAAAAAAEo/7KHoWnQl12i0USKAjXTN/AzZTEMAdB/AQvQjfRrvtBMdlAjgIF0zP0M20wIA3QewVOJBF20JAAAAAACAbgJYrDCARQD+30EPRjei66nsU/fVaLXCAFbTjKO5ubMdBgEoDuBR9Cv6+VeHFQZweMy82Q6PACgOYLbCB120WQCKA5ipEYAZAAAAoCCAxzUC8BiAk3+3fzeajCZSN6OXNQLwMu3U2W8y7TwEwNENaTe0CQCWW7cbDOA2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcWQB3GgzgDgDLrbHoa/Ql1+foe40O+nvaKb9jtvMYAMutc9Hl9C3hTgPR0xoBeJp2yu+Y7XzO8wE8IAIAAAAAAABPCQPgTwD3ok/Req6P0V6FD3ovzZifOdvhHgD/9hKI7JPzpVwXoxcVBvAizZifeaDKL5fwsGgPiwYAAAAAAACAswJgKnqf3tzV6W20X+JB76dr5mfIZpoCoPsAeqPz6aeETheiDyUC+JCumZ8hm6kXAO8NBAAAAAAAoFQAfdG7EgFk1+oDoLuHOhI9jB6covvRVokAttI1TzNbtsMIAMUBPKnRXwOfAOD/AQAAAAAAACj04si6APDiyBMOejh6Fs3naqX/pqkLgPW0U37HbOdhAI7eoNXUbwZNAuC7gQAAAAAADQYw3mAA440BkD7svYlWotepV9FmgwFspnvQuR8r6R5N1hHAfIMPumjzdQQw52BP3RwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA2QQwHe1E36JtHdu3dI+mfTVMAAgAASAABIAAEAACQAAIAAEgAASAABAAAkAACAAV7DcOsgfgT8DmTAAAAABJRU5ErkJggg=="
  , k3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAOxAAADsQH1g+1JAAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0xMS0yN1QxNToyNToyMC0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMTEtMjdUMTU6MzM6MjgtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMTEtMjdUMTU6MzM6MjgtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjdlZDg3MTgxLTIyMTUtOGY0Ni1iYWM3LTZlNjE0ZmM3ZTljNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3ZWQ4NzE4MS0yMjE1LThmNDYtYmFjNy02ZTYxNGZjN2U5YzYiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3ZWQ4NzE4MS0yMjE1LThmNDYtYmFjNy02ZTYxNGZjN2U5YzYiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjdlZDg3MTgxLTIyMTUtOGY0Ni1iYWM3LTZlNjE0ZmM3ZTljNiIgc3RFdnQ6d2hlbj0iMjAyNC0xMS0yN1QxNToyNToyMC0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgVVvLIAAAprSURBVHja7Z1rTFvXHcBdRZpAVatVWV5SpX2Z1g9LlCaCD2FLk4YlJOmgiVKyAkmhTSAPViAuYCgLwcBiygIYQ2KwsXHwdTDGBgyBBFhIAgbaoLXLa1IXVaqUSHzZ162VmsQ7x7meHOPHfZzre6/9//BTFAP/e+79/+65556XFV6vVwEkLnARQAC4CCAAAAIAIAAAAgAgAAACACAAAAIAIAAAAgAgAAACACBACA5e/pwzH1rPKUyTgwrzlEvxR2vt/z8fvz39CvrXSPME4Q1mX89n3nf1n0bDGIBCTrC9lvEiQBpiOZeqWw6VdA4CBLKM0IEA0hNgdeu4NfWw9ex/oiWdpwDBpCDWgQAiCpDdd7ZO5eoYYpN4ggJgJhGrQYDYC1CAWOKSeMICYO4jXCBAbARYg9jJJ/ECCOCnC7EeBBBOgG2If5NIvkAC+CkAAcgLsBXxHankCyzAU0Q5CEBWgKckky+wAJjniKMgAH8BtgiR/BgI4CcbBOAuQBrpal8EATBKEIC9AGtINvhEFuBHRDEIwE6AnUImP8YCYNoRSUInfXd3GedONSkJkC908kUQAKMFAZgJsBSnAniFSjw6F0Vmr0qR1VslawFWIZpikXwRBXiMSCYtwHumCl5jKqIKcNJY7+NYT11KrJIvogCYiySTn2FUKjLNKvkKoNVqfTR0XEhNEAEeIbaQSP4ufQnvxIsuwAeWGh+HLDX/JZBYSwBSFQCzX6jpWXJtA6TxTXzNdUO+eenqb3DMds/gdtW4vjCSCEwFyDLVtP5pSHvijFuXjzloqf4CfW7mKwEIQKOboPB0rmU+yW+bc7wbKrZmxprJUwBz89+cO4LjotetLr4SgAA0i4uLrxyxqXkJEC722D/nk/kI8FF/Q3W42ARqgYcgwIsCG/lW/0IJcMyhOSOgAM9AAIkL8LH9fHmouMP3Z18DAcgJ8ISvAKXudmWo2MXDrVV8BNhn/Kxj9MH8q8FxMwzKS4TmDNSDAGTe6y3BNUG010EWr4H4TjfjmF23Jzf5/0/oddANApDr3LGEgFQ/gJlw4kEAAQSQS08gCAACgAAgwAtmEWtBgMQVAFMEAoAAIAAIAAIwQXekv76x0+NMvbQwvPX8dcs+/JlIAtgx9VPmrJZb/e8UD7V8Sn/GJsb3u7vLth+wVOehMhUhUkCACMnHBP+9eWn8LS4S8BXgmENTFVwW/BlLCZbfM1W4UXl+oMv1LcIdgnoQIETy/TTftKXHWAC7crSjMMwgEataAAnApLzPEc9oHoIAQbju3XrjUN+f22IpQIRRQiEECMd+xNsJLwAmx1anYfMo4CGA3Xnv5i8kIgDmEeIiIjmhBaBj6ZhKwFEA+8iDudcjlYGNALsNZ7wHLleTerN5HO/zAXQsJBBCAHuWWaWPdGzcLmAjwB4kgACvuFpEUrxOCIkqgGpcf4SJBCwFsGcYlJZox86zqRvZSCWQAJh2xGlZCOCcmfhVLnWO6UpgXam7/WS0mEWu5spoErAQwB6p0efHcXdmLdvn//u9VUJ2dv2IUEpegJueWXznsJkUqjPdufpWtLhXF+4kfWg790U4ERgKYM8wRr/zuTT+dnWVxKrXM1sO6wLYduTomMZvmu7bE6pxGEUA312vuWHdwyL5rASIcdf3ETksDmUlwOfjXblsjmNYcG8KEEGHBDAFJxyT09eoGfpm4Q2mcTs8rlQOXcCxFgB3JJXHkwA+CT5xaGq4HrdswHAyMPFcYhgW3ZtQVc46+X8wV4oxAPaU3mBTsgJwWR2sq5syHxRji3THP26s5XLnp6Nnf2avyivWKChivVQFWIeY5CKBesqcFcvkd6M7n0vyMXuNSjGTj+mS8g4hqxH3uUhQcEVTq51z/Fbo5OdY1Zpd+hJOyU/vKvUesFSLLQDGJeUtYlw8TkzXfM2WLkTiA9sLXAeRJJB4P/fpm02yu4R18ZEA0780uWH0oedVXs/5uzNrMTnUOQ2fxGMyxK/6g5mkH7uSFGA9oZPUKcc6Cmsnez6w/X3yTaZlwn36bPv1oyVfIlV/MClS3im0gPA2sbpgft9daguq2nlX8ytG/LrLpJj4QCS9V3A53Ykh20mhEk++5AVQ0N2YshRgP//JHrFAJ4ft4rNlJIBtr6G856DlLJ6iFgjfMl8MA9+4y3L5xhAlPcQpZQFspSPaFZNFjw82VfKV4PjAym5v1bg+n5AERskLQP/uaXqygyQFKHOZC8Od58cOTTWfu3/w6xsh5yG23LbvICCBPASgfz+JnvYkKQEyDEqv/cs7G8IOPo3qCrmWtdTZdjrKNUwcAYL+9rHYAqQHTOyoGO09KoQAZS7BBfDKVYBk+uQfxVoAnPi9Kzt42sKd57EX7QDij4D2ucFtCStAQIy36UUSqlgIgMfzs0IP6bY1TPWu2Ab21NCFEr6NwJODzRXBcdXTvQcINQLlLUCImA8DllI9JyEAizl8bWGQ6mtg/AkQFL8+1ILLXErzbYahHCf3h/SuUjeq0pdfXrRR5pu2jcmyVMmhQwcEYIN6Yizl8OXGInRn52X2qrZnmiu/x8u0/BBcsQMCSFGAoDIUJVKyQQAQAAQIxPbNVGrxcOu/QIAEFQBzfsbqBgESWAD67UCsBFB5NnXnYWutCQSIbwEoTKW7s1g769il8zh3+MFluH7vq1WBnxU5mxv9fwMCyFsAXxId81MbuJTNODeyWWgRQADhBKA6pwd+R6KMxx1NGqEkAAFe9BiSnH9IlTq15T1fjW0mWc5Ls1e3FTqaGgmL8CThBaDL8oxU8hsmTNlClvXUUEstQQmMIAA5AajqUX1hjMpLql0AAgSMIvJK/omBC+pYLlTN729s5VnmnxANIACZzasppscZeTD3876F8V+XOH1fbOW/kyndLccO/DOmcSbuen7GsxaQx6xgGQhAOb6+weg1r8LdWRwlaVSB/S+tNdcMnzCJVzdtzuMhQRoI8HJ59nO5kIWOlsZosUc986+xfG5TTGuVHKpOH68rg2ItwBYOcwwp89L4xkhx+z233uR4l1KnnH+tjVZuzXXL+xziT4IABGbZFgycb40U79o9z6pc7neoT4KyYW05w7eCuFkdLKYAyWymnBcPt0bcrOqw9SyJQR4q94paT1CAJsQqEIBAg/CU60LYKvrK4sQvCXbYUIQEWJLyFjFSEoDRCqRcW/g7k3CXLXV6qCWkbKZ590YWx8oHAZiVLYnhWkTqaH9D+0tfZfPl2MYTjmY16cGbbPQ4Md0eeanB2bM4uvlQX81lhjF2SnmXMEkJQJevmOGqZCoEgg4vczgW3pR7jSwFEBllHEz7+s7f6QMCcCNbxsl/SvdvKEAAfhwVas8igZMv+e3i5UQ54d3LhK72t4IA5CmQQfJxg2+bHL4zSK6s57mjqZDsDNfaBwHI4+K4wbUQLEX6TgAQQDhWc9zqniRNfM4BBODPOo5fekFi0+eUwIEdEEAa6OjpVqQT/hMdN41keUEA4TAGwHnefkCMBiHKKZoAgPyBiwACwEUAAQAQAAABABAAAAEAEAAAAQAQAAABABAAAAEAEACIV/4HmscvZd8W84IAAAAASUVORK5CYII="
  , Q3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGiGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wNS0xNVQxNzoxOTozNC0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDUtMTVUMTc6MzM6MTEtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDUtMTVUMTc6MzM6MTEtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjJkMTY5MDdlLWQyY2EtZDA0Mi05MWRjLTliZTMyYzYyYjlmOSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowMzZkNWExYy1jOTYwLTAxNDktODlkMC00NzQ0NDMwM2QyNWQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMzZkNWExYy1jOTYwLTAxNDktODlkMC00NzQ0NDMwM2QyNWQiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjAzNmQ1YTFjLWM5NjAtMDE0OS04OWQwLTQ3NDQ0MzAzZDI1ZCIgc3RFdnQ6d2hlbj0iMjAyNC0wNS0xNVQxNzoxOTozNC0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo2N2JiZmQ0OC0yMGMzLTI0NDktODQyNS1kNWJmOTBlNzMwYjYiIHN0RXZ0OndoZW49IjIwMjQtMDUtMTVUMTc6MzA6MTQtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MmQxNjkwN2UtZDJjYS1kMDQyLTkxZGMtOWJlMzJjNjJiOWY5IiBzdEV2dDp3aGVuPSIyMDI0LTA1LTE1VDE3OjMzOjExLTA2OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Q6I0lAAAAs1JREFUeNrt3TtrFFEYgOFE2HjFXgv9AyIYsbATMaAWQtqAYBPQ0ibCgoSA/yGbwsJ/o6Ag3gMWEkurTeGlcfwGzoIs7LKT3TXOOU/xFlnYkNnvIRNOZs4sVFW1oHLzIQDgQwBAAAgAASAABIAAEAACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAiAiVt91l2OXkRVi3oTXQVg+uHfjX60bPiDfkUPADj48C+2ePh/dx2AgwF4ncHw695HHQCaA6gy6hYAZQPYAqBsANsAlA1gBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAogDE14tRt359RL3ocbQSLQGQH4Aj0bsJ31tfF3EDgPwAvGzw/t/ROgDlAhhcY7gMQLkABpeXnQSgXAB1mwCUDeAjAGUD6ANQNoB9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOCQ6wFQNoAnQ8fWiXYBKAfAnaFjOxXtATAewIdMhv85Ojp0bGfqq3sBGA/gcrodKrt9guO11Sm+XxkA0gd1P90Y2dbhb4w4rm8ATI5gpYVbx+8On/eHHoJRAdAMwVJ9j3zaNKE3ZmOFw6z+uTaj29HxEcdxLvoKQIHVd/XW9/XN4LcLAC0c/vno04xOLwC0bPj3oi8z/PsCgIYDWExLr/+iTlrkORutTbHYA8AMAXTTuvu8e5XO8XtTLPIAMAcATzNbVgagIYAdAAAAAAAAAAAAAADKA7CdGYA+AM0AbGUG4C0AzQDczAzABgDNAHTSHrs5DL9ebTwGQHME1zIY/vfoQjG7hc8BwXr0s8XDXyvqeQFzQnClhZeXPY8uFffEkDkiOB09ShDq/9rt/4f10/n+YXSiyGcGqfCnhgkAASAABIAAEAACQAAIAAEgAASAABAAAkAACAABIAAEgAAQAAJAAAgAAaBp+gMB5Yr6zMTlPAAAAABJRU5ErkJggg=="
  , H3e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAGiGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDEgNzkuMTQ2Mjg5OSwgMjAyMy8wNi8yNS0yMDowMTo1NSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wNS0xNVQxNzoxOTo1Ny0wNjowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6MjYtMDY6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDUtMTVUMTc6MzI6MjYtMDY6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOmFmYmE3YzFhLWI0MTMtMGQ0MS05YmRkLTE2ZGY2MTllOTgyMSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5MTFjMjQ0NC01M2M4LWI1NDgtYmYwZi03M2VhOGZlOTVmM2UiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo5MTFjMjQ0NC01M2M4LWI1NDgtYmYwZi03M2VhOGZlOTVmM2UiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjkxMWMyNDQ0LTUzYzgtYjU0OC1iZjBmLTczZWE4ZmU5NWYzZSIgc3RFdnQ6d2hlbj0iMjAyNC0wNS0xNVQxNzoxOTo1Ny0wNjowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDI1LjEgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmNjZhMzQ1Ni02ODczLWQ5NDYtOTRkMy1mZTYwZjQ5NzliNjYiIHN0RXZ0OndoZW49IjIwMjQtMDUtMTVUMTc6MzA6NDQtMDY6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNS4xIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWZiYTdjMWEtYjQxMy0wZDQxLTliZGQtMTZkZjYxOWU5ODIxIiBzdEV2dDp3aGVuPSIyMDI0LTA1LTE1VDE3OjMyOjI2LTA2OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjUuMSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+F7DBkwAABCVJREFUeNrt3TtMFEEYwHHuAiYkNjRg74mJpSYUkCiGAhKxsLKXggQ6yi2wQUh8RMCGRJulEgotjgLwVaCVDYYeHzQaKU5FCRo4vwnfRdQgHvu4mZ1/8W/Iec7c/u7gdmd368rlch35Gy8CAHgRAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAJLpUhjkpW5pQfoolaRPjlXSsZs59Jg5AeDgDZ+T2qRFaUcqZyQzl0c6txwA9n/X9+m7ppzR1nWOeQD8DaBD+pzhjV/JzLEDAL9v/JPSmgcbv5KZaysAfv3ev+PRxq80acPfAzYAKEgrHgIwcy4AIAwGpS8eAjBzHgBAGEx7uPErhQAIg6LHAIoACIM5jwHMAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIuA3pjbYBgOwDMOvyNqUZ6azUuGcMjfqz+/qYHQBkC8BXaUI6/p/rE8b13wAgAwB+SOel+irGVC91St8B4DYAs8K4J8LYehJepQyAhAEMVfPO3+eTYAgAbgJYinGMSwBwC8A36VyMY+zU5wSAIwCWpeYYx9gsvQKAOwAe7P2eH8MYzX6ChwBwB8DtOE+60PMWxwHgDoCRBMY5AgB3AIzHeQaufgJMAIC/AQDg8beAZQC4A2Argf0AWwBwa0/gc+lIDONr0OdiT6CjxwJyEcaW41iA2wDeS70RxnZBnwMADq8HMOfhXzzEuHpTuG4BAFJaEWQO5IxKp/61f0C/75vHXEvo4A8Aarwm8J00K13WpV9HtYL+bFYfw5pAT5aFb2osC+e8AABkFcBOxADgGIBt6YU0pUfwhqWrh2xYn2NKn3MbAHYDeCId0713ed2RE0d5fc4W6TEA7APwVuqPsgK4ypXC/XpKGQAsAPBB6qrBuLti2EsIgIgAzFk/fTUce5+OAQA1AjCTxsf+Ab8OZgBQGwDmtiynLRj/mQj3OQBABAAv41z1E2H8LToWAKQMwOy3b7Bg/A06FgCkDOCmRbe7uQWA9AGMWgRgFADpAxizCMAYAAAAAAAAgL8BAJAagOsWAbgBgPQBPJWaLBh/k/QMAOkDMIsz7lkw/rsRFooAIIbDweY27avS65Rb1f+bw8EsCgUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCCAoscAigAIg2mPAYQACIPBFC7GZGNmzgMA2L0+z4qHAMycCwDYPf9+0kMAk3He08BZAIqgVVrzaOObuZ6w4bW3AoAiaI9wkqVLmTm22/K62wTA/Cq4kvCNGmvdul5TIA+A/RG0SQspXqwxrYtULurccja95lYB+OOSrd3SvH4ilPR6AC5V0rHP6y1o8za+1lYCIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAFXRT5xealqlzx1wAAAAAElFTkSuQmCC"
  , z3e = "_InformationContainerPos_1m76y_2"
  , G3e = "_scrollContainer_1m76y_15"
  , V3e = "_centerAlign_1m76y_25"
  , j3e = "_traitInfoTitle_1m76y_28"
  , W3e = "_dropdownFlex_1m76y_38"
  , K3e = "_checkboxFlex_1m76y_44"
  , X3e = "_simpleFlex_1m76y_49"
  , Y3e = "_traitInfoText_1m76y_55"
  , $3e = "_dropdownBase_1m76y_64"
  , Z3e = "_dropdownControl_1m76y_74"
  , J3e = "_dropdownControlSmall_1m76y_80"
  , q3e = "_flexSelect_1m76y_106"
  , eke = "_checked_1m76y_163"
  , tke = "_checkmark_1m76y_167"
  , nke = "_checkboxHolder_1m76y_180"
  , rke = "_actionButton_1m76y_189"
  , ike = "_tabHolder_1m76y_209"
  , ske = "_tabButton_1m76y_215"
  , oke = "_tabButtonSelected_1m76y_235"
  , Ke = {
    InformationContainerPos: z3e,
    scrollContainer: G3e,
    centerAlign: V3e,
    traitInfoTitle: j3e,
    dropdownFlex: W3e,
    checkboxFlex: K3e,
    simpleFlex: X3e,
    traitInfoText: Y3e,
    dropdownBase: $3e,
    dropdownControl: Z3e,
    dropdownControlSmall: J3e,
    "input-box": "_input-box_1m76y_87",
    flexSelect: q3e,
    "arrow-button": "_arrow-button_1m76y_114",
    "left-button": "_left-button_1m76y_130",
    "right-button": "_right-button_1m76y_137",
    "anim-button": "_anim-button_1m76y_144",
    "custom-checkbox": "_custom-checkbox_1m76y_149",
    "checkbox-container": "_checkbox-container_1m76y_154",
    checked: eke,
    checkmark: tke,
    checkboxHolder: nke,
    actionButton: rke,
    tabHolder: ike,
    tabButton: ske,
    tabButtonSelected: oke
}
  , ake = "_slider_1y6nx_1"
  , lke = "_infoContainer_1y6nx_13"
  , Wy = {
    "slider-container": "_slider-container_1y6nx_1",
    slider: ake,
    infoContainer: lke,
    "input-box": "_input-box_1y6nx_18"
};
function mu({title: n, value: e, min: t, max: r, onChange: i, step: s, stepBox: o}) {
    return k.jsxs(k.Fragment, {
        children: [k.jsxs("div", {
            className: Wy.infoContainer,
            children: [n, o && k.jsx("input", {
                type: "number",
                min: "0",
                max: "100",
                value: e,
                onChange: i,
                className: Wy["input-box"],
                step: o
            })]
        }), k.jsx("div", {
            className: Wy["slider-container"],
            children: k.jsx("input", {
                type: "range",
                min: t,
                max: r,
                value: e,
                onChange: i,
                className: Wy.slider,
                step: s
            })
        })]
    })
}
function cke({selectedTrait: n, selectedVRM: e}) {
    const {animationManager: t, characterManager: r} = be.useContext($n)
      , [i,s] = be.useState(0)
      , [o,a] = be.useState(0)
      , [l,c] = be.useState(0);
    be.useEffect( () => {
        var d, m, g;
        e != null && (c((d = e.data) == null ? void 0 : d.cullingLayer),
        s(((m = e.data) == null ? void 0 : m.cullingDistance[0]) || 0),
        a(((g = e.data) == null ? void 0 : g.cullingDistance[1]) || 0))
    }
    , [e]);
    const A = d => {
        s(d.target.value),
        e != null && e.data && (e.data.cullingDistance[0] = d.target.value)
    }
      , u = d => {
        a(d.target.value),
        e != null && e.data && (e.data.cullingDistance[1] = d.target.value)
    }
      , f = d => {
        e != null && e.data && (c(d.target.value),
        e.data.cullingLayer = d.target.value)
    }
      , h = () => {
        r.updateCullHiddenMeshes()
    }
    ;
    return k.jsx("div", {
        children: k.jsxs("div", {
            className: Ke.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Trait Information",
                width: 180,
                right: 20
            }), k.jsx("div", {
                className: Ke.scrollContainer,
                children: n != null ? k.jsxs(k.Fragment, {
                    children: [k.jsx("div", {
                        className: Ke.traitInfoTitle,
                        children: "Trait ID"
                    }), k.jsx("div", {
                        className: Ke.traitInfoText,
                        children: n == null ? void 0 : n.id
                    }), k.jsx("div", {
                        className: Ke.traitInfoTitle,
                        children: "Trait Name"
                    }), k.jsx("div", {
                        className: Ke.traitInfoText,
                        children: n == null ? void 0 : n.name
                    }), k.jsx("div", {
                        className: Ke.traitInfoTitle,
                        children: "Description"
                    }), k.jsx("div", {
                        className: Ke.traitInfoText,
                        children: (n == null ? void 0 : n.description) || "A nice " + (n == null ? void 0 : n.name)
                    }), k.jsx("div", {
                        className: Ke.traitInfoTitle,
                        children: "Culling Options"
                    }), k.jsx("br", {}), k.jsxs("div", {
                        className: Ke.traitInfoText,
                        children: ["Culling Layer", k.jsx("input", {
                            type: "number",
                            min: "0",
                            max: "100",
                            value: l,
                            onChange: f,
                            className: Ke["input-box"],
                            step: 1
                        }), k.jsx("br", {}), k.jsx("br", {}), k.jsx(mu, {
                            title: "Out Distance",
                            value: i,
                            onChange: A,
                            min: 0,
                            max: 1,
                            step: .001,
                            stepBox: .01
                        }), k.jsx("br", {}), k.jsx(mu, {
                            title: "In Distance",
                            value: o,
                            onChange: u,
                            min: 0,
                            max: 1,
                            step: .001,
                            stepBox: .01
                        }), k.jsx("div", {
                            className: Ke.actionButton,
                            onClick: h,
                            children: k.jsx("div", {
                                children: "Update Culling "
                            })
                        })]
                    })]
                }) : k.jsx(k.Fragment, {
                    children: k.jsx("div", {
                        className: Ke.traitInfoTitle,
                        children: "No Trait Selected"
                    })
                })
            })]
        })
    })
}
var Hj = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.default = void 0;
    var e = s(be)
      , t = r(bV);
    function r(b) {
        return b && b.__esModule ? b : {
            default: b
        }
    }
    function i() {
        if (typeof WeakMap != "function")
            return null;
        var b = new WeakMap;
        return i = function() {
            return b
        }
        ,
        b
    }
    function s(b) {
        if (b && b.__esModule)
            return b;
        if (b === null || o(b) !== "object" && typeof b != "function")
            return {
                default: b
            };
        var B = i();
        if (B && B.has(b))
            return B.get(b);
        var S = {}
          , I = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var M in b)
            if (Object.prototype.hasOwnProperty.call(b, M)) {
                var L = I ? Object.getOwnPropertyDescriptor(b, M) : null;
                L && (L.get || L.set) ? Object.defineProperty(S, M, L) : S[M] = b[M]
            }
        return S.default = b,
        B && B.set(b, S),
        S
    }
    function o(b) {
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(S) {
            return typeof S
        }
        : o = function(S) {
            return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S
        }
        ,
        o(b)
    }
    function a() {
        return a = Object.assign || function(b) {
            for (var B = 1; B < arguments.length; B++) {
                var S = arguments[B];
                for (var I in S)
                    Object.prototype.hasOwnProperty.call(S, I) && (b[I] = S[I])
            }
            return b
        }
        ,
        a.apply(this, arguments)
    }
    function l(b, B) {
        var S = Object.keys(b);
        if (Object.getOwnPropertySymbols) {
            var I = Object.getOwnPropertySymbols(b);
            B && (I = I.filter(function(M) {
                return Object.getOwnPropertyDescriptor(b, M).enumerable
            })),
            S.push.apply(S, I)
        }
        return S
    }
    function c(b) {
        for (var B = 1; B < arguments.length; B++) {
            var S = arguments[B] != null ? arguments[B] : {};
            B % 2 ? l(S, !0).forEach(function(I) {
                A(b, I, S[I])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(b, Object.getOwnPropertyDescriptors(S)) : l(S).forEach(function(I) {
                Object.defineProperty(b, I, Object.getOwnPropertyDescriptor(S, I))
            })
        }
        return b
    }
    function A(b, B, S) {
        return B in b ? Object.defineProperty(b, B, {
            value: S,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : b[B] = S,
        b
    }
    function u(b, B) {
        if (!(b instanceof B))
            throw new TypeError("Cannot call a class as a function")
    }
    function f(b, B) {
        for (var S = 0; S < B.length; S++) {
            var I = B[S];
            I.enumerable = I.enumerable || !1,
            I.configurable = !0,
            "value"in I && (I.writable = !0),
            Object.defineProperty(b, I.key, I)
        }
    }
    function h(b, B, S) {
        return B && f(b.prototype, B),
        S && f(b, S),
        b
    }
    function d(b, B) {
        return B && (o(B) === "object" || typeof B == "function") ? B : g(b)
    }
    function m(b) {
        return m = Object.setPrototypeOf ? Object.getPrototypeOf : function(S) {
            return S.__proto__ || Object.getPrototypeOf(S)
        }
        ,
        m(b)
    }
    function g(b) {
        if (b === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return b
    }
    function p(b, B) {
        if (typeof B != "function" && B !== null)
            throw new TypeError("Super expression must either be null or a function");
        b.prototype = Object.create(B && B.prototype, {
            constructor: {
                value: b,
                writable: !0,
                configurable: !0
            }
        }),
        B && v(b, B)
    }
    function v(b, B) {
        return v = Object.setPrototypeOf || function(I, M) {
            return I.__proto__ = M,
            I
        }
        ,
        v(b, B)
    }
    var w = "Select..."
      , _ = function(b) {
        p(B, b);
        function B(S) {
            var I;
            return u(this, B),
            I = d(this, m(B).call(this, S)),
            I.state = {
                selected: I.parseValue(S.value, S.options) || {
                    label: typeof S.placeholder > "u" ? w : S.placeholder,
                    value: ""
                },
                isOpen: !1
            },
            I.dropdownRef = (0,
            e.createRef)(),
            I.mounted = !0,
            I.handleDocumentClick = I.handleDocumentClick.bind(g(I)),
            I.fireChangeEvent = I.fireChangeEvent.bind(g(I)),
            I
        }
        return h(B, [{
            key: "componentDidUpdate",
            value: function(I) {
                if (this.props.value !== I.value)
                    if (this.props.value) {
                        var M = this.parseValue(this.props.value, this.props.options);
                        M !== this.state.selected && this.setState({
                            selected: M
                        })
                    } else
                        this.setState({
                            selected: {
                                label: typeof this.props.placeholder > "u" ? w : this.props.placeholder,
                                value: ""
                            }
                        })
            }
        }, {
            key: "componentDidMount",
            value: function() {
                document.addEventListener("click", this.handleDocumentClick, !1),
                document.addEventListener("touchend", this.handleDocumentClick, !1)
            }
        }, {
            key: "componentWillUnmount",
            value: function() {
                this.mounted = !1,
                document.removeEventListener("click", this.handleDocumentClick, !1),
                document.removeEventListener("touchend", this.handleDocumentClick, !1)
            }
        }, {
            key: "handleMouseDown",
            value: function(I) {
                this.props.onFocus && typeof this.props.onFocus == "function" && this.props.onFocus(this.state.isOpen),
                !(I.type === "mousedown" && I.button !== 0) && (I.stopPropagation(),
                I.preventDefault(),
                this.props.disabled || this.setState({
                    isOpen: !this.state.isOpen
                }))
            }
        }, {
            key: "parseValue",
            value: function(I, M) {
                var L;
                if (typeof I == "string")
                    for (var D = 0, T = M.length; D < T; D++)
                        if (M[D].type === "group") {
                            var y = M[D].items.filter(function(E) {
                                return E.value === I
                            });
                            y.length && (L = y[0])
                        } else
                            typeof M[D].value < "u" && M[D].value === I && (L = M[D]);
                return L || I
            }
        }, {
            key: "setValue",
            value: function(I, M) {
                var L = {
                    selected: {
                        value: I,
                        label: M
                    },
                    isOpen: !1
                };
                this.fireChangeEvent(L),
                this.setState(L)
            }
        }, {
            key: "fireChangeEvent",
            value: function(I) {
                I.selected !== this.state.selected && this.props.onChange && this.props.onChange(I.selected)
            }
        }, {
            key: "renderOption",
            value: function(I) {
                var M, L = I.value;
                typeof L > "u" && (L = I.label || I);
                var D = I.label || I.value || I
                  , T = L === this.state.selected.value || L === this.state.selected
                  , y = (M = {},
                A(M, "".concat(this.props.baseClassName, "-option"), !0),
                A(M, I.className, !!I.className),
                A(M, "is-selected", T),
                M)
                  , E = (0,
                t.default)(y)
                  , R = Object.keys(I.data || {}).reduce(function(F, O) {
                    return c({}, F, A({}, "data-".concat(O), I.data[O]))
                }, {});
                return e.default.createElement("div", a({
                    key: L,
                    className: E,
                    onMouseDown: this.setValue.bind(this, L, D),
                    onClick: this.setValue.bind(this, L, D),
                    role: "option",
                    "aria-selected": T ? "true" : "false"
                }, R), D)
            }
        }, {
            key: "buildMenu",
            value: function() {
                var I = this
                  , M = this.props
                  , L = M.options
                  , D = M.baseClassName
                  , T = L.map(function(y) {
                    if (y.type === "group") {
                        var E = e.default.createElement("div", {
                            className: "".concat(D, "-title")
                        }, y.name)
                          , R = y.items.map(function(F) {
                            return I.renderOption(F)
                        });
                        return e.default.createElement("div", {
                            className: "".concat(D, "-group"),
                            key: y.name,
                            role: "listbox",
                            tabIndex: "-1"
                        }, E, R)
                    } else
                        return I.renderOption(y)
                });
                return T.length ? T : e.default.createElement("div", {
                    className: "".concat(D, "-noresults")
                }, "No options found")
            }
        }, {
            key: "handleDocumentClick",
            value: function(I) {
                this.mounted && (this.dropdownRef.current.contains(I.target) || this.state.isOpen && this.setState({
                    isOpen: !1
                }))
            }
        }, {
            key: "isValueSelected",
            value: function() {
                return typeof this.state.selected == "string" || this.state.selected.value !== ""
            }
        }, {
            key: "render",
            value: function() {
                var I, M, L, D, T, y = this.props, E = y.baseClassName, R = y.controlClassName, F = y.placeholderClassName, O = y.menuClassName, z = y.arrowClassName, j = y.arrowClosed, Q = y.arrowOpen, C = y.className, W = this.props.disabled ? "Dropdown-disabled" : "", ee = typeof this.state.selected == "string" ? this.state.selected : this.state.selected.label, P = (0,
                t.default)((I = {},
                A(I, "".concat(E, "-root"), !0),
                A(I, C, !!C),
                A(I, "is-open", this.state.isOpen),
                I)), re = (0,
                t.default)((M = {},
                A(M, "".concat(E, "-control"), !0),
                A(M, R, !!R),
                A(M, W, !!W),
                M)), ue = (0,
                t.default)((L = {},
                A(L, "".concat(E, "-placeholder"), !0),
                A(L, F, !!F),
                A(L, "is-selected", this.isValueSelected()),
                L)), le = (0,
                t.default)((D = {},
                A(D, "".concat(E, "-menu"), !0),
                A(D, O, !!O),
                D)), me = (0,
                t.default)((T = {},
                A(T, "".concat(E, "-arrow"), !0),
                A(T, z, !!z),
                T)), ie = e.default.createElement("div", {
                    className: ue
                }, ee), ge = this.state.isOpen ? e.default.createElement("div", {
                    className: le,
                    "aria-expanded": "true"
                }, this.buildMenu()) : null;
                return e.default.createElement("div", {
                    ref: this.dropdownRef,
                    className: P
                }, e.default.createElement("div", {
                    className: re,
                    onMouseDown: this.handleMouseDown.bind(this),
                    onTouchEnd: this.handleMouseDown.bind(this),
                    "aria-haspopup": "listbox"
                }, ie, e.default.createElement("div", {
                    className: "".concat(E, "-arrow-wrapper")
                }, Q && j ? this.state.isOpen ? Q : j : e.default.createElement("span", {
                    className: me
                }))), ge)
            }
        }]),
        B
    }(e.Component);
    _.defaultProps = {
        baseClassName: "Dropdown"
    };
    var x = _;
    n.default = x
}
)(Hj);
const Qc = oc(Hj);
function Ake({selectedTrait: n, selectedVRM: e}) {
    const {manifest: t, loraDataGenerator: r, sceneElements: i} = Z.useContext($n)
      , [s,o] = be.useState([])
      , [a,l] = be.useState(null)
      , c = u => {
        (t == null ? void 0 : t.loras) != null && (l(t.loras[u.value]),
        console.log(t.loras[u.value]))
    }
      , A = async () => {
        const u = i.parent;
        u.remove(i),
        await r.createLoraData(a),
        u.add(i)
    }
    ;
    return be.useEffect( () => {
        if ((t == null ? void 0 : t.loras) != null) {
            const u = t.loras.map( (f, h) => ({
                value: h,
                label: f.name,
                description: f.description,
                manifest: f.manifest
            }));
            o(u)
        }
    }
    , [t]),
    k.jsx("div", {
        children: k.jsxs("div", {
            className: Ke.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Lora Creation",
                width: 180,
                right: 20
            }), k.jsxs("div", {
                className: Ke.scrollContainer,
                children: [k.jsx("div", {
                    className: Ke.traitInfoTitle,
                    children: "Lora Manifests"
                }), k.jsx(Qc, {
                    className: Ke.dropdownControl,
                    options: s,
                    onChange: c,
                    placeholder: "Select an option"
                }), ";", k.jsx("div", {
                    className: Ke.traitInfoText,
                    children: (a == null ? void 0 : a.description) || ""
                }), a != null && k.jsx("div", {
                    className: Ke.actionButton,
                    onClick: A,
                    children: k.jsx("div", {
                        children: "  Create Lora Data "
                    })
                })]
            })]
        })
    })
}
function uke({selectedTrait: n, selectedVRM: e}) {
    const {manifest: t, spriteAtlasGenerator: r, sceneElements: i} = Z.useContext($n)
      , [s,o] = be.useState([])
      , [a,l] = be.useState("")
      , [c,A] = be.useState(null)
      , u = h => {
        (t == null ? void 0 : t.sprites) != null && (l(t.sprites[h.value].description),
        A(t.sprites[h.value]))
    }
      , f = async () => {
        const h = i.parent;
        h.remove(i),
        await r.createSpriteAtlas(c),
        h.add(i)
    }
    ;
    return be.useEffect( () => {
        if ((t == null ? void 0 : t.sprites) != null) {
            const h = t.sprites.map( (d, m) => ({
                value: m,
                label: d.name,
                description: d.description,
                manifest: d.manifest
            }));
            o(h)
        }
    }
    , [t]),
    k.jsx("div", {
        children: k.jsxs("div", {
            className: Ke.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Sprite Creation",
                width: 180,
                right: 20
            }), k.jsxs("div", {
                className: Ke.scrollContainer,
                children: [k.jsx("div", {
                    className: Ke.traitInfoTitle,
                    children: "Sprite Manifests"
                }), k.jsx(Qc, {
                    className: Ke.dropdownControl,
                    options: s,
                    onChange: u,
                    placeholder: "Select an option"
                }), ";", k.jsx("div", {
                    className: Ke.traitInfoText,
                    children: a || ""
                }), c != null && k.jsx("div", {
                    className: Ke.actionButton,
                    onClick: f,
                    children: k.jsx("div", {
                        children: "  Create Sprite Data "
                    })
                })]
            })]
        })
    })
}
const d4 = 4096;
function fke({selectedTrait: n, traitGroupName: e}) {
    const {manifest: t, thumbnailsGenerator: r, sceneElements: i, characterManager: s} = Z.useContext($n)
      , [o,a] = be.useState([])
      , [l,c] = be.useState("")
      , [A,u] = be.useState("")
      , [f,h] = be.useState("")
      , [d,m] = be.useState(!1)
      , [g,p] = be.useState(512)
      , [v,w] = be.useState(512)
      , [_,x] = be.useState(.1)
      , [b,B] = be.useState(.1)
      , [S,I] = be.useState("center")
      , [M,L] = be.useState("center")
      , [D,T] = be.useState("center")
      , [y,E] = be.useState("head")
      , [R,F] = be.useState("chest")
      , [O,z] = be.useState(!0)
      , [j,Q] = be.useState(!1)
      , C = [{
        label: "center"
    }, {
        label: "left"
    }, {
        label: "right"
    }]
      , W = [{
        label: "center"
    }, {
        label: "top"
    }, {
        label: "bottom"
    }]
      , ee = [{
        label: "center"
    }, {
        label: "front"
    }, {
        label: "back"
    }]
      , P = [{
        label: "head"
    }, {
        label: "neck"
    }, {
        label: "chest"
    }, {
        label: "spine"
    }, {
        label: "hips"
    }, {
        label: "upperLeg"
    }, {
        label: "lowerLeg"
    }, {
        label: "foot"
    }]
      , re = Ae => {
        (t == null ? void 0 : t.thumbnails) != null && (c(t.thumbnails[Ae.value].description),
        h(t.thumbnails[Ae.value].manifest),
        u(t.thumbnails[Ae.value].name))
    }
      , ue = (Ae, J, q, he) => isNaN(Ae) ? he : Ae > q ? q : Ae < J ? J : Ae
      , le = Ae => {
        const J = parseInt(Ae.target.value);
        p(ue(J, 1, d4, 512))
    }
      , me = Ae => {
        const J = parseInt(Ae.target.value);
        w(ue(J, 1, d4, 512))
    }
      , ie = Ae => {
        const J = parseFloat(Ae.target.value);
        x(ue(J, 0, 1, .1))
    }
      , ge = Ae => {
        const J = parseFloat(Ae.target.value);
        B(ue(J, 0, 1, .1))
    }
      , _e = Ae => {
        m(Ae)
    }
      , se = async () => {
        const Ae = i.parent;
        Ae.remove(i),
        await r.createThumbnails(t.thumbnails[0]),
        Ae.add(i)
    }
      , H = (Ae=!0) => ({
        topFrameOffset: b,
        bottomFrameOffset: _,
        thumbnailsWidth: g,
        thumbnailsHeight: v,
        backgroundColor: [0, 0, 0, 0],
        thumbnailsCollection: [{
            traitGroup: e,
            cameraPosition: M + "-" + D + "-" + S,
            topBoneName: y === "upperLeg" || y === "lowerLeg" || y === "foot" ? "left" + y[0].toUpperCase() + y.slice(1) : y,
            topBoneMaxVertex: O,
            bottomBoneName: R === "upperLeg" || R === "lowerLeg" || y === "foot" ? "left" + R[0].toUpperCase() + R.slice(1) : R,
            bottomBoneMaxVertex: j,
            saveOnlyIDs: Ae ? null : n.id
        }]
    })
      , fe = async (Ae=!1) => {
        s.storeCurrentAvatar();
        const J = i.parent;
        J.remove(i),
        Ae ? await r.createThumbnailsWithObjectData(H(), !1, null, e + "_thumbnails") : await r.createThumbnailsWithObjectData(H(!1), !1),
        J.add(i),
        s.loadStoredAvatar()
    }
    ;
    return be.useEffect( () => {
        if ((t == null ? void 0 : t.thumbnails) != null) {
            const Ae = t.thumbnails.map( (J, q) => ({
                value: q,
                label: J.name,
                description: J.description,
                manifest: J.manifest
            }));
            a(Ae)
        }
    }
    , [t]),
    k.jsx("div", {
        children: k.jsxs("div", {
            className: Ke.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Thumbnail Creation",
                width: 180,
                right: 20
            }), k.jsxs("div", {
                className: Ke.scrollContainer,
                children: [k.jsxs("div", {
                    className: Ke.tabHolder,
                    children: [k.jsx("div", {
                        className: Ke.tabButton + (d ? "" : " " + Ke.tabButtonSelected),
                        onClick: () => {
                            _e(!1)
                        }
                        ,
                        children: k.jsxs("div", {
                            children: ["  ", "Custom", " "]
                        })
                    }), k.jsx("div", {
                        className: Ke.tabButton + (d ? " " + Ke.tabButtonSelected : ""),
                        onClick: () => {
                            _e(!0)
                        }
                        ,
                        children: k.jsxs("div", {
                            children: ["  ", "Manifest", " "]
                        })
                    })]
                }), k.jsx("br", {}), d ? k.jsxs(k.Fragment, {
                    children: [k.jsx("div", {
                        className: Ke.traitInfoTitle + " " + Ke.centerAlign,
                        children: "Thumbnail Manifests"
                    }), k.jsx(Qc, {
                        className: Ke.dropdownControl,
                        options: o,
                        value: A,
                        onChange: re,
                        placeholder: "Select an option"
                    }), ";", k.jsx("div", {
                        className: Ke.traitInfoText,
                        children: l || ""
                    }), f != "" && k.jsx("div", {
                        className: Ke.actionButton,
                        onClick: se,
                        children: k.jsx("div", {
                            children: "  Create Thumbnails "
                        })
                    })]
                }) : k.jsxs(k.Fragment, {
                    children: [k.jsxs("div", {
                        className: Ke.traitInfoText,
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle + " " + Ke.centerAlign,
                            style: {
                                margin: "10px 0px 10px"
                            },
                            children: "Resolution"
                        }), "Width ", k.jsx("input", {
                            value: g,
                            className: Ke["input-box"],
                            step: 1,
                            onChange: Ae => {
                                p(Ae.target.value)
                            }
                            ,
                            onBlur: le
                        }), k.jsx("br", {}), "Height ", k.jsx("input", {
                            value: v,
                            className: Ke["input-box"],
                            step: 1,
                            onChange: Ae => {
                                w(Ae.target.value)
                            }
                            ,
                            onBlur: me
                        }), k.jsx("br", {}), "Top Spacing ", k.jsx("input", {
                            value: _,
                            className: Ke["input-box"],
                            step: .1,
                            onChange: Ae => {
                                x(Ae.target.value)
                            }
                            ,
                            onBlur: ie
                        }), k.jsx("br", {}), "Bottom Spacing ", k.jsx("input", {
                            value: b,
                            className: Ke["input-box"],
                            step: .1,
                            onChange: Ae => {
                                B(Ae.target.value)
                            }
                            ,
                            onBlur: ge
                        }), k.jsx("br", {}), k.jsx("div", {
                            className: Ke.traitInfoTitle + " " + Ke.centerAlign,
                            style: {
                                margin: "20px"
                            },
                            children: "Camera Position"
                        })]
                    }), k.jsxs("div", {
                        className: Ke.dropdownFlex,
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle,
                            style: {
                                margin: "0px"
                            },
                            children: "X"
                        }), k.jsx(Qc, {
                            className: Ke.dropdownControlSmall,
                            options: C,
                            onChange: Ae => {
                                L(Ae.label)
                            }
                            ,
                            value: M
                        })]
                    }), k.jsxs("div", {
                        className: Ke.dropdownFlex,
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle,
                            style: {
                                margin: "0px"
                            },
                            children: "Y"
                        }), k.jsx(Qc, {
                            className: Ke.dropdownControlSmall,
                            options: W,
                            onChange: Ae => {
                                T(Ae.label)
                            }
                            ,
                            value: D
                        })]
                    }), k.jsxs("div", {
                        className: Ke.dropdownFlex,
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle,
                            style: {
                                margin: "0px"
                            },
                            children: "Z"
                        }), k.jsx(Qc, {
                            className: Ke.dropdownControlSmall,
                            options: ee,
                            onChange: Ae => {
                                I(Ae.label)
                            }
                            ,
                            value: S
                        })]
                    }), k.jsx("div", {
                        className: Ke.traitInfoTitle + " " + Ke.centerAlign,
                        style: {
                            margin: "30px 0px 30px"
                        },
                        children: "Target Bones"
                    }), k.jsxs("div", {
                        className: Ke.dropdownFlex,
                        style: {
                            justifyContent: "space-between"
                        },
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle,
                            style: {
                                margin: "0px"
                            },
                            children: "Top"
                        }), k.jsx(Qc, {
                            className: Ke.dropdownControlSmall,
                            options: P,
                            onChange: Ae => {
                                E(Ae.label)
                            }
                            ,
                            value: y
                        })]
                    }), k.jsxs("div", {
                        className: Ke.dropdownFlex,
                        style: {
                            justifyContent: "space-between"
                        },
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle,
                            style: {
                                margin: "0px"
                            },
                            children: "Bottom"
                        }), k.jsx(Qc, {
                            className: Ke.dropdownControlSmall,
                            options: P,
                            onChange: Ae => {
                                F(Ae.label)
                            }
                            ,
                            value: R
                        })]
                    }), k.jsxs("div", {
                        style: {
                            textAlign: "left"
                        },
                        children: [k.jsxs("div", {
                            className: Ke.checkboxFlex,
                            style: {
                                marginTop: "20px"
                            },
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: O,
                                onChange: Ae => {
                                    z(Ae.target.checked)
                                }
                            }), k.jsx("div", {
                                className: Ke.traitInfoText,
                                style: {
                                    margin: "0px",
                                    fontSize: "12px"
                                },
                                children: `Top bone ${O ? "uses Top" : "uses Low"} Vertex`
                            })]
                        }), k.jsxs("div", {
                            className: Ke.checkboxFlex,
                            style: {
                                marginTop: "10px"
                            },
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: j,
                                onChange: Ae => {
                                    Q(Ae.target.checked)
                                }
                            }), k.jsx("div", {
                                className: Ke.traitInfoText,
                                style: {
                                    margin: "0px",
                                    fontSize: "12px"
                                },
                                children: `Bottom bone ${j ? "uses Top" : "uses Low"} Vertex`
                            })]
                        })]
                    }), e == "" ? k.jsx("div", {
                        className: Ke.traitInfoText + " " + Ke.centerAlign,
                        style: {
                            marginTop: "40px"
                        },
                        children: "Please choose a trait category in the left side menu."
                    }) : k.jsxs(k.Fragment, {
                        children: [k.jsx("div", {
                            className: Ke.traitInfoTitle + " " + Ke.centerAlign,
                            style: {
                                marginTop: "20px"
                            },
                            children: "Generate"
                        }), k.jsx("div", {
                            className: Ke.traitInfoText + " " + Ke.centerAlign,
                            style: {
                                margin: "0px auto 20px"
                            },
                            children: "( " + e + " )"
                        }), k.jsxs("div", {
                            className: Ke.simpleFlex,
                            style: {
                                marginTop: "0px"
                            },
                            children: [k.jsx("div", {
                                className: Ke.actionButton,
                                style: {
                                    margin: "0px"
                                },
                                onClick: () => {
                                    fe(!1)
                                }
                                ,
                                children: k.jsx("div", {
                                    children: "  Current "
                                })
                            }), k.jsx("div", {
                                className: Ke.actionButton,
                                style: {
                                    margin: "0px"
                                },
                                onClick: () => {
                                    fe(!0)
                                }
                                ,
                                children: k.jsx("div", {
                                    children: "  All "
                                })
                            })]
                        })]
                    })]
                })]
            })]
        })
    })
}
const hke = "_InformationContainerPos_10g06_2"
  , dke = "_scrollContainer_10g06_15"
  , pke = "_centerAlign_10g06_25"
  , mke = "_traitInfoTitle_10g06_28"
  , gke = "_traitInfoText_10g06_39"
  , vke = "_checked_10g06_65"
  , yke = "_checkmark_10g06_69"
  , wke = "_checkboxHolder_10g06_82"
  , _ke = "_actionButton_10g06_92"
  , Uc = {
    InformationContainerPos: hke,
    scrollContainer: dke,
    centerAlign: pke,
    traitInfoTitle: mke,
    traitInfoText: gke,
    "custom-checkbox": "_custom-checkbox_10g06_51",
    "checkbox-container": "_checkbox-container_10g06_56",
    checked: vke,
    checkmark: yke,
    checkboxHolder: wke,
    actionButton: _ke
};
function xke() {
    const {characterManager: n, moveCamera: e} = Z.useContext($n)
      , [t,r] = Z.useState(!1)
      , [i,s] = Z.useState(1)
      , o = n.emotionManager.availableEmotions;
    be.useEffect( () => {
        e({
            targetY: 1.8,
            distance: 2
        })
    }
    , []);
    const a = l => {
        n.emotionManager.playEmotion(l, void 0, t, i)
    }
    ;
    return k.jsx("div", {
        children: k.jsxs("div", {
            className: Uc.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Emotions",
                width: 180,
                right: 20
            }), k.jsxs("div", {
                className: Uc.scrollContainer,
                children: [k.jsx("div", {
                    className: Uc.traitInfoText,
                    children: "View different emotions"
                }), k.jsxs("div", {
                    className: Uc.checkboxHolder,
                    children: [k.jsx("div", {}), k.jsxs("label", {
                        className: Uc["custom-checkbox"],
                        children: [k.jsx("input", {
                            type: "checkbox",
                            checked: t,
                            onChange: () => r(!t)
                        }), k.jsx("div", {
                            className: Uc["checkbox-container"]
                        })]
                    }), k.jsx("div", {}), k.jsx("div", {}), k.jsx("div", {
                        style: {
                            color: "white"
                        },
                        children: "Constant Emotion"
                    })]
                }), k.jsx("br", {}), k.jsxs("div", {
                    className: Uc.traitInfoText,
                    children: ["Intensity: ", parseFloat(i.toFixed(2))]
                }), k.jsx(mu, {
                    title: "",
                    value: parseFloat(i.toFixed(2)),
                    onChange: l => s(parseFloat(l.currentTarget.value.toString())),
                    min: 0,
                    max: 1,
                    step: .01
                }), k.jsx("br", {}), o.map( (l, c) => k.jsx("div", {
                    className: Uc.actionButton,
                    onClick: () => {
                        a(l)
                    }
                    ,
                    children: k.jsxs("div", {
                        children: ["  ", l, " "]
                    })
                }, c))]
            })]
        })
    })
}
function bke({selectedTrait: n, selectedVRM: e, traitGroupName: t}) {
    const [r,i] = Z.useState("")
      , s = o => {
        o != r ? i(o) : i("")
    }
    ;
    return k.jsxs("div", {
        children: [r == "Information" && k.jsx(cke, {
            selectedTrait: n,
            selectedVRM: e
        }), r == "LoraCreation" && k.jsx(Ake, {
            selectedTrait: n,
            selectedVRM: e
        }), r == "SpriteCreation" && k.jsx(uke, {
            selectedTrait: n,
            selectedVRM: e
        }), r == "ThumbnailCreation" && k.jsx(fke, {
            selectedTrait: n,
            traitGroupName: t
        }), r == "EmotionManager" && k.jsx(xke, {}), k.jsxs("div", {
            className: xM.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Tools",
                width: 90,
                right: 0
            }), k.jsx("div", {
                className: xM.scrollContainer,
                children: k.jsxs("div", {
                    className: xM.optionsContainer,
                    children: [k.jsx("div", {
                        onClick: () => {
                            s("Information")
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: N3e,
                            rarity: r == "Information" ? "mythic" : "none"
                        })
                    }, "Information"), k.jsx("div", {
                        onClick: () => {
                            s("LoraCreation")
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: Q3e,
                            rarity: r == "LoraCreation" ? "mythic" : "none"
                        })
                    }, "LoraCreation"), k.jsx("div", {
                        onClick: () => {
                            s("SpriteCreation")
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: O3e,
                            rarity: r == "SpriteCreation" ? "mythic" : "none"
                        })
                    }, "SpriteCreation"), k.jsx("div", {
                        onClick: () => {
                            s("ThumbnailCreation")
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: H3e,
                            rarity: r == "ThumbnailCreation" ? "mythic" : "none"
                        })
                    }, "ThumbnailCreation"), k.jsx("div", {
                        onClick: () => {
                            s("EmotionManager")
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: k3e,
                            rarity: r == "EmotionManager" ? "mythic" : "none"
                        })
                    }, "Emotions")]
                })
            })]
        })]
    })
}
const ji = {
    TRAIT: 0,
    BLEND_SHAPE: 1,
    DECAL: 2
};
function Eke() {
    var me;
    const {isLoading: n, setViewMode: e, setIsLoading: t} = Z.useContext(us)
      , {toggleDebugMode: r, characterManager: i, animationManager: s, moveCamera: o} = Z.useContext($n)
      , [a,l] = Z.useState(ji.TRAIT)
      , {playSound: c} = Z.useContext(Co)
      , {isMute: A} = Z.useContext(So)
      , {t: u} = be.useContext(fa)
      , f = () => {
        !A && c("backNextButton"),
        i.removeCurrentCharacter(),
        i.removeCurrentManifest(),
        e(wt.CREATE),
        r(!1)
    }
      , [h,d] = Z.useState(null)
      , [m,g] = Z.useState(null)
      , [p,v] = Z.useState(null)
      , [w,_] = Z.useState(null)
      , [x,b] = Z.useState({})
      , [B,S] = Z.useState(null)
      , [I,M] = Z.useState("")
      , [L,D] = Z.useState(!1)
      , [T,y] = Z.useState({
        background: "#ffffff"
    })
      , E = () => {
        !A && c("backNextButton"),
        e(wt.SAVE),
        r(!1)
    }
      , R = () => {
        t(!0),
        d(null),
        i.loadRandomTraits().then( () => {
            console.log("success"),
            p && p.trait != "" && _(i.getCurrentTraitData(p.trait)),
            t(!1)
        }
        ).catch(ie => {
            t(!1),
            console.error("Error loading random traits:", ie.message)
        }
        )
    }
      , F = ie => {
        y({
            background: ie.hex
        })
    }
      , O = ie => {
        y({
            background: ie.hex
        }),
        i.setTraitColor(p == null ? void 0 : p.trait, ie.hex)
    }
      , z = async ie => {
        const ge = Kl(ie.name)
          , _e = URL.createObjectURL(ie);
        await s.loadAnimation(_e, !1, 0, !0, "", ge),
        M(s.getCurrentAnimationName())
    }
      , j = ie => {
        if (D(!1),
        p && p.trait != "") {
            t(!0);
            const ge = URL.createObjectURL(ie);
            i.loadCustomTexture(p.trait, ge).then( () => {
                t(!1)
            }
            )
        } else
            console.warn("Please select a group trait first.")
    }
      , Q = ie => {
        if (D(!1),
        p && p.trait != "") {
            t(!0);
            const ge = URL.createObjectURL(ie);
            i.loadCustomTrait(p.trait, ge).then( () => {
                t(!1)
            }
            )
        } else
            console.warn("Please select a group trait first.")
    }
      , C = ie => {
        var ge;
        if (ie.id === (w == null ? void 0 : w.id)) {
            ((ge = ie.blendshapeTraits) == null ? void 0 : ge.length) > 0 && l(ji.BLEND_SHAPE);
            return
        }
        D(!1),
        t(!0),
        i.loadTrait(ie.traitGroup.trait, ie.id).then( () => {
            var _e;
            if (t(!1),
            ((_e = ie.blendshapeTraits) == null ? void 0 : _e.length) > 0) {
                const se = i.getCurrentBlendShapeTraitData(ie.traitGroup.trait);
                b(Object.entries(se).reduce( (H, [fe,Ae]) => (H[fe] = Ae.id,
                H), {})),
                l(ji.BLEND_SHAPE)
            }
            _(ie)
        }
        )
    }
      , W = ie => {
        D(!1),
        i.removeTrait(ie),
        _(null)
    }
      , ee = ie => {
        D(!1),
        t(!0),
        i.loadRandomTrait(ie).then( () => {
            t(!1),
            _(i.getCurrentTraitData(ie))
        }
        )
    }
      , P = ie => {
        D(!1);
        const ge = Array.from(ie)
          , _e = []
          , se = H => new Promise( (fe, Ae) => {
            var J;
            if (H && H.name.toLowerCase().endsWith(".json")) {
                const q = new FileReader
                  , he = `${(J = i.manifestData) == null ? void 0 : J.getAssetsDirectory()}/anata/_thumbnails/t_${H.name.split("_")[0]}.jpg`;
                console.log(he),
                q.onload = function(X) {
                    try {
                        const G = JSON.parse(X.target.result);
                        G.thumb = he,
                        _e.push(G),
                        fe()
                    } catch (G) {
                        console.error("Error parsing the JSON file:", G),
                        Ae(G)
                    }
                }
                ,
                q.readAsText(H)
            }
        }
        );
        Promise.all(ge.map(se)).then( () => {
            _e.length > 0 && (d(_e),
            t(!0),
            i.loadTraitsFromNFTObject(_e[0]).then( () => {
                t(!1)
            }
            ))
        }
        ).catch(H => {
            console.error("Error processing files:", H)
        }
        )
    }
      , re = async ie => {
        const ge = ie[0];
        ge && ge.name.toLowerCase().endsWith(".fbx") && z(ge),
        ge && (ge.name.toLowerCase().endsWith(".png") || ge.name.toLowerCase().endsWith(".jpg")) && j(ge),
        ge && ge.name.toLowerCase().endsWith(".vrm") && Q(ge),
        ge && ge.name.toLowerCase().endsWith(".json") && P(ie)
    }
      , ue = ie => {
        if (!A && c("optionClick"),
        D(!1),
        (p == null ? void 0 : p.trait) !== ie.trait) {
            l(ji.TRAIT),
            g(i.getTraits(ie.trait)),
            v(ie);
            const ge = i.getCurrentTraitData(ie.trait)
              , _e = i.getCurrentBlendShapeTraitData(ie.trait);
            _(ge),
            b(Object.entries(_e).reduce( (se, [H,fe]) => (se[H] = fe.id,
            se), {})),
            S(i.getCurrentTraitVRM(ie.trait)),
            o({
                targetY: ie.cameraTarget.height,
                distance: ie.cameraTarget.distance
            })
        } else
            g(null),
            v(null),
            _(null),
            b({}),
            o({
                targetY: .8,
                distance: 3.2
            })
    }
      , le = () => {
        D(!1);
        var ie = document.createElement("input");
        if (ie.type = "file",
        ie.accept = ".vrm",
        !p)
            return console.error("Please select a trait group first");
        ie.onchange = ge => {
            var _e = ge.target.files[0];
            if (_e.name.endsWith(".vrm")) {
                const se = URL.createObjectURL(_e);
                t(!0),
                i.loadCustomTrait(p.trait, se).then( () => {
                    t(!1)
                }
                )
            }
        }
        ,
        ie.click()
    }
    ;
    return k.jsxs("div", {
        className: jt.container,
        children: [k.jsx("div", {
            className: `loadingIndicator ${n ? "active" : ""}`,
            children: k.jsx("img", {
                className: "rotate",
                src: "ui/loading.svg"
            })
        }), k.jsx("div", {
            className: "sectionTitle",
            children: u("pageTitles.chooseAppearance")
        }), k.jsx(S0, {
            onFilesDrop: re
        }), k.jsxs("div", {
            className: jt.sideMenu,
            children: [k.jsx(Aa, {
                title: "Appearance",
                left: 20
            }), k.jsx("div", {
                className: jt.bottomLine
            }), k.jsx("div", {
                className: jt.scrollContainer,
                children: k.jsx("div", {
                    className: jt["editor-container"],
                    children: i.getGroupTraits().map( (ie, ge) => k.jsxs("div", {
                        className: jt.editorButton,
                        onClick: () => {
                            ue(ie)
                        }
                        ,
                        children: [k.jsx(Jo, {
                            size: 56,
                            icon: ie.fullIconSvg,
                            rarity: (p == null ? void 0 : p.trait) !== ie.trait ? "none" : "mythic"
                        }), k.jsx("div", {
                            className: jt.editorText,
                            children: ie.name
                        })]
                    }, "options_" + ge))
                })
            })]
        }), !!m && p && k.jsxs("div", {
            className: jt.selectorContainerPos,
            children: [k.jsx(Aa, {
                title: p.trait,
                width: 130,
                left: 20
            }), k.jsxs("div", {
                className: jt.selectorPickerTabs,
                children: [w && a == ji.TRAIT && k.jsx("div", {
                    className: jt.selectorColorPickerButton,
                    onClick: () => {
                        D(!L)
                    }
                    ,
                    children: k.jsx("img", {
                        className: jt.selectorColorPickerImg,
                        src: V_e
                    })
                }), p && ((me = p.getAllDecals()) == null ? void 0 : me.length) && k.jsx("div", {
                    className: jt.selectorColorPickerButton,
                    onClick: () => a == ji.DECAL ? l(ji.TRAIT) : l(ji.DECAL),
                    children: k.jsx("img", {
                        className: jt.selectorColorPickerImg,
                        src: g_e
                    })
                })]
            }), a == ji.TRAIT && !!L && k.jsx("div", {
                draggable: !1,
                className: jt.selectorColorPickerUI,
                children: k.jsx(a3e, {
                    styles: {
                        default: {
                            picker: {
                                width: "200px"
                            }
                        }
                    },
                    color: T.background,
                    onChange: F,
                    onChangeComplete: O
                })
            }), k.jsx("div", {
                className: jt.bottomLine
            }), k.jsxs("div", {
                className: jt.scrollContainerOptions,
                children: [a == ji.TRAIT && k.jsxs("div", {
                    className: jt["selector-container"],
                    children: [k.jsx("div", {
                        className: `${jt.selectorButton}`,
                        onClick: () => {
                            ee(p.trait)
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: G_e,
                            rarity: "none"
                        })
                    }, "randomize-trait"), i.isTraitGroupRequired(p.trait) ? k.jsx(k.Fragment, {}) : k.jsx("div", {
                        className: `${jt.selectorButton}`,
                        icon: hx,
                        onClick: () => {
                            W(p.trait)
                        }
                        ,
                        children: k.jsx(Jo, {
                            size: 56,
                            icon: hx,
                            rarity: w == null ? "mythic" : "none"
                        })
                    }, "no-trait"), m.map(ie => {
                        let ge = ie.id === (w == null ? void 0 : w.id);
                        return k.jsx("div", {
                            className: `${jt.selectorButton}`,
                            onClick: () => {
                                C(ie)
                            }
                            ,
                            children: k.jsx(Jo, {
                                size: 56,
                                icon: ie.fullThumbnail,
                                rarity: ge ? "mythic" : "none"
                            })
                        }, ie.id)
                    }
                    )]
                }), a == ji.BLEND_SHAPE && k.jsx(Bke, {
                    selectedTrait: w,
                    onBack: () => {
                        l(ji.TRAIT)
                    }
                    ,
                    selectedBlendShapeTrait: x,
                    setSelectedBlendshapeTrait: b
                }), a == ji.DECAL && k.jsx(z_e, {
                    selectedTraitGroup: p,
                    onBack: () => {
                        l(ji.TRAIT)
                    }
                })]
            }), k.jsx("div", {
                className: jt.uploadContainer,
                children: k.jsx("div", {
                    className: jt.uploadButton,
                    onClick: le,
                    children: k.jsx("div", {
                        children: "Upload "
                    })
                })
            })]
        }), k.jsx(w2, {
            jsonSelectionArray: h
        }), k.jsx(bke, {
            selectedTrait: w,
            selectedVRM: B,
            traitGroupName: (p == null ? void 0 : p.trait) || ""
        }), k.jsx(k1, {
            loadedAnimationName: I,
            randomize: R
        }), k.jsxs("div", {
            className: jt.buttonContainer,
            children: [k.jsx(Bn, {
                theme: "light",
                text: u("callToAction.back"),
                size: 14,
                className: jt.buttonLeft,
                onClick: f
            }), i.canDownload() && k.jsx(Bn, {
                theme: "light",
                text: u("callToAction.next"),
                size: 14,
                className: jt.buttonRight,
                onClick: E
            })]
        })]
    })
}
const Bke = ({selectedTrait: n, onBack: e, selectedBlendShapeTrait: t, setSelectedBlendshapeTrait: r}) => {
    const {characterManager: i, moveCamera: s} = Z.useContext($n)
      , o = i.getBlendShapeGroupTraits((n == null ? void 0 : n.traitGroup.trait) || "", (n == null ? void 0 : n.id) || "")
      , a = (c, A) => {
        i.removeBlendShapeTrait(c, A.trait);
        const u = {
            ...t
        };
        delete u[A.trait],
        r(u)
    }
      , l = c => {
        const A = c.parentGroup;
        i.loadBlendShapeTrait((n == null ? void 0 : n.traitGroup.trait) || "", A.trait || "", (c == null ? void 0 : c.id) || ""),
        s({
            targetY: A.cameraTarget.height,
            distance: A.cameraTarget.distance
        });
        const u = {
            ...t
        };
        u[A.trait || ""] = c.id,
        r(u)
    }
    ;
    return k.jsxs("div", {
        className: jt["selector-container-column"],
        children: [k.jsx(Bn, {
            theme: "dark",
            text: "Back",
            size: 14,
            className: jt.buttonLeft,
            onClick: e
        }), o && o.length > 0 && o.map(c => k.jsxs("div", {
            className: jt.blendshapeGroup,
            children: [k.jsx("div", {
                children: c.name
            }), k.jsxs("div", {
                className: jt["selector-container"],
                children: [k.jsx(p4, {
                    src: hx,
                    active: !t[c.trait],
                    blendshapeID: "cancel",
                    select: () => a(n.traitGroup.trait, c)
                }, "empty"), c.collection.map(A => {
                    let u = A.id === t[c.trait];
                    return k.jsx(p4, {
                        src: A.fullThumbnail || "",
                        active: u,
                        blendshapeID: A.id,
                        select: () => l(A)
                    }, A.id)
                }
                )]
            })]
        }, c.trait))]
    })
}
  , p4 = ({active: n, blendshapeID: e, src: t, select: r}) => k.jsx("div", {
    className: `${jt.selectorButton}`,
    onClick: r,
    children: k.jsx(Jo, {
        size: 56,
        icon: t || "",
        rarity: n ? "mythic" : "none"
    })
}, e)
  , Mke = "_InformationContainerPos_rgqwy_1"
  , Ske = "_traitInfoTitle_rgqwy_13"
  , Cke = "_traitInfoText_rgqwy_21"
  , Tke = "_flexSelect_rgqwy_30"
  , Ike = "_scrollContainer_rgqwy_65"
  , Rke = "_checked_rgqwy_90"
  , Uke = "_checkmark_rgqwy_94"
  , Fke = "_checkboxHolder_rgqwy_107"
  , Pke = "_buttonContainer_rgqwy_114"
  , Lke = "_buttonLeft_rgqwy_123"
  , Dke = "_buttonRight_rgqwy_127"
  , Nke = "_buttonCenter_rgqwy_131"
  , Oi = {
    InformationContainerPos: Mke,
    traitInfoTitle: Ske,
    traitInfoText: Cke,
    flexSelect: Tke,
    "arrow-button": "_arrow-button_rgqwy_37",
    "left-button": "_left-button_rgqwy_51",
    "right-button": "_right-button_rgqwy_58",
    scrollContainer: Ike,
    "custom-checkbox": "_custom-checkbox_rgqwy_76",
    "checkbox-container": "_checkbox-container_rgqwy_81",
    checked: Rke,
    checkmark: Uke,
    checkboxHolder: Fke,
    buttonContainer: Pke,
    buttonLeft: Lke,
    buttonRight: Dke,
    buttonCenter: Nke
}
  , Oke = "_InformationContainerPos_11mqa_2"
  , kke = "_scrollContainer_11mqa_16"
  , Qke = "_traitInfoTitle_11mqa_28"
  , Hke = "_traitInfoText_11mqa_38"
  , zke = "_flexSelect_11mqa_66"
  , Gke = "_checked_11mqa_124"
  , Vke = "_checkmark_11mqa_128"
  , jke = "_checkboxHolder_11mqa_141"
  , cr = {
    InformationContainerPos: Oke,
    scrollContainer: kke,
    traitInfoTitle: Qke,
    traitInfoText: Hke,
    "input-box": "_input-box_11mqa_47",
    flexSelect: zke,
    "arrow-button": "_arrow-button_11mqa_76",
    "left-button": "_left-button_11mqa_91",
    "right-button": "_right-button_11mqa_98",
    "anim-button": "_anim-button_11mqa_105",
    "custom-checkbox": "_custom-checkbox_11mqa_110",
    "checkbox-container": "_checkbox-container_11mqa_115",
    checked: Gke,
    checkmark: Vke,
    checkboxHolder: jke
};
function fU({model: n, name: e, files: t, index: r, nextVrm: i, previousVrm: s}) {
    const {characterManager: o} = Z.useContext($n)
      , [a,l] = be.useState(0)
      , [c,A] = be.useState(0)
      , [u,f] = be.useState(0)
      , [h,d] = be.useState(0)
      , [m,g] = be.useState(0)
      , [p,v] = be.useState(0)
      , [w,_] = be.useState(0)
      , [x,b] = be.useState(0)
      , [B,S] = be.useState(0)
      , [I,M] = be.useState(0);
    return be.useEffect( () => {
        if (n != null) {
            const L = kd(n, "Mesh")
              , D = kd(n, "SkinnedMesh");
            l(L.length),
            A(D.length);
            const T = L.concat(D)
              , {stdMats: y, stdCutoutpMats: E, stdTranspMats: R, mToonMats: F, mToonCutoutMats: O, mToonTranspMats: z} = fge(T);
            f(y.length),
            d(R.length),
            g(E.length),
            v(F.length),
            _(z.length),
            b(O.length);
            const {triangles: j, bones: Q} = o.getBoneTriangleCount();
            S(j),
            M(Q)
        }
    }
    , [n]),
    n != null ? k.jsx("div", {
        children: k.jsxs("div", {
            className: cr.InformationContainerPos,
            children: [k.jsx(Aa, {
                title: "Model Information",
                width: 180,
                right: 20
            }), k.jsxs("div", {
                className: cr.scrollContainer,
                children: [k.jsxs("div", {
                    className: cr.flexSelect,
                    children: [(t == null ? void 0 : t.length) > 1 ? k.jsx("div", {
                        className: `${cr["arrow-button"]} ${cr["left-button"]}`,
                        onClick: s
                    }) : k.jsx(k.Fragment, {}), e && k.jsx("div", {
                        style: {
                            textAlign: "center"
                        },
                        children: k.jsx("div", {
                            className: cr.traitInfoTitle,
                            style: {
                                margin: "auto",
                                fontSize: "14px",
                                width: "200px",
                                textAlign: "center",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                                overflow: "hidden"
                            },
                            children: e
                        })
                    }), (t == null ? void 0 : t.length) > 1 ? k.jsx("div", {
                        className: `${cr["arrow-button"]} ${cr["right-button"]}`,
                        onClick: i
                    }) : k.jsx(k.Fragment, {})]
                }), k.jsx("div", {
                    className: cr.traitInfoTitle,
                    children: "Geometry info:"
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["Meshes: ", a]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["SkinnedMeshes: ", c]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["Triangles: ", B]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["Bones: ", I]
                }), k.jsx("div", {
                    className: cr.traitInfoTitle,
                    children: "Standard Material Count:"
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["opaque: ", u]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["cutout: ", m]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["transparent: ", h]
                }), k.jsx("div", {
                    className: cr.traitInfoTitle,
                    children: "MToon Material Count:"
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["opaque: ", p]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["cutout: ", x]
                }), k.jsxs("div", {
                    className: cr.traitInfoText,
                    children: ["transparent: ", w]
                })]
            })]
        })
    }) : k.jsx(k.Fragment, {})
}
const Wke = "_InformationContainerPos_b0msk_1"
  , Kke = "_traitInfoTitle_b0msk_13"
  , Xke = "_traitInfoText_b0msk_22"
  , Yke = "_flexSelect_b0msk_33"
  , $ke = "_scrollContainer_b0msk_68"
  , Zke = "_checked_b0msk_93"
  , Jke = "_checkmark_b0msk_97"
  , qke = "_checkboxHolder_b0msk_110"
  , gt = {
    InformationContainerPos: Wke,
    traitInfoTitle: Kke,
    traitInfoText: Xke,
    flexSelect: Yke,
    "arrow-button": "_arrow-button_b0msk_40",
    "left-button": "_left-button_b0msk_54",
    "right-button": "_right-button_b0msk_61",
    scrollContainer: $ke,
    "custom-checkbox": "_custom-checkbox_b0msk_79",
    "checkbox-container": "_checkbox-container_b0msk_84",
    checked: Zke,
    checkmark: Jke,
    checkboxHolder: qke
};
function up() {
    localStorage && Object.keys(localStorage).map(n => {
        this.setItem(n, localStorage[n], !1)
    }
    ),
    Object.defineProperty(this, "length", {
        get: function() {
            return Object.keys(this).length
        },
        enumerable: !1
    })
}
up.prototype.key = function(n) {
    return Object.keys(this)[n]
}
;
up.prototype.getItem = function(n) {
    try {
        return JSON.parse(this[n])
    } catch {}
    return this[n]
}
;
up.prototype.setItem = function(n, e, t=!0) {
    const r = typeof e == "string" ? e : JSON.stringify(e);
    return t && localStorage.setItem(n, r),
    this[n] = r
}
;
up.prototype.removeItem = function(n) {
    delete this[n]
}
;
up.prototype.clear = function() {
    Object.keys(this).forEach(n => delete this[n])
}
;
let e4e = new up;
const t4e = n => ({
    get(e, t) {
        return n.getItem(String(t))
    },
    set(e, t, r) {
        return n.setItem(String(t), r),
        !0
    }
})
  , n4e = (n=e4e) => new Proxy({},t4e(n))
  , ze = n4e();
function nb({showDropToDownload: n, showCreateAtlas: e, mergeMenuTitle: t}) {
    const [r,i] = be.useState(ze.mergeOptions_atlas_std_size || 6)
      , [s,o] = be.useState(ze.mergeOptions_atlas_std_transp_size || 6)
      , [a,l] = be.useState(ze.mergeOptions_atlas_mtoon_size || 6)
      , [c,A] = be.useState(ze.mergeOptions_atlas_mtoon_transp_size || 6)
      , [u,f] = be.useState(ze.mergeOptions_sel_option || 0)
      , [h,d] = be.useState(ze.mergeOptions_two_sided_mat || !1)
      , [m] = be.useState(["Merge to Standard", "Merge to MToon", "Keep Both"])
      , [g,p] = be.useState(ze.mergeOptions_download_vrm == null ? !0 : ze.mergeOptions_download_vrm)
      , [v,w] = be.useState(ze.mergeOptions_download_vrm_preview == null ? !0 : ze.mergeOptions_download_vrm_preview)
      , [_,x] = be.useState(ze.mergeOptions_drop_download || !1)
      , [b,B] = be.useState(ze.merge_options_ktx_compression || !1)
      , [S,I] = be.useState(ze.mergeOptions_create_atlas == null ? !0 : ze.mergeOptions_create_atlas)
      , [M,L] = be.useState(ze.mergeOptions_download_lora == null ? !0 : ze.mergeOptions_download_lora)
      , [D,T] = be.useState(ze.mergeOptions_download_sprites == null ? !0 : ze.mergeOptions_download_sprites)
      , y = P => {
        x(P.target.checked),
        ze.mergeOptions_drop_download = P.target.checked
    }
      , E = P => {
        d(P.target.checked),
        ze.mergeOptions_two_sided_mat = P.target.checked
    }
      , R = P => {
        B(P.target.checked),
        ze.merge_options_ktx_compression = P.target.checked
    }
      , F = P => {
        I(P.target.checked),
        ze.mergeOptions_create_atlas = P.target.checked
    }
      , O = P => {
        p(P.target.checked),
        ze.mergeOptions_download_vrm = P.target.checked
    }
      , z = P => {
        w(P.target.checked),
        ze.mergeOptions_download_vrm_preview = P.target.checked
    }
      , j = P => {
        L(P.target.checked),
        ze.mergeOptions_download_lora = P.target.checked
    }
      , Q = P => {
        T(P.target.checked),
        ze.mergeOptions_download_sprites = P.target.checked
    }
      , C = () => {
        let P = u;
        u <= 0 ? P = m.length - 1 : P -= 1,
        f(P),
        ze.mergeOptions_sel_option = P
    }
      , W = () => {
        let P = u;
        u >= m.length - 1 ? P = 0 : P += 1,
        f(P),
        ze.mergeOptions_sel_option = P
    }
      , ee = async (P, re) => {
        let ue = parseInt(P.target.value);
        ue > 8 ? ue = 8 : ue < 0 && (ue = 0),
        (me => {
            switch (re) {
            case "standard opaque":
                i(me),
                ze.mergeOptions_atlas_std_size = me;
                break;
            case "standard transparent":
                o(me),
                ze.mergeOptions_atlas_std_transp_size = me;
                break;
            case "mtoon opaque":
                l(me),
                ze.mergeOptions_atlas_mtoon_size = me;
                break;
            case "mtoon transparent":
                A(me),
                ze.mergeOptions_atlas_mtoon_transp_size = me;
                break
            }
        }
        )(ue)
    }
    ;
    return k.jsxs("div", {
        className: gt.InformationContainerPos,
        children: [k.jsx(Aa, {
            title: t,
            width: 180,
            left: 20
        }), k.jsxs("div", {
            className: gt.scrollContainer,
            children: [k.jsx("div", {
                className: gt.traitInfoTitle,
                children: "Download Options"
            }), k.jsx(k.Fragment, {
                children: k.jsx("div", {
                    className: gt.traitInfoText,
                    children: k.jsxs("div", {
                        className: gt.checkboxHolder,
                        children: [k.jsx("div", {}), k.jsxs("label", {
                            className: gt["custom-checkbox"],
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: g,
                                onChange: O
                            }), k.jsx("div", {
                                className: gt["checkbox-container"]
                            })]
                        }), k.jsx("div", {}), k.jsx("div", {}), "Download VRM"]
                    })
                })
            }), k.jsx(k.Fragment, {
                children: k.jsx("div", {
                    className: gt.traitInfoText,
                    children: k.jsxs("div", {
                        className: gt.checkboxHolder,
                        children: [k.jsx("div", {}), k.jsxs("label", {
                            className: gt["custom-checkbox"],
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: v,
                                onChange: z
                            }), k.jsx("div", {
                                className: gt["checkbox-container"]
                            })]
                        }), k.jsx("div", {}), k.jsx("div", {}), "Download VRM Preview"]
                    })
                })
            }), k.jsx(k.Fragment, {
                children: k.jsx("div", {
                    className: gt.traitInfoText,
                    children: k.jsxs("div", {
                        className: gt.checkboxHolder,
                        children: [k.jsx("div", {}), k.jsxs("label", {
                            className: gt["custom-checkbox"],
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: M,
                                onChange: j
                            }), k.jsx("div", {
                                className: gt["checkbox-container"]
                            })]
                        }), k.jsx("div", {}), k.jsx("div", {}), "Download Lora Data"]
                    })
                })
            }), k.jsx(k.Fragment, {
                children: k.jsx("div", {
                    className: gt.traitInfoText,
                    children: k.jsxs("div", {
                        className: gt.checkboxHolder,
                        children: [k.jsx("div", {}), k.jsxs("label", {
                            className: gt["custom-checkbox"],
                            children: [k.jsx("input", {
                                type: "checkbox",
                                checked: D,
                                onChange: Q
                            }), k.jsx("div", {
                                className: gt["checkbox-container"]
                            })]
                        }), k.jsx("div", {}), k.jsx("div", {}), "Download Sprites Data"]
                    })
                })
            }), g && k.jsxs(k.Fragment, {
                children: [e && k.jsx(k.Fragment, {
                    children: k.jsx("div", {
                        className: gt.traitInfoText,
                        children: k.jsxs("div", {
                            className: gt.checkboxHolder,
                            children: [k.jsx("div", {}), k.jsxs("label", {
                                className: gt["custom-checkbox"],
                                children: [k.jsx("input", {
                                    type: "checkbox",
                                    checked: S,
                                    onChange: F
                                }), k.jsx("div", {
                                    className: gt["checkbox-container"]
                                })]
                            }), k.jsx("div", {}), k.jsx("div", {}), "Create Atlas"]
                        })
                    })
                }), (e == !1 || S) && k.jsxs(k.Fragment, {
                    children: [k.jsx("br", {}), k.jsx("div", {
                        className: gt.traitInfoTitle,
                        children: "Merge Atlas Type"
                    }), k.jsx("br", {}), k.jsxs("div", {
                        className: gt.flexSelect,
                        children: [k.jsx("div", {
                            className: `${gt["arrow-button"]} ${gt["left-button"]}`,
                            onClick: C
                        }), k.jsx("div", {
                            className: gt.traitInfoText,
                            style: {
                                marginBottom: "0"
                            },
                            children: m[u]
                        }), k.jsx("div", {
                            className: `${gt["arrow-button"]} ${gt["right-button"]}`,
                            onClick: W
                        })]
                    }), k.jsx("br", {}), k.jsx("br", {}), (u === 0 || u == 2) && k.jsxs(k.Fragment, {
                        children: [k.jsx("div", {
                            className: gt.traitInfoTitle,
                            children: "Standard Atlas Size"
                        }), k.jsx("br", {}), k.jsxs("div", {
                            className: gt.traitInfoText,
                            children: ["Opaque: ", Nn(r) + " x " + Nn(r)]
                        }), k.jsx(mu, {
                            value: r,
                            onChange: P => ee(P, "standard opaque"),
                            min: 1,
                            max: 8,
                            step: 1
                        }), k.jsx("br", {}), k.jsxs("div", {
                            className: gt.traitInfoText,
                            children: ["Transparent: ", Nn(s) + " x " + Nn(s)]
                        }), k.jsx(mu, {
                            value: s,
                            onChange: P => ee(P, "standard transparent"),
                            min: 1,
                            max: 8,
                            step: 1
                        }), k.jsx("br", {}), " ", k.jsx("br", {})]
                    }), (u === 1 || u == 2) && k.jsxs(k.Fragment, {
                        children: [k.jsx("div", {
                            className: gt.traitInfoTitle,
                            children: "MToon Atlas Size"
                        }), k.jsx("br", {}), k.jsxs("div", {
                            className: gt.traitInfoText,
                            children: ["Opaque: ", Nn(a) + " x " + Nn(a)]
                        }), k.jsx(mu, {
                            value: a,
                            onChange: P => ee(P, "mtoon opaque"),
                            min: 1,
                            max: 8,
                            step: 1
                        }), k.jsx("br", {}), k.jsxs("div", {
                            className: gt.traitInfoText,
                            children: ["Transparent: ", Nn(c) + " x " + Nn(c)]
                        }), k.jsx(mu, {
                            value: c,
                            onChange: P => ee(P, "mtoon transparent"),
                            min: 1,
                            max: 8,
                            step: 1
                        }), k.jsx("br", {}), " ", k.jsx("br", {})]
                    }), k.jsx("div", {
                        className: gt.traitInfoTitle,
                        children: "Options"
                    }), k.jsx("div", {
                        className: gt.traitInfoText,
                        children: k.jsxs("div", {
                            className: gt.checkboxHolder,
                            children: [k.jsx("div", {}), k.jsxs("label", {
                                className: gt["custom-checkbox"],
                                children: [k.jsx("input", {
                                    type: "checkbox",
                                    checked: h,
                                    onChange: E
                                }), k.jsx("div", {
                                    className: gt["checkbox-container"]
                                })]
                            }), k.jsx("div", {}), k.jsx("div", {}), "Two Sided Material"]
                        })
                    }), n && k.jsx(k.Fragment, {
                        children: k.jsx("div", {
                            className: gt.traitInfoText,
                            children: k.jsxs("div", {
                                className: gt.checkboxHolder,
                                children: [k.jsx("div", {}), k.jsxs("label", {
                                    className: gt["custom-checkbox"],
                                    children: [k.jsx("input", {
                                        type: "checkbox",
                                        checked: _,
                                        onChange: y
                                    }), k.jsx("div", {
                                        className: gt["checkbox-container"]
                                    })]
                                }), k.jsx("div", {}), k.jsx("div", {}), "Drag Drop - Download"]
                            })
                        })
                    }), k.jsx(k.Fragment, {
                        children: k.jsx("div", {
                            className: gt.traitInfoText,
                            children: k.jsxs("div", {
                                className: gt.checkboxHolder,
                                children: [k.jsx("div", {}), k.jsxs("label", {
                                    className: gt["custom-checkbox"],
                                    children: [k.jsx("input", {
                                        type: "checkbox",
                                        checked: b,
                                        onChange: R
                                    }), k.jsx("div", {
                                        className: gt["checkbox-container"]
                                    })]
                                }), k.jsx("div", {}), k.jsx("div", {}), "KTX Compression"]
                            })
                        })
                    })]
                })]
            })]
        })]
    })
}
function r4e() {
    const {isLoading: n, setViewMode: e, setIsLoading: t} = Z.useContext(us)
      , {manifest: r, toggleDebugMode: i, characterManager: s, animationManager: o, loraDataGenerator: a, spriteAtlasGenerator: l, sceneElements: c} = Z.useContext($n)
      , [A,u] = be.useState(null)
      , [f,h] = be.useState("")
      , [d,m] = Z.useState("")
      , {playSound: g} = Z.useContext(Co)
      , {isMute: p} = Z.useContext(So)
      , [v,w] = Z.useState(null)
      , _ = () => {
        !p && g("backNextButton"),
        s.removeCurrentCharacter(),
        s.removeCurrentManifest(),
        i(!1),
        e(wt.LANDING)
    }
      , x = () => {
        const T = ze.mergeOptions_sel_option || 0;
        return {
            isVrm0: !0,
            createTextureAtlas: !0,
            mToonAtlasSize: Nn(ze.mergeOptions_atlas_mtoon_size || 6),
            mToonAtlasSizeTransp: Nn(ze.mergeOptions_atlas_mtoon_transp_size || 6),
            stdAtlasSize: Nn(ze.mergeOptions_atlas_std_size || 6),
            stdAtlasSizeTransp: Nn(ze.mergeOptions_atlas_std_transp_size || 6),
            exportStdAtlas: T === 0 || T == 2,
            exportMtoonAtlas: T === 1 || T == 2,
            ktxCompression: ze.merge_options_ktx_compression || !1,
            twoSidedMaterial: ze.mergeOptions_two_sided_mat || !1
        }
    }
      , b = (T, y=!1) => {
        console.log(y),
        (async () => {
            await s.loadTraitsFromNFTObject(v[T]),
            (ze.mergeOptions_download_vrm == null ? !0 : ze.mergeOptions_download_vrm) && await s.downloadVRM(v[T].name, x());
            const F = new ep
              , O = c.parent;
            O.remove(c);
            const z = ze.mergeOptions_download_lora == null ? !0 : ze.mergeOptions_download_lora;
            if (z === !0) {
                const Q = r.loras.map(async C => a.createLoraData(C, F));
                await Promise.all(Q)
            }
            const j = ze.mergeOptions_download_sprites == null ? !0 : ze.mergeOptions_download_sprites;
            if (j === !0) {
                const Q = r.sprites.map(async C => l.createSpriteAtlas(C, F));
                await Promise.all(Q)
            }
            (z === !0 || j === !0) && F.saveZip(v[T].name),
            O.add(c),
            T < v.length - 1 ? b(T + 1) : t(!1)
        }
        )()
    }
      , B = () => {
        t(!0),
        b(0, !0)
    }
      , {t: S} = be.useContext(fa)
      , I = async T => {
        if (s.getCurrentCharacterModel()) {
            const E = Kl(T.name)
              , R = URL.createObjectURL(T);
            await o.loadAnimation(R, !1, 0, !0, "", E),
            m(o.getCurrentAnimationName()),
            URL.revokeObjectURL(R)
        } else
            console.warn("Please load a vrm model to test animations.")
    }
      , M = async T => {
        const y = URL.createObjectURL(T);
        await s.loadOptimizerCharacter(y),
        URL.revokeObjectURL(y);
        const E = Kl(T.name);
        h(E),
        u(s.getCurrentCharacterModel())
    }
      , L = T => {
        const y = Array.from(T)
          , E = []
          , R = F => new Promise( (O, z) => {
            var j;
            if (F && F.name.toLowerCase().endsWith(".json")) {
                const Q = new FileReader
                  , C = `${(j = s.manifestData) == null ? void 0 : j.getAssetsDirectory()}/anata/_thumbnails/t_${F.name.split("_")[0]}.jpg`;
                Q.onload = function(W) {
                    try {
                        const ee = JSON.parse(W.target.result);
                        ee.thumb = C,
                        E.push(ee),
                        O()
                    } catch (ee) {
                        console.error("Error parsing the JSON file:", ee),
                        z(ee)
                    }
                }
                ,
                Q.readAsText(F)
            }
        }
        );
        Promise.all(y.map(R)).then( () => {
            E.length > 0 && (w(E),
            t(!0),
            s.loadTraitsFromNFTObject(E[0]).then( () => {
                t(!1)
            }
            ))
        }
        ).catch(F => {
            console.error("Error processing files:", F)
        }
        )
    }
      , D = async T => {
        const y = T[0];
        console.log("anim"),
        y && y.name.toLowerCase().endsWith(".fbx") && (console.log("anim2"),
        I(y)),
        y && y.name.toLowerCase().endsWith(".vrm") && M(y),
        y && y.name.toLowerCase().endsWith(".json") && L(T)
    }
    ;
    return k.jsxs("div", {
        className: Oi.container,
        children: [k.jsx("div", {
            className: `loadingIndicator ${n ? "active" : ""}`,
            children: k.jsx("img", {
                className: "rotate",
                src: "ui/loading.svg"
            })
        }), k.jsx("div", {
            className: "sectionTitle",
            children: "Batch Download"
        }), k.jsx(S0, {
            onFilesDrop: D
        }), k.jsx(nb, {
            showDropToDownload: !0,
            showCreateAtlas: !1,
            mergeMenuTitle: "Download Options"
        }), k.jsx(fU, {
            model: A
        }), k.jsx(w2, {
            jsonSelectionArray: v
        }), k.jsx(k1, {
            loadedAnimationName: d
        }), k.jsxs("div", {
            className: Oi.buttonContainer,
            children: [k.jsx(Bn, {
                theme: "light",
                text: S("callToAction.back"),
                size: 14,
                className: Oi.buttonLeft,
                onClick: _
            }), (v == null ? void 0 : v.length) == 1 && k.jsx(Bn, {
                theme: "light",
                text: "Download",
                size: 14,
                className: Oi.buttonRight,
                onClick: B
            }), (v == null ? void 0 : v.length) > 1 && k.jsx(Bn, {
                theme: "light",
                text: "Download All",
                size: 14,
                className: Oi.buttonRight,
                onClick: B
            })]
        })]
    })
}
const N0 = "abi/5.7.0"
  , zt = new xe(N0)
  , zu = {};
let m4 = {
    calldata: !0,
    memory: !0,
    storage: !0
}
  , i4e = {
    calldata: !0,
    memory: !0
};
function Ky(n, e) {
    if (n === "bytes" || n === "string") {
        if (m4[e])
            return !0
    } else if (n === "address") {
        if (e === "payable")
            return !0
    } else if ((n.indexOf("[") >= 0 || n === "tuple") && i4e[e])
        return !0;
    return (m4[e] || e === "payable") && zt.throwArgumentError("invalid modifier", "name", e),
    !1
}
function s4e(n, e) {
    let t = n;
    function r(a) {
        zt.throwArgumentError(`unexpected character at position ${a}`, "param", n)
    }
    n = n.replace(/\s/g, " ");
    function i(a) {
        let l = {
            type: "",
            name: "",
            parent: a,
            state: {
                allowType: !0
            }
        };
        return e && (l.indexed = !1),
        l
    }
    let s = {
        type: "",
        name: "",
        state: {
            allowType: !0
        }
    }
      , o = s;
    for (let a = 0; a < n.length; a++) {
        let l = n[a];
        switch (l) {
        case "(":
            o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || r(a),
            o.state.allowType = !1,
            o.type = ph(o.type),
            o.components = [i(o)],
            o = o.components[0];
            break;
        case ")":
            delete o.state,
            o.name === "indexed" && (e || r(a),
            o.indexed = !0,
            o.name = ""),
            Ky(o.type, o.name) && (o.name = ""),
            o.type = ph(o.type);
            let c = o;
            o = o.parent,
            o || r(a),
            delete c.parent,
            o.state.allowParams = !1,
            o.state.allowName = !0,
            o.state.allowArray = !0;
            break;
        case ",":
            delete o.state,
            o.name === "indexed" && (e || r(a),
            o.indexed = !0,
            o.name = ""),
            Ky(o.type, o.name) && (o.name = ""),
            o.type = ph(o.type);
            let A = i(o.parent);
            o.parent.components.push(A),
            delete o.parent,
            o = A;
            break;
        case " ":
            o.state.allowType && o.type !== "" && (o.type = ph(o.type),
            delete o.state.allowType,
            o.state.allowName = !0,
            o.state.allowParams = !0),
            o.state.allowName && o.name !== "" && (o.name === "indexed" ? (e || r(a),
            o.indexed && r(a),
            o.indexed = !0,
            o.name = "") : Ky(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
            break;
        case "[":
            o.state.allowArray || r(a),
            o.type += l,
            o.state.allowArray = !1,
            o.state.allowName = !1,
            o.state.readArray = !0;
            break;
        case "]":
            o.state.readArray || r(a),
            o.type += l,
            o.state.readArray = !1,
            o.state.allowArray = !0,
            o.state.allowName = !0;
            break;
        default:
            o.state.allowType ? (o.type += l,
            o.state.allowParams = !0,
            o.state.allowArray = !0) : o.state.allowName ? (o.name += l,
            delete o.state.allowArray) : o.state.readArray ? o.type += l : r(a)
        }
    }
    return o.parent && zt.throwArgumentError("unexpected eof", "param", n),
    delete s.state,
    o.name === "indexed" ? (e || r(t.length - 7),
    o.indexed && r(t.length - 7),
    o.indexed = !0,
    o.name = "") : Ky(o.type, o.name) && (o.name = ""),
    s.type = ph(s.type),
    s
}
function Hw(n, e) {
    for (let t in e)
        Ue(n, t, e[t])
}
const Zt = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
})
  , o4e = new RegExp(/^(.*)\[([0-9]*)\]$/);
class Vr {
    constructor(e, t) {
        e !== zu && zt.throwError("use fromString", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
        }),
        Hw(this, t);
        let r = this.type.match(o4e);
        r ? Hw(this, {
            arrayLength: parseInt(r[2] || "-1"),
            arrayChildren: Vr.fromObject({
                type: r[1],
                components: this.components
            }),
            baseType: "array"
        }) : Hw(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
        }),
        this._isParamType = !0,
        Object.freeze(this)
    }
    format(e) {
        if (e || (e = Zt.sighash),
        Zt[e] || zt.throwArgumentError("invalid format type", "format", e),
        e === Zt.json) {
            let r = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || void 0
            };
            return typeof this.indexed == "boolean" && (r.indexed = this.indexed),
            this.components && (r.components = this.components.map(i => JSON.parse(i.format(e)))),
            JSON.stringify(r)
        }
        let t = "";
        return this.baseType === "array" ? (t += this.arrayChildren.format(e),
        t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== Zt.sighash && (t += this.type),
        t += "(" + this.components.map(r => r.format(e)).join(e === Zt.full ? ", " : ",") + ")") : t += this.type,
        e !== Zt.sighash && (this.indexed === !0 && (t += " indexed"),
        e === Zt.full && this.name && (t += " " + this.name)),
        t
    }
    static from(e, t) {
        return typeof e == "string" ? Vr.fromString(e, t) : Vr.fromObject(e)
    }
    static fromObject(e) {
        return Vr.isParamType(e) ? e : new Vr(zu,{
            name: e.name || null,
            type: ph(e.type),
            indexed: e.indexed == null ? null : !!e.indexed,
            components: e.components ? e.components.map(Vr.fromObject) : null
        })
    }
    static fromString(e, t) {
        function r(i) {
            return Vr.fromObject({
                name: i.name,
                type: i.type,
                indexed: i.indexed,
                components: i.components
            })
        }
        return r(s4e(e, !!t))
    }
    static isParamType(e) {
        return !!(e != null && e._isParamType)
    }
}
function t0(n, e) {
    return l4e(n).map(t => Vr.fromString(t, e))
}
class Gl {
    constructor(e, t) {
        e !== zu && zt.throwError("use a static from method", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
        }),
        Hw(this, t),
        this._isFragment = !0,
        Object.freeze(this)
    }
    static from(e) {
        return Gl.isFragment(e) ? e : typeof e == "string" ? Gl.fromString(e) : Gl.fromObject(e)
    }
    static fromObject(e) {
        if (Gl.isFragment(e))
            return e;
        switch (e.type) {
        case "function":
            return Oa.fromObject(e);
        case "event":
            return Ol.fromObject(e);
        case "constructor":
            return Na.fromObject(e);
        case "error":
            return Vc.fromObject(e);
        case "fallback":
        case "receive":
            return null
        }
        return zt.throwArgumentError("invalid fragment object", "value", e)
    }
    static fromString(e) {
        return e = e.replace(/\s/g, " "),
        e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "),
        e = e.trim(),
        e.split(" ")[0] === "event" ? Ol.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? Oa.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? Na.fromString(e.trim()) : e.split(" ")[0] === "error" ? Vc.fromString(e.substring(5).trim()) : zt.throwArgumentError("unsupported fragment", "value", e)
    }
    static isFragment(e) {
        return !!(e && e._isFragment)
    }
}
class Ol extends Gl {
    format(e) {
        if (e || (e = Zt.sighash),
        Zt[e] || zt.throwArgumentError("invalid format type", "format", e),
        e === Zt.json)
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        let t = "";
        return e !== Zt.sighash && (t += "event "),
        t += this.name + "(" + this.inputs.map(r => r.format(e)).join(e === Zt.full ? ", " : ",") + ") ",
        e !== Zt.sighash && this.anonymous && (t += "anonymous "),
        t.trim()
    }
    static from(e) {
        return typeof e == "string" ? Ol.fromString(e) : Ol.fromObject(e)
    }
    static fromObject(e) {
        if (Ol.isEventFragment(e))
            return e;
        e.type !== "event" && zt.throwArgumentError("invalid event object", "value", e);
        const t = {
            name: n0(e.name),
            anonymous: e.anonymous,
            inputs: e.inputs ? e.inputs.map(Vr.fromObject) : [],
            type: "event"
        };
        return new Ol(zu,t)
    }
    static fromString(e) {
        let t = e.match(r0);
        t || zt.throwArgumentError("invalid event string", "value", e);
        let r = !1;
        return t[3].split(" ").forEach(i => {
            switch (i.trim()) {
            case "anonymous":
                r = !0;
                break;
            case "":
                break;
            default:
                zt.warn("unknown modifier: " + i)
            }
        }
        ),
        Ol.fromObject({
            name: t[1].trim(),
            anonymous: r,
            inputs: t0(t[2], !0),
            type: "event"
        })
    }
    static isEventFragment(e) {
        return e && e._isFragment && e.type === "event"
    }
}
function zj(n, e) {
    e.gas = null;
    let t = n.split("@");
    return t.length !== 1 ? (t.length > 2 && zt.throwArgumentError("invalid human-readable ABI signature", "value", n),
    t[1].match(/^[0-9]+$/) || zt.throwArgumentError("invalid human-readable ABI signature gas", "value", n),
    e.gas = je.from(t[1]),
    t[0]) : n
}
function Gj(n, e) {
    e.constant = !1,
    e.payable = !1,
    e.stateMutability = "nonpayable",
    n.split(" ").forEach(t => {
        switch (t.trim()) {
        case "constant":
            e.constant = !0;
            break;
        case "payable":
            e.payable = !0,
            e.stateMutability = "payable";
            break;
        case "nonpayable":
            e.payable = !1,
            e.stateMutability = "nonpayable";
            break;
        case "pure":
            e.constant = !0,
            e.stateMutability = "pure";
            break;
        case "view":
            e.constant = !0,
            e.stateMutability = "view";
            break;
        case "external":
        case "public":
        case "":
            break;
        default:
            console.log("unknown modifier: " + t)
        }
    }
    )
}
function Vj(n) {
    let e = {
        constant: !1,
        payable: !0,
        stateMutability: "payable"
    };
    return n.stateMutability != null ? (e.stateMutability = n.stateMutability,
    e.constant = e.stateMutability === "view" || e.stateMutability === "pure",
    n.constant != null && !!n.constant !== e.constant && zt.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", n),
    e.payable = e.stateMutability === "payable",
    n.payable != null && !!n.payable !== e.payable && zt.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", n)) : n.payable != null ? (e.payable = !!n.payable,
    n.constant == null && !e.payable && n.type !== "constructor" && zt.throwArgumentError("unable to determine stateMutability", "value", n),
    e.constant = !!n.constant,
    e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable",
    e.payable && e.constant && zt.throwArgumentError("cannot have constant payable function", "value", n)) : n.constant != null ? (e.constant = !!n.constant,
    e.payable = !e.constant,
    e.stateMutability = e.constant ? "view" : "payable") : n.type !== "constructor" && zt.throwArgumentError("unable to determine stateMutability", "value", n),
    e
}
class Na extends Gl {
    format(e) {
        if (e || (e = Zt.sighash),
        Zt[e] || zt.throwArgumentError("invalid format type", "format", e),
        e === Zt.json)
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        e === Zt.sighash && zt.throwError("cannot format a constructor for sighash", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
        });
        let t = "constructor(" + this.inputs.map(r => r.format(e)).join(e === Zt.full ? ", " : ",") + ") ";
        return this.stateMutability && this.stateMutability !== "nonpayable" && (t += this.stateMutability + " "),
        t.trim()
    }
    static from(e) {
        return typeof e == "string" ? Na.fromString(e) : Na.fromObject(e)
    }
    static fromObject(e) {
        if (Na.isConstructorFragment(e))
            return e;
        e.type !== "constructor" && zt.throwArgumentError("invalid constructor object", "value", e);
        let t = Vj(e);
        t.constant && zt.throwArgumentError("constructor cannot be constant", "value", e);
        const r = {
            name: null,
            type: e.type,
            inputs: e.inputs ? e.inputs.map(Vr.fromObject) : [],
            payable: t.payable,
            stateMutability: t.stateMutability,
            gas: e.gas ? je.from(e.gas) : null
        };
        return new Na(zu,r)
    }
    static fromString(e) {
        let t = {
            type: "constructor"
        };
        e = zj(e, t);
        let r = e.match(r0);
        return (!r || r[1].trim() !== "constructor") && zt.throwArgumentError("invalid constructor string", "value", e),
        t.inputs = t0(r[2].trim(), !1),
        Gj(r[3].trim(), t),
        Na.fromObject(t)
    }
    static isConstructorFragment(e) {
        return e && e._isFragment && e.type === "constructor"
    }
}
class Oa extends Na {
    format(e) {
        if (e || (e = Zt.sighash),
        Zt[e] || zt.throwArgumentError("invalid format type", "format", e),
        e === Zt.json)
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map(r => JSON.parse(r.format(e))),
                outputs: this.outputs.map(r => JSON.parse(r.format(e)))
            });
        let t = "";
        return e !== Zt.sighash && (t += "function "),
        t += this.name + "(" + this.inputs.map(r => r.format(e)).join(e === Zt.full ? ", " : ",") + ") ",
        e !== Zt.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (t += this.stateMutability + " ") : this.constant && (t += "view "),
        this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map(r => r.format(e)).join(", ") + ") "),
        this.gas != null && (t += "@" + this.gas.toString() + " ")),
        t.trim()
    }
    static from(e) {
        return typeof e == "string" ? Oa.fromString(e) : Oa.fromObject(e)
    }
    static fromObject(e) {
        if (Oa.isFunctionFragment(e))
            return e;
        e.type !== "function" && zt.throwArgumentError("invalid function object", "value", e);
        let t = Vj(e);
        const r = {
            type: e.type,
            name: n0(e.name),
            constant: t.constant,
            inputs: e.inputs ? e.inputs.map(Vr.fromObject) : [],
            outputs: e.outputs ? e.outputs.map(Vr.fromObject) : [],
            payable: t.payable,
            stateMutability: t.stateMutability,
            gas: e.gas ? je.from(e.gas) : null
        };
        return new Oa(zu,r)
    }
    static fromString(e) {
        let t = {
            type: "function"
        };
        e = zj(e, t);
        let r = e.split(" returns ");
        r.length > 2 && zt.throwArgumentError("invalid function string", "value", e);
        let i = r[0].match(r0);
        if (i || zt.throwArgumentError("invalid function signature", "value", e),
        t.name = i[1].trim(),
        t.name && n0(t.name),
        t.inputs = t0(i[2], !1),
        Gj(i[3].trim(), t),
        r.length > 1) {
            let s = r[1].match(r0);
            (s[1].trim() != "" || s[3].trim() != "") && zt.throwArgumentError("unexpected tokens", "value", e),
            t.outputs = t0(s[2], !1)
        } else
            t.outputs = [];
        return Oa.fromObject(t)
    }
    static isFunctionFragment(e) {
        return e && e._isFragment && e.type === "function"
    }
}
function g4(n) {
    const e = n.format();
    return (e === "Error(string)" || e === "Panic(uint256)") && zt.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", n),
    n
}
class Vc extends Gl {
    format(e) {
        if (e || (e = Zt.sighash),
        Zt[e] || zt.throwArgumentError("invalid format type", "format", e),
        e === Zt.json)
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map(r => JSON.parse(r.format(e)))
            });
        let t = "";
        return e !== Zt.sighash && (t += "error "),
        t += this.name + "(" + this.inputs.map(r => r.format(e)).join(e === Zt.full ? ", " : ",") + ") ",
        t.trim()
    }
    static from(e) {
        return typeof e == "string" ? Vc.fromString(e) : Vc.fromObject(e)
    }
    static fromObject(e) {
        if (Vc.isErrorFragment(e))
            return e;
        e.type !== "error" && zt.throwArgumentError("invalid error object", "value", e);
        const t = {
            type: e.type,
            name: n0(e.name),
            inputs: e.inputs ? e.inputs.map(Vr.fromObject) : []
        };
        return g4(new Vc(zu,t))
    }
    static fromString(e) {
        let t = {
            type: "error"
        }
          , r = e.match(r0);
        return r || zt.throwArgumentError("invalid error signature", "value", e),
        t.name = r[1].trim(),
        t.name && n0(t.name),
        t.inputs = t0(r[2], !1),
        g4(Vc.fromObject(t))
    }
    static isErrorFragment(e) {
        return e && e._isFragment && e.type === "error"
    }
}
function ph(n) {
    return n.match(/^uint($|[^1-9])/) ? n = "uint256" + n.substring(4) : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)),
    n
}
const a4e = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function n0(n) {
    return (!n || !n.match(a4e)) && zt.throwArgumentError(`invalid identifier "${n}"`, "value", n),
    n
}
const r0 = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function l4e(n) {
    n = n.trim();
    let e = []
      , t = ""
      , r = 0;
    for (let i = 0; i < n.length; i++) {
        let s = n[i];
        s === "," && r === 0 ? (e.push(t),
        t = "") : (t += s,
        s === "(" ? r++ : s === ")" && (r--,
        r === -1 && zt.throwArgumentError("unbalanced parenthesis", "value", n)))
    }
    return t && e.push(t),
    e
}
const hU = new xe(N0);
function c4e(n) {
    const e = []
      , t = function(r, i) {
        if (Array.isArray(i))
            for (let s in i) {
                const o = r.slice();
                o.push(s);
                try {
                    t(o, i[s])
                } catch (a) {
                    e.push({
                        path: o,
                        error: a
                    })
                }
            }
    };
    return t([], n),
    e
}
class dc {
    constructor(e, t, r, i) {
        this.name = e,
        this.type = t,
        this.localName = r,
        this.dynamic = i
    }
    _throwError(e, t) {
        hU.throwArgumentError(e, this.localName, t)
    }
}
class KT {
    constructor(e) {
        Ue(this, "wordSize", e || 32),
        this._data = [],
        this._dataLength = 0,
        this._padding = new Uint8Array(e)
    }
    get data() {
        return $i(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(e) {
        return this._data.push(e),
        this._dataLength += e.length,
        e.length
    }
    appendWriter(e) {
        return this._writeData(Ss(e._data))
    }
    writeBytes(e) {
        let t = pt(e);
        const r = t.length % this.wordSize;
        return r && (t = Ss([t, this._padding.slice(r)])),
        this._writeData(t)
    }
    _getValue(e) {
        let t = pt(je.from(e));
        return t.length > this.wordSize && hU.throwError("value out-of-bounds", xe.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: t.length
        }),
        t.length % this.wordSize && (t = Ss([this._padding.slice(t.length % this.wordSize), t])),
        t
    }
    writeValue(e) {
        return this._writeData(this._getValue(e))
    }
    writeUpdatableValue() {
        const e = this._data.length;
        return this._data.push(this._padding),
        this._dataLength += this.wordSize,
        t => {
            this._data[e] = this._getValue(t)
        }
    }
}
class Ex {
    constructor(e, t, r, i) {
        Ue(this, "_data", pt(e)),
        Ue(this, "wordSize", t || 32),
        Ue(this, "_coerceFunc", r),
        Ue(this, "allowLoose", i),
        this._offset = 0
    }
    get data() {
        return lt(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(e, t) {
        let r = e.match("^u?int([0-9]+)$");
        return r && parseInt(r[1]) <= 48 && (t = t.toNumber()),
        t
    }
    coerce(e, t) {
        return this._coerceFunc ? this._coerceFunc(e, t) : Ex.coerce(e, t)
    }
    _peekBytes(e, t, r) {
        let i = Math.ceil(t / this.wordSize) * this.wordSize;
        return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + t <= this._data.length ? i = t : hU.throwError("data out-of-bounds", xe.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + i
        })),
        this._data.slice(this._offset, this._offset + i)
    }
    subReader(e) {
        return new Ex(this._data.slice(this._offset + e),this.wordSize,this._coerceFunc,this.allowLoose)
    }
    readBytes(e, t) {
        let r = this._peekBytes(0, e, !!t);
        return this._offset += r.length,
        r.slice(0, e)
    }
    readValue() {
        return je.from(this.readBytes(this.wordSize))
    }
}
class A4e extends dc {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, t) {
        try {
            t = ai(t)
        } catch (r) {
            this._throwError(r.message, t)
        }
        return e.writeValue(t)
    }
    decode(e) {
        return ai(ir(e.readValue().toHexString(), 20))
    }
}
class u4e extends dc {
    constructor(e) {
        super(e.name, e.type, void 0, e.dynamic),
        this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, t) {
        return this.coder.encode(e, t)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
const jh = new xe(N0);
function jj(n, e, t) {
    let r = null;
    if (Array.isArray(t))
        r = t;
    else if (t && typeof t == "object") {
        let l = {};
        r = e.map(c => {
            const A = c.localName;
            return A || jh.throwError("cannot encode object for signature with missing names", xe.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: c,
                value: t
            }),
            l[A] && jh.throwError("cannot encode object for signature with duplicate names", xe.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: c,
                value: t
            }),
            l[A] = !0,
            t[A]
        }
        )
    } else
        jh.throwArgumentError("invalid tuple value", "tuple", t);
    e.length !== r.length && jh.throwArgumentError("types/value length mismatch", "tuple", t);
    let i = new KT(n.wordSize)
      , s = new KT(n.wordSize)
      , o = [];
    e.forEach( (l, c) => {
        let A = r[c];
        if (l.dynamic) {
            let u = s.length;
            l.encode(s, A);
            let f = i.writeUpdatableValue();
            o.push(h => {
                f(h + u)
            }
            )
        } else
            l.encode(i, A)
    }
    ),
    o.forEach(l => {
        l(i.length)
    }
    );
    let a = n.appendWriter(i);
    return a += n.appendWriter(s),
    a
}
function Wj(n, e) {
    let t = []
      , r = n.subReader(0);
    e.forEach(s => {
        let o = null;
        if (s.dynamic) {
            let a = n.readValue()
              , l = r.subReader(a.toNumber());
            try {
                o = s.decode(l)
            } catch (c) {
                if (c.code === xe.errors.BUFFER_OVERRUN)
                    throw c;
                o = c,
                o.baseType = s.name,
                o.name = s.localName,
                o.type = s.type
            }
        } else
            try {
                o = s.decode(n)
            } catch (a) {
                if (a.code === xe.errors.BUFFER_OVERRUN)
                    throw a;
                o = a,
                o.baseType = s.name,
                o.name = s.localName,
                o.type = s.type
            }
        o != null && t.push(o)
    }
    );
    const i = e.reduce( (s, o) => {
        const a = o.localName;
        return a && (s[a] || (s[a] = 0),
        s[a]++),
        s
    }
    , {});
    e.forEach( (s, o) => {
        let a = s.localName;
        if (!a || i[a] !== 1 || (a === "length" && (a = "_length"),
        t[a] != null))
            return;
        const l = t[o];
        l instanceof Error ? Object.defineProperty(t, a, {
            enumerable: !0,
            get: () => {
                throw l
            }
        }) : t[a] = l
    }
    );
    for (let s = 0; s < t.length; s++) {
        const o = t[s];
        o instanceof Error && Object.defineProperty(t, s, {
            enumerable: !0,
            get: () => {
                throw o
            }
        })
    }
    return Object.freeze(t)
}
class f4e extends dc {
    constructor(e, t, r) {
        const i = e.type + "[" + (t >= 0 ? t : "") + "]"
          , s = t === -1 || e.dynamic;
        super("array", i, r, s),
        this.coder = e,
        this.length = t
    }
    defaultValue() {
        const e = this.coder.defaultValue()
          , t = [];
        for (let r = 0; r < this.length; r++)
            t.push(e);
        return t
    }
    encode(e, t) {
        Array.isArray(t) || this._throwError("expected array value", t);
        let r = this.length;
        r === -1 && (r = t.length,
        e.writeValue(t.length)),
        jh.checkArgumentCount(t.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
        let i = [];
        for (let s = 0; s < t.length; s++)
            i.push(this.coder);
        return jj(e, i, t)
    }
    decode(e) {
        let t = this.length;
        t === -1 && (t = e.readValue().toNumber(),
        t * 32 > e._data.length && jh.throwError("insufficient data length", xe.errors.BUFFER_OVERRUN, {
            length: e._data.length,
            count: t
        }));
        let r = [];
        for (let i = 0; i < t; i++)
            r.push(new u4e(this.coder));
        return e.coerce(this.name, Wj(e, r))
    }
}
class h4e extends dc {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, t) {
        return e.writeValue(t ? 1 : 0)
    }
    decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
    }
}
class Kj extends dc {
    constructor(e, t) {
        super(e, e, t, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, t) {
        t = pt(t);
        let r = e.writeValue(t.length);
        return r += e.writeBytes(t),
        r
    }
    decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
    }
}
class d4e extends Kj {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return e.coerce(this.name, lt(super.decode(e)))
    }
}
class p4e extends dc {
    constructor(e, t) {
        let r = "bytes" + String(e);
        super(r, r, t, !1),
        this.size = e
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, t) {
        let r = pt(t);
        return r.length !== this.size && this._throwError("incorrect data length", t),
        e.writeBytes(r)
    }
    decode(e) {
        return e.coerce(this.name, lt(e.readBytes(this.size)))
    }
}
class m4e extends dc {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, t) {
        return t != null && this._throwError("not null", t),
        e.writeBytes([])
    }
    decode(e) {
        return e.readBytes(0),
        e.coerce(this.name, null)
    }
}
class g4e extends dc {
    constructor(e, t, r) {
        const i = (t ? "int" : "uint") + e * 8;
        super(i, i, r, !1),
        this.size = e,
        this.signed = t
    }
    defaultValue() {
        return 0
    }
    encode(e, t) {
        let r = je.from(t)
          , i = E9.mask(e.wordSize * 8);
        if (this.signed) {
            let s = i.mask(this.size * 8 - 1);
            (r.gt(s) || r.lt(s.add(b9).mul(x9))) && this._throwError("value out-of-bounds", t)
        } else
            (r.lt(sQ) || r.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", t);
        return r = r.toTwos(this.size * 8).mask(this.size * 8),
        this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)),
        e.writeValue(r)
    }
    decode(e) {
        let t = e.readValue().mask(this.size * 8);
        return this.signed && (t = t.fromTwos(this.size * 8)),
        e.coerce(this.name, t)
    }
}
class v4e extends Kj {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, t) {
        return super.encode(e, $a(t))
    }
    decode(e) {
        return c0(super.decode(e))
    }
}
class Xy extends dc {
    constructor(e, t) {
        let r = !1;
        const i = [];
        e.forEach(o => {
            o.dynamic && (r = !0),
            i.push(o.type)
        }
        );
        const s = "tuple(" + i.join(",") + ")";
        super("tuple", s, t, r),
        this.coders = e
    }
    defaultValue() {
        const e = [];
        this.coders.forEach(r => {
            e.push(r.defaultValue())
        }
        );
        const t = this.coders.reduce( (r, i) => {
            const s = i.localName;
            return s && (r[s] || (r[s] = 0),
            r[s]++),
            r
        }
        , {});
        return this.coders.forEach( (r, i) => {
            let s = r.localName;
            !s || t[s] !== 1 || (s === "length" && (s = "_length"),
            e[s] == null && (e[s] = e[i]))
        }
        ),
        Object.freeze(e)
    }
    encode(e, t) {
        return jj(e, this.coders, t)
    }
    decode(e) {
        return e.coerce(this.name, Wj(e, this.coders))
    }
}
const Yy = new xe(N0)
  , y4e = new RegExp(/^bytes([0-9]*)$/)
  , w4e = new RegExp(/^(u?int)([0-9]*)$/);
class _4e {
    constructor(e) {
        Ue(this, "coerceFunc", e || null)
    }
    _getCoder(e) {
        switch (e.baseType) {
        case "address":
            return new A4e(e.name);
        case "bool":
            return new h4e(e.name);
        case "string":
            return new v4e(e.name);
        case "bytes":
            return new d4e(e.name);
        case "array":
            return new f4e(this._getCoder(e.arrayChildren),e.arrayLength,e.name);
        case "tuple":
            return new Xy((e.components || []).map(r => this._getCoder(r)),e.name);
        case "":
            return new m4e(e.name)
        }
        let t = e.type.match(w4e);
        if (t) {
            let r = parseInt(t[2] || "256");
            return (r === 0 || r > 256 || r % 8 !== 0) && Yy.throwArgumentError("invalid " + t[1] + " bit length", "param", e),
            new g4e(r / 8,t[1] === "int",e.name)
        }
        if (t = e.type.match(y4e),
        t) {
            let r = parseInt(t[1]);
            return (r === 0 || r > 32) && Yy.throwArgumentError("invalid bytes length", "param", e),
            new p4e(r,e.name)
        }
        return Yy.throwArgumentError("invalid type", "type", e.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(e, t) {
        return new Ex(e,this._getWordSize(),this.coerceFunc,t)
    }
    _getWriter() {
        return new KT(this._getWordSize())
    }
    getDefaultValue(e) {
        const t = e.map(i => this._getCoder(Vr.from(i)));
        return new Xy(t,"_").defaultValue()
    }
    encode(e, t) {
        e.length !== t.length && Yy.throwError("types/values length mismatch", xe.errors.INVALID_ARGUMENT, {
            count: {
                types: e.length,
                values: t.length
            },
            value: {
                types: e,
                values: t
            }
        });
        const r = e.map(o => this._getCoder(Vr.from(o)))
          , i = new Xy(r,"_")
          , s = this._getWriter();
        return i.encode(s, t),
        s.data
    }
    decode(e, t, r) {
        const i = e.map(o => this._getCoder(Vr.from(o)));
        return new Xy(i,"_").decode(this._getReader(pt(t), r))
    }
}
const x4e = new _4e
  , zn = new xe(N0);
class b4e extends a0 {
}
class E4e extends a0 {
}
class B4e extends a0 {
}
class XT extends a0 {
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const M4e = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: !0
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"]
    }
};
function v4(n, e) {
    const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
    return t.error = e,
    t
}
class y4 {
    constructor(e) {
        let t = [];
        typeof e == "string" ? t = JSON.parse(e) : t = e,
        Ue(this, "fragments", t.map(r => Gl.from(r)).filter(r => r != null)),
        Ue(this, "_abiCoder", Cs(new.target, "getAbiCoder")()),
        Ue(this, "functions", {}),
        Ue(this, "errors", {}),
        Ue(this, "events", {}),
        Ue(this, "structs", {}),
        this.fragments.forEach(r => {
            let i = null;
            switch (r.type) {
            case "constructor":
                if (this.deploy) {
                    zn.warn("duplicate definition - constructor");
                    return
                }
                Ue(this, "deploy", r);
                return;
            case "function":
                i = this.functions;
                break;
            case "event":
                i = this.events;
                break;
            case "error":
                i = this.errors;
                break;
            default:
                return
            }
            let s = r.format();
            if (i[s]) {
                zn.warn("duplicate definition - " + s);
                return
            }
            i[s] = r
        }
        ),
        this.deploy || Ue(this, "deploy", Na.from({
            payable: !1,
            type: "constructor"
        })),
        Ue(this, "_isInterface", !0)
    }
    format(e) {
        e || (e = Zt.full),
        e === Zt.sighash && zn.throwArgumentError("interface does not support formatting sighash", "format", e);
        const t = this.fragments.map(r => r.format(e));
        return e === Zt.json ? JSON.stringify(t.map(r => JSON.parse(r))) : t
    }
    static getAbiCoder() {
        return x4e
    }
    static getAddress(e) {
        return ai(e)
    }
    static getSighash(e) {
        return mi(mh(e.format()), 0, 4)
    }
    static getEventTopic(e) {
        return mh(e.format())
    }
    getFunction(e) {
        if (It(e)) {
            for (const r in this.functions)
                if (e === this.getSighash(r))
                    return this.functions[r];
            zn.throwArgumentError("no matching function", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const r = e.trim()
              , i = Object.keys(this.functions).filter(s => s.split("(")[0] === r);
            return i.length === 0 ? zn.throwArgumentError("no matching function", "name", r) : i.length > 1 && zn.throwArgumentError("multiple matching functions", "name", r),
            this.functions[i[0]]
        }
        const t = this.functions[Oa.fromString(e).format()];
        return t || zn.throwArgumentError("no matching function", "signature", e),
        t
    }
    getEvent(e) {
        if (It(e)) {
            const r = e.toLowerCase();
            for (const i in this.events)
                if (r === this.getEventTopic(i))
                    return this.events[i];
            zn.throwArgumentError("no matching event", "topichash", r)
        }
        if (e.indexOf("(") === -1) {
            const r = e.trim()
              , i = Object.keys(this.events).filter(s => s.split("(")[0] === r);
            return i.length === 0 ? zn.throwArgumentError("no matching event", "name", r) : i.length > 1 && zn.throwArgumentError("multiple matching events", "name", r),
            this.events[i[0]]
        }
        const t = this.events[Ol.fromString(e).format()];
        return t || zn.throwArgumentError("no matching event", "signature", e),
        t
    }
    getError(e) {
        if (It(e)) {
            const r = Cs(this.constructor, "getSighash");
            for (const i in this.errors) {
                const s = this.errors[i];
                if (e === r(s))
                    return this.errors[i]
            }
            zn.throwArgumentError("no matching error", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const r = e.trim()
              , i = Object.keys(this.errors).filter(s => s.split("(")[0] === r);
            return i.length === 0 ? zn.throwArgumentError("no matching error", "name", r) : i.length > 1 && zn.throwArgumentError("multiple matching errors", "name", r),
            this.errors[i[0]]
        }
        const t = this.errors[Oa.fromString(e).format()];
        return t || zn.throwArgumentError("no matching error", "signature", e),
        t
    }
    getSighash(e) {
        if (typeof e == "string")
            try {
                e = this.getFunction(e)
            } catch (t) {
                try {
                    e = this.getError(e)
                } catch {
                    throw t
                }
            }
        return Cs(this.constructor, "getSighash")(e)
    }
    getEventTopic(e) {
        return typeof e == "string" && (e = this.getEvent(e)),
        Cs(this.constructor, "getEventTopic")(e)
    }
    _decodeParams(e, t) {
        return this._abiCoder.decode(e, t)
    }
    _encodeParams(e, t) {
        return this._abiCoder.encode(e, t)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, t) {
        typeof e == "string" && (e = this.getError(e));
        const r = pt(t);
        return lt(r.slice(0, 4)) !== this.getSighash(e) && zn.throwArgumentError(`data signature does not match error ${e.name}.`, "data", lt(r)),
        this._decodeParams(e.inputs, r.slice(4))
    }
    encodeErrorResult(e, t) {
        return typeof e == "string" && (e = this.getError(e)),
        lt(Ss([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
    }
    decodeFunctionData(e, t) {
        typeof e == "string" && (e = this.getFunction(e));
        const r = pt(t);
        return lt(r.slice(0, 4)) !== this.getSighash(e) && zn.throwArgumentError(`data signature does not match function ${e.name}.`, "data", lt(r)),
        this._decodeParams(e.inputs, r.slice(4))
    }
    encodeFunctionData(e, t) {
        return typeof e == "string" && (e = this.getFunction(e)),
        lt(Ss([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
    }
    decodeFunctionResult(e, t) {
        typeof e == "string" && (e = this.getFunction(e));
        let r = pt(t)
          , i = null
          , s = ""
          , o = null
          , a = null
          , l = null;
        switch (r.length % this._abiCoder._getWordSize()) {
        case 0:
            try {
                return this._abiCoder.decode(e.outputs, r)
            } catch {}
            break;
        case 4:
            {
                const c = lt(r.slice(0, 4))
                  , A = M4e[c];
                if (A)
                    o = this._abiCoder.decode(A.inputs, r.slice(4)),
                    a = A.name,
                    l = A.signature,
                    A.reason && (i = o[0]),
                    a === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : a === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
                else
                    try {
                        const u = this.getError(c);
                        o = this._abiCoder.decode(u.inputs, r.slice(4)),
                        a = u.name,
                        l = u.format()
                    } catch {}
                break
            }
        }
        return zn.throwError("call revert exception" + s, xe.errors.CALL_EXCEPTION, {
            method: e.format(),
            data: lt(t),
            errorArgs: o,
            errorName: a,
            errorSignature: l,
            reason: i
        })
    }
    encodeFunctionResult(e, t) {
        return typeof e == "string" && (e = this.getFunction(e)),
        lt(this._abiCoder.encode(e.outputs, t || []))
    }
    encodeFilterTopics(e, t) {
        typeof e == "string" && (e = this.getEvent(e)),
        t.length > e.inputs.length && zn.throwError("too many arguments for " + e.format(), xe.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: t
        });
        let r = [];
        e.anonymous || r.push(this.getEventTopic(e));
        const i = (s, o) => s.type === "string" ? mh(o) : s.type === "bytes" ? Er(lt(o)) : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"),
        s.type.match(/^u?int/) && (o = je.from(o).toHexString()),
        s.type === "address" && this._abiCoder.encode(["address"], [o]),
        ir(lt(o), 32));
        for (t.forEach( (s, o) => {
            let a = e.inputs[o];
            if (!a.indexed) {
                s != null && zn.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
                return
            }
            s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? zn.throwArgumentError("filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map(l => i(a, l))) : r.push(i(a, s))
        }
        ); r.length && r[r.length - 1] === null; )
            r.pop();
        return r
    }
    encodeEventLog(e, t) {
        typeof e == "string" && (e = this.getEvent(e));
        const r = []
          , i = []
          , s = [];
        return e.anonymous || r.push(this.getEventTopic(e)),
        t.length !== e.inputs.length && zn.throwArgumentError("event arguments/values mismatch", "values", t),
        e.inputs.forEach( (o, a) => {
            const l = t[a];
            if (o.indexed)
                if (o.type === "string")
                    r.push(mh(l));
                else if (o.type === "bytes")
                    r.push(Er(l));
                else {
                    if (o.baseType === "tuple" || o.baseType === "array")
                        throw new Error("not implemented");
                    r.push(this._abiCoder.encode([o.type], [l]))
                }
            else
                i.push(o),
                s.push(l)
        }
        ),
        {
            data: this._abiCoder.encode(i, s),
            topics: r
        }
    }
    decodeEventLog(e, t, r) {
        if (typeof e == "string" && (e = this.getEvent(e)),
        r != null && !e.anonymous) {
            let f = this.getEventTopic(e);
            (!It(r[0], 32) || r[0].toLowerCase() !== f) && zn.throwError("fragment/topic mismatch", xe.errors.INVALID_ARGUMENT, {
                argument: "topics[0]",
                expected: f,
                value: r[0]
            }),
            r = r.slice(1)
        }
        let i = []
          , s = []
          , o = [];
        e.inputs.forEach( (f, h) => {
            f.indexed ? f.type === "string" || f.type === "bytes" || f.baseType === "tuple" || f.baseType === "array" ? (i.push(Vr.fromObject({
                type: "bytes32",
                name: f.name
            })),
            o.push(!0)) : (i.push(f),
            o.push(!1)) : (s.push(f),
            o.push(!1))
        }
        );
        let a = r != null ? this._abiCoder.decode(i, Ss(r)) : null
          , l = this._abiCoder.decode(s, t, !0)
          , c = []
          , A = 0
          , u = 0;
        e.inputs.forEach( (f, h) => {
            if (f.indexed)
                if (a == null)
                    c[h] = new XT({
                        _isIndexed: !0,
                        hash: null
                    });
                else if (o[h])
                    c[h] = new XT({
                        _isIndexed: !0,
                        hash: a[u++]
                    });
                else
                    try {
                        c[h] = a[u++]
                    } catch (d) {
                        c[h] = d
                    }
            else
                try {
                    c[h] = l[A++]
                } catch (d) {
                    c[h] = d
                }
            if (f.name && c[f.name] == null) {
                const d = c[h];
                d instanceof Error ? Object.defineProperty(c, f.name, {
                    enumerable: !0,
                    get: () => {
                        throw v4(`property ${JSON.stringify(f.name)}`, d)
                    }
                }) : c[f.name] = d
            }
        }
        );
        for (let f = 0; f < c.length; f++) {
            const h = c[f];
            h instanceof Error && Object.defineProperty(c, f, {
                enumerable: !0,
                get: () => {
                    throw v4(`index ${f}`, h)
                }
            })
        }
        return Object.freeze(c)
    }
    parseTransaction(e) {
        let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
        return t ? new E4e({
            args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
            functionFragment: t,
            name: t.name,
            signature: t.format(),
            sighash: this.getSighash(t),
            value: je.from(e.value || "0")
        }) : null
    }
    parseLog(e) {
        let t = this.getEvent(e.topics[0]);
        return !t || t.anonymous ? null : new b4e({
            eventFragment: t,
            name: t.name,
            signature: t.format(),
            topic: this.getEventTopic(t),
            args: this.decodeEventLog(t, e.data, e.topics)
        })
    }
    parseError(e) {
        const t = lt(e);
        let r = this.getError(t.substring(0, 10).toLowerCase());
        return r ? new B4e({
            args: this._abiCoder.decode(r.inputs, "0x" + t.substring(10)),
            errorFragment: r,
            name: r.name,
            signature: r.format(),
            sighash: this.getSighash(r)
        }) : null
    }
    static isInterface(e) {
        return !!(e && e._isInterface)
    }
}
const S4e = "contracts/5.7.0";
var Gu = globalThis && globalThis.__awaiter || function(n, e, t, r) {
    function i(s) {
        return s instanceof t ? s : new t(function(o) {
            o(s)
        }
        )
    }
    return new (t || (t = Promise))(function(s, o) {
        function a(A) {
            try {
                c(r.next(A))
            } catch (u) {
                o(u)
            }
        }
        function l(A) {
            try {
                c(r.throw(A))
            } catch (u) {
                o(u)
            }
        }
        function c(A) {
            A.done ? s(A.value) : i(A.value).then(a, l)
        }
        c((r = r.apply(n, e || [])).next())
    }
    )
}
;
const fr = new xe(S4e);
function Bx(n, e) {
    return Gu(this, void 0, void 0, function*() {
        const t = yield e;
        typeof t != "string" && fr.throwArgumentError("invalid address or ENS name", "name", t);
        try {
            return ai(t)
        } catch {}
        n || fr.throwError("a provider or signer is needed to resolve ENS names", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName"
        });
        const r = yield n.resolveName(t);
        return r == null && fr.throwArgumentError("resolver or addr is not configured for ENS name", "name", t),
        r
    })
}
function zw(n, e, t) {
    return Gu(this, void 0, void 0, function*() {
        return Array.isArray(t) ? yield Promise.all(t.map( (r, i) => zw(n, Array.isArray(e) ? e[i] : e[r.name], r))) : t.type === "address" ? yield Bx(n, e) : t.type === "tuple" ? yield zw(n, e, t.components) : t.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map(r => zw(n, r, t.arrayChildren))) : Promise.reject(fr.makeError("invalid value for array", xe.errors.INVALID_ARGUMENT, {
            argument: "value",
            value: e
        })) : e
    })
}
function rb(n, e, t) {
    return Gu(this, void 0, void 0, function*() {
        let r = {};
        t.length === e.inputs.length + 1 && typeof t[t.length - 1] == "object" && (r = Qn(t.pop())),
        fr.checkArgumentCount(t.length, e.inputs.length, "passed to contract"),
        n.signer ? r.from ? r.from = wr({
            override: Bx(n.signer, r.from),
            signer: n.signer.getAddress()
        }).then(c => Gu(this, void 0, void 0, function*() {
            return ai(c.signer) !== c.override && fr.throwError("Contract with a Signer cannot override from", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
            }),
            c.override
        })) : r.from = n.signer.getAddress() : r.from && (r.from = Bx(n.provider, r.from));
        const i = yield wr({
            args: zw(n.signer || n.provider, t, e.inputs),
            address: n.resolvedAddress,
            overrides: wr(r) || {}
        })
          , s = n.interface.encodeFunctionData(e, i.args)
          , o = {
            data: s,
            to: i.address
        }
          , a = i.overrides;
        if (a.nonce != null && (o.nonce = je.from(a.nonce).toNumber()),
        a.gasLimit != null && (o.gasLimit = je.from(a.gasLimit)),
        a.gasPrice != null && (o.gasPrice = je.from(a.gasPrice)),
        a.maxFeePerGas != null && (o.maxFeePerGas = je.from(a.maxFeePerGas)),
        a.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = je.from(a.maxPriorityFeePerGas)),
        a.from != null && (o.from = a.from),
        a.type != null && (o.type = a.type),
        a.accessList != null && (o.accessList = Wu(a.accessList)),
        o.gasLimit == null && e.gas != null) {
            let c = 21e3;
            const A = pt(s);
            for (let u = 0; u < A.length; u++)
                c += 4,
                A[u] && (c += 64);
            o.gasLimit = je.from(e.gas).add(c)
        }
        if (a.value) {
            const c = je.from(a.value);
            !c.isZero() && !e.payable && fr.throwError("non-payable method cannot override value", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: r.value
            }),
            o.value = c
        }
        a.customData && (o.customData = Qn(a.customData)),
        a.ccipReadEnabled && (o.ccipReadEnabled = !!a.ccipReadEnabled),
        delete r.nonce,
        delete r.gasLimit,
        delete r.gasPrice,
        delete r.from,
        delete r.value,
        delete r.type,
        delete r.accessList,
        delete r.maxFeePerGas,
        delete r.maxPriorityFeePerGas,
        delete r.customData,
        delete r.ccipReadEnabled;
        const l = Object.keys(r).filter(c => r[c] != null);
        return l.length && fr.throwError(`cannot override ${l.map(c => JSON.stringify(c)).join(",")}`, xe.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides",
            overrides: l
        }),
        o
    })
}
function C4e(n, e) {
    return function(...t) {
        return rb(n, e, t)
    }
}
function T4e(n, e) {
    const t = n.signer || n.provider;
    return function(...r) {
        return Gu(this, void 0, void 0, function*() {
            t || fr.throwError("estimate require a provider or signer", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "estimateGas"
            });
            const i = yield rb(n, e, r);
            return yield t.estimateGas(i)
        })
    }
}
function I4e(n, e) {
    const t = e.wait.bind(e);
    e.wait = r => t(r).then(i => (i.events = i.logs.map(s => {
        let o = Ps(s)
          , a = null;
        try {
            a = n.interface.parseLog(s)
        } catch {}
        return a && (o.args = a.args,
        o.decode = (l, c) => n.interface.decodeEventLog(a.eventFragment, l, c),
        o.event = a.name,
        o.eventSignature = a.signature),
        o.removeListener = () => n.provider,
        o.getBlock = () => n.provider.getBlock(i.blockHash),
        o.getTransaction = () => n.provider.getTransaction(i.transactionHash),
        o.getTransactionReceipt = () => Promise.resolve(i),
        o
    }
    ),
    i))
}
function Xj(n, e, t) {
    const r = n.signer || n.provider;
    return function(...i) {
        return Gu(this, void 0, void 0, function*() {
            let s;
            if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
                const l = Qn(i.pop());
                l.blockTag != null && (s = yield l.blockTag),
                delete l.blockTag,
                i.push(l)
            }
            n.deployTransaction != null && (yield n._deployed(s));
            const o = yield rb(n, e, i)
              , a = yield r.call(o, s);
            try {
                let l = n.interface.decodeFunctionResult(e, a);
                return t && e.outputs.length === 1 && (l = l[0]),
                l
            } catch (l) {
                throw l.code === xe.errors.CALL_EXCEPTION && (l.address = n.address,
                l.args = i,
                l.transaction = o),
                l
            }
        })
    }
}
function R4e(n, e) {
    return function(...t) {
        return Gu(this, void 0, void 0, function*() {
            n.signer || fr.throwError("sending a transaction requires a signer", xe.errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction"
            }),
            n.deployTransaction != null && (yield n._deployed());
            const r = yield rb(n, e, t)
              , i = yield n.signer.sendTransaction(r);
            return I4e(n, i),
            i
        })
    }
}
function w4(n, e, t) {
    return e.constant ? Xj(n, e, t) : R4e(n, e)
}
function Yj(n) {
    return n.address && (n.topics == null || n.topics.length === 0) ? "*" : (n.address || "*") + "@" + (n.topics ? n.topics.map(e => Array.isArray(e) ? e.join("|") : e).join(":") : "")
}
class i0 {
    constructor(e, t) {
        Ue(this, "tag", e),
        Ue(this, "filter", t),
        this._listeners = []
    }
    addListener(e, t) {
        this._listeners.push({
            listener: e,
            once: t
        })
    }
    removeListener(e) {
        let t = !1;
        this._listeners = this._listeners.filter(r => t || r.listener !== e ? !0 : (t = !0,
        !1))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map(e => e.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(e) {
        const t = this.listenerCount();
        return this._listeners = this._listeners.filter(r => {
            const i = e.slice();
            return setTimeout( () => {
                r.listener.apply(this, i)
            }
            , 0),
            !r.once
        }
        ),
        t
    }
    prepareEvent(e) {}
    getEmit(e) {
        return [e]
    }
}
class U4e extends i0 {
    constructor() {
        super("error", null)
    }
}
class _4 extends i0 {
    constructor(e, t, r, i) {
        const s = {
            address: e
        };
        let o = t.getEventTopic(r);
        i ? (o !== i[0] && fr.throwArgumentError("topic mismatch", "topics", i),
        s.topics = i.slice()) : s.topics = [o],
        super(Yj(s), s),
        Ue(this, "address", e),
        Ue(this, "interface", t),
        Ue(this, "fragment", r)
    }
    prepareEvent(e) {
        super.prepareEvent(e),
        e.event = this.fragment.name,
        e.eventSignature = this.fragment.format(),
        e.decode = (t, r) => this.interface.decodeEventLog(this.fragment, t, r);
        try {
            e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
        } catch (t) {
            e.args = null,
            e.decodeError = t
        }
    }
    getEmit(e) {
        const t = c4e(e.args);
        if (t.length)
            throw t[0].error;
        const r = (e.args || []).slice();
        return r.push(e),
        r
    }
}
class x4 extends i0 {
    constructor(e, t) {
        super("*", {
            address: e
        }),
        Ue(this, "address", e),
        Ue(this, "interface", t)
    }
    prepareEvent(e) {
        super.prepareEvent(e);
        try {
            const t = this.interface.parseLog(e);
            e.event = t.name,
            e.eventSignature = t.signature,
            e.decode = (r, i) => this.interface.decodeEventLog(t.eventFragment, r, i),
            e.args = t.args
        } catch {}
    }
}
class F4e {
    constructor(e, t, r) {
        Ue(this, "interface", Cs(new.target, "getInterface")(t)),
        r == null ? (Ue(this, "provider", null),
        Ue(this, "signer", null)) : u0.isSigner(r) ? (Ue(this, "provider", r.provider || null),
        Ue(this, "signer", r)) : l0.isProvider(r) ? (Ue(this, "provider", r),
        Ue(this, "signer", null)) : fr.throwArgumentError("invalid signer or provider", "signerOrProvider", r),
        Ue(this, "callStatic", {}),
        Ue(this, "estimateGas", {}),
        Ue(this, "functions", {}),
        Ue(this, "populateTransaction", {}),
        Ue(this, "filters", {});
        {
            const o = {};
            Object.keys(this.interface.events).forEach(a => {
                const l = this.interface.events[a];
                Ue(this.filters, a, (...c) => ({
                    address: this.address,
                    topics: this.interface.encodeFilterTopics(l, c)
                })),
                o[l.name] || (o[l.name] = []),
                o[l.name].push(a)
            }
            ),
            Object.keys(o).forEach(a => {
                const l = o[a];
                l.length === 1 ? Ue(this.filters, a, this.filters[l[0]]) : fr.warn(`Duplicate definition of ${a} (${l.join(", ")})`)
            }
            )
        }
        if (Ue(this, "_runningEvents", {}),
        Ue(this, "_wrappedEmits", {}),
        e == null && fr.throwArgumentError("invalid contract address or ENS name", "addressOrName", e),
        Ue(this, "address", e),
        this.provider)
            Ue(this, "resolvedAddress", Bx(this.provider, e));
        else
            try {
                Ue(this, "resolvedAddress", Promise.resolve(ai(e)))
            } catch {
                fr.throwError("provider is required to use ENS name as contract address", xe.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract"
                })
            }
        this.resolvedAddress.catch(o => {}
        );
        const i = {}
          , s = {};
        Object.keys(this.interface.functions).forEach(o => {
            const a = this.interface.functions[o];
            if (s[o]) {
                fr.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
                return
            }
            s[o] = !0;
            {
                const l = a.name;
                i[`%${l}`] || (i[`%${l}`] = []),
                i[`%${l}`].push(o)
            }
            this[o] == null && Ue(this, o, w4(this, a, !0)),
            this.functions[o] == null && Ue(this.functions, o, w4(this, a, !1)),
            this.callStatic[o] == null && Ue(this.callStatic, o, Xj(this, a, !0)),
            this.populateTransaction[o] == null && Ue(this.populateTransaction, o, C4e(this, a)),
            this.estimateGas[o] == null && Ue(this.estimateGas, o, T4e(this, a))
        }
        ),
        Object.keys(i).forEach(o => {
            const a = i[o];
            if (a.length > 1)
                return;
            o = o.substring(1);
            const l = a[0];
            try {
                this[o] == null && Ue(this, o, this[l])
            } catch {}
            this.functions[o] == null && Ue(this.functions, o, this.functions[l]),
            this.callStatic[o] == null && Ue(this.callStatic, o, this.callStatic[l]),
            this.populateTransaction[o] == null && Ue(this.populateTransaction, o, this.populateTransaction[l]),
            this.estimateGas[o] == null && Ue(this.estimateGas, o, this.estimateGas[l])
        }
        )
    }
    static getContractAddress(e) {
        return yQ(e)
    }
    static getInterface(e) {
        return y4.isInterface(e) ? e : new y4(e)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(e) {
        return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then( () => this) : this._deployedPromise = this.provider.getCode(this.address, e).then(t => (t === "0x" && fr.throwError("contract not deployed", xe.errors.UNSUPPORTED_OPERATION, {
            contractAddress: this.address,
            operation: "getDeployed"
        }),
        this))),
        this._deployedPromise
    }
    fallback(e) {
        this.signer || fr.throwError("sending a transactions require a signer", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction(fallback)"
        });
        const t = Qn(e || {});
        return ["from", "to"].forEach(function(r) {
            t[r] != null && fr.throwError("cannot override " + r, xe.errors.UNSUPPORTED_OPERATION, {
                operation: r
            })
        }),
        t.to = this.resolvedAddress,
        this.deployed().then( () => this.signer.sendTransaction(t))
    }
    connect(e) {
        typeof e == "string" && (e = new gI(e,this.provider));
        const t = new this.constructor(this.address,this.interface,e);
        return this.deployTransaction && Ue(t, "deployTransaction", this.deployTransaction),
        t
    }
    attach(e) {
        return new this.constructor(e,this.interface,this.signer || this.provider)
    }
    static isIndexed(e) {
        return XT.isIndexed(e)
    }
    _normalizeRunningEvent(e) {
        return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
    }
    _getRunningEvent(e) {
        if (typeof e == "string") {
            if (e === "error")
                return this._normalizeRunningEvent(new U4e);
            if (e === "event")
                return this._normalizeRunningEvent(new i0("event",null));
            if (e === "*")
                return this._normalizeRunningEvent(new x4(this.address,this.interface));
            const t = this.interface.getEvent(e);
            return this._normalizeRunningEvent(new _4(this.address,this.interface,t))
        }
        if (e.topics && e.topics.length > 0) {
            try {
                const r = e.topics[0];
                if (typeof r != "string")
                    throw new Error("invalid topic");
                const i = this.interface.getEvent(r);
                return this._normalizeRunningEvent(new _4(this.address,this.interface,i,e.topics))
            } catch {}
            const t = {
                address: this.address,
                topics: e.topics
            };
            return this._normalizeRunningEvent(new i0(Yj(t),t))
        }
        return this._normalizeRunningEvent(new x4(this.address,this.interface))
    }
    _checkRunningEvents(e) {
        if (e.listenerCount() === 0) {
            delete this._runningEvents[e.tag];
            const t = this._wrappedEmits[e.tag];
            t && e.filter && (this.provider.off(e.filter, t),
            delete this._wrappedEmits[e.tag])
        }
    }
    _wrapEvent(e, t, r) {
        const i = Ps(t);
        return i.removeListener = () => {
            r && (e.removeListener(r),
            this._checkRunningEvents(e))
        }
        ,
        i.getBlock = () => this.provider.getBlock(t.blockHash),
        i.getTransaction = () => this.provider.getTransaction(t.transactionHash),
        i.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash),
        e.prepareEvent(i),
        i
    }
    _addEventListener(e, t, r) {
        if (this.provider || fr.throwError("events require a provider or a signer with a provider", xe.errors.UNSUPPORTED_OPERATION, {
            operation: "once"
        }),
        e.addListener(t, r),
        this._runningEvents[e.tag] = e,
        !this._wrappedEmits[e.tag]) {
            const i = s => {
                let o = this._wrapEvent(e, s, t);
                if (o.decodeError == null)
                    try {
                        const a = e.getEmit(o);
                        this.emit(e.filter, ...a)
                    } catch (a) {
                        o.decodeError = a.error
                    }
                e.filter != null && this.emit("event", o),
                o.decodeError != null && this.emit("error", o.decodeError, o)
            }
            ;
            this._wrappedEmits[e.tag] = i,
            e.filter != null && this.provider.on(e.filter, i)
        }
    }
    queryFilter(e, t, r) {
        const i = this._getRunningEvent(e)
          , s = Qn(i.filter);
        return typeof t == "string" && It(t, 32) ? (r != null && fr.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", r),
        s.blockHash = t) : (s.fromBlock = t ?? 0,
        s.toBlock = r ?? "latest"),
        this.provider.getLogs(s).then(o => o.map(a => this._wrapEvent(i, a, null)))
    }
    on(e, t) {
        return this._addEventListener(this._getRunningEvent(e), t, !1),
        this
    }
    once(e, t) {
        return this._addEventListener(this._getRunningEvent(e), t, !0),
        this
    }
    emit(e, ...t) {
        if (!this.provider)
            return !1;
        const r = this._getRunningEvent(e)
          , i = r.run(t) > 0;
        return this._checkRunningEvents(r),
        i
    }
    listenerCount(e) {
        return this.provider ? e == null ? Object.keys(this._runningEvents).reduce( (t, r) => t + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0
    }
    listeners(e) {
        if (!this.provider)
            return [];
        if (e == null) {
            const t = [];
            for (let r in this._runningEvents)
                this._runningEvents[r].listeners().forEach(i => {
                    t.push(i)
                }
                );
            return t
        }
        return this._getRunningEvent(e).listeners()
    }
    removeAllListeners(e) {
        if (!this.provider)
            return this;
        if (e == null) {
            for (const r in this._runningEvents) {
                const i = this._runningEvents[r];
                i.removeAllListeners(),
                this._checkRunningEvents(i)
            }
            return this
        }
        const t = this._getRunningEvent(e);
        return t.removeAllListeners(),
        this._checkRunningEvents(t),
        this
    }
    off(e, t) {
        if (!this.provider)
            return this;
        const r = this._getRunningEvent(e);
        return r.removeListener(t),
        this._checkRunningEvents(r),
        this
    }
    removeListener(e, t) {
        return this.off(e, t)
    }
}
class ib extends F4e {
}
const P4e = "0x543D43F390b7d681513045e8a85707438c463d80"
  , Mx = {
    owner: "0x634B0510C5062CFf8009eAAc2435eB93bc4764ad",
    address: "0x69341F01C2113E2d09Cd4837bbF1786dfbBc41d7",
    abi: [{
        inputs: [{
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "symbol",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "index",
            type: "uint256"
        }],
        name: "tokenByIndex",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "uint256",
            name: "index",
            type: "uint256"
        }],
        name: "tokenOfOwnerByIndex",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "tokenPrice",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "tokenURI",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "totalSupply",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "numberOfTokens",
            type: "uint256"
        }, {
            internalType: "string",
            name: "_tokenURI",
            type: "string"
        }],
        name: "mintToken",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }]
}
  , b4 = {
    address: "0x0000000000000aF8FE6E4DE40F4804C90fA8Ea8F",
    abi: [{
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        inputs: [],
        name: "AddressMismatch",
        type: "error"
    }, {
        inputs: [],
        name: "AlreadyProxied",
        type: "error"
    }, {
        inputs: [],
        name: "ColdAddressCannotBeTheSameAsHot",
        type: "error"
    }, {
        inputs: [],
        name: "ColdIsAddressZero",
        type: "error"
    }, {
        inputs: [],
        name: "ColdWalletCannotInteractUseHot",
        type: "error"
    }, {
        inputs: [],
        name: "DeliveryCannotBeTheZeroAddress",
        type: "error"
    }, {
        inputs: [],
        name: "DeliveryIsAddressZero",
        type: "error"
    }, {
        inputs: [],
        name: "EthWithdrawFailed",
        type: "error"
    }, {
        inputs: [],
        name: "IncorrectProxyRegisterFee",
        type: "error"
    }, {
        inputs: [],
        name: "MigrationIsAllowedOnceOnly",
        type: "error"
    }, {
        inputs: [],
        name: "NoPaymentPendingForAddress",
        type: "error"
    }, {
        inputs: [],
        name: "NoRecordFoundForAddress",
        type: "error"
    }, {
        inputs: [],
        name: "OnlyHotAddressCanChangeAddress",
        type: "error"
    }, {
        inputs: [],
        name: "ProxyRegisterFeeRequired",
        type: "error"
    }, {
        inputs: [],
        name: "RegisterAddressLocked",
        type: "error"
    }, {
        inputs: [],
        name: "RewardRateIsLocked",
        type: "error"
    }, {
        inputs: [],
        name: "UnknownAmount",
        type: "error"
    }, {
        inputs: [],
        name: "UnrecognisedEPSAPIAmount",
        type: "error"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "oldDelivery",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "provider",
            type: "uint256"
        }],
        name: "DeliveryUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "ensReverseRegistrarAddress",
            type: "address"
        }],
        name: "ENSReverseRegistrarSet",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "erc20",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "erc20Fee_",
            type: "uint256"
        }],
        name: "ERC20FeeUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [],
        name: "MigrationComplete",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint64",
            name: "provider",
            type: "uint64"
        }],
        name: "NominationAccepted",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "provider",
            type: "uint256"
        }],
        name: "NominationMade",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint64",
            name: "provider",
            type: "uint64"
        }],
        name: "ProxyRecordLive",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "enum IEPSProxyRegister.Participant",
            name: "initiator",
            type: "uint8"
        }, {
            indexed: !0,
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "provider",
            type: "uint256"
        }],
        name: "RecordDeleted",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [],
        name: "RewardRateLocked",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint96",
            name: "rewardRate",
            type: "uint96"
        }],
        name: "RewardRateUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "newToken",
            type: "address"
        }],
        name: "RewardTokenUpdated",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }, {
        inputs: [{
            internalType: "address",
            name: "hot_",
            type: "address"
        }, {
            internalType: "uint64",
            name: "provider_",
            type: "uint64"
        }],
        name: "acceptNomination",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [],
        name: "activeEthAddresses",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }, {
            internalType: "bool",
            name: "checkingHot_",
            type: "bool"
        }],
        name: "addressIsAvailable",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }],
        name: "beneficiaryBalance",
        outputs: [{
            internalType: "uint256",
            name: "balance_",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenContract_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "beneficiaryBalanceOf",
        outputs: [{
            internalType: "uint256",
            name: "balance_",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenContract_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "id_",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "beneficiaryBalanceOf1155",
        outputs: [{
            internalType: "uint256",
            name: "balance_",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }, {
            internalType: "address",
            name: "tokenContract_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "beneficiaryBalanceOf20",
        outputs: [{
            internalType: "uint256",
            name: "balance_",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "tokenContract_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId_",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "beneficiaryOf",
        outputs: [{
            internalType: "address",
            name: "beneficiary_",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "cold_",
            type: "address"
        }],
        name: "coldIsActiveOnRegister",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "cold_",
            type: "address"
        }],
        name: "coldIsLive",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "coldToHot",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "decimals",
        outputs: [{
            internalType: "uint8",
            name: "",
            type: "uint8"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "provider_",
            type: "uint256"
        }],
        name: "deleteRecord",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "deletionNominalEth",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "ensReverseRegistrar",
        outputs: [{
            internalType: "contract ENSReverseRegistrar",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "epsAPIBalance",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc1155DelegationRegister",
        outputs: [{
            internalType: "contract IERC1155DelegateRegister",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc1155DelegationRegisterAddressLocked",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc20DelegationRegister",
        outputs: [{
            internalType: "contract IERC20DelegateRegister",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc20DelegationRegisterAddressLocked",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "erc20PerTransactionFee",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc721DelegationRegister",
        outputs: [{
            internalType: "contract IERC721DelegateRegister",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "erc721DelegationRegisterAddressLocked",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "receivedAddress_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "getAddresses1155",
        outputs: [{
            internalType: "address[]",
            name: "proxyAddresses_",
            type: "address[]"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "receivedAddress_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "getAddresses20",
        outputs: [{
            internalType: "address[]",
            name: "proxyAddresses_",
            type: "address[]"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "receivedAddress_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "getAddresses721",
        outputs: [{
            internalType: "address[]",
            name: "proxyAddresses_",
            type: "address[]"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "receivedAddress_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "rightsIndex_",
            type: "uint256"
        }],
        name: "getAllAddresses",
        outputs: [{
            internalType: "address[]",
            name: "erc721Addresses_",
            type: "address[]"
        }, {
            internalType: "address[]",
            name: "erc1155Addresses_",
            type: "address[]"
        }, {
            internalType: "address[]",
            name: "erc20Addresses_",
            type: "address[]"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_receivedAddress",
            type: "address"
        }],
        name: "getColdAndDeliveryAddresses",
        outputs: [{
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            internalType: "bool",
            name: "isProxied",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "queryAddress_",
            type: "address"
        }],
        name: "getProxyRecordForAddress",
        outputs: [{
            internalType: "enum IEPSProxyRegister.ProxyStatus",
            name: "status",
            type: "uint8"
        }, {
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            internalType: "uint64",
            name: "provider_",
            type: "uint64"
        }, {
            internalType: "bool",
            name: "feePaid",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "cold_",
            type: "address"
        }],
        name: "getProxyRecordForCold",
        outputs: [{
            internalType: "enum IEPSProxyRegister.ProxyStatus",
            name: "status",
            type: "uint8"
        }, {
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            internalType: "uint64",
            name: "provider_",
            type: "uint64"
        }, {
            internalType: "bool",
            name: "feePaid",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "hot_",
            type: "address"
        }],
        name: "getProxyRecordForHot",
        outputs: [{
            internalType: "enum IEPSProxyRegister.ProxyStatus",
            name: "status",
            type: "uint8"
        }, {
            internalType: "address",
            name: "hot",
            type: "address"
        }, {
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery",
            type: "address"
        }, {
            internalType: "uint64",
            name: "provider_",
            type: "uint64"
        }, {
            internalType: "bool",
            name: "feePaid",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "hot_",
            type: "address"
        }],
        name: "hotIsActiveOnRegister",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "hot_",
            type: "address"
        }],
        name: "hotIsLive",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "hotToRecord",
        outputs: [{
            internalType: "uint64",
            name: "provider",
            type: "uint64"
        }, {
            internalType: "enum IEPSProxyRegister.ProxyStatus",
            name: "status",
            type: "uint8"
        }, {
            internalType: "bool",
            name: "feePaid",
            type: "bool"
        }, {
            internalType: "address",
            name: "cold",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "hot_",
            type: "address"
        }, {
            internalType: "address",
            name: "cold_",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }],
        name: "isValidAddresses",
        outputs: [],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [],
        name: "lockERC1155DelegationRegisterAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "lockERC20DelegationRegisterAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "lockERC721DelegationRegisterAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "lockRewardRate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            components: [{
                internalType: "address",
                name: "hot",
                type: "address"
            }, {
                internalType: "address",
                name: "cold",
                type: "address"
            }, {
                internalType: "address",
                name: "delivery",
                type: "address"
            }],
            internalType: "struct EPSRegister.MigratedRecord[]",
            name: "migratedRecords_",
            type: "tuple[]"
        }],
        name: "migration",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "migrationComplete",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "name",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "cold_",
            type: "address"
        }, {
            internalType: "address",
            name: "delivery_",
            type: "address"
        }, {
            internalType: "uint64",
            name: "provider_",
            type: "uint64"
        }],
        name: "nominate",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "sender_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "erc20Value_",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data_",
            type: "bytes"
        }],
        name: "onTokenTransfer",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }, {
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "proxyRegisterFee",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "contract IERC1155",
            name: "token_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId_",
            type: "uint256"
        }],
        name: "rescueERC1155",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "contract IERC20",
            name: "token_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount_",
            type: "uint256"
        }],
        name: "rescueERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "contract IERC721",
            name: "token_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId_",
            type: "uint256"
        }],
        name: "rescueERC721",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "rewardRate",
        outputs: [{
            internalType: "uint88",
            name: "",
            type: "uint88"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "rewardRateLocked",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [],
        name: "rewardToken",
        outputs: [{
            internalType: "contract IOAT",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "deleteNominalEth_",
            type: "uint256"
        }],
        name: "setDeletionNominalEth",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "string",
            name: "ensName_",
            type: "string"
        }],
        name: "setENSName",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "ensReverseRegistrar_",
            type: "address"
        }],
        name: "setENSReverseRegistrar",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "erc1155DelegationRegister_",
            type: "address"
        }],
        name: "setERC1155DelegationRegister",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "erc20DelegationRegister_",
            type: "address"
        }],
        name: "setERC20DelegationRegister",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "erc20_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "erc20Fee_",
            type: "uint256"
        }],
        name: "setERC20Fee",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "erc721DelegationRegister_",
            type: "address"
        }],
        name: "setERC721DelegationRegister",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "count_",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "air_",
            type: "uint256"
        }],
        name: "setNNumberOfEthAddressesAndAirdropAmount",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "registerFee_",
            type: "uint256"
        }],
        name: "setRegisterFee",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint88",
            name: "rewardRate_",
            type: "uint88"
        }],
        name: "setRewardRate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "rewardToken_",
            type: "address"
        }],
        name: "setRewardToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "treasuryAddress_",
            type: "address"
        }],
        name: "setTreasuryAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "symbol",
        outputs: [{
            internalType: "string",
            name: "",
            type: "string"
        }],
        stateMutability: "pure",
        type: "function"
    }, {
        inputs: [],
        name: "totalSupply",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "transfer",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        name: "treasury",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "delivery_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "provider_",
            type: "uint256"
        }],
        name: "updateDeliveryAddress",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "contract IERC20",
            name: "token_",
            type: "address"
        }, {
            internalType: "uint256",
            name: "amount_",
            type: "uint256"
        }],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "uint256",
            name: "amount_",
            type: "uint256"
        }],
        name: "withdrawETH",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        stateMutability: "payable",
        type: "receive"
    }]
};
function $j(n, e) {
    return function() {
        return n.apply(e, arguments)
    }
}
const {toString: L4e} = Object.prototype
  , {getPrototypeOf: dU} = Object
  , sb = (n => e => {
    const t = L4e.call(e);
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , pa = n => (n = n.toLowerCase(),
e => sb(e) === n)
  , ob = n => e => typeof e === n
  , {isArray: fp} = Array
  , s0 = ob("undefined");
function D4e(n) {
    return n !== null && !s0(n) && n.constructor !== null && !s0(n.constructor) && Os(n.constructor.isBuffer) && n.constructor.isBuffer(n)
}
const Zj = pa("ArrayBuffer");
function N4e(n) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && Zj(n.buffer),
    e
}
const O4e = ob("string")
  , Os = ob("function")
  , Jj = ob("number")
  , ab = n => n !== null && typeof n == "object"
  , k4e = n => n === !0 || n === !1
  , Gw = n => {
    if (sb(n) !== "object")
        return !1;
    const e = dU(n);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n)
}
  , Q4e = pa("Date")
  , H4e = pa("File")
  , z4e = pa("Blob")
  , G4e = pa("FileList")
  , V4e = n => ab(n) && Os(n.pipe)
  , j4e = n => {
    let e;
    return n && (typeof FormData == "function" && n instanceof FormData || Os(n.append) && ((e = sb(n)) === "formdata" || e === "object" && Os(n.toString) && n.toString() === "[object FormData]"))
}
  , W4e = pa("URLSearchParams")
  , [K4e,X4e,Y4e,$4e] = ["ReadableStream", "Request", "Response", "Headers"].map(pa)
  , Z4e = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function O0(n, e, {allOwnKeys: t=!1}={}) {
    if (n === null || typeof n > "u")
        return;
    let r, i;
    if (typeof n != "object" && (n = [n]),
    fp(n))
        for (r = 0,
        i = n.length; r < i; r++)
            e.call(null, n[r], r, n);
    else {
        const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n)
          , o = s.length;
        let a;
        for (r = 0; r < o; r++)
            a = s[r],
            e.call(null, n[a], a, n)
    }
}
function qj(n, e) {
    e = e.toLowerCase();
    const t = Object.keys(n);
    let r = t.length, i;
    for (; r-- > 0; )
        if (i = t[r],
        e === i.toLowerCase())
            return i;
    return null
}
const gu = ( () => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)()
  , eW = n => !s0(n) && n !== gu;
function YT() {
    const {caseless: n} = eW(this) && this || {}
      , e = {}
      , t = (r, i) => {
        const s = n && qj(e, i) || i;
        Gw(e[s]) && Gw(r) ? e[s] = YT(e[s], r) : Gw(r) ? e[s] = YT({}, r) : fp(r) ? e[s] = r.slice() : e[s] = r
    }
    ;
    for (let r = 0, i = arguments.length; r < i; r++)
        arguments[r] && O0(arguments[r], t);
    return e
}
const J4e = (n, e, t, {allOwnKeys: r}={}) => (O0(e, (i, s) => {
    t && Os(i) ? n[s] = $j(i, t) : n[s] = i
}
, {
    allOwnKeys: r
}),
n)
  , q4e = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)),
n)
  , eQe = (n, e, t, r) => {
    n.prototype = Object.create(e.prototype, r),
    n.prototype.constructor = n,
    Object.defineProperty(n, "super", {
        value: e.prototype
    }),
    t && Object.assign(n.prototype, t)
}
  , tQe = (n, e, t, r) => {
    let i, s, o;
    const a = {};
    if (e = e || {},
    n == null)
        return e;
    do {
        for (i = Object.getOwnPropertyNames(n),
        s = i.length; s-- > 0; )
            o = i[s],
            (!r || r(o, n, e)) && !a[o] && (e[o] = n[o],
            a[o] = !0);
        n = t !== !1 && dU(n)
    } while (n && (!t || t(n, e)) && n !== Object.prototype);
    return e
}
  , nQe = (n, e, t) => {
    n = String(n),
    (t === void 0 || t > n.length) && (t = n.length),
    t -= e.length;
    const r = n.indexOf(e, t);
    return r !== -1 && r === t
}
  , rQe = n => {
    if (!n)
        return null;
    if (fp(n))
        return n;
    let e = n.length;
    if (!Jj(e))
        return null;
    const t = new Array(e);
    for (; e-- > 0; )
        t[e] = n[e];
    return t
}
  , iQe = (n => e => n && e instanceof n)(typeof Uint8Array < "u" && dU(Uint8Array))
  , sQe = (n, e) => {
    const r = (n && n[Symbol.iterator]).call(n);
    let i;
    for (; (i = r.next()) && !i.done; ) {
        const s = i.value;
        e.call(n, s[0], s[1])
    }
}
  , oQe = (n, e) => {
    let t;
    const r = [];
    for (; (t = n.exec(e)) !== null; )
        r.push(t);
    return r
}
  , aQe = pa("HTMLFormElement")
  , lQe = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, r, i) {
    return r.toUpperCase() + i
})
  , E4 = ( ({hasOwnProperty: n}) => (e, t) => n.call(e, t))(Object.prototype)
  , cQe = pa("RegExp")
  , tW = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n)
      , r = {};
    O0(t, (i, s) => {
        let o;
        (o = e(i, s, n)) !== !1 && (r[s] = o || i)
    }
    ),
    Object.defineProperties(n, r)
}
  , AQe = n => {
    tW(n, (e, t) => {
        if (Os(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
            return !1;
        const r = n[t];
        if (Os(r)) {
            if (e.enumerable = !1,
            "writable"in e) {
                e.writable = !1;
                return
            }
            e.set || (e.set = () => {
                throw Error("Can not rewrite read-only method '" + t + "'")
            }
            )
        }
    }
    )
}
  , uQe = (n, e) => {
    const t = {}
      , r = i => {
        i.forEach(s => {
            t[s] = !0
        }
        )
    }
    ;
    return fp(n) ? r(n) : r(String(n).split(e)),
    t
}
  , fQe = () => {}
  , hQe = (n, e) => n != null && Number.isFinite(n = +n) ? n : e
  , bM = "abcdefghijklmnopqrstuvwxyz"
  , B4 = "0123456789"
  , nW = {
    DIGIT: B4,
    ALPHA: bM,
    ALPHA_DIGIT: bM + bM.toUpperCase() + B4
}
  , dQe = (n=16, e=nW.ALPHA_DIGIT) => {
    let t = "";
    const {length: r} = e;
    for (; n--; )
        t += e[Math.random() * r | 0];
    return t
}
;
function pQe(n) {
    return !!(n && Os(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator])
}
const mQe = n => {
    const e = new Array(10)
      , t = (r, i) => {
        if (ab(r)) {
            if (e.indexOf(r) >= 0)
                return;
            if (!("toJSON"in r)) {
                e[i] = r;
                const s = fp(r) ? [] : {};
                return O0(r, (o, a) => {
                    const l = t(o, i + 1);
                    !s0(l) && (s[a] = l)
                }
                ),
                e[i] = void 0,
                s
            }
        }
        return r
    }
    ;
    return t(n, 0)
}
  , gQe = pa("AsyncFunction")
  , vQe = n => n && (ab(n) || Os(n)) && Os(n.then) && Os(n.catch)
  , rW = ( (n, e) => n ? setImmediate : e ? ( (t, r) => (gu.addEventListener("message", ({source: i, data: s}) => {
    i === gu && s === t && r.length && r.shift()()
}
, !1),
i => {
    r.push(i),
    gu.postMessage(t, "*")
}
))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == "function", Os(gu.postMessage))
  , yQe = typeof queueMicrotask < "u" ? queueMicrotask.bind(gu) : typeof process < "u" && process.nextTick || rW
  , Ie = {
    isArray: fp,
    isArrayBuffer: Zj,
    isBuffer: D4e,
    isFormData: j4e,
    isArrayBufferView: N4e,
    isString: O4e,
    isNumber: Jj,
    isBoolean: k4e,
    isObject: ab,
    isPlainObject: Gw,
    isReadableStream: K4e,
    isRequest: X4e,
    isResponse: Y4e,
    isHeaders: $4e,
    isUndefined: s0,
    isDate: Q4e,
    isFile: H4e,
    isBlob: z4e,
    isRegExp: cQe,
    isFunction: Os,
    isStream: V4e,
    isURLSearchParams: W4e,
    isTypedArray: iQe,
    isFileList: G4e,
    forEach: O0,
    merge: YT,
    extend: J4e,
    trim: Z4e,
    stripBOM: q4e,
    inherits: eQe,
    toFlatObject: tQe,
    kindOf: sb,
    kindOfTest: pa,
    endsWith: nQe,
    toArray: rQe,
    forEachEntry: sQe,
    matchAll: oQe,
    isHTMLForm: aQe,
    hasOwnProperty: E4,
    hasOwnProp: E4,
    reduceDescriptors: tW,
    freezeMethods: AQe,
    toObjectSet: uQe,
    toCamelCase: lQe,
    noop: fQe,
    toFiniteNumber: hQe,
    findKey: qj,
    global: gu,
    isContextDefined: eW,
    ALPHABET: nW,
    generateString: dQe,
    isSpecCompliantForm: pQe,
    toJSONObject: mQe,
    isAsyncFn: gQe,
    isThenable: vQe,
    setImmediate: rW,
    asap: yQe
};
function bt(n, e, t, r, i) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = n,
    this.name = "AxiosError",
    e && (this.code = e),
    t && (this.config = t),
    r && (this.request = r),
    i && (this.response = i,
    this.status = i.status ? i.status : null)
}
Ie.inherits(bt, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Ie.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const iW = bt.prototype
  , sW = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(n => {
    sW[n] = {
        value: n
    }
}
);
Object.defineProperties(bt, sW);
Object.defineProperty(iW, "isAxiosError", {
    value: !0
});
bt.from = (n, e, t, r, i, s) => {
    const o = Object.create(iW);
    return Ie.toFlatObject(n, o, function(l) {
        return l !== Error.prototype
    }, a => a !== "isAxiosError"),
    bt.call(o, n.message, e, t, r, i),
    o.cause = n,
    o.name = n.name,
    s && Object.assign(o, s),
    o
}
;
const wQe = null;
function $T(n) {
    return Ie.isPlainObject(n) || Ie.isArray(n)
}
function oW(n) {
    return Ie.endsWith(n, "[]") ? n.slice(0, -2) : n
}
function M4(n, e, t) {
    return n ? n.concat(e).map(function(i, s) {
        return i = oW(i),
        !t && s ? "[" + i + "]" : i
    }).join(t ? "." : "") : e
}
function _Qe(n) {
    return Ie.isArray(n) && !n.some($T)
}
const xQe = Ie.toFlatObject(Ie, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});
function lb(n, e, t) {
    if (!Ie.isObject(n))
        throw new TypeError("target must be an object");
    e = e || new FormData,
    t = Ie.toFlatObject(t, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(m, g) {
        return !Ie.isUndefined(g[m])
    });
    const r = t.metaTokens
      , i = t.visitor || A
      , s = t.dots
      , o = t.indexes
      , l = (t.Blob || typeof Blob < "u" && Blob) && Ie.isSpecCompliantForm(e);
    if (!Ie.isFunction(i))
        throw new TypeError("visitor must be a function");
    function c(d) {
        if (d === null)
            return "";
        if (Ie.isDate(d))
            return d.toISOString();
        if (!l && Ie.isBlob(d))
            throw new bt("Blob is not supported. Use a Buffer instead.");
        return Ie.isArrayBuffer(d) || Ie.isTypedArray(d) ? l && typeof Blob == "function" ? new Blob([d]) : Buffer.from(d) : d
    }
    function A(d, m, g) {
        let p = d;
        if (d && !g && typeof d == "object") {
            if (Ie.endsWith(m, "{}"))
                m = r ? m : m.slice(0, -2),
                d = JSON.stringify(d);
            else if (Ie.isArray(d) && _Qe(d) || (Ie.isFileList(d) || Ie.endsWith(m, "[]")) && (p = Ie.toArray(d)))
                return m = oW(m),
                p.forEach(function(w, _) {
                    !(Ie.isUndefined(w) || w === null) && e.append(o === !0 ? M4([m], _, s) : o === null ? m : m + "[]", c(w))
                }),
                !1
        }
        return $T(d) ? !0 : (e.append(M4(g, m, s), c(d)),
        !1)
    }
    const u = []
      , f = Object.assign(xQe, {
        defaultVisitor: A,
        convertValue: c,
        isVisitable: $T
    });
    function h(d, m) {
        if (!Ie.isUndefined(d)) {
            if (u.indexOf(d) !== -1)
                throw Error("Circular reference detected in " + m.join("."));
            u.push(d),
            Ie.forEach(d, function(p, v) {
                (!(Ie.isUndefined(p) || p === null) && i.call(e, p, Ie.isString(v) ? v.trim() : v, m, f)) === !0 && h(p, m ? m.concat(v) : [v])
            }),
            u.pop()
        }
    }
    if (!Ie.isObject(n))
        throw new TypeError("data must be an object");
    return h(n),
    e
}
function S4(n) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(r) {
        return e[r]
    })
}
function pU(n, e) {
    this._pairs = [],
    n && lb(n, this, e)
}
const aW = pU.prototype;
aW.append = function(e, t) {
    this._pairs.push([e, t])
}
;
aW.toString = function(e) {
    const t = e ? function(r) {
        return e.call(this, r, S4)
    }
    : S4;
    return this._pairs.map(function(i) {
        return t(i[0]) + "=" + t(i[1])
    }, "").join("&")
}
;
function bQe(n) {
    return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function lW(n, e, t) {
    if (!e)
        return n;
    const r = t && t.encode || bQe
      , i = t && t.serialize;
    let s;
    if (i ? s = i(e, t) : s = Ie.isURLSearchParams(e) ? e.toString() : new pU(e,t).toString(r),
    s) {
        const o = n.indexOf("#");
        o !== -1 && (n = n.slice(0, o)),
        n += (n.indexOf("?") === -1 ? "?" : "&") + s
    }
    return n
}
class EQe {
    constructor() {
        this.handlers = []
    }
    use(e, t, r) {
        return this.handlers.push({
            fulfilled: e,
            rejected: t,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        Ie.forEach(this.handlers, function(r) {
            r !== null && e(r)
        })
    }
}
const C4 = EQe
  , cW = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , BQe = typeof URLSearchParams < "u" ? URLSearchParams : pU
  , MQe = typeof FormData < "u" ? FormData : null
  , SQe = typeof Blob < "u" ? Blob : null
  , CQe = {
    isBrowser: !0,
    classes: {
        URLSearchParams: BQe,
        FormData: MQe,
        Blob: SQe
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , mU = typeof window < "u" && typeof document < "u"
  , ZT = typeof navigator == "object" && navigator || void 0
  , TQe = mU && (!ZT || ["ReactNative", "NativeScript", "NS"].indexOf(ZT.product) < 0)
  , IQe = ( () => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")()
  , RQe = mU && window.location.href || "http://localhost"
  , UQe = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: mU,
    hasStandardBrowserEnv: TQe,
    hasStandardBrowserWebWorkerEnv: IQe,
    navigator: ZT,
    origin: RQe
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ls = {
    ...UQe,
    ...CQe
};
function FQe(n, e) {
    return lb(n, new ls.classes.URLSearchParams, Object.assign({
        visitor: function(t, r, i, s) {
            return ls.isNode && Ie.isBuffer(t) ? (this.append(r, t.toString("base64")),
            !1) : s.defaultVisitor.apply(this, arguments)
        }
    }, e))
}
function PQe(n) {
    return Ie.matchAll(/\w+|\[(\w*)]/g, n).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}
function LQe(n) {
    const e = {}
      , t = Object.keys(n);
    let r;
    const i = t.length;
    let s;
    for (r = 0; r < i; r++)
        s = t[r],
        e[s] = n[s];
    return e
}
function AW(n) {
    function e(t, r, i, s) {
        let o = t[s++];
        if (o === "__proto__")
            return !0;
        const a = Number.isFinite(+o)
          , l = s >= t.length;
        return o = !o && Ie.isArray(i) ? i.length : o,
        l ? (Ie.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r,
        !a) : ((!i[o] || !Ie.isObject(i[o])) && (i[o] = []),
        e(t, r, i[o], s) && Ie.isArray(i[o]) && (i[o] = LQe(i[o])),
        !a)
    }
    if (Ie.isFormData(n) && Ie.isFunction(n.entries)) {
        const t = {};
        return Ie.forEachEntry(n, (r, i) => {
            e(PQe(r), i, t, 0)
        }
        ),
        t
    }
    return null
}
function DQe(n, e, t) {
    if (Ie.isString(n))
        try {
            return (e || JSON.parse)(n),
            Ie.trim(n)
        } catch (r) {
            if (r.name !== "SyntaxError")
                throw r
        }
    return (t || JSON.stringify)(n)
}
const gU = {
    transitional: cW,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, t) {
        const r = t.getContentType() || ""
          , i = r.indexOf("application/json") > -1
          , s = Ie.isObject(e);
        if (s && Ie.isHTMLForm(e) && (e = new FormData(e)),
        Ie.isFormData(e))
            return i ? JSON.stringify(AW(e)) : e;
        if (Ie.isArrayBuffer(e) || Ie.isBuffer(e) || Ie.isStream(e) || Ie.isFile(e) || Ie.isBlob(e) || Ie.isReadableStream(e))
            return e;
        if (Ie.isArrayBufferView(e))
            return e.buffer;
        if (Ie.isURLSearchParams(e))
            return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            e.toString();
        let a;
        if (s) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1)
                return FQe(e, this.formSerializer).toString();
            if ((a = Ie.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return lb(a ? {
                    "files[]": e
                } : e, l && new l, this.formSerializer)
            }
        }
        return s || i ? (t.setContentType("application/json", !1),
        DQe(e)) : e
    }
    ],
    transformResponse: [function(e) {
        const t = this.transitional || gU.transitional
          , r = t && t.forcedJSONParsing
          , i = this.responseType === "json";
        if (Ie.isResponse(e) || Ie.isReadableStream(e))
            return e;
        if (e && Ie.isString(e) && (r && !this.responseType || i)) {
            const o = !(t && t.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (o)
                    throw a.name === "SyntaxError" ? bt.from(a, bt.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: ls.classes.FormData,
        Blob: ls.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Ie.forEach(["delete", "get", "head", "post", "put", "patch"], n => {
    gU.headers[n] = {}
}
);
const vU = gU
  , NQe = Ie.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , OQe = n => {
    const e = {};
    let t, r, i;
    return n && n.split(`
`).forEach(function(o) {
        i = o.indexOf(":"),
        t = o.substring(0, i).trim().toLowerCase(),
        r = o.substring(i + 1).trim(),
        !(!t || e[t] && NQe[t]) && (t === "set-cookie" ? e[t] ? e[t].push(r) : e[t] = [r] : e[t] = e[t] ? e[t] + ", " + r : r)
    }),
    e
}
  , T4 = Symbol("internals");
function hm(n) {
    return n && String(n).trim().toLowerCase()
}
function Vw(n) {
    return n === !1 || n == null ? n : Ie.isArray(n) ? n.map(Vw) : String(n)
}
function kQe(n) {
    const e = Object.create(null)
      , t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = t.exec(n); )
        e[r[1]] = r[2];
    return e
}
const QQe = n => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function EM(n, e, t, r, i) {
    if (Ie.isFunction(r))
        return r.call(this, e, t);
    if (i && (e = t),
    !!Ie.isString(e)) {
        if (Ie.isString(r))
            return e.indexOf(r) !== -1;
        if (Ie.isRegExp(r))
            return r.test(e)
    }
}
function HQe(n) {
    return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, r) => t.toUpperCase() + r)
}
function zQe(n, e) {
    const t = Ie.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(n, r + t, {
            value: function(i, s, o) {
                return this[r].call(this, e, i, s, o)
            },
            configurable: !0
        })
    }
    )
}
class cb {
    constructor(e) {
        e && this.set(e)
    }
    set(e, t, r) {
        const i = this;
        function s(a, l, c) {
            const A = hm(l);
            if (!A)
                throw new Error("header name must be a non-empty string");
            const u = Ie.findKey(i, A);
            (!u || i[u] === void 0 || c === !0 || c === void 0 && i[u] !== !1) && (i[u || l] = Vw(a))
        }
        const o = (a, l) => Ie.forEach(a, (c, A) => s(c, A, l));
        if (Ie.isPlainObject(e) || e instanceof this.constructor)
            o(e, t);
        else if (Ie.isString(e) && (e = e.trim()) && !QQe(e))
            o(OQe(e), t);
        else if (Ie.isHeaders(e))
            for (const [a,l] of e.entries())
                s(l, a, r);
        else
            e != null && s(t, e, r);
        return this
    }
    get(e, t) {
        if (e = hm(e),
        e) {
            const r = Ie.findKey(this, e);
            if (r) {
                const i = this[r];
                if (!t)
                    return i;
                if (t === !0)
                    return kQe(i);
                if (Ie.isFunction(t))
                    return t.call(this, i, r);
                if (Ie.isRegExp(t))
                    return t.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, t) {
        if (e = hm(e),
        e) {
            const r = Ie.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!t || EM(this, this[r], r, t)))
        }
        return !1
    }
    delete(e, t) {
        const r = this;
        let i = !1;
        function s(o) {
            if (o = hm(o),
            o) {
                const a = Ie.findKey(r, o);
                a && (!t || EM(r, r[a], a, t)) && (delete r[a],
                i = !0)
            }
        }
        return Ie.isArray(e) ? e.forEach(s) : s(e),
        i
    }
    clear(e) {
        const t = Object.keys(this);
        let r = t.length
          , i = !1;
        for (; r--; ) {
            const s = t[r];
            (!e || EM(this, this[s], s, e, !0)) && (delete this[s],
            i = !0)
        }
        return i
    }
    normalize(e) {
        const t = this
          , r = {};
        return Ie.forEach(this, (i, s) => {
            const o = Ie.findKey(r, s);
            if (o) {
                t[o] = Vw(i),
                delete t[s];
                return
            }
            const a = e ? HQe(s) : String(s).trim();
            a !== s && delete t[s],
            t[a] = Vw(i),
            r[a] = !0
        }
        ),
        this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const t = Object.create(null);
        return Ie.forEach(this, (r, i) => {
            r != null && r !== !1 && (t[i] = e && Ie.isArray(r) ? r.join(", ") : r)
        }
        ),
        t
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([e,t]) => e + ": " + t).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...t) {
        const r = new this(e);
        return t.forEach(i => r.set(i)),
        r
    }
    static accessor(e) {
        const r = (this[T4] = this[T4] = {
            accessors: {}
        }).accessors
          , i = this.prototype;
        function s(o) {
            const a = hm(o);
            r[a] || (zQe(i, o),
            r[a] = !0)
        }
        return Ie.isArray(e) ? e.forEach(s) : s(e),
        this
    }
}
cb.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Ie.reduceDescriptors(cb.prototype, ({value: n}, e) => {
    let t = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => n,
        set(r) {
            this[t] = r
        }
    }
}
);
Ie.freezeMethods(cb);
const oa = cb;
function BM(n, e) {
    const t = this || vU
      , r = e || t
      , i = oa.from(r.headers);
    let s = r.data;
    return Ie.forEach(n, function(a) {
        s = a.call(t, s, i.normalize(), e ? e.status : void 0)
    }),
    i.normalize(),
    s
}
function uW(n) {
    return !!(n && n.__CANCEL__)
}
function hp(n, e, t) {
    bt.call(this, n ?? "canceled", bt.ERR_CANCELED, e, t),
    this.name = "CanceledError"
}
Ie.inherits(hp, bt, {
    __CANCEL__: !0
});
function fW(n, e, t) {
    const r = t.config.validateStatus;
    !t.status || !r || r(t.status) ? n(t) : e(new bt("Request failed with status code " + t.status,[bt.ERR_BAD_REQUEST, bt.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4],t.config,t.request,t))
}
function GQe(n) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
    return e && e[1] || ""
}
function VQe(n, e) {
    n = n || 10;
    const t = new Array(n)
      , r = new Array(n);
    let i = 0, s = 0, o;
    return e = e !== void 0 ? e : 1e3,
    function(l) {
        const c = Date.now()
          , A = r[s];
        o || (o = c),
        t[i] = l,
        r[i] = c;
        let u = s
          , f = 0;
        for (; u !== i; )
            f += t[u++],
            u = u % n;
        if (i = (i + 1) % n,
        i === s && (s = (s + 1) % n),
        c - o < e)
            return;
        const h = A && c - A;
        return h ? Math.round(f * 1e3 / h) : void 0
    }
}
function jQe(n, e) {
    let t = 0, r = 1e3 / e, i, s;
    const o = (c, A=Date.now()) => {
        t = A,
        i = null,
        s && (clearTimeout(s),
        s = null),
        n.apply(null, c)
    }
    ;
    return [ (...c) => {
        const A = Date.now()
          , u = A - t;
        u >= r ? o(c, A) : (i = c,
        s || (s = setTimeout( () => {
            s = null,
            o(i)
        }
        , r - u)))
    }
    , () => i && o(i)]
}
const Sx = (n, e, t=3) => {
    let r = 0;
    const i = VQe(50, 250);
    return jQe(s => {
        const o = s.loaded
          , a = s.lengthComputable ? s.total : void 0
          , l = o - r
          , c = i(l)
          , A = o <= a;
        r = o;
        const u = {
            loaded: o,
            total: a,
            progress: a ? o / a : void 0,
            bytes: l,
            rate: c || void 0,
            estimated: c && a && A ? (a - o) / c : void 0,
            event: s,
            lengthComputable: a != null,
            [e ? "download" : "upload"]: !0
        };
        n(u)
    }
    , t)
}
  , I4 = (n, e) => {
    const t = n != null;
    return [r => e[0]({
        lengthComputable: t,
        total: n,
        loaded: r
    }), e[1]]
}
  , R4 = n => (...e) => Ie.asap( () => n(...e))
  , WQe = ls.hasStandardBrowserEnv ? function() {
    const e = ls.navigator && /(msie|trident)/i.test(ls.navigator.userAgent)
      , t = document.createElement("a");
    let r;
    function i(s) {
        let o = s;
        return e && (t.setAttribute("href", o),
        o = t.href),
        t.setAttribute("href", o),
        {
            href: t.href,
            protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
            host: t.host,
            search: t.search ? t.search.replace(/^\?/, "") : "",
            hash: t.hash ? t.hash.replace(/^#/, "") : "",
            hostname: t.hostname,
            port: t.port,
            pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
        }
    }
    return r = i(window.location.href),
    function(o) {
        const a = Ie.isString(o) ? i(o) : o;
        return a.protocol === r.protocol && a.host === r.host
    }
}() : function() {
    return function() {
        return !0
    }
}()
  , KQe = ls.hasStandardBrowserEnv ? {
    write(n, e, t, r, i, s) {
        const o = [n + "=" + encodeURIComponent(e)];
        Ie.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()),
        Ie.isString(r) && o.push("path=" + r),
        Ie.isString(i) && o.push("domain=" + i),
        s === !0 && o.push("secure"),
        document.cookie = o.join("; ")
    },
    read(n) {
        const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return e ? decodeURIComponent(e[3]) : null
    },
    remove(n) {
        this.write(n, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function XQe(n) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n)
}
function YQe(n, e) {
    return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n
}
function hW(n, e) {
    return n && !XQe(e) ? YQe(n, e) : e
}
const U4 = n => n instanceof oa ? {
    ...n
} : n;
function Vu(n, e) {
    e = e || {};
    const t = {};
    function r(c, A, u) {
        return Ie.isPlainObject(c) && Ie.isPlainObject(A) ? Ie.merge.call({
            caseless: u
        }, c, A) : Ie.isPlainObject(A) ? Ie.merge({}, A) : Ie.isArray(A) ? A.slice() : A
    }
    function i(c, A, u) {
        if (Ie.isUndefined(A)) {
            if (!Ie.isUndefined(c))
                return r(void 0, c, u)
        } else
            return r(c, A, u)
    }
    function s(c, A) {
        if (!Ie.isUndefined(A))
            return r(void 0, A)
    }
    function o(c, A) {
        if (Ie.isUndefined(A)) {
            if (!Ie.isUndefined(c))
                return r(void 0, c)
        } else
            return r(void 0, A)
    }
    function a(c, A, u) {
        if (u in e)
            return r(c, A);
        if (u in n)
            return r(void 0, c)
    }
    const l = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        withXSRFToken: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (c, A) => i(U4(c), U4(A), !0)
    };
    return Ie.forEach(Object.keys(Object.assign({}, n, e)), function(A) {
        const u = l[A] || i
          , f = u(n[A], e[A], A);
        Ie.isUndefined(f) && u !== a || (t[A] = f)
    }),
    t
}
const dW = n => {
    const e = Vu({}, n);
    let {data: t, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a} = e;
    e.headers = o = oa.from(o),
    e.url = lW(hW(e.baseURL, e.url), n.params, n.paramsSerializer),
    a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
    let l;
    if (Ie.isFormData(t)) {
        if (ls.hasStandardBrowserEnv || ls.hasStandardBrowserWebWorkerEnv)
            o.setContentType(void 0);
        else if ((l = o.getContentType()) !== !1) {
            const [c,...A] = l ? l.split(";").map(u => u.trim()).filter(Boolean) : [];
            o.setContentType([c || "multipart/form-data", ...A].join("; "))
        }
    }
    if (ls.hasStandardBrowserEnv && (r && Ie.isFunction(r) && (r = r(e)),
    r || r !== !1 && WQe(e.url))) {
        const c = i && s && KQe.read(s);
        c && o.set(i, c)
    }
    return e
}
  , $Qe = typeof XMLHttpRequest < "u"
  , ZQe = $Qe && function(n) {
    return new Promise(function(t, r) {
        const i = dW(n);
        let s = i.data;
        const o = oa.from(i.headers).normalize();
        let {responseType: a, onUploadProgress: l, onDownloadProgress: c} = i, A, u, f, h, d;
        function m() {
            h && h(),
            d && d(),
            i.cancelToken && i.cancelToken.unsubscribe(A),
            i.signal && i.signal.removeEventListener("abort", A)
        }
        let g = new XMLHttpRequest;
        g.open(i.method.toUpperCase(), i.url, !0),
        g.timeout = i.timeout;
        function p() {
            if (!g)
                return;
            const w = oa.from("getAllResponseHeaders"in g && g.getAllResponseHeaders())
              , x = {
                data: !a || a === "text" || a === "json" ? g.responseText : g.response,
                status: g.status,
                statusText: g.statusText,
                headers: w,
                config: n,
                request: g
            };
            fW(function(B) {
                t(B),
                m()
            }, function(B) {
                r(B),
                m()
            }, x),
            g = null
        }
        "onloadend"in g ? g.onloadend = p : g.onreadystatechange = function() {
            !g || g.readyState !== 4 || g.status === 0 && !(g.responseURL && g.responseURL.indexOf("file:") === 0) || setTimeout(p)
        }
        ,
        g.onabort = function() {
            g && (r(new bt("Request aborted",bt.ECONNABORTED,n,g)),
            g = null)
        }
        ,
        g.onerror = function() {
            r(new bt("Network Error",bt.ERR_NETWORK,n,g)),
            g = null
        }
        ,
        g.ontimeout = function() {
            let _ = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
            const x = i.transitional || cW;
            i.timeoutErrorMessage && (_ = i.timeoutErrorMessage),
            r(new bt(_,x.clarifyTimeoutError ? bt.ETIMEDOUT : bt.ECONNABORTED,n,g)),
            g = null
        }
        ,
        s === void 0 && o.setContentType(null),
        "setRequestHeader"in g && Ie.forEach(o.toJSON(), function(_, x) {
            g.setRequestHeader(x, _)
        }),
        Ie.isUndefined(i.withCredentials) || (g.withCredentials = !!i.withCredentials),
        a && a !== "json" && (g.responseType = i.responseType),
        c && ([f,d] = Sx(c, !0),
        g.addEventListener("progress", f)),
        l && g.upload && ([u,h] = Sx(l),
        g.upload.addEventListener("progress", u),
        g.upload.addEventListener("loadend", h)),
        (i.cancelToken || i.signal) && (A = w => {
            g && (r(!w || w.type ? new hp(null,n,g) : w),
            g.abort(),
            g = null)
        }
        ,
        i.cancelToken && i.cancelToken.subscribe(A),
        i.signal && (i.signal.aborted ? A() : i.signal.addEventListener("abort", A)));
        const v = GQe(i.url);
        if (v && ls.protocols.indexOf(v) === -1) {
            r(new bt("Unsupported protocol " + v + ":",bt.ERR_BAD_REQUEST,n));
            return
        }
        g.send(s || null)
    }
    )
}
  , JQe = (n, e) => {
    const {length: t} = n = n ? n.filter(Boolean) : [];
    if (e || t) {
        let r = new AbortController, i;
        const s = function(c) {
            if (!i) {
                i = !0,
                a();
                const A = c instanceof Error ? c : this.reason;
                r.abort(A instanceof bt ? A : new hp(A instanceof Error ? A.message : A))
            }
        };
        let o = e && setTimeout( () => {
            o = null,
            s(new bt(`timeout ${e} of ms exceeded`,bt.ETIMEDOUT))
        }
        , e);
        const a = () => {
            n && (o && clearTimeout(o),
            o = null,
            n.forEach(c => {
                c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s)
            }
            ),
            n = null)
        }
        ;
        n.forEach(c => c.addEventListener("abort", s));
        const {signal: l} = r;
        return l.unsubscribe = () => Ie.asap(a),
        l
    }
}
  , qQe = JQe
  , eHe = function*(n, e) {
    let t = n.byteLength;
    if (!e || t < e) {
        yield n;
        return
    }
    let r = 0, i;
    for (; r < t; )
        i = r + e,
        yield n.slice(r, i),
        r = i
}
  , tHe = async function*(n, e) {
    for await(const t of nHe(n))
        yield*eHe(t, e)
}
  , nHe = async function*(n) {
    if (n[Symbol.asyncIterator]) {
        yield*n;
        return
    }
    const e = n.getReader();
    try {
        for (; ; ) {
            const {done: t, value: r} = await e.read();
            if (t)
                break;
            yield r
        }
    } finally {
        await e.cancel()
    }
}
  , F4 = (n, e, t, r) => {
    const i = tHe(n, e);
    let s = 0, o, a = l => {
        o || (o = !0,
        r && r(l))
    }
    ;
    return new ReadableStream({
        async pull(l) {
            try {
                const {done: c, value: A} = await i.next();
                if (c) {
                    a(),
                    l.close();
                    return
                }
                let u = A.byteLength;
                if (t) {
                    let f = s += u;
                    t(f)
                }
                l.enqueue(new Uint8Array(A))
            } catch (c) {
                throw a(c),
                c
            }
        },
        cancel(l) {
            return a(l),
            i.return()
        }
    },{
        highWaterMark: 2
    })
}
  , Ab = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
  , pW = Ab && typeof ReadableStream == "function"
  , rHe = Ab && (typeof TextEncoder == "function" ? (n => e => n.encode(e))(new TextEncoder) : async n => new Uint8Array(await new Response(n).arrayBuffer()))
  , mW = (n, ...e) => {
    try {
        return !!n(...e)
    } catch {
        return !1
    }
}
  , iHe = pW && mW( () => {
    let n = !1;
    const e = new Request(ls.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return n = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return n && !e
}
)
  , P4 = 64 * 1024
  , JT = pW && mW( () => Ie.isReadableStream(new Response("").body))
  , Cx = {
    stream: JT && (n => n.body)
};
Ab && (n => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !Cx[e] && (Cx[e] = Ie.isFunction(n[e]) ? t => t[e]() : (t, r) => {
            throw new bt(`Response type '${e}' is not supported`,bt.ERR_NOT_SUPPORT,r)
        }
        )
    }
    )
}
)(new Response);
const sHe = async n => {
    if (n == null)
        return 0;
    if (Ie.isBlob(n))
        return n.size;
    if (Ie.isSpecCompliantForm(n))
        return (await new Request(ls.origin,{
            method: "POST",
            body: n
        }).arrayBuffer()).byteLength;
    if (Ie.isArrayBufferView(n) || Ie.isArrayBuffer(n))
        return n.byteLength;
    if (Ie.isURLSearchParams(n) && (n = n + ""),
    Ie.isString(n))
        return (await rHe(n)).byteLength
}
  , oHe = async (n, e) => {
    const t = Ie.toFiniteNumber(n.getContentLength());
    return t ?? sHe(e)
}
  , aHe = Ab && (async n => {
    let {url: e, method: t, data: r, signal: i, cancelToken: s, timeout: o, onDownloadProgress: a, onUploadProgress: l, responseType: c, headers: A, withCredentials: u="same-origin", fetchOptions: f} = dW(n);
    c = c ? (c + "").toLowerCase() : "text";
    let h = qQe([i, s && s.toAbortSignal()], o), d;
    const m = h && h.unsubscribe && ( () => {
        h.unsubscribe()
    }
    );
    let g;
    try {
        if (l && iHe && t !== "get" && t !== "head" && (g = await oHe(A, r)) !== 0) {
            let x = new Request(e,{
                method: "POST",
                body: r,
                duplex: "half"
            }), b;
            if (Ie.isFormData(r) && (b = x.headers.get("content-type")) && A.setContentType(b),
            x.body) {
                const [B,S] = I4(g, Sx(R4(l)));
                r = F4(x.body, P4, B, S)
            }
        }
        Ie.isString(u) || (u = u ? "include" : "omit");
        const p = "credentials"in Request.prototype;
        d = new Request(e,{
            ...f,
            signal: h,
            method: t.toUpperCase(),
            headers: A.normalize().toJSON(),
            body: r,
            duplex: "half",
            credentials: p ? u : void 0
        });
        let v = await fetch(d);
        const w = JT && (c === "stream" || c === "response");
        if (JT && (a || w && m)) {
            const x = {};
            ["status", "statusText", "headers"].forEach(I => {
                x[I] = v[I]
            }
            );
            const b = Ie.toFiniteNumber(v.headers.get("content-length"))
              , [B,S] = a && I4(b, Sx(R4(a), !0)) || [];
            v = new Response(F4(v.body, P4, B, () => {
                S && S(),
                m && m()
            }
            ),x)
        }
        c = c || "text";
        let _ = await Cx[Ie.findKey(Cx, c) || "text"](v, n);
        return !w && m && m(),
        await new Promise( (x, b) => {
            fW(x, b, {
                data: _,
                headers: oa.from(v.headers),
                status: v.status,
                statusText: v.statusText,
                config: n,
                request: d
            })
        }
        )
    } catch (p) {
        throw m && m(),
        p && p.name === "TypeError" && /fetch/i.test(p.message) ? Object.assign(new bt("Network Error",bt.ERR_NETWORK,n,d), {
            cause: p.cause || p
        }) : bt.from(p, p && p.code, n, d)
    }
}
)
  , qT = {
    http: wQe,
    xhr: ZQe,
    fetch: aHe
};
Ie.forEach(qT, (n, e) => {
    if (n) {
        try {
            Object.defineProperty(n, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(n, "adapterName", {
            value: e
        })
    }
}
);
const L4 = n => `- ${n}`
  , lHe = n => Ie.isFunction(n) || n === null || n === !1
  , gW = {
    getAdapter: n => {
        n = Ie.isArray(n) ? n : [n];
        const {length: e} = n;
        let t, r;
        const i = {};
        for (let s = 0; s < e; s++) {
            t = n[s];
            let o;
            if (r = t,
            !lHe(t) && (r = qT[(o = String(t)).toLowerCase()],
            r === void 0))
                throw new bt(`Unknown adapter '${o}'`);
            if (r)
                break;
            i[o || "#" + s] = r
        }
        if (!r) {
            const s = Object.entries(i).map( ([a,l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build"));
            let o = e ? s.length > 1 ? `since :
` + s.map(L4).join(`
`) : " " + L4(s[0]) : "as no adapter specified";
            throw new bt("There is no suitable adapter to dispatch the request " + o,"ERR_NOT_SUPPORT")
        }
        return r
    }
    ,
    adapters: qT
};
function MM(n) {
    if (n.cancelToken && n.cancelToken.throwIfRequested(),
    n.signal && n.signal.aborted)
        throw new hp(null,n)
}
function D4(n) {
    return MM(n),
    n.headers = oa.from(n.headers),
    n.data = BM.call(n, n.transformRequest),
    ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1),
    gW.getAdapter(n.adapter || vU.adapter)(n).then(function(r) {
        return MM(n),
        r.data = BM.call(n, n.transformResponse, r),
        r.headers = oa.from(r.headers),
        r
    }, function(r) {
        return uW(r) || (MM(n),
        r && r.response && (r.response.data = BM.call(n, n.transformResponse, r.response),
        r.response.headers = oa.from(r.response.headers))),
        Promise.reject(r)
    })
}
const vW = "1.7.7"
  , yU = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (n, e) => {
    yU[n] = function(r) {
        return typeof r === n || "a" + (e < 1 ? "n " : " ") + n
    }
}
);
const N4 = {};
yU.transitional = function(e, t, r) {
    function i(s, o) {
        return "[Axios v" + vW + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "")
    }
    return (s, o, a) => {
        if (e === !1)
            throw new bt(i(o, " has been removed" + (t ? " in " + t : "")),bt.ERR_DEPRECATED);
        return t && !N4[o] && (N4[o] = !0,
        console.warn(i(o, " has been deprecated since v" + t + " and will be removed in the near future"))),
        e ? e(s, o, a) : !0
    }
}
;
function cHe(n, e, t) {
    if (typeof n != "object")
        throw new bt("options must be an object",bt.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(n);
    let i = r.length;
    for (; i-- > 0; ) {
        const s = r[i]
          , o = e[s];
        if (o) {
            const a = n[s]
              , l = a === void 0 || o(a, s, n);
            if (l !== !0)
                throw new bt("option " + s + " must be " + l,bt.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (t !== !0)
            throw new bt("Unknown option " + s,bt.ERR_BAD_OPTION)
    }
}
const eI = {
    assertOptions: cHe,
    validators: yU
}
  , Fc = eI.validators;
class Tx {
    constructor(e) {
        this.defaults = e,
        this.interceptors = {
            request: new C4,
            response: new C4
        }
    }
    async request(e, t) {
        try {
            return await this._request(e, t)
        } catch (r) {
            if (r instanceof Error) {
                let i;
                Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error;
                const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s
                } catch {}
            }
            throw r
        }
    }
    _request(e, t) {
        typeof e == "string" ? (t = t || {},
        t.url = e) : t = e || {},
        t = Vu(this.defaults, t);
        const {transitional: r, paramsSerializer: i, headers: s} = t;
        r !== void 0 && eI.assertOptions(r, {
            silentJSONParsing: Fc.transitional(Fc.boolean),
            forcedJSONParsing: Fc.transitional(Fc.boolean),
            clarifyTimeoutError: Fc.transitional(Fc.boolean)
        }, !1),
        i != null && (Ie.isFunction(i) ? t.paramsSerializer = {
            serialize: i
        } : eI.assertOptions(i, {
            encode: Fc.function,
            serialize: Fc.function
        }, !0)),
        t.method = (t.method || this.defaults.method || "get").toLowerCase();
        let o = s && Ie.merge(s.common, s[t.method]);
        s && Ie.forEach(["delete", "get", "head", "post", "put", "patch", "common"], d => {
            delete s[d]
        }
        ),
        t.headers = oa.concat(o, s);
        const a = [];
        let l = !0;
        this.interceptors.request.forEach(function(m) {
            typeof m.runWhen == "function" && m.runWhen(t) === !1 || (l = l && m.synchronous,
            a.unshift(m.fulfilled, m.rejected))
        });
        const c = [];
        this.interceptors.response.forEach(function(m) {
            c.push(m.fulfilled, m.rejected)
        });
        let A, u = 0, f;
        if (!l) {
            const d = [D4.bind(this), void 0];
            for (d.unshift.apply(d, a),
            d.push.apply(d, c),
            f = d.length,
            A = Promise.resolve(t); u < f; )
                A = A.then(d[u++], d[u++]);
            return A
        }
        f = a.length;
        let h = t;
        for (u = 0; u < f; ) {
            const d = a[u++]
              , m = a[u++];
            try {
                h = d(h)
            } catch (g) {
                m.call(this, g);
                break
            }
        }
        try {
            A = D4.call(this, h)
        } catch (d) {
            return Promise.reject(d)
        }
        for (u = 0,
        f = c.length; u < f; )
            A = A.then(c[u++], c[u++]);
        return A
    }
    getUri(e) {
        e = Vu(this.defaults, e);
        const t = hW(e.baseURL, e.url);
        return lW(t, e.params, e.paramsSerializer)
    }
}
Ie.forEach(["delete", "get", "head", "options"], function(e) {
    Tx.prototype[e] = function(t, r) {
        return this.request(Vu(r || {}, {
            method: e,
            url: t,
            data: (r || {}).data
        }))
    }
});
Ie.forEach(["post", "put", "patch"], function(e) {
    function t(r) {
        return function(s, o, a) {
            return this.request(Vu(a || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    Tx.prototype[e] = t(),
    Tx.prototype[e + "Form"] = t(!0)
});
const jw = Tx;
class wU {
    constructor(e) {
        if (typeof e != "function")
            throw new TypeError("executor must be a function.");
        let t;
        this.promise = new Promise(function(s) {
            t = s
        }
        );
        const r = this;
        this.promise.then(i => {
            if (!r._listeners)
                return;
            let s = r._listeners.length;
            for (; s-- > 0; )
                r._listeners[s](i);
            r._listeners = null
        }
        ),
        this.promise.then = i => {
            let s;
            const o = new Promise(a => {
                r.subscribe(a),
                s = a
            }
            ).then(i);
            return o.cancel = function() {
                r.unsubscribe(s)
            }
            ,
            o
        }
        ,
        e(function(s, o, a) {
            r.reason || (r.reason = new hp(s,o,a),
            t(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners)
            return;
        const t = this._listeners.indexOf(e);
        t !== -1 && this._listeners.splice(t, 1)
    }
    toAbortSignal() {
        const e = new AbortController
          , t = r => {
            e.abort(r)
        }
        ;
        return this.subscribe(t),
        e.signal.unsubscribe = () => this.unsubscribe(t),
        e.signal
    }
    static source() {
        let e;
        return {
            token: new wU(function(i) {
                e = i
            }
            ),
            cancel: e
        }
    }
}
const AHe = wU;
function uHe(n) {
    return function(t) {
        return n.apply(null, t)
    }
}
function fHe(n) {
    return Ie.isObject(n) && n.isAxiosError === !0
}
const tI = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(tI).forEach( ([n,e]) => {
    tI[e] = n
}
);
const hHe = tI;
function yW(n) {
    const e = new jw(n)
      , t = $j(jw.prototype.request, e);
    return Ie.extend(t, jw.prototype, e, {
        allOwnKeys: !0
    }),
    Ie.extend(t, e, null, {
        allOwnKeys: !0
    }),
    t.create = function(i) {
        return yW(Vu(n, i))
    }
    ,
    t
}
const Cr = yW(vU);
Cr.Axios = jw;
Cr.CanceledError = hp;
Cr.CancelToken = AHe;
Cr.isCancel = uW;
Cr.VERSION = vW;
Cr.toFormData = lb;
Cr.AxiosError = bt;
Cr.Cancel = Cr.CanceledError;
Cr.all = function(e) {
    return Promise.all(e)
}
;
Cr.spread = uHe;
Cr.isAxiosError = fHe;
Cr.mergeConfig = Vu;
Cr.AxiosHeaders = oa;
Cr.formToJSON = n => AW(Ie.isHTMLForm(n) ? new FormData(n) : n);
Cr.getAdapter = gW.getAdapter;
Cr.HttpStatusCode = hHe;
Cr.default = Cr;
const dHe = Cr
  , pHe = {}.VITE_OPENSEA_KEY
  , mHe = {}.VITE_PINATA_API_KEY
  , gHe = {}.VITE_PINATA_API_SECRET
  , SM = "0x89";
let $y;
async function vHe() {
    if ($y != null)
        return $y;
    const n = new tH("https://polygon-rpc.com/")
      , t = await new ib(Mx.address,Mx.abi,n).tokenPrice();
    return $y = je.from(t).mul(1),
    $y
}
function yHe(n, e) {
    const t = {
        method: "GET",
        headers: {
            accept: "application/json",
            "x-api-key": pHe
        }
    };
    return console.log(t),
    new Promise( (r, i) => {
        fetch("https://api.opensea.io/api/v2/chain/ethereum/account/" + n + "/nfts?collection=" + e, t).then(s => {
            if (s.ok)
                return s.json();
            i("Failed to fetch data from Opensea API")
        }
        ).then(s => {
            r(s)
        }
        ).catch(s => {
            i(s)
        }
        )
    }
    )
}
async function _U() {
    if (window.ethereum)
        try {
            const n = await window.ethereum.request({
                method: "eth_chainId"
            });
            if (parseInt(n, 16) == parseInt(SM, 16)) {
                const e = await window.ethereum.request({
                    method: "eth_requestAccounts"
                });
                return e.length > 0 ? e[0] : ""
            } else
                try {
                    await window.ethereum.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: SM
                        }]
                    });
                    const e = await window.ethereum.request({
                        method: "eth_requestAccounts"
                    });
                    return e.length > 0 ? e[0] : ""
                } catch (e) {
                    console.log("polygon not find:", e);
                    try {
                        await window.ethereum.request({
                            method: "wallet_addEthereumChain",
                            params: [{
                                chainId: "0x89",
                                chainName: "Polygon Mainnet",
                                rpcUrls: ["https://polygon-rpc.com"],
                                nativeCurrency: {
                                    name: "Matic",
                                    symbol: "MATIC",
                                    decimals: 18
                                },
                                blockExplorerUrls: ["https://polygonscan.com/"]
                            }]
                        }),
                        await window.ethereum.request({
                            method: "wallet_switchEthereumChain",
                            params: [{
                                chainId: SM
                            }]
                        });
                        const t = await window.ethereum.request({
                            method: "eth_requestAccounts"
                        });
                        return t.length > 0 ? t[0] : ""
                    } catch (t) {
                        console.log("Adding polygon chain failed", t)
                    }
                }
        } catch {
            return ""
        }
    else
        return ""
}
async function CM(n, e) {
    if (!n)
        return console.warn("Error saving to pinata: No file data");
    const t = "https://api.pinata.cloud/pinning/pinFileToIPFS";
    let r = new FormData;
    return r.append("file", n, e),
    (await dHe.post(t, r, {
        maxContentLength: "Infinity",
        maxBodyLength: "Infinity",
        headers: {
            "Content-Type": `multipart/form-data; boundary=${r._boundary}`,
            pinata_api_key: mHe,
            pinata_secret_api_key: gHe
        }
    })).data
}
const wHe = n => {
    let e = [];
    return Object.keys(n).map(t => {
        Object.keys(n[t]).length !== 0 && e.push({
            trait_type: t,
            value: n[t].name
        })
    }
    ),
    e
}
;
async function _He(n, e, t, r, i) {
    if (!n)
        throw new Error("No avatar was provided");
    if (!e)
        throw new Error("No screenshot was provided");
    if (!t)
        throw new Error("No model was provided");
    const s = await _U();
    if (s == "")
        return "Please Connect Wallet";
    if (!i || await xHe(s)) {
        console.log("minting");
        let a = "AvatarImage_" + Date.now() + ".png"
          , l = await (async () => {
            for (let v = 0; v < 10; v++)
                try {
                    return await CM(e, a).catch(_ => {
                        console.error(v, "---", _)
                    }
                    )
                } catch (w) {
                    return console.warn(w),
                    w
                }
            return "Failed to upload screenshot"
        }
        )();
        const c = await _0e(t, n, 4096);
        let A;
        if (c) {
            let v = "AvatarGlb_" + Date.now() + ".glb";
            A = await (async () => {
                for (let w = 0; w < 10; w++)
                    try {
                        return await CM(c, v).catch(x => (console.error(w, "---", x),
                        "Couldn't save glb to pinata"))
                    } catch (_) {
                        return console.warn(_),
                        "Couldn't save glb to pinata"
                    }
                return "Failed to upload glb"
            }
            )()
        } else
            return "Unable to get glb";
        const u = {
            name: r || "Avatars",
            description: "Character Studio Avatars.",
            image: `ipfs://${l.IpfsHash}`,
            animation_url: `ipfs://${A.IpfsHash}`,
            attributes: wHe(n)
        }
          , f = JSON.stringify(u)
          , d = `ipfs://${(await CM(new Blob([f]), "AvatarMetadata_" + Date.now() + ".json")).IpfsHash}`;
        let m = await vHe();
        const g = new yI(window.ethereum).getSigner()
          , p = new ib(Mx.address,Mx.abi,g);
        try {
            const v = {
                value: m,
                from: s
            };
            if ((await (await p.mintToken(1, d, v)).wait()).transactionHash)
                return console.log("Mint success!"),
                "Mint success!"
        } catch {
            return "Public Mint failed."
        }
    }
}
const xHe = async n => {
    if (n) {
        const e = "0x6e58309CD851A5B124E3A56768a42d12f3B6D104"
          , t = AY("mainnet", {
            alchemy: {}.VITE_ALCHEMY_API_KEY
        })
          , i = await new ib(b4.address,b4.abi,t).beneficiaryBalanceOf(e, P4e, 1);
        return parseInt(i) > 0 ? !0 : (console.log(`Currently in alpha. You need a genesis pass to mint. 
 Will be public soon!`),
        !1)
    } else
        return console.log("Please connect your wallet"),
        !1
}
;
function bHe() {
    const {isLoading: n, setViewMode: e, setIsLoading: t} = Z.useContext(us)
      , {manifest: r, characterManager: i, animationManager: s, toggleDebugMode: o, loraDataGenerator: a, spriteAtlasGenerator: l, sceneElements: c} = Z.useContext($n)
      , [A,u] = be.useState(null)
      , [f,h] = be.useState("")
      , {playSound: d} = Z.useContext(Co)
      , {isMute: m} = Z.useContext(So);
    Z.useState(null);
    const [g,p] = Z.useState(null)
      , [v,w] = Z.useState("")
      , _ = () => {
        !m && d("backNextButton"),
        i.removeCurrentCharacter(),
        i.removeCurrentManifest(),
        o(!1),
        e(wt.LANDING)
    }
      , x = () => {
        const y = ze.mergeOptions_sel_option || 0;
        return {
            isVrm0: !0,
            createTextureAtlas: !0,
            mToonAtlasSize: Nn(ze.mergeOptions_atlas_mtoon_size || 6),
            mToonAtlasSizeTransp: Nn(ze.mergeOptions_atlas_mtoon_transp_size || 6),
            stdAtlasSize: Nn(ze.mergeOptions_atlas_std_size || 6),
            stdAtlasSizeTransp: Nn(ze.mergeOptions_atlas_std_transp_size || 6),
            exportStdAtlas: y === 0 || y == 2,
            exportMtoonAtlas: y === 1 || y == 2,
            ktxCompression: ze.merge_options_ktx_compression || !1,
            twoSidedMaterial: ze.mergeOptions_two_sided_mat || !1
        }
    }
      , b = y => {
        const E = g[y].manifestName;
        (async () => {
            (ze.mergeOptions_download_vrm_preview == null ? !0 : ze.mergeOptions_download_vrm_preview) && i.savePortraitScreenshot(E, 512, 1024, 1.5, -.1),
            (ze.mergeOptions_download_vrm == null ? !0 : ze.mergeOptions_download_vrm) && await i.downloadVRM(E, x());
            const z = new ep
              , j = c.parent;
            j.remove(c);
            const Q = ze.mergeOptions_download_lora == null ? !0 : ze.mergeOptions_download_lora;
            if (Q === !0) {
                const W = r.loras.map(async ee => a.createLoraData(ee, z));
                await Promise.all(W)
            }
            const C = ze.mergeOptions_download_sprites == null ? !0 : ze.mergeOptions_download_sprites;
            if (C === !0) {
                const W = r.sprites.map(async ee => l.createSpriteAtlas(ee, z));
                await Promise.all(W)
            }
            (Q === !0 || C === !0) && z.saveZip(g[y].manifestName),
            j.add(c),
            y < g.length - 1 ? (console.log("downloaded " + E),
            B(y + 1)) : t(!1)
        }
        )()
    }
      , B = async y => {
        y == 0 ? (console.log(r.loras[0]),
        b(y)) : (await i.setManifest(g[y]),
        t(!0),
        i.loadInitialTraits().then(async () => {
            await (R => new Promise(F => setTimeout(F, R)))(1),
            b(y)
        }
        ))
    }
      , S = () => {
        t(!0),
        B(0)
    }
      , {t: I} = be.useContext(fa)
      , M = async y => {
        if (i.getCurrentCharacterModel()) {
            const R = Kl(y.name)
              , F = URL.createObjectURL(y);
            await s.loadAnimation(F, !1, 0, !0, "", R),
            w(s.getCurrentAnimationName()),
            URL.revokeObjectURL(F)
        } else
            console.warn("Please load a vrm model to test animations.")
    }
      , L = async y => {
        const E = URL.createObjectURL(y);
        await i.loadOptimizerCharacter(E),
        URL.revokeObjectURL(E);
        const R = Kl(y.name);
        h(R),
        u(i.getCurrentCharacterModel())
    }
      , D = y => {
        const E = Array.from(y)
          , R = []
          , F = O => new Promise( (z, j) => {
            if (O && O.name.toLowerCase().endsWith(".json")) {
                const Q = new FileReader
                  , C = O.name.replace(/\.[^/.]+$/, "");
                Q.onload = function(W) {
                    try {
                        const ee = JSON.parse(W.target.result)
                          , P = ee.thumbnail;
                        ee.manifestName = C,
                        R.push(ee),
                        z()
                    } catch (ee) {
                        console.error("Error parsing the JSON file:", ee),
                        j(ee)
                    }
                }
                ,
                Q.readAsText(O)
            }
        }
        );
        Promise.all(E.map(F)).then( () => {
            R.length > 0 && (p(R),
            i.setManifest(R[0]),
            t(!0),
            i.loadInitialTraits().then( () => {
                t(!1)
            }
            ))
        }
        ).catch(O => {
            console.error("Error processing files:", O)
        }
        )
    }
      , T = async y => {
        const E = y[0];
        E && E.name.toLowerCase().endsWith(".fbx") && M(E),
        E && E.name.toLowerCase().endsWith(".vrm") && L(E),
        E && E.name.toLowerCase().endsWith(".json") && D(y)
    }
    ;
    return k.jsxs("div", {
        className: Oi.container,
        children: [k.jsx("div", {
            className: `loadingIndicator ${n ? "active" : ""}`,
            children: k.jsx("img", {
                className: "rotate",
                src: "ui/loading.svg"
            })
        }), k.jsx("div", {
            className: "sectionTitle",
            children: "NFT Characters"
        }), k.jsx(S0, {
            onFilesDrop: T
        }), k.jsx(nb, {
            showDropToDownload: !0,
            showCreateAtlas: !1,
            mergeMenuTitle: "Download Options"
        }), k.jsx(fU, {
            model: A
        }), k.jsx(w2, {
            jsonSelectionArray: g,
            byManifest: !0
        }), (g == null ? void 0 : g.length) > 0 && k.jsx(k1, {
            loadedAnimationName: v
        }), k.jsxs("div", {
            className: Oi.buttonContainer,
            children: [k.jsx(Bn, {
                theme: "light",
                text: I("callToAction.back"),
                size: 14,
                className: Oi.buttonLeft,
                onClick: _
            }), (g == null ? void 0 : g.length) == 1 && k.jsx(Bn, {
                theme: "light",
                text: "Download",
                size: 14,
                className: Oi.buttonRight,
                onClick: S
            }), (g == null ? void 0 : g.length) > 1 && k.jsx(Bn, {
                theme: "light",
                text: "Download All",
                size: 14,
                className: Oi.buttonRight,
                onClick: S
            })]
        })]
    })
}
const EHe = "_classdisabled_hpzv8_1"
  , BHe = "_container_hpzv8_6"
  , MHe = "_classContainer_hpzv8_14"
  , SHe = "_icon_hpzv8_39"
  , CHe = "_name_hpzv8_70"
  , THe = "_description_hpzv8_79"
  , IHe = "_classFrame_hpzv8_84"
  , RHe = "_frameContainer_hpzv8_104"
  , UHe = "_frame_hpzv8_104"
  , FHe = "_image_hpzv8_114"
  , PHe = "_lockedContainer_hpzv8_120"
  , LHe = "_locked_hpzv8_120"
  , DHe = "_buttonContainer_hpzv8_134"
  , NHe = "_buttonLeft_hpzv8_143"
  , OHe = "_buttonRight_hpzv8_147"
  , kHe = "_buttonCenter_hpzv8_151"
  , QHe = "_topLine_hpzv8_165"
  , HHe = "_bottomLine_hpzv8_191"
  , ht = {
    classdisabled: EHe,
    container: BHe,
    classContainer: MHe,
    class: "_class_hpzv8_1",
    icon: SHe,
    name: CHe,
    description: THe,
    classFrame: IHe,
    frameContainer: RHe,
    frame: UHe,
    image: FHe,
    lockedContainer: PHe,
    locked: LHe,
    buttonContainer: DHe,
    buttonLeft: NHe,
    buttonRight: OHe,
    buttonCenter: kHe,
    topLine: QHe,
    bottomLine: HHe
};
function zHe() {
    const {t: n} = be.useContext(fa)
      , {setViewMode: e, setIsLoading: t, isLoading: r} = Z.useContext(us)
      , {playSound: i} = Z.useContext(Co)
      , {isMute: s} = Z.useContext(So)
      , {manifest: o, characterManager: a} = Z.useContext($n)
      , [l,c] = be.useState([]);
    be.useEffect( () => {
        if ((o == null ? void 0 : o.characters) != null) {
            const d = o.characters.map(m => ({
                name: m.name,
                image: m.portrait,
                description: m.description,
                manifest: m.manifest,
                icon: m.icon,
                format: m.format,
                disabled: !1
            }));
            c(d)
        }
    }
    , [o]);
    const A = () => {
        e(wt.LANDING),
        !s && i("backNextButton")
    }
      , u = async d => {
        t(!0),
        a.loadManifest(o.characters[d].manifest).then( () => {
            e(wt.BATCHDOWNLOAD),
            a.loadInitialTraits().then( () => {
                t(!1)
            }
            )
        }
        ),
        !s && i("classSelect")
    }
      , f = () => {
        e(wt.BATCHMANIFEST)
    }
      , h = () => {
        !s && i("classMouseOver")
    }
    ;
    return k.jsxs("div", {
        className: `${ht.container} horizontalScroll`,
        children: [k.jsx("div", {
            className: "sectionTitle",
            children: n("pageTitles.chooseClass")
        }), k.jsx("div", {
            className: ht.vrmOptimizerButton
        }), k.jsx("div", {
            className: ht.topLine
        }), k.jsxs("div", {
            className: ht.classContainer,
            children: [l.map( (d, m) => k.jsxs("div", {
                className: d.disabled ? ht.classdisabled : ht.class,
                onClick: d.disabled ? null : () => u(m),
                onMouseOver: d.disabled ? null : () => h(),
                children: [k.jsxs("div", {
                    className: ht.classFrame,
                    style: {
                        backgroundImage: `url(${d.image})`
                    },
                    children: [k.jsx("div", {
                        className: ht.frameContainer,
                        children: k.jsx("img", {
                            src: "./public/assets/backgrounds/class-frame.svg",
                            className: ht.frame
                        })
                    }), k.jsx("div", {
                        className: ht.lockedContainer,
                        children: d.disabled && k.jsx("img", {
                            src: "./public/assets/icons/locked.svg",
                            className: ht.locked
                        })
                    })]
                }), k.jsx("div", {
                    className: ht.name,
                    children: d.name
                }), k.jsx("div", {
                    className: ht.description,
                    children: d.description
                })]
            }, m)), k.jsxs("div", {
                className: ht.class,
                onClick: () => f(),
                onMouseOver: () => h(),
                children: [k.jsx("div", {
                    className: ht.classFrame,
                    style: {
                        backgroundImage: "url(./public/assets/media/disabled.png)"
                    },
                    children: k.jsx("div", {
                        className: ht.frameContainer,
                        children: k.jsx("img", {
                            src: "./public/assets/backgrounds/class-frame.svg",
                            className: ht.frame
                        })
                    })
                }), k.jsx("div", {
                    className: ht.name,
                    children: "Manifest"
                }), k.jsx("div", {
                    className: ht.description,
                    children: "Load by manifest"
                })]
            }, "manifest-load")]
        }), k.jsx("div", {
            className: ht.bottomLine
        }), k.jsx("div", {
            className: ht.buttonContainer,
            children: k.jsx(Bn, {
                theme: "light",
                text: n("callToAction.back"),
                size: 14,
                className: ht.buttonLeft,
                onClick: A
            })
        })]
    })
}
function GHe() {
    const {t: n} = be.useContext(fa)
      , {setViewMode: e, setIsLoading: t, isLoading: r} = Z.useContext(us)
      , {playSound: i} = Z.useContext(Co)
      , {isMute: s} = Z.useContext(So)
      , {manifest: o, characterManager: a} = Z.useContext($n)
      , [l,c] = be.useState([]);
    be.useEffect( () => {
        if ((o == null ? void 0 : o.characters) != null) {
            const h = o.characters.map(d => ({
                name: d.name,
                image: d.portrait,
                description: d.description,
                manifest: d.manifest,
                icon: d.icon,
                format: d.format,
                disabled: !1
            }));
            c(h)
        }
    }
    , [o]);
    const A = () => {
        e(wt.LANDING),
        !s && i("backNextButton")
    }
      , u = async h => {
        t(!0),
        a.loadManifest(o.characters[h].manifest).then( () => {
            e(wt.APPEARANCE),
            a.loadInitialTraits().then( () => {
                t(!1)
            }
            )
        }
        ),
        !s && i("classSelect")
    }
      , f = () => {
        !s && i("classMouseOver")
    }
    ;
    return k.jsxs("div", {
        className: `${ht.container} horizontalScroll`,
        children: [k.jsx("div", {
            className: "sectionTitle",
            children: n("pageTitles.chooseClass")
        }), k.jsx("div", {
            className: ht.vrmOptimizerButton
        }), k.jsx("div", {
            className: ht.topLine
        }), k.jsx("div", {
            className: ht.classContainer,
            children: l.map( (h, d) => k.jsxs("div", {
                className: h.disabled ? ht.classdisabled : ht.class,
                onClick: h.disabled ? null : () => u(d),
                onMouseOver: h.disabled ? null : () => f(),
                children: [k.jsxs("div", {
                    className: ht.classFrame,
                    style: {
                        backgroundImage: `url(${h.image})`
                    },
                    children: [k.jsx("div", {
                        className: ht.frameContainer,
                        children: k.jsx("img", {
                            src: "./public/assets/backgrounds/class-frame.svg",
                            className: ht.frame
                        })
                    }), k.jsx("div", {
                        className: ht.lockedContainer,
                        children: h.disabled && k.jsx("img", {
                            src: "./public/assets/icons/locked.svg",
                            className: ht.locked
                        })
                    })]
                }), k.jsx("div", {
                    className: ht.name,
                    children: h.name
                }), k.jsx("div", {
                    className: ht.description,
                    children: h.description
                })]
            }, d))
        }), k.jsx("div", {
            className: ht.bottomLine
        }), k.jsx("div", {
            className: ht.buttonContainer,
            children: k.jsx(Bn, {
                theme: "light",
                text: n("callToAction.back"),
                size: 14,
                className: ht.buttonLeft,
                onClick: A
            })
        })]
    })
}
const VHe = "_buttonContainer_1ueuk_1"
  , jHe = "_button_1ueuk_1"
  , Wf = {
    buttonContainer: VHe,
    button: jHe
}
  , O4 = {}.VITE_OPENSEA_KEY;
function WHe() {
    const {setViewMode: n} = Z.useContext(us)
      , {playSound: e} = Z.useContext(Co)
      , {isMute: t} = Z.useContext(So)
      , {characterManager: r} = Z.useContext($n)
      , i = () => {
        n(wt.CREATE),
        !t && e("backNextButton")
    }
      , s = () => {
        n(wt.CLAIM),
        !t && e("backNextButton")
    }
      , o = () => {
        n(wt.OPTIMIZER),
        r.loadOptimizerManifest(),
        !t && e("backNextButton")
    }
      , a = async () => {
        await _U() != "" && n(wt.WALLET),
        !t && e("backNextButton")
    }
    ;
    return k.jsx("div", {
        className: Wf.container,
        children: k.jsxs("div", {
            className: Wf.buttonContainer,
            children: [k.jsx("button", {
                className: Wf.button,
                onClick: i,
                children: k.jsx("img", {
                    src: "./public/assets/media/btn_create_character.png"
                })
            }), k.jsx("button", {
                className: Wf.button,
                onClick: s,
                children: k.jsx("img", {
                    src: "./public/assets/media/btn_batch_download_character.png"
                })
            }), k.jsx("button", {
                className: Wf.button,
                onClick: o,
                children: k.jsx("img", {
                    src: "./public/assets/media/btn_optimize_character.png"
                })
            }), O4 && O4 != "" && k.jsx("button", {
                className: Wf.button,
                onClick: a,
                children: k.jsx("img", {
                    src: "./public/assets/media/btn_optimize_character.png"
                })
            })]
        })
    })
}
const qA = {};
var xU = {
    exports: {}
}, fd = typeof Reflect == "object" ? Reflect : null, k4 = fd && typeof fd.apply == "function" ? fd.apply : function(e, t, r) {
    return Function.prototype.apply.call(e, t, r)
}
, Ww;
fd && typeof fd.ownKeys == "function" ? Ww = fd.ownKeys : Object.getOwnPropertySymbols ? Ww = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
}
: Ww = function(e) {
    return Object.getOwnPropertyNames(e)
}
;
function KHe(n) {
    console && console.warn && console.warn(n)
}
var wW = Number.isNaN || function(e) {
    return e !== e
}
;
function gn() {
    gn.init.call(this)
}
xU.exports = gn;
xU.exports.once = ZHe;
gn.EventEmitter = gn;
gn.prototype._events = void 0;
gn.prototype._eventsCount = 0;
gn.prototype._maxListeners = void 0;
var Q4 = 10;
function ub(n) {
    if (typeof n != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n)
}
Object.defineProperty(gn, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return Q4
    },
    set: function(n) {
        if (typeof n != "number" || n < 0 || wW(n))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
        Q4 = n
    }
});
gn.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
    this._eventsCount = 0),
    this._maxListeners = this._maxListeners || void 0
}
;
gn.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || wW(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e,
    this
}
;
function _W(n) {
    return n._maxListeners === void 0 ? gn.defaultMaxListeners : n._maxListeners
}
gn.prototype.getMaxListeners = function() {
    return _W(this)
}
;
gn.prototype.emit = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
        t.push(arguments[r]);
    var i = e === "error"
      , s = this._events;
    if (s !== void 0)
        i = i && s.error === void 0;
    else if (!i)
        return !1;
    if (i) {
        var o;
        if (t.length > 0 && (o = t[0]),
        o instanceof Error)
            throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o,
        a
    }
    var l = s[e];
    if (l === void 0)
        return !1;
    if (typeof l == "function")
        k4(l, this, t);
    else
        for (var c = l.length, A = MW(l, c), r = 0; r < c; ++r)
            k4(A[r], this, t);
    return !0
}
;
function xW(n, e, t, r) {
    var i, s, o;
    if (ub(t),
    s = n._events,
    s === void 0 ? (s = n._events = Object.create(null),
    n._eventsCount = 0) : (s.newListener !== void 0 && (n.emit("newListener", e, t.listener ? t.listener : t),
    s = n._events),
    o = s[e]),
    o === void 0)
        o = s[e] = t,
        ++n._eventsCount;
    else if (typeof o == "function" ? o = s[e] = r ? [t, o] : [o, t] : r ? o.unshift(t) : o.push(t),
    i = _W(n),
    i > 0 && o.length > i && !o.warned) {
        o.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning",
        a.emitter = n,
        a.type = e,
        a.count = o.length,
        KHe(a)
    }
    return n
}
gn.prototype.addListener = function(e, t) {
    return xW(this, e, t, !1)
}
;
gn.prototype.on = gn.prototype.addListener;
gn.prototype.prependListener = function(e, t) {
    return xW(this, e, t, !0)
}
;
function XHe() {
    if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn),
        this.fired = !0,
        arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
}
function bW(n, e, t) {
    var r = {
        fired: !1,
        wrapFn: void 0,
        target: n,
        type: e,
        listener: t
    }
      , i = XHe.bind(r);
    return i.listener = t,
    r.wrapFn = i,
    i
}
gn.prototype.once = function(e, t) {
    return ub(t),
    this.on(e, bW(this, e, t)),
    this
}
;
gn.prototype.prependOnceListener = function(e, t) {
    return ub(t),
    this.prependListener(e, bW(this, e, t)),
    this
}
;
gn.prototype.removeListener = function(e, t) {
    var r, i, s, o, a;
    if (ub(t),
    i = this._events,
    i === void 0)
        return this;
    if (r = i[e],
    r === void 0)
        return this;
    if (r === t || r.listener === t)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e],
        i.removeListener && this.emit("removeListener", e, r.listener || t));
    else if (typeof r != "function") {
        for (s = -1,
        o = r.length - 1; o >= 0; o--)
            if (r[o] === t || r[o].listener === t) {
                a = r[o].listener,
                s = o;
                break
            }
        if (s < 0)
            return this;
        s === 0 ? r.shift() : YHe(r, s),
        r.length === 1 && (i[e] = r[0]),
        i.removeListener !== void 0 && this.emit("removeListener", e, a || t)
    }
    return this
}
;
gn.prototype.off = gn.prototype.removeListener;
gn.prototype.removeAllListeners = function(e) {
    var t, r, i;
    if (r = this._events,
    r === void 0)
        return this;
    if (r.removeListener === void 0)
        return arguments.length === 0 ? (this._events = Object.create(null),
        this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]),
        this;
    if (arguments.length === 0) {
        var s = Object.keys(r), o;
        for (i = 0; i < s.length; ++i)
            o = s[i],
            o !== "removeListener" && this.removeAllListeners(o);
        return this.removeAllListeners("removeListener"),
        this._events = Object.create(null),
        this._eventsCount = 0,
        this
    }
    if (t = r[e],
    typeof t == "function")
        this.removeListener(e, t);
    else if (t !== void 0)
        for (i = t.length - 1; i >= 0; i--)
            this.removeListener(e, t[i]);
    return this
}
;
function EW(n, e, t) {
    var r = n._events;
    if (r === void 0)
        return [];
    var i = r[e];
    return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? $He(i) : MW(i, i.length)
}
gn.prototype.listeners = function(e) {
    return EW(this, e, !0)
}
;
gn.prototype.rawListeners = function(e) {
    return EW(this, e, !1)
}
;
gn.listenerCount = function(n, e) {
    return typeof n.listenerCount == "function" ? n.listenerCount(e) : BW.call(n, e)
}
;
gn.prototype.listenerCount = BW;
function BW(n) {
    var e = this._events;
    if (e !== void 0) {
        var t = e[n];
        if (typeof t == "function")
            return 1;
        if (t !== void 0)
            return t.length
    }
    return 0
}
gn.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Ww(this._events) : []
}
;
function MW(n, e) {
    for (var t = new Array(e), r = 0; r < e; ++r)
        t[r] = n[r];
    return t
}
function YHe(n, e) {
    for (; e + 1 < n.length; e++)
        n[e] = n[e + 1];
    n.pop()
}
function $He(n) {
    for (var e = new Array(n.length), t = 0; t < e.length; ++t)
        e[t] = n[t].listener || n[t];
    return e
}
function ZHe(n, e) {
    return new Promise(function(t, r) {
        function i(o) {
            n.removeListener(e, s),
            r(o)
        }
        function s() {
            typeof n.removeListener == "function" && n.removeListener("error", i),
            t([].slice.call(arguments))
        }
        SW(n, e, s, {
            once: !0
        }),
        e !== "error" && JHe(n, i, {
            once: !0
        })
    }
    )
}
function JHe(n, e, t) {
    typeof n.on == "function" && SW(n, "error", e, t)
}
function SW(n, e, t, r) {
    if (typeof n.on == "function")
        r.once ? n.once(e, t) : n.on(e, t);
    else if (typeof n.addEventListener == "function")
        n.addEventListener(e, function i(s) {
            r.once && n.removeEventListener(e, i),
            t(s)
        });
    else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n)
}
var qHe = xU.exports;
function e5e(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    n.__proto__ = e
}
var t5e = function(n) {
    e5e(e, n);
    function e(r) {
        var i, s = r === void 0 ? {} : r, o = s.supportedChainIds;
        return i = n.call(this) || this,
        i.supportedChainIds = o,
        i
    }
    var t = e.prototype;
    return t.emitUpdate = function(i) {
        this.emit(Yo.Update, i)
    }
    ,
    t.emitError = function(i) {
        this.emit(Yo.Error, i)
    }
    ,
    t.emitDeactivate = function() {
        this.emit(Yo.Deactivate)
    }
    ,
    e
}(qHe.EventEmitter);
function nI() {
    return nI = Object.assign || function(n) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    ,
    nI.apply(this, arguments)
}
function bU(n, e) {
    n.prototype = Object.create(e.prototype),
    n.prototype.constructor = n,
    n.__proto__ = e
}
function rI(n) {
    return rI = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }
    ,
    rI(n)
}
function Ix(n, e) {
    return Ix = Object.setPrototypeOf || function(r, i) {
        return r.__proto__ = i,
        r
    }
    ,
    Ix(n, e)
}
function n5e() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function Kw(n, e, t) {
    return n5e() ? Kw = Reflect.construct : Kw = function(i, s, o) {
        var a = [null];
        a.push.apply(a, s);
        var l = Function.bind.apply(i, a)
          , c = new l;
        return o && Ix(c, o.prototype),
        c
    }
    ,
    Kw.apply(null, arguments)
}
function r5e(n) {
    return Function.toString.call(n).indexOf("[native code]") !== -1
}
function Rx(n) {
    var e = typeof Map == "function" ? new Map : void 0;
    return Rx = function(r) {
        if (r === null || !r5e(r))
            return r;
        if (typeof r != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(r))
                return e.get(r);
            e.set(r, i)
        }
        function i() {
            return Kw(r, arguments, rI(this).constructor)
        }
        return i.prototype = Object.create(r.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        Ix(i, r)
    }
    ,
    Rx(n)
}
function Zy(n) {
    if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return n
}
typeof Symbol < "u" && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")));
typeof Symbol < "u" && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
function Kf(n, e) {
    try {
        var t = n()
    } catch (r) {
        return e(r)
    }
    return t && t.then ? t.then(void 0, e) : t
}
function Ea(n) {
    return n.hasOwnProperty("result") ? n.result : n
}
var TM = function(n) {
    bU(e, n);
    function e() {
        var t;
        return t = n.call(this) || this,
        t.name = t.constructor.name,
        t.message = "No Ethereum provider was found on window.ethereum.",
        t
    }
    return e
}(Rx(Error))
  , i5e = function(n) {
    bU(e, n);
    function e() {
        var t;
        return t = n.call(this) || this,
        t.name = t.constructor.name,
        t.message = "The user rejected the request.",
        t
    }
    return e
}(Rx(Error))
  , s5e = function(n) {
    bU(e, n);
    function e(r) {
        var i;
        return i = n.call(this, r) || this,
        i.handleNetworkChanged = i.handleNetworkChanged.bind(Zy(i)),
        i.handleChainChanged = i.handleChainChanged.bind(Zy(i)),
        i.handleAccountsChanged = i.handleAccountsChanged.bind(Zy(i)),
        i.handleClose = i.handleClose.bind(Zy(i)),
        i
    }
    var t = e.prototype;
    return t.handleChainChanged = function(i) {
        this.emitUpdate({
            chainId: i,
            provider: window.ethereum
        })
    }
    ,
    t.handleAccountsChanged = function(i) {
        i.length === 0 ? this.emitDeactivate() : this.emitUpdate({
            account: i[0]
        })
    }
    ,
    t.handleClose = function(i, s) {
        this.emitDeactivate()
    }
    ,
    t.handleNetworkChanged = function(i) {
        this.emitUpdate({
            chainId: i,
            provider: window.ethereum
        })
    }
    ,
    t.activate = function() {
        try {
            var i = function(A) {
                if (s)
                    return A;
                function u() {
                    return nI({
                        provider: window.ethereum
                    }, a ? {
                        account: a
                    } : {})
                }
                var f = function() {
                    if (!a)
                        return Promise.resolve(window.ethereum.enable().then(function(h) {
                            return h && Ea(h)[0]
                        })).then(function(h) {
                            a = h
                        })
                }();
                return f && f.then ? f.then(u) : u(f)
            }
              , s = !1
              , o = this;
            if (!window.ethereum)
                throw new TM;
            window.ethereum.on && (window.ethereum.on("chainChanged", o.handleChainChanged),
            window.ethereum.on("accountsChanged", o.handleAccountsChanged),
            window.ethereum.on("close", o.handleClose),
            window.ethereum.on("networkChanged", o.handleNetworkChanged)),
            window.ethereum.isMetaMask && (window.ethereum.autoRefreshOnNetworkChange = !1);
            var a, l = Kf(function() {
                return Promise.resolve(window.ethereum.send("eth_requestAccounts").then(function(c) {
                    return Ea(c)[0]
                })).then(function(c) {
                    a = c
                })
            }, function(c) {
                if (c.code === 4001)
                    throw new i5e
            });
            return Promise.resolve(l && l.then ? l.then(i) : i(l))
        } catch (c) {
            return Promise.reject(c)
        }
    }
    ,
    t.getProvider = function() {
        try {
            return Promise.resolve(window.ethereum)
        } catch (i) {
            return Promise.reject(i)
        }
    }
    ,
    t.getChainId = function() {
        try {
            var i = function() {
                function l() {
                    if (!s)
                        try {
                            s = Ea(window.ethereum.send({
                                method: "net_version"
                            }))
                        } catch {}
                    return s || (window.ethereum.isDapper ? s = Ea(window.ethereum.cachedResults.net_version) : s = window.ethereum.chainId || window.ethereum.netVersion || window.ethereum.networkVersion || window.ethereum._chainId),
                    s
                }
                var c = function() {
                    if (!s) {
                        var A = Kf(function() {
                            return Promise.resolve(window.ethereum.send("net_version").then(Ea)).then(function(u) {
                                s = u
                            })
                        }, function() {});
                        if (A && A.then)
                            return A.then(function() {})
                    }
                }();
                return c && c.then ? c.then(l) : l(c)
            };
            if (!window.ethereum)
                throw new TM;
            var s, o = Kf(function() {
                return Promise.resolve(window.ethereum.send("eth_chainId").then(Ea)).then(function(a) {
                    s = a
                })
            }, function() {});
            return Promise.resolve(o && o.then ? o.then(i) : i(o))
        } catch (a) {
            return Promise.reject(a)
        }
    }
    ,
    t.getAccount = function() {
        try {
            var i = function() {
                function l() {
                    return s || (s = Ea(window.ethereum.send({
                        method: "eth_accounts"
                    }))[0]),
                    s
                }
                var c = function() {
                    if (!s) {
                        var A = Kf(function() {
                            return Promise.resolve(window.ethereum.enable().then(function(u) {
                                return Ea(u)[0]
                            })).then(function(u) {
                                s = u
                            })
                        }, function() {});
                        if (A && A.then)
                            return A.then(function() {})
                    }
                }();
                return c && c.then ? c.then(l) : l(c)
            };
            if (!window.ethereum)
                throw new TM;
            var s, o = Kf(function() {
                return Promise.resolve(window.ethereum.send("eth_accounts").then(function(a) {
                    return Ea(a)[0]
                })).then(function(a) {
                    s = a
                })
            }, function() {});
            return Promise.resolve(o && o.then ? o.then(i) : i(o))
        } catch (a) {
            return Promise.reject(a)
        }
    }
    ,
    t.deactivate = function() {
        window.ethereum && window.ethereum.removeListener && (window.ethereum.removeListener("chainChanged", this.handleChainChanged),
        window.ethereum.removeListener("accountsChanged", this.handleAccountsChanged),
        window.ethereum.removeListener("close", this.handleClose),
        window.ethereum.removeListener("networkChanged", this.handleNetworkChanged))
    }
    ,
    t.isAuthorized = function() {
        try {
            return window.ethereum ? Promise.resolve(Kf(function() {
                return Promise.resolve(window.ethereum.send("eth_accounts").then(function(i) {
                    return Ea(i).length > 0
                }))
            }, function() {
                return !1
            })) : Promise.resolve(!1)
        } catch (i) {
            return Promise.reject(i)
        }
    }
    ,
    e
}(t5e);
function o5e() {
    const {account: n, library: e, activate: t} = yY()
      , [r,i] = be.useState([])
      , {setViewMode: s} = Z.useContext(us)
      , {playSound: o} = Z.useContext(Co)
      , {isMute: a} = Z.useContext(So)
      , l = new s5e({
        supportedChainIds: [137, 1, 3, 4, 5, 42, 97]
    });
    be.useEffect( () => {
        if (n && e) {
            const f = "0x69341F01C2113E2d09Cd4837bbF1786dfbBc41d7"
              , h = ["function balanceOf(address owner) external view returns (uint256)", "function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256)", "function tokenURI(uint256 tokenId) external view returns (string)"]
              , d = new ib(f,h,e);
            d.balanceOf(n).then(m => {
                const g = [];
                for (let p = 0; p < m; p++)
                    g.push(d.tokenOfOwnerByIndex(n, p));
                Promise.all(g).then(p => {
                    const v = p.map(w => d.tokenURI(w));
                    Promise.all(v).then(w => {
                        i(w)
                    }
                    )
                }
                )
            }
            )
        }
    }
    , [n, e]);
    const c = () => {
        t(l)
    }
      , A = f => {
        !a && o("backNextButton"),
        s(wt.APPEARANCE)
    }
      , u = () => {
        s(wt.LANDING),
        !a && o("backNextButton")
    }
    ;
    return k.jsxs("div", {
        className: qA.container,
        children: [!n && k.jsxs("div", {
            className: qA.message,
            children: ["Please connect your wallet to load your characters", k.jsx("button", {
                className: qA.button,
                onClick: () => c(),
                children: "Connect"
            })]
        }), k.jsxs("div", {
            className: qA.characterContainer,
            children: [k.jsx("div", {
                className: qA.title,
                children: "Load Character"
            }), r.map( (f, h) => k.jsx("div", {
                className: qA.character,
                onClick: () => {
                    A()
                }
                ,
                children: JSON.stringify(f)
            }, h))]
        }), k.jsx("button", {
            className: qA.button,
            onClick: () => u(),
            children: "Back"
        })]
    })
}
const a5e = "_container_q73cc_1"
  , l5e = "_mintContainer_q73cc_6"
  , c5e = "_mainTitleWrap_q73cc_33"
  , A5e = "_mainTitle_q73cc_33"
  , u5e = "_mintButtonContainer_q73cc_49"
  , f5e = "_mintButton_q73cc_49"
  , h5e = "_genesisText_q73cc_60"
  , d5e = "_required_q73cc_64"
  , p5e = "_divider_q73cc_68"
  , m5e = "_bottomContainer_q73cc_75"
  , g5e = "_mintInfo_q73cc_85"
  , v5e = "_topLine_q73cc_91"
  , y5e = "_bottomLine_q73cc_104"
  , Wi = {
    container: a5e,
    mintContainer: l5e,
    mainTitleWrap: c5e,
    mainTitle: A5e,
    mintButtonContainer: u5e,
    mintButton: f5e,
    genesisText: h5e,
    required: d5e,
    divider: p5e,
    bottomContainer: m5e,
    mintInfo: g5e,
    topLine: v5e,
    bottomLine: y5e
};
function w5e() {
    const {model: n, avatar: e} = Z.useContext($n)
      , {setViewMode: t} = Z.useContext(us)
      , {playSound: r} = Z.useContext(Co)
      , {isMute: i} = Z.useContext(So)
      , [s,o] = Z.useState("")
      , [a,l] = Z.useState(!1)
      , c = () => {
        t(wt.SAVE),
        !i && r("backNextButton")
    }
    ;
    function A() {
        return k.jsxs("div", {
            className: Wi.mainTitleWrap,
            children: [k.jsx("div", {
                className: Wi.topLine
            }), k.jsx("div", {
                className: Wi.mainTitle,
                children: "Mint"
            })]
        })
    }
    async function u() {
        !i && r("backNextButton"),
        l(!0),
        o("Please check your wallet");
        const d = await _He(e, null, n, {
            name: "XXXRestore"
        }.name);
        o(d),
        l(!1),
        console.log(d)
    }
    return k.jsxs("div", {
        className: Wi.container,
        children: [k.jsx("div", {
            className: "sectionTitle",
            children: "Mint Your Character"
        }), k.jsxs("div", {
            className: Wi.mintContainer,
            children: [k.jsx(A, {}), k.jsxs("div", {
                className: Wi.mintButtonContainer,
                children: [k.jsx(Bn, {
                    size: 16,
                    theme: "light",
                    icon: "polygon",
                    text: a ? "Minting..." : "Open Edition",
                    className: Wi.mintButton,
                    disabled: a,
                    onClick: u,
                    minWidth: 220
                }), k.jsx("div", {
                    className: Wi.divider
                }), k.jsx(Bn, {
                    size: 16,
                    theme: "light",
                    icon: "tokens",
                    text: "Genesis Edition",
                    className: Wi.mintButton,
                    disabled: !0,
                    minWidth: 220
                }), k.jsxs("span", {
                    className: Wi.genesisText,
                    children: ["(", k.jsx("span", {
                        className: Wi.required,
                        children: "Coming Soon!"
                    }), ")"]
                })]
            }), k.jsxs("span", {
                className: Wi.mintInfo,
                children: [s, " "]
            })]
        }), k.jsx("div", {
            className: Wi.bottomContainer,
            children: k.jsx(Bn, {
                theme: "light",
                text: "Back",
                size: 14,
                className: Wi.buttonLeft,
                onClick: c
            })
        })]
    })
}
function _5e() {
    const {isLoading: n, setViewMode: e} = Z.useContext(us)
      , {manifest: t, characterManager: r, animationManager: i, sceneElements: s, loraDataGenerator: o, spriteAtlasGenerator: a} = Z.useContext($n)
      , {playSound: l} = Z.useContext(Co)
      , {isMute: c} = Z.useContext(So)
      , [A,u] = be.useState(null)
      , [f,h] = be.useState("")
      , [d,m] = be.useState([])
      , [g,p] = be.useState(0)
      , [v,w] = Z.useState("T-Pose")
      , _ = () => {
        !c && l("backNextButton"),
        r.removeCurrentCharacter(),
        r.removeCurrentManifest(),
        e(wt.LANDING)
    }
      , x = () => {
        const E = ze.mergeOptions_sel_option || 0;
        return {
            isVrm0: !0,
            createTextureAtlas: !0,
            mToonAtlasSize: Nn(ze.mergeOptions_atlas_mtoon_size || 6),
            mToonAtlasSizeTransp: Nn(ze.mergeOptions_atlas_mtoon_transp_size || 6),
            stdAtlasSize: Nn(ze.mergeOptions_atlas_std_size || 6),
            stdAtlasSizeTransp: Nn(ze.mergeOptions_atlas_std_transp_size || 6),
            exportStdAtlas: E === 0 || E == 2,
            exportMtoonAtlas: E === 1 || E == 2,
            ktxCompression: ze.merge_options_ktx_compression || !1,
            twoSidedMaterial: ze.mergeOptions_two_sided_mat || !1
        }
    }
      , b = async () => {
        for (let E = 0; E < d.length; E++)
            try {
                await D(d[E]);
                const R = Kl(d[E].name);
                await B(R)
            } catch (R) {
                console.error(`Error processing ${d[E].name}:`, R)
            }
    }
      , B = async E => {
        typeof E != "string" && (E = f),
        await (async () => {
            var W;
            (ze.mergeOptions_download_vrm_preview == null ? !0 : ze.mergeOptions_download_vrm_preview) && r.savePortraitScreenshot(E + "_portrait", 512, 1024, 1.5, -.1),
            (ze.mergeOptions_download_vrm == null ? !0 : ze.mergeOptions_download_vrm) && await r.downloadVRM(E + "_merged", x());
            const z = new ep
              , j = s.parent;
            j.remove(s),
            (W = r.getCurrentOptimizerCharacterModel().data) == null || W.isVRM0;
            const Q = ze.mergeOptions_download_lora == null ? !0 : ze.mergeOptions_download_lora;
            if (Q === !0) {
                const ee = t.loras.map(async P => o.createLoraData(P, z));
                await Promise.all(ee)
            }
            const C = ze.mergeOptions_download_sprites == null ? !0 : ze.mergeOptions_download_sprites;
            if (C === !0) {
                const ee = t.sprites.map(async P => a.createSpriteAtlas(P, z));
                await Promise.all(ee)
            }
            (Q === !0 || C === !0) && z.saveZip(E),
            j.add(s)
        }
        )()
    }
      , {t: S} = be.useContext(fa)
      , I = async E => {
        if (r.getCurrentOptimizerCharacterModel()) {
            const F = Kl(E.name)
              , O = URL.createObjectURL(E);
            await i.loadAnimation(O, !1, 0, !0, "", F),
            w(i.getCurrentAnimationName()),
            URL.revokeObjectURL(O)
        } else
            console.warn("Please load a vrm model to test animations.")
    }
      , M = () => {
        if (g === 0)
            D(d[d.length - 1]),
            p(d.length - 1);
        else {
            const E = g - 1;
            D(d[E]),
            p(E)
        }
    }
      , L = () => {
        if (g >= d.length - 1)
            D(d[0]),
            p(0);
        else {
            const E = g + 1;
            D(d[E]),
            p(E)
        }
    }
      , D = async E => {
        const R = URL.createObjectURL(E);
        await r.loadOptimizerCharacter(R),
        URL.revokeObjectURL(R);
        const F = Kl(E.name);
        h(F),
        u({
            ...r.getCurrentCharacterModel()
        })
    }
      , T = async E => {
        D(E[0]);
        const R = [];
        for (let F = 0; F < E.length; F++) {
            const O = E[F];
            O && O.name.toLowerCase().endsWith(".vrm") && R.push(E[F])
        }
        m(R),
        p(0)
    }
      , y = async E => {
        const R = E[0];
        R && R.name.toLowerCase().endsWith(".fbx") && I(R),
        R && R.name.toLowerCase().endsWith(".vrm") && T(E)
    }
    ;
    return k.jsxs("div", {
        className: Oi.container,
        children: [k.jsx("div", {
            className: `loadingIndicator ${n ? "active" : ""}`,
            children: k.jsx("img", {
                className: "rotate",
                src: "ui/loading.svg"
            })
        }), k.jsx("div", {
            className: "sectionTitle",
            children: "Optimize your character"
        }), k.jsx(S0, {
            onFilesDrop: y
        }), k.jsx(nb, {
            showDropToDownload: !0,
            showCreateAtlas: !1,
            mergeMenuTitle: "Optimizer Options"
        }), k.jsx(fU, {
            model: A,
            name: f,
            files: d,
            index: g,
            nextVrm: L,
            previousVrm: M
        }), k.jsx(k1, {
            loadedAnimationName: v
        }), k.jsxs("div", {
            className: Oi.buttonContainer,
            children: [k.jsx(Bn, {
                theme: "light",
                text: S("callToAction.back"),
                size: 14,
                className: Oi.buttonLeft,
                onClick: _
            }), (d == null ? void 0 : d.length) > 1 != "" && k.jsx(Bn, {
                theme: "light",
                text: "Download All",
                size: 14,
                className: Oi.buttonRight,
                onClick: b
            }), A != "" && k.jsx(Bn, {
                theme: "light",
                text: "Download",
                size: 14,
                className: Oi.buttonRight,
                onClick: B
            })]
        })]
    })
}
const x5e = "_buttonContainer_1fd4o_1"
  , b5e = "_buttonLeft_1fd4o_10"
  , E5e = "_buttonRight_1fd4o_14"
  , B5e = "_buttonCenter_1fd4o_18"
  , Jy = {
    buttonContainer: x5e,
    buttonLeft: b5e,
    buttonRight: E5e,
    buttonCenter: B5e
}
  , M5e = "_button_13dfi_1"
  , H4 = {
    button: M5e
}
  , S5e = "Anon"
  , C5e = () => {
    be.useContext(fa);
    const [n] = Z.useState(localStorage.getItem("name") || S5e)
      , {model: e, characterManager: t} = be.useContext($n)
      , r = () => {
        const o = ze.mergeOptions_sel_option || 0;
        return {
            createTextureAtlas: ze.mergeOptions_create_atlas == null ? !0 : ze.mergeOptions_create_atlas,
            mToonAtlasSize: Nn(ze.mergeOptions_atlas_mtoon_size || 6),
            mToonAtlasSizeTransp: Nn(ze.mergeOptions_atlas_mtoon_transp_size || 6),
            stdAtlasSize: Nn(ze.mergeOptions_atlas_std_size || 6),
            stdAtlasSizeTransp: Nn(ze.mergeOptions_atlas_std_transp_size || 6),
            ktxCompression: ze.merge_options_ktx_compression,
            exportStdAtlas: o === 0 || o == 2,
            exportMtoonAtlas: o === 1 || o == 2,
            twoSidedMaterial: ze.mergeOptions_two_sided_mat || !1
        }
    }
      , i = o => {
        const a = r();
        a.isVrm0 = Object.values(t.avatar)[0].vrm.meta.metaVersion == "0",
        a.outputVRM0 = o !== 1,
        t.downloadVRM(n, a)
    }
      , s = () => {
        const o = r();
        t.downloadGLB(n, o)
    }
    ;
    return k.jsxs(Z.Fragment, {
        children: [k.jsx(Bn, {
            theme: "light",
            text: "GLB",
            icon: "download",
            size: 14,
            className: H4.button,
            onClick: () => {
                s()
            }
        }), k.jsx(Bn, {
            theme: "light",
            text: "VRM 0",
            icon: "download",
            size: 14,
            className: H4.button,
            onClick: () => i(0)
        })]
    })
}
;
function T5e() {
    const {t: n} = be.useContext(fa)
      , {playSound: e} = Z.useContext(Co)
      , {isMute: t} = Z.useContext(So)
      , {setViewMode: r} = Z.useContext(us)
      , i = () => {
        r(wt.APPEARANCE),
        !t && e("backNextButton")
    }
      , s = () => {
        r(wt.MINT),
        !t && e("backNextButton")
    }
      , o = async a => {
        const l = a[0];
        l && l.name.toLowerCase().endsWith(".json")
    }
    ;
    return k.jsxs("div", {
        className: Jy.container,
        children: [k.jsx("div", {
            className: "sectionTitle",
            children: n("pageTitles.saveCharacter")
        }), k.jsxs("div", {
            className: Jy.buttonContainer,
            children: [k.jsx(S0, {
                onFilesDrop: o
            }), k.jsx(Bn, {
                theme: "light",
                text: n("callToAction.back"),
                size: 14,
                className: Jy.buttonLeft,
                onClick: i
            }), k.jsx(nb, {
                showCreateAtlas: !0,
                mergeMenuTitle: "Download Options"
            }), k.jsx(C5e, {}), k.jsx(Bn, {
                theme: "light",
                text: "mint",
                size: 14,
                className: Jy.buttonRight,
                onClick: s
            })]
        })]
    })
}
function I5e() {
    const {t: n} = be.useContext(fa)
      , {setViewMode: e, setIsLoading: t, isLoading: r} = Z.useContext(us)
      , {playSound: i} = Z.useContext(Co)
      , {isMute: s} = Z.useContext(So)
      , {manifest: o, characterManager: a} = Z.useContext($n);
    be.useState([]);
    const [l,c] = be.useState([]);
    be.useEffect( () => {
        A()
    }
    , []);
    const A = async () => {
        const m = await _U();
        yHe(m, "the-anata-nft").then(g => {
            c(g.nfts),
            console.log(g.nfts)
        }
        )
    }
      , u = () => {
        e(wt.LANDING),
        !s && i("backNextButton")
    }
      , f = async m => {
        t(!0),
        a.loadManifest(o[m].manifest).then( () => {
            e(wt.APPEARANCE),
            a.loadInitialTraits().then( () => {
                t(!1)
            }
            )
        }
        ),
        !s && i("classSelect")
    }
      , h = () => {
        console.log("ttt"),
        a.loadManifest(o[0].manifest).then( () => {
            a.loadAppendManifest(o[1].manifest, !0).then( () => {
                console.log(a.manifestData)
            }
            )
        }
        )
    }
      , d = () => {
        !s && i("classMouseOver")
    }
    ;
    return k.jsxs("div", {
        className: `${ht.container} horizontalScroll`,
        children: [k.jsx("div", {
            className: "sectionTitle",
            children: n("pageTitles.chooseClass")
        }), k.jsx("div", {
            className: ht.vrmOptimizerButton
        }), k.jsx("div", {
            className: ht.topLine
        }), k.jsx("div", {
            className: ht.classContainer,
            children: l.map( (m, g) => k.jsxs("div", {
                className: ht.class,
                onClick: () => f(g),
                onMouseOver: () => d(),
                children: [k.jsx("div", {
                    className: ht.classFrame,
                    style: {
                        backgroundImage: `url(${m.image_url})`
                    },
                    children: k.jsx("div", {
                        className: ht.frameContainer,
                        children: k.jsx("img", {
                            src: "./public/assets/backgrounds/class-frame.svg",
                            className: ht.frame
                        })
                    })
                }), k.jsx("div", {
                    className: ht.name,
                    children: m.name
                })]
            }, g))
        }), k.jsx("div", {
            className: ht.bottomLine
        }), k.jsxs("div", {
            className: ht.buttonContainer,
            children: [k.jsx(Bn, {
                theme: "light",
                text: n("callToAction.back"),
                size: 14,
                className: ht.buttonLeft,
                onClick: u
            }), k.jsx(Bn, {
                theme: "light",
                text: "test",
                size: 14,
                className: ht.buttonLeft,
                onClick: h
            })]
        })]
    })
}
const R5e = ".//manifest.json"
  , U5e = 6
  , F5e = new $(0,.8,0);
new $(-2.2367993753934425,1.1512971720174363,2.2612065299409223);
async function P5e(n) {
    try {
        const e = await fetch(n);
        if (!e.ok)
            throw new Error(`Failed to fetch manifest. Status: ${e.status}`);
        return await e.json()
    } catch (e) {
        return console.error(`Error fetching manifest: ${e.message}`),
        []
    }
}
async function L5e() {
    const n = await P5e(R5e)
      , e = new rwe;
    return {
        initialManifest: n,
        effectManager: e
    }
}
const D5e = () => {
    let n, e;
    const r = L5e().then(i => {
        n = "success",
        e = i
    }
    , i => {
        n = "error",
        e = i
    }
    );
    return {
        read() {
            if (n === "error")
                throw e;
            if (n === "success")
                return e;
            throw r
        }
    }
}
  , N5e = D5e();
function O5e() {
    const {initialManifest: n, effectManager: e} = N5e.read()
      , [t,r] = be.useState(!1)
      , {camera: i, controls: s, scene: o, moveCamera: a, setManifest: l, lookAtManager: c, showEnvironmentModels: A} = be.useContext($n)
      , {viewMode: u} = be.useContext(us);
    e.camera = i,
    e.scene = o;
    const f = () => {
        e.camera && (a({
            targetX: 0,
            targetY: F5e.y,
            targetZ: 0,
            distance: U5e
        }),
        s && ([wt.APPEARANCE, wt.SAVE, wt.OPTIMIZER, wt.BATCHDOWNLOAD, wt.BATCHMANIFEST].includes(u) ? s.enabled = !0 : s.enabled = !1))
    }
      , [h,d] = be.useState(!1)
      , [m,g] = be.useState("")
      , [p,v] = be.useState([])
      , w = (b, B) => {
        g(b),
        d(!0),
        v([B])
    }
      , _ = {
        [wt.LANDING]: k.jsx(WHe, {}),
        [wt.APPEARANCE]: k.jsx(Eke, {
            confirmDialog: w
        }),
        [wt.OPTIMIZER]: k.jsx(_5e, {}),
        [wt.CREATE]: k.jsx(GHe, {}),
        [wt.WALLET]: k.jsx(I5e, {}),
        [wt.CLAIM]: k.jsx(zHe, {}),
        [wt.BATCHMANIFEST]: k.jsx(bHe, {}),
        [wt.BATCHDOWNLOAD]: k.jsx(r4e, {}),
        [wt.LOAD]: k.jsx(o5e, {}),
        [wt.MINT]: k.jsx(w5e, {}),
        [wt.SAVE]: k.jsx(T5e, {})
    };
    let x = 0;
    return be.useEffect( () => {
        const b = B => {
            const S = new Date().getTime()
              , I = S - x;
            I < 300 && I > 10 && B.target.id == "editor-scene" && r(!t),
            x = S
        }
        ;
        return window.addEventListener("touchend", b),
        window.addEventListener("click", b),
        () => {
            window.removeEventListener("touchend", b),
            window.removeEventListener("click", b)
        }
    }
    , [t]),
    be.useEffect( () => {
        if (c != null)
            return f(),
            c.enabled = !0,
            [wt.LANDING, wt.CREATE, wt.CLAIM, wt.LOAD, wt.CLAIM, wt.CLAIM].includes(u) ? A(!1) : A(!0),
            window.addEventListener("resize", f),
            () => {
                window.removeEventListener("resize", f)
            }
    }
    , [u, c]),
    be.useEffect( () => {
        l(n)
    }
    , [n]),
    be.useContext(fa),
    k.jsxs(be.Fragment, {
        children: [k.jsx("div", {
            className: "generalTitle",
            children: "Character Studio"
        }), k.jsx(_we, {
            confirmDialogText: m,
            confirmDialogCallback: p,
            confirmDialogWindow: h,
            setConfirmDialogWindow: d
        }), k.jsx(Bwe, {}), _[u]]
    })
}
const k5e = n => {
    const e = new yI(n);
    return e.pollingInterval = 12e3,
    e
}
;
QM.createRoot(document.getElementById("root")).render(k.jsx(Z.StrictMode, {
    children: k.jsx(gY, {
        getLibrary: k5e,
        children: k.jsx(CZ, {
            children: k.jsx(Lye, {
                children: k.jsx(MZ, {
                    children: k.jsx(uve, {
                        children: k.jsx(cve, {
                            children: k.jsx(_ve, {
                                children: k.jsx(be.Suspense, {
                                    children: k.jsx(O5e, {})
                                })
                            })
                        })
                    })
                })
            })
        })
    })
}));
export {ka as c, oc as g};
